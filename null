package com.ichi2.anki.tests;

import android.test.AndroidTestCase;

import com.ichi2.anki.CollectionHelper;

import java.io.IOException;

/**
 * This test case verifies that the directory initialization works even if the app is not yet fully initialized.
 */
public class CollectionTest extends AndroidTestCase{
    public void testOpenCollection() throws IOException {
        assertNotNull("Collection could not be opened", CollectionHelper.getInstance().getCol(getContext()));
    }
}/***************************************************************************************
 *                                                                                      *
 * Copyright (c) 2015 Frank Oltmanns <frank.oltmanns@gmail.com>                         *
 * Copyright (c) 2015 Timothy Rae <timothy.rae@gmail.com>                               *
 * Copyright (c) 2016 Mark Carter <mark@marcardar.com>                                  *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.tests;

import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;
import android.test.AndroidTestCase;
import android.util.Log;

import com.ichi2.anki.AbstractFlashcardViewer;
import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.FlashCardsContract;
import com.ichi2.anki.exception.ConfirmModSchemaException;
import com.ichi2.libanki.Card;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Decks;
import com.ichi2.libanki.Models;
import com.ichi2.libanki.Note;
import com.ichi2.libanki.Sched;
import com.ichi2.libanki.Utils;

import org.json.JSONArray;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Test cases for {@link com.ichi2.anki.provider.CardContentProvider}.
 * <p/>
 * These tests should cover all supported operations for each URI.
 */
public class ContentProviderTest extends AndroidTestCase {

    private static final String BASIC_MODEL_NAME = "com.ichi2.anki.provider.test.basic.x94oa3F";
    private static final String TEST_FIELD_NAME = "TestFieldName";
    private static final String TEST_FIELD_VALUE = "test field value";
    private static final String TEST_TAG = "aldskfhewjklhfczmxkjshf";
    private static final String[] TEST_DECKS = {"cmxieunwoogyxsctnjmv"
                                                ,"sstuljxgmfdyugiujyhq"
                                                ,"pdsqoelhmemmmbwjunnu"
                                                ,"scxipjiyozczaaczoawo"};
    private static final String TEST_MODEL_NAME = "com.ichi2.anki.provider.test.a1x6h9l";
    private static final String[] TEST_MODEL_FIELDS = {"FRONTS","BACK"};
    private static final String[] TEST_MODEL_CARDS = {"cArD1", "caRD2"};
    private static final String[] TEST_MODEL_QFMT = {"{{FRONTS}}", "{{BACK}}"};
    private static final String[] TEST_MODEL_AFMT = {"{{BACK}}", "{{FRONTS}}"};
    private static final String[] TEST_NOTE_FIELDS = {"dis is za Fr0nt", "Te$t"};
    private static final String TEST_MODEL_CSS = "styleeeee";

    private int mNumDecksBeforeTest;
    private long[] mTestDeckIds = new long[TEST_DECKS.length];
    private ArrayList<Uri> mCreatedNotes;
    private long mModelId = 0;
    private String[] mDummyFields = new String[1];
    /**
     * Initially create one note for each model.
     */
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        Log.i(AnkiDroidApp.TAG, "setUp()");
        mCreatedNotes = new ArrayList<>();
        final Collection col = CollectionHelper.getInstance().getCol(getContext());
        // Add a new basic model that we use for testing purposes (existing models could potentially be corrupted)
        JSONObject model = Models.addBasicModel(col, BASIC_MODEL_NAME);
        mModelId = model.getLong("id");
        ArrayList<String> flds = col.getModels().fieldNames(model);
        // Use the names of the fields as test values for the notes which will be added
        mDummyFields = flds.toArray(new String[flds.size()]);
        // create test decks and add one note for every deck
        mNumDecksBeforeTest = col.getDecks().count();
        for(int i = 0; i < TEST_DECKS.length; i++) {
            long did = col.getDecks().id(TEST_DECKS[i]);
            mTestDeckIds[i] = did;
            mCreatedNotes.add(setupNewNote(col, mModelId, did, mDummyFields, TEST_TAG));
        }
        // Add a note to the default deck as well so that testQueryNextCard() works
        mCreatedNotes.add(setupNewNote(col, mModelId, 1, mDummyFields, TEST_TAG));
    }

    private static Uri setupNewNote(Collection col, long mid, long did, String[] flds, String tag) {
        Note newNote = new Note(col, col.getModels().get(mid));
        for (int idx=0; idx < flds.length; idx++) {
            newNote.setField(idx, flds[idx]);
        }
        newNote.addTag(tag);
        assertTrue("At least one card added for note", col.addNote(newNote) >= 1);
        for (Card c: newNote.cards()) {
            c.setDid(did);
            c.flush();
        }
        return Uri.withAppendedPath(FlashCardsContract.Note.CONTENT_URI, Long.toString(newNote.getId()));
    }

    /**
     * Remove the notes and decks created in setUp().
     */
    @Override
    protected void tearDown() throws Exception {
        Log.i(AnkiDroidApp.TAG, "tearDown()");
        final Collection col = CollectionHelper.getInstance().getCol(getContext());
        // Delete all notes
        List<Long> remnantNotes = col.findNotes("tag:" + TEST_TAG);
        if (remnantNotes.size() > 0) {
            long[] nids = new long[remnantNotes.size()];
            for (int i = 0; i < remnantNotes.size(); i++) {
                nids[i] = remnantNotes.get(i);
            }
            col.remNotes(nids);
            col.save();
            assertEquals("Check that remnant notes have been deleted", 0, col.findNotes("tag:" + TEST_TAG).size());
        }
        // delete test decks
        for(long did : mTestDeckIds) {
            col.getDecks().rem(did, true);
        }
        col.getDecks().flush();
        assertEquals("Check that all created decks have been deleted", mNumDecksBeforeTest, col.getDecks().count());
        // Delete test model
        col.modSchema(false);
        col.getModels().rem(col.getModels().get(mModelId));
        super.tearDown();
    }


    /**
     * Check that inserting and removing a note into default deck works as expected
     */
    public void testInsertAndRemoveNote() throws Exception {
        // Get required objects for test
        final ContentResolver cr = getContext().getContentResolver();
        // Add the note
        ContentValues values = new ContentValues();
        values.put(FlashCardsContract.Note.MID, mModelId);
        values.put(FlashCardsContract.Note.FLDS, Utils.joinFields(TEST_NOTE_FIELDS));
        values.put(FlashCardsContract.Note.TAGS, TEST_TAG);
        Uri newNoteUri = cr.insert(FlashCardsContract.Note.CONTENT_URI, values);
        assertNotNull("Check that URI returned from addNewNote is not null", newNoteUri);
        final Collection col = reopenCol();  // test that the changes are physically saved to the DB
        // Check that it looks as expected
        Note addedNote = new Note(col, Long.parseLong(newNoteUri.getLastPathSegment()));
        addedNote.load();
        assertTrue("Check that fields were set correctly", Arrays.equals(addedNote.getFields(), TEST_NOTE_FIELDS));
        assertEquals("Check that tag was set correctly", TEST_TAG, addedNote.getTags().get(0));
        int expectedNumCards = col.getModels().get(mModelId).getJSONArray("tmpls").length();
        assertEquals("Check that correct number of cards generated", expectedNumCards, addedNote.cards().size());
        // Now delete the note
        cr.delete(newNoteUri, null, null);
        try {
            addedNote.load();
            fail("Expected RuntimeException to be thrown when deleting note");
        } catch (RuntimeException e) {
            // Expect RuntimeException to be thrown when loading deleted note
        }
    }

    /**
     * Check that inserting and removing a note into default deck works as expected
     */
    public void testInsertTemplate() throws Exception {
        // Get required objects for test
        final ContentResolver cr = getContext().getContentResolver();
        Collection col = CollectionHelper.getInstance().getCol(getContext());
        // Add a new basic model that we use for testing purposes (existing models could potentially be corrupted)
        JSONObject model = Models.addBasicModel(col, BASIC_MODEL_NAME);
        long modelId = model.getLong("id");
        // Add the note
        Uri modelUri = ContentUris.withAppendedId(FlashCardsContract.Model.CONTENT_URI, modelId);
        int testIndex = TEST_MODEL_CARDS.length - 1; // choose the last one because not the same as the basic model template
        int expectedOrd = model.getJSONArray("tmpls").length();
        ContentValues cv = new ContentValues();
        cv.put(FlashCardsContract.CardTemplate.NAME, TEST_MODEL_CARDS[testIndex]);
        cv.put(FlashCardsContract.CardTemplate.QUESTION_FORMAT, TEST_MODEL_QFMT[testIndex]);
        cv.put(FlashCardsContract.CardTemplate.ANSWER_FORMAT, TEST_MODEL_AFMT[testIndex]);
        cv.put(FlashCardsContract.CardTemplate.BROWSER_QUESTION_FORMAT, TEST_MODEL_QFMT[testIndex]);
        cv.put(FlashCardsContract.CardTemplate.BROWSER_ANSWER_FORMAT, TEST_MODEL_AFMT[testIndex]);
        Uri templatesUri = Uri.withAppendedPath(modelUri, "templates");
        Uri templateUri = cr.insert(templatesUri, cv);
        col = reopenCol();  // test that the changes are physically saved to the DB
        assertNotNull("Check template uri", templateUri);
        assertEquals("Check template uri ord", expectedOrd, ContentUris.parseId(templateUri));
        JSONObject template = col.getModels().get(modelId).getJSONArray("tmpls").getJSONObject(expectedOrd);
        assertEquals("Check template JSONObject ord", expectedOrd, template.getInt("ord"));
        assertEquals("Check template name", TEST_MODEL_CARDS[testIndex], template.getString("name"));
        assertEquals("Check qfmt", TEST_MODEL_QFMT[testIndex], template.getString("qfmt"));
        assertEquals("Check afmt", TEST_MODEL_AFMT[testIndex], template.getString("afmt"));
        assertEquals("Check bqfmt", TEST_MODEL_QFMT[testIndex], template.getString("bqfmt"));
        assertEquals("Check bafmt", TEST_MODEL_AFMT[testIndex], template.getString("bafmt"));
        col.getModels().rem(model);
    }

    /**
     * Check that inserting and removing a note into default deck works as expected
     */
    public void testInsertField() throws Exception {
        // Get required objects for test
        final ContentResolver cr = getContext().getContentResolver();
        Collection col = CollectionHelper.getInstance().getCol(getContext());
        JSONObject model = Models.addBasicModel(col, BASIC_MODEL_NAME);
        long modelId = model.getLong("id");
        JSONArray initialFldsArr = model.getJSONArray("flds");
        int initialFieldCount = initialFldsArr.length();
        Uri noteTypeUri = ContentUris.withAppendedId(FlashCardsContract.Model.CONTENT_URI, modelId);
        ContentValues insertFieldValues = new ContentValues();
        insertFieldValues.put(FlashCardsContract.Model.FIELD_NAME, TEST_FIELD_NAME);
        Uri fieldUri = cr.insert(Uri.withAppendedPath(noteTypeUri, "fields"), insertFieldValues);
        assertNotNull("Check field uri", fieldUri);
        // Ensure that the changes are physically saved to the DB
        col = reopenCol();
        model = col.getModels().get(modelId);
        // Test the field is as expected
        long fieldId = ContentUris.parseId(fieldUri);
        assertEquals("Check field id", initialFieldCount, fieldId);
        JSONArray fldsArr = model.getJSONArray("flds");
        assertEquals("Check fields length", initialFieldCount + 1, fldsArr.length());
        assertEquals("Check last field name", TEST_FIELD_NAME, fldsArr.getJSONObject(fldsArr.length() - 1).optString("name", ""));
        col.getModels().rem(model);
    }

    /**
     * Test queries to notes table using direct SQL URI
     */
    public void testQueryDirectSqlQuery() {
        // search for correct mid
        final ContentResolver cr = getContext().getContentResolver();
        Cursor cursor = cr.query(FlashCardsContract.Note.CONTENT_URI_V2, null, String.format("mid=%d", mModelId), null, null);
        assertNotNull(cursor);
        try {
            assertEquals("Check number of results", mCreatedNotes.size(), cursor.getCount());
        } finally {
            cursor.close();
        }
        // search for bogus mid
        cursor = cr.query(FlashCardsContract.Note.CONTENT_URI_V2, null, "mid=0", null, null);
        assertNotNull(cursor);
        try {
            assertEquals("Check number of results", 0, cursor.getCount());
        } finally {
            cursor.close();
        }
        // check usage of selection args
        cursor = cr.query(FlashCardsContract.Note.CONTENT_URI_V2, null, "mid=?", new String[]{"0"}, null);
        assertNotNull(cursor);
    }

    /**
     * Test that a query for all the notes added in setup() looks correct
     */
    public void testQueryNoteIds() {
        final ContentResolver cr = getContext().getContentResolver();
        // Query all available notes
        final Cursor allNotesCursor = cr.query(FlashCardsContract.Note.CONTENT_URI, null, "tag:" + TEST_TAG, null, null);
        assertNotNull(allNotesCursor);
        try {
            assertEquals("Check number of results", mCreatedNotes.size(), allNotesCursor.getCount());
            while (allNotesCursor.moveToNext()) {
                // Check that it's possible to leave out columns from the projection
                for (int i = 0; i < FlashCardsContract.Note.DEFAULT_PROJECTION.length; i++) {
                    String[] projection = removeFromProjection(FlashCardsContract.Note.DEFAULT_PROJECTION, i);
                    String noteId = allNotesCursor.getString(allNotesCursor.getColumnIndex(FlashCardsContract.Note._ID));
                    Uri noteUri = Uri.withAppendedPath(FlashCardsContract.Note.CONTENT_URI, noteId);
                    final Cursor singleNoteCursor = cr.query(noteUri, projection, null, null, null);
                    assertNotNull("Check that there is a valid cursor for detail data", singleNoteCursor);
                    try {
                        assertEquals("Check that there is exactly one result", 1, singleNoteCursor.getCount());
                        assertTrue("Move to beginning of cursor after querying for detail data", singleNoteCursor.moveToFirst());
                        // Check columns
                        assertEquals("Check column count", projection.length, singleNoteCursor.getColumnCount());
                        for (int j = 0; j < projection.length; j++) {
                            assertEquals("Check column name " + j, projection[j], singleNoteCursor.getColumnName(j));
                        }
                    } finally {
                        singleNoteCursor.close();
                    }
                }
            }
        } finally {
            allNotesCursor.close();
        }
    }

    /**
     * Check that a valid Cursor is returned when querying notes table with non-default projections
     */
    public void testQueryNotesProjection() {
        final ContentResolver cr = getContext().getContentResolver();
        // Query all available notes
        for (int i = 0; i < FlashCardsContract.Note.DEFAULT_PROJECTION.length; i++) {
            String[] projection = removeFromProjection(FlashCardsContract.Note.DEFAULT_PROJECTION, i);
            final Cursor allNotesCursor = cr.query(FlashCardsContract.Note.CONTENT_URI, projection, "tag:" + TEST_TAG, null, null);
            assertNotNull("Check that there is a valid cursor", allNotesCursor);
            try {
                assertEquals("Check number of results", mCreatedNotes.size(), allNotesCursor.getCount());
                // Check columns
                assertEquals("Check column count", projection.length, allNotesCursor.getColumnCount());
                for (int j = 0; j < projection.length; j++) {
                    assertEquals("Check column name " + j, projection[j], allNotesCursor.getColumnName(j));
                }
            } finally {
                allNotesCursor.close();
            }
        }
    }

    private String[] removeFromProjection(String[] inputProjection, int idx) {
        String[] outputProjection = new String[inputProjection.length - 1];
        for (int i = 0; i < idx; i++) {
            outputProjection[i] = inputProjection[i];
        }
        for (int i = idx + 1; i < inputProjection.length; i++) {
            outputProjection[i - 1] = inputProjection[i];
        }
        return outputProjection;
    }


    /**
     * Check that updating the flds column works as expected
     */
    public void testUpdateNoteFields() {
        final ContentResolver cr = getContext().getContentResolver();
        ContentValues cv = new ContentValues();
        // Change the fields so that the first field is now "newTestValue"
        String[] dummyFields2 = mDummyFields.clone();
        dummyFields2[0] = TEST_FIELD_VALUE;
        for (Uri uri: mCreatedNotes) {
            // Update the flds
            cv.put(FlashCardsContract.Note.FLDS, Utils.joinFields(dummyFields2));
            cr.update(uri, cv, null, null);
            // Query the table again
            Cursor noteCursor = cr.query(uri, FlashCardsContract.Note.DEFAULT_PROJECTION, null, null, null);
            try {
                assertNotNull("Check that there is a valid cursor for detail data after update", noteCursor);
                assertEquals("Check that there is one and only one entry after update", 1, noteCursor.getCount());
                assertTrue("Move to first item in cursor", noteCursor.moveToFirst());
                String[] newFlds = Utils.splitFields(
                        noteCursor.getString(noteCursor.getColumnIndex(FlashCardsContract.Note.FLDS)));
                assertTrue("Check that the flds have been updated correctly", Arrays.equals(newFlds, dummyFields2));
            } finally {
                noteCursor.close();
            }
        }
    }


    /**
     * Check that inserting a new model works as expected
     */
    public void testInsertAndUpdateModel() throws Exception {
        final ContentResolver cr = getContext().getContentResolver();
        ContentValues cv = new ContentValues();
        // Insert a new model
        cv.put(FlashCardsContract.Model.NAME, TEST_MODEL_NAME);
        cv.put(FlashCardsContract.Model.FIELD_NAMES, Utils.joinFields(TEST_MODEL_FIELDS));
        cv.put(FlashCardsContract.Model.NUM_CARDS, TEST_MODEL_CARDS.length);
        Uri modelUri = cr.insert(FlashCardsContract.Model.CONTENT_URI, cv);
        assertNotNull("Check inserted model isn't null", modelUri);
        long mid = Long.parseLong(modelUri.getLastPathSegment());
        Collection col = reopenCol();
        try {
            JSONObject model = col.getModels().get(mid);
            assertEquals("Check model name", TEST_MODEL_NAME, model.getString("name"));
            assertEquals("Check templates length", TEST_MODEL_CARDS.length, model.getJSONArray("tmpls").length());
            assertEquals("Check field length", TEST_MODEL_FIELDS.length, model.getJSONArray("flds").length());
            JSONArray flds = model.getJSONArray("flds");
            for (int i = 0; i < flds.length(); i++) {
                assertEquals("Check name of fields", flds.getJSONObject(i).getString("name"), TEST_MODEL_FIELDS[i]);
            }
            // Test updating the model CSS (to test updating MODELS_ID Uri)
            cv = new ContentValues();
            cv.put(FlashCardsContract.Model.CSS, TEST_MODEL_CSS);
            assertTrue(cr.update(modelUri, cv, null, null) > 0);
            col = reopenCol();
            assertEquals("Check css", TEST_MODEL_CSS, col.getModels().get(mid).getString("css"));
            // Update each of the templates in model (to test updating MODELS_ID_TEMPLATES_ID Uri)
            for (int i = 0; i < TEST_MODEL_CARDS.length; i++) {
                cv = new ContentValues();
                cv.put(FlashCardsContract.CardTemplate.NAME, TEST_MODEL_CARDS[i]);
                cv.put(FlashCardsContract.CardTemplate.QUESTION_FORMAT, TEST_MODEL_QFMT[i]);
                cv.put(FlashCardsContract.CardTemplate.ANSWER_FORMAT, TEST_MODEL_AFMT[i]);
                cv.put(FlashCardsContract.CardTemplate.BROWSER_QUESTION_FORMAT, TEST_MODEL_QFMT[i]);
                cv.put(FlashCardsContract.CardTemplate.BROWSER_ANSWER_FORMAT, TEST_MODEL_AFMT[i]);
                Uri tmplUri = Uri.withAppendedPath(Uri.withAppendedPath(modelUri, "templates"), Integer.toString(i));
                assertTrue("Update rows", cr.update(tmplUri, cv, null, null) > 0);
                col = reopenCol();
                JSONObject template = col.getModels().get(mid).getJSONArray("tmpls").getJSONObject(i);
                assertEquals("Check template name", TEST_MODEL_CARDS[i], template.getString("name"));
                assertEquals("Check qfmt", TEST_MODEL_QFMT[i], template.getString("qfmt"));
                assertEquals("Check afmt", TEST_MODEL_AFMT[i], template.getString("afmt"));
                assertEquals("Check bqfmt", TEST_MODEL_QFMT[i], template.getString("bqfmt"));
                assertEquals("Check bafmt", TEST_MODEL_AFMT[i], template.getString("bafmt"));
            }
        } finally {
            // Delete the model (this will force a full-sync)
            try {
                col.modSchema(false);
                col.getModels().rem(col.getModels().get(mid));
            } catch (ConfirmModSchemaException e) {
                // This will never happen
                throw new IllegalStateException("Unexpected ConfirmModSchemaException trying to remove model");
            }
        }
    }

    /**
     * Query .../models URI
     */
    public void testQueryAllModels() {
        final ContentResolver cr = getContext().getContentResolver();
        // Query all available models
        final Cursor allModels = cr.query(FlashCardsContract.Model.CONTENT_URI, null, null, null, null);
        assertNotNull(allModels);
        try {
            assertTrue("Check that there is at least one result", allModels.getCount() > 0);
            while (allModels.moveToNext()) {
                long modelId = allModels.getLong(allModels.getColumnIndex(FlashCardsContract.Model._ID));
                Uri modelUri = Uri.withAppendedPath(FlashCardsContract.Model.CONTENT_URI, Long.toString(modelId));
                final Cursor singleModel = cr.query(modelUri, null, null, null, null);
                assertNotNull(singleModel);
                try {
                    assertEquals("Check that there is exactly one result", 1, singleModel.getCount());
                    assertTrue("Move to beginning of cursor", singleModel.moveToFirst());
                    String nameFromModels = allModels.getString(allModels.getColumnIndex(FlashCardsContract.Model.NAME));
                    String nameFromModel = singleModel.getString(allModels.getColumnIndex(FlashCardsContract.Model.NAME));
                    assertEquals("Check that model names are the same", nameFromModel, nameFromModels);
                    String flds = allModels.getString(allModels.getColumnIndex(FlashCardsContract.Model.FIELD_NAMES));
                    assertTrue("Check that valid number of fields", Utils.splitFields(flds).length >= 1);
                    Integer numCards = allModels.getInt(allModels.getColumnIndex(FlashCardsContract.Model.NUM_CARDS));
                    assertTrue("Check that valid number of cards", numCards >= 1);
                } finally {
                    singleModel.close();
                }
            }
        } finally {
            allModels.close();
        }
    }

    /**
     * Move all the cards from their old decks to the first deck that was added in setup()
     */
    public void testMoveCardsToOtherDeck() {
        final ContentResolver cr = getContext().getContentResolver();
        // Query all available notes
        final Cursor allNotesCursor = cr.query(FlashCardsContract.Note.CONTENT_URI, null, "tag:" + TEST_TAG, null, null);
        assertNotNull(allNotesCursor);
        try {
            assertEquals("Check number of results", mCreatedNotes.size(), allNotesCursor.getCount());
            while (allNotesCursor.moveToNext()) {
                // Now iterate over all cursors
                Uri cardsUri = Uri.withAppendedPath(Uri.withAppendedPath(FlashCardsContract.Note.CONTENT_URI,
                        allNotesCursor.getString(allNotesCursor.getColumnIndex(FlashCardsContract.Note._ID))), "cards");
                final Cursor cardsCursor = cr.query(cardsUri, null, null, null, null);
                assertNotNull("Check that there is a valid cursor after query for cards", cardsCursor);
                try {
                    assertTrue("Check that there is at least one result for cards", cardsCursor.getCount() > 0);
                    while (cardsCursor.moveToNext()) {
                        long targetDid = mTestDeckIds[0];
                        // Move to test deck (to test NOTES_ID_CARDS_ORD Uri)
                        ContentValues values = new ContentValues();
                        values.put(FlashCardsContract.Card.DECK_ID, targetDid);
                        Uri cardUri = Uri.withAppendedPath(cardsUri,
                                cardsCursor.getString(cardsCursor.getColumnIndex(FlashCardsContract.Card.CARD_ORD)));
                        cr.update(cardUri, values, null, null);
                        reopenCol();
                        Cursor movedCardCur = cr.query(cardUri, null, null, null, null);
                        assertNotNull("Check that there is a valid cursor after moving card", movedCardCur);
                        assertTrue("Move to beginning of cursor after moving card", movedCardCur.moveToFirst());
                        long did = movedCardCur.getLong(movedCardCur.getColumnIndex(FlashCardsContract.Card.DECK_ID));
                        assertEquals("Make sure that card is in new deck", targetDid, did);
                    }
                } finally {
                    cardsCursor.close();
                }
            }
        } finally {
            allNotesCursor.close();
        }
    }

    /**
     * Check that querying the current model gives a valid result
     */
    public void testQueryCurrentModel() {
        final ContentResolver cr = getContext().getContentResolver();
        Uri uri = Uri.withAppendedPath(FlashCardsContract.Model.CONTENT_URI, FlashCardsContract.Model.CURRENT_MODEL_ID);
        final Cursor modelCursor = cr.query(uri, null, null, null, null);
        assertNotNull(modelCursor);
        try {
            assertEquals("Check that there is exactly one result", 1, modelCursor.getCount());
            assertTrue("Move to beginning of cursor", modelCursor.moveToFirst());
            assertNotNull("Check non-empty field names",
                    modelCursor.getString(modelCursor.getColumnIndex(FlashCardsContract.Model.FIELD_NAMES)));
            assertTrue("Check at least one template",
                    modelCursor.getInt(modelCursor.getColumnIndex(FlashCardsContract.Model.NUM_CARDS)) > 0);
        } finally {
            modelCursor.close();
        }
    }

    /**
     * Check that an Exception is thrown when unsupported operations are performed
     */
    public void testUnsupportedOperations() {
        final ContentResolver cr = getContext().getContentResolver();
        ContentValues dummyValues = new ContentValues();
        Uri[] updateUris = {
                // Can't update most tables in bulk -- only via ID
                FlashCardsContract.Note.CONTENT_URI,
                FlashCardsContract.Model.CONTENT_URI,
                FlashCardsContract.Deck.CONTENT_ALL_URI,
                FlashCardsContract.Note.CONTENT_URI.buildUpon()
                        .appendPath("1234")
                        .appendPath("cards")
                        .build(),
        };
        for (Uri uri : updateUris) {
            try {
                cr.update(uri, dummyValues, null, null);
                fail("Update on " + uri + " was supposed to throw exception");
            } catch (UnsupportedOperationException e) {
                // This was expected ...
            } catch (IllegalArgumentException e) {
                // ... or this.
            }
        }
        Uri[] deleteUris = {
                FlashCardsContract.Note.CONTENT_URI,
                // Only note/<id> is supported
                FlashCardsContract.Note.CONTENT_URI.buildUpon()
                        .appendPath("1234")
                        .appendPath("cards")
                        .build(),
                FlashCardsContract.Note.CONTENT_URI.buildUpon()
                        .appendPath("1234")
                        .appendPath("cards")
                        .appendPath("2345")
                        .build(),
                FlashCardsContract.Model.CONTENT_URI,
                FlashCardsContract.Model.CONTENT_URI.buildUpon()
                        .appendPath("1234")
                        .build(),
        };
        for (Uri uri : deleteUris) {
            try {
                cr.delete(uri, null, null);
                fail("Delete on " + uri + " was supposed to throw exception");
            } catch (UnsupportedOperationException e) {
                // This was expected
            }
        }
        Uri[] insertUris = {
                // Can't do an insert with specific ID on the following tables
                FlashCardsContract.Note.CONTENT_URI.buildUpon()
                        .appendPath("1234")
                        .build(),
                FlashCardsContract.Note.CONTENT_URI.buildUpon()
                        .appendPath("1234")
                        .appendPath("cards")
                        .build(),
                FlashCardsContract.Note.CONTENT_URI.buildUpon()
                        .appendPath("1234")
                        .appendPath("cards")
                        .appendPath("2345")
                        .build(),
                FlashCardsContract.Model.CONTENT_URI.buildUpon()
                        .appendPath("1234")
                        .build(),
        };
        for (Uri uri : insertUris) {
            try {
                cr.insert(uri, dummyValues);
                fail("Insert on " + uri + " was supposed to throw exception");
            } catch (UnsupportedOperationException e) {
                // This was expected ...
            } catch (IllegalArgumentException e) {
                // ... or this.
            }
        }
    }

    /**
     * Test query to decks table
     * @throws Exception
     */
    public void testQueryAllDecks() throws Exception{
        Collection col;
        col = CollectionHelper.getInstance().getCol(getContext());
        Decks decks = col.getDecks();

        Cursor decksCursor = getContext().getContentResolver()
                .query(FlashCardsContract.Deck.CONTENT_ALL_URI, FlashCardsContract.Deck.DEFAULT_PROJECTION, null, null, null);

        assertNotNull(decksCursor);
        try {
            assertEquals("Check number of results", decks.count(), decksCursor.getCount());
            while (decksCursor.moveToNext()) {
                long deckID = decksCursor.getLong(decksCursor.getColumnIndex(FlashCardsContract.Deck.DECK_ID));
                String deckName = decksCursor.getString(decksCursor.getColumnIndex(FlashCardsContract.Deck.DECK_NAME));

                JSONObject deck = decks.get(deckID);
                assertNotNull("Check that the deck we received actually exists", deck);
                assertEquals("Check that the received deck has the correct name", deck.getString("name"), deckName);
            }
        } finally {
            decksCursor.close();
        }
    }

    /**
     * Test query to specific deck ID
     * @throws Exception
     */
    public void testQueryCertainDeck() throws Exception {
        Collection col;
        col = CollectionHelper.getInstance().getCol(getContext());

        long deckId = mTestDeckIds[0];
        Uri deckUri = Uri.withAppendedPath(FlashCardsContract.Deck.CONTENT_ALL_URI, Long.toString(deckId));
        Cursor decksCursor = getContext().getContentResolver().query(deckUri, null, null, null, null);
        try {
            if (decksCursor == null || !decksCursor.moveToFirst()) {
                fail("No deck received. Should have delivered deck with id " + deckId);
            } else {
                long returnedDeckID = decksCursor.getLong(decksCursor.getColumnIndex(FlashCardsContract.Deck.DECK_ID));
                String returnedDeckName = decksCursor.getString(decksCursor.getColumnIndex(FlashCardsContract.Deck.DECK_NAME));

                JSONObject realDeck = col.getDecks().get(deckId);
                assertEquals("Check that received deck ID equals real deck ID", deckId, returnedDeckID);
                assertEquals("Check that received deck name equals real deck name", realDeck.getString("name"), returnedDeckName);
            }
        } finally {
            decksCursor.close();
        }
    }

    /**
     * Test that query for the next card in the schedule returns a valid result without any deck selector
     */
    public void testQueryNextCard(){
        Collection col;
        col = CollectionHelper.getInstance().getCol(getContext());
        Sched sched = col.getSched();

        Cursor reviewInfoCursor = getContext().getContentResolver().query(
                FlashCardsContract.ReviewInfo.CONTENT_URI, null, null, null, null);
        assertNotNull(reviewInfoCursor);
        assertEquals("Check that we actually received one card", 1, reviewInfoCursor.getCount());

        reviewInfoCursor.moveToFirst();
        int cardOrd = reviewInfoCursor.getInt(reviewInfoCursor.getColumnIndex(FlashCardsContract.ReviewInfo.CARD_ORD));
        long noteID = reviewInfoCursor.getLong(reviewInfoCursor.getColumnIndex(FlashCardsContract.ReviewInfo.NOTE_ID));


        Card nextCard = null;
        for(int i = 0; i < 10; i++) {//minimizing fails, when sched.reset() randomly chooses between multiple cards
            sched.reset();
            nextCard = sched.getCard();
            if(nextCard.note().getId() == noteID && nextCard.getOrd() == cardOrd)break;
        }
        assertNotNull("Check that there actually is a next scheduled card", nextCard);
        assertEquals("Check that received card and actual card have same note id", nextCard.note().getId(), noteID);
        assertEquals("Check that received card and actual card have same card ord", nextCard.getOrd(), cardOrd);

    }

    /**
     * Test that query for the next card in the schedule returns a valid result WITH a deck selector
     */
    public void testQueryCardFromCertainDeck(){
        long deckToTest = mTestDeckIds[0];
        String deckSelector = "deckID=?";
        String deckArguments[] = {Long.toString(deckToTest)};
        Collection col;
        col = CollectionHelper.getInstance().getCol(getContext());
        Sched sched = col.getSched();
        long selectedDeckBeforeTest = col.getDecks().selected();
        col.getDecks().select(1); //select Default deck

        Cursor reviewInfoCursor = getContext().getContentResolver().query(
                FlashCardsContract.ReviewInfo.CONTENT_URI, null, deckSelector, deckArguments, null);
        assertNotNull(reviewInfoCursor);
        assertEquals("Check that we actually received one card", 1, reviewInfoCursor.getCount());
        try {
            reviewInfoCursor.moveToFirst();
            int cardOrd = reviewInfoCursor.getInt(reviewInfoCursor.getColumnIndex(FlashCardsContract.ReviewInfo.CARD_ORD));
            long noteID = reviewInfoCursor.getLong(reviewInfoCursor.getColumnIndex(FlashCardsContract.ReviewInfo.NOTE_ID));
            assertEquals("Check that the selected deck has not changed", 1, col.getDecks().selected());

            col.getDecks().select(deckToTest);
            Card nextCard = null;
            for(int i = 0; i < 10; i++) {//minimizing fails, when sched.reset() randomly chooses between multiple cards
                sched.reset();
                nextCard = sched.getCard();
                if(nextCard.note().getId() == noteID && nextCard.getOrd() == cardOrd)break;
            }
            assertNotNull("Check that there actually is a next scheduled card", nextCard);
            assertEquals("Check that received card and actual card have same note id", nextCard.note().getId(), noteID);
            assertEquals("Check that received card and actual card have same card ord", nextCard.getOrd(), cardOrd);
        }finally {
            reviewInfoCursor.close();
        }

        col.getDecks().select(selectedDeckBeforeTest);
    }

    /**
     * Test changing the selected deck
     */
    public void testSetSelectedDeck(){
        long deckId = mTestDeckIds[0];
        ContentResolver cr = getContext().getContentResolver();
        Uri selectDeckUri = FlashCardsContract.Deck.CONTENT_SELECTED_URI;
        ContentValues values = new ContentValues();
        values.put(FlashCardsContract.Deck.DECK_ID, deckId);
        cr.update(selectDeckUri, values, null, null);
        Collection col = reopenCol();
        assertEquals("Check that the selected deck has been correctly set", deckId, col.getDecks().selected());
    }

    /**
     * Test giving the answer for a reviewed card
     */
    public void testAnswerCard(){
        Collection col;
        col = CollectionHelper.getInstance().getCol(getContext());
        long deckId = mTestDeckIds[0];
        col.getDecks().select(deckId);
        Card card = col.getSched().getCard();

        ContentResolver cr = getContext().getContentResolver();
        Uri reviewInfoUri = FlashCardsContract.ReviewInfo.CONTENT_URI;
        ContentValues values = new ContentValues();
        long noteId = card.note().getId();
        int cardOrd = card.getOrd();
        int ease = AbstractFlashcardViewer.EASE_3; //<- insert real ease here

        values.put(FlashCardsContract.ReviewInfo.NOTE_ID, noteId);
        values.put(FlashCardsContract.ReviewInfo.CARD_ORD, cardOrd);
        values.put(FlashCardsContract.ReviewInfo.EASE, ease);
        int updateCount = cr.update(reviewInfoUri, values, null, null);
        assertEquals("Check if update returns 1", 1, updateCount);
        col.getSched().reset();
        Card newCard = col.getSched().getCard();
        if(newCard != null){
            if(newCard.note().getId() == card.note().getId() && newCard.getOrd() == card.getOrd()){
                fail("Next scheduled card has not changed");
            }
        }else{
            //We expected this
        }
    }

    private Collection reopenCol() {
        CollectionHelper.getInstance().closeCollection(false);
        return CollectionHelper.getInstance().getCol(getContext());
    }

}
/****************************************************************************************
 * Copyright (c) 2014 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.tests;

import android.content.Context;
import android.content.res.AssetManager;
import android.text.TextUtils;

import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Storage;
import com.ichi2.libanki.Utils;
import com.ichi2.libanki.hooks.Hooks;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;

/**
 * Shared methods for unit tests.
 */
public class Shared {

    public static Collection getEmptyCol(Context context) throws IOException {
        File f = File.createTempFile("test", ".anki2");
        // Provide a string instead of an actual File. Storage.Collection won't populate the DB
        // if the file already exists (it assumes it's an existing DB).
        String path = f.getAbsolutePath();
        f.delete();
        return Storage.Collection(context, path);
    }


    /**
     * @return A File object pointing to a directory in which temporary test files can be placed. The directory is
     *         emptied on every invocation of this method so it is suitable to use at the start of each test.
     *         Only add files (and not subdirectories) to this directory.
     */
    public static File getTestDir(Context context) {
        return getTestDir(context, "");
    }



    /**
     * @param name An additional suffix to ensure the test directory is only used by a particular resource.
     * @return See getTestDir.
     */
    public static File getTestDir(Context context, String name) {
        if (!TextUtils.isEmpty(name)) {
            name = "-" + name;
        }
        File dir = new File(context.getCacheDir(), "testfiles" + name);
        dir.mkdir();
        for (File f : dir.listFiles()) {
            f.delete();
        }
        return dir;
    }


    /**
     * Copy a file from the application's assets directory and return the absolute path of that
     * copy.
     *
     * Files located inside the application's assets collection are not stored on the file
     * system and can not return a usable path, so copying them to disk is a requirement.
     */
    public static String getTestFilePath(Context context, String name) throws IOException {
        InputStream is = context.getClassLoader().getResourceAsStream("assets/"+name);
        String dst = new File(getTestDir(context, name), name).getAbsolutePath();
        Utils.writeToFile(is, dst);
        return dst;
    }
}
/****************************************************************************************
 * Copyright (c) 2016 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/
package com.ichi2.anki.tests.libanki;


import android.test.AndroidTestCase;
import android.test.suitebuilder.annotation.Suppress;

import com.ichi2.anki.exception.ConfirmModSchemaException;
import com.ichi2.anki.tests.Shared;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Models;
import com.ichi2.libanki.Note;
import com.ichi2.libanki.Utils;
import com.ichi2.libanki.importer.Anki2Importer;
import com.ichi2.libanki.importer.AnkiPackageImporter;
import com.ichi2.libanki.importer.Importer;
import com.ichi2.libanki.importer.TextImporter;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;

public class ImportTest extends AndroidTestCase {

    public void testAnki2Mediadupes() throws IOException, JSONException {
        List<String> expected;
        List<String> actual;

        Collection tmp = Shared.getEmptyCol(getContext());
        // add a note that references a sound
        Note n = tmp.newNote();
        n.setItem("Front", "[sound:foo.mp3]");
        long mid = n.model().getLong("id");
        tmp.addNote(n);
        // add that sound to the media folder
        FileOutputStream os;
        os = new FileOutputStream(new File(tmp.getMedia().dir(), "foo.mp3"), false);
        os.write("foo".getBytes());
        os.close();
        tmp.close();
        // it should be imported correctly into an empty deck
        Collection empty = Shared.getEmptyCol(getContext());
        Importer imp = new Anki2Importer(empty, tmp.getPath());
        imp.run();
        expected = Arrays.asList("foo.mp3");
        actual = Arrays.asList(new File(empty.getMedia().dir()).list());
        actual.retainAll(expected);
        assertEquals(expected.size(), actual.size());
        // and importing again will not duplicate, as the file content matches
        empty.remCards(Utils.arrayList2array(empty.getDb().queryColumn(Long.class, "select id from cards", 0)));
        imp = new Anki2Importer(empty, tmp.getPath());
        imp.run();
        expected = Arrays.asList("foo.mp3");
        actual = Arrays.asList(new File(empty.getMedia().dir()).list());
        actual.retainAll(expected);
        assertEquals(expected.size(), actual.size());
        n = empty.getNote(empty.getDb().queryLongScalar("select id from notes"));
        assertTrue(n.getFields()[0].contains("foo.mp3"));
        // if the local file content is different, and import should trigger a rename
        empty.remCards(Utils.arrayList2array(empty.getDb().queryColumn(Long.class, "select id from cards", 0)));
        os = new FileOutputStream(new File(empty.getMedia().dir(), "foo.mp3"), false);
        os.write("bar".getBytes());
        os.close();
        imp = new Anki2Importer(empty, tmp.getPath());
        imp.run();
        expected = Arrays.asList("foo.mp3", String.format("foo_%s.mp3", mid));
        actual = Arrays.asList(new File(empty.getMedia().dir()).list());
        actual.retainAll(expected);
        assertEquals(expected.size(), actual.size());
        n = empty.getNote(empty.getDb().queryLongScalar("select id from notes"));
        assertTrue(n.getFields()[0].contains("_"));
        // if the localized media file already exists, we rewrite the note and media
        empty.remCards(Utils.arrayList2array(empty.getDb().queryColumn(Long.class, "select id from cards", 0)));
        os = new FileOutputStream(new File(empty.getMedia().dir(), "foo.mp3"));
        os.write("bar".getBytes());
        os.close();
        imp = new Anki2Importer(empty, tmp.getPath());
        imp.run();
        expected =  Arrays.asList("foo.mp3", String.format("foo_%s.mp3", mid));
        actual = Arrays.asList(new File(empty.getMedia().dir()).list());
        actual.retainAll(expected);
        assertEquals(expected.size(), actual.size());
        n = empty.getNote(empty.getDb().queryLongScalar("select id from notes"));
        assertTrue(n.getFields()[0].contains("_"));
    }

    public void testApkg() throws IOException {
        List<String> expected;
        List<String> actual;

        Collection tmp = Shared.getEmptyCol(getContext());
        String apkg = Shared.getTestFilePath(getContext(), "media.apkg");
        Importer imp = new AnkiPackageImporter(tmp, apkg);
        expected = Arrays.asList();
        actual = Arrays.asList(new File(tmp.getMedia().dir()).list());
        actual.retainAll(expected);
        assertEquals(actual.size(), expected.size());
        imp.run();
        expected = Arrays.asList("foo.wav");
        actual = Arrays.asList(new File(tmp.getMedia().dir()).list());
        actual.retainAll(expected);
        assertEquals(expected.size(), actual.size());
        // import again should be idempotent in terms of media
        tmp.remCards(Utils.arrayList2array(tmp.getDb().queryColumn(Long.class, "select id from cards", 0)));
        imp = new AnkiPackageImporter(tmp, apkg);
        imp.run();
        expected = Arrays.asList("foo.wav");
        actual = Arrays.asList(new File(tmp.getMedia().dir()).list());
        actual.retainAll(expected);
        assertEquals(actual.size(), expected.size());
        // but if the local file has different data, it will rename
        tmp.remCards(Utils.arrayList2array(tmp.getDb().queryColumn(Long.class, "select id from cards", 0)));
        FileOutputStream os;
        os = new FileOutputStream(new File(tmp.getMedia().dir(), "foo.wav"), false);
        os.write("xyz".getBytes());
        os.close();
        imp = new AnkiPackageImporter(tmp, apkg);
        imp.run();
        assertTrue(new File(tmp.getMedia().dir()).list().length == 2);
    }

    public void testAnki2Diffmodels() throws IOException {
        // create a new empty deck
        Collection dst = Shared.getEmptyCol(getContext());
        // import the 1 card version of the model
        String tmp = Shared.getTestFilePath(getContext(), "diffmodels2-1.apkg");
        AnkiPackageImporter imp = new AnkiPackageImporter(dst, tmp);
        imp.setDupeOnSchemaChange(true);
        imp.run();
        int before = dst.noteCount();
        // repeating the process should do nothing
        imp = new AnkiPackageImporter(dst, tmp);
        imp.setDupeOnSchemaChange(true);
        imp.run();
        assertTrue(before == dst.noteCount());
        // then the 2 card version
        tmp = Shared.getTestFilePath(getContext(), "diffmodels2-2.apkg");
        imp = new AnkiPackageImporter(dst, tmp);
        imp.setDupeOnSchemaChange(true);
        imp.run();
        int after = dst.noteCount();
        // as the model schemas differ, should have been imported as new model
        assertTrue(after == before + 1);
        // and the new model should have both cards
        assertTrue(dst.cardCount() == 3);
        // repeating the process should do nothing
        imp = new AnkiPackageImporter(dst, tmp);
        imp.setDupeOnSchemaChange(true);
        imp.run();
        after = dst.noteCount();
        assertTrue(after == before + 1);
        assertTrue(dst.cardCount() == 3);
    }

    public void testAnki2DiffmodelTemplates() throws IOException, JSONException {
        // different from the above as this one tests only the template text being
        // changed, not the number of cards/fields
        Collection dst = Shared.getEmptyCol(getContext());
        // import the first version of the model
        String tmp = Shared.getTestFilePath(getContext(), "diffmodeltemplates-1.apkg");
        AnkiPackageImporter imp = new AnkiPackageImporter(dst, tmp);
        imp.setDupeOnSchemaChange(true);
        imp.run();
        // then the version with updated template
        tmp = Shared.getTestFilePath(getContext(), "diffmodeltemplates-2.apkg");
        imp = new AnkiPackageImporter(dst, tmp);
        imp.setDupeOnSchemaChange(true);
        imp.run();
        // collection should contain the note we imported
        assertTrue(dst.noteCount() == 1);
        // the front template should contain the text added in the 2nd package
        Long tcid = dst.findCards("").get(0);
        Note tnote = dst.getCard(tcid).note();
        assertTrue(dst.findTemplates(tnote).get(0).getString("qfmt").contains("Changed Front Template"));
    }

    public void testAnki2Updates() throws IOException {
        // create a new empty deck
        Collection dst = Shared.getEmptyCol(getContext());
        String tmp = Shared.getTestFilePath(getContext(), "update1.apkg");
        AnkiPackageImporter imp = new AnkiPackageImporter(dst, tmp);
        imp.run();
        assertTrue(imp.getDupes() == 0);
        assertTrue(imp.getAdded() == 1);
        assertTrue(imp.getUpdated() == 0);
        // importing again should be idempotent
        imp = new AnkiPackageImporter(dst, tmp);
        imp.run();
        assertTrue(imp.getDupes() == 1);
        assertTrue(imp.getAdded() == 0);
        assertTrue(imp.getUpdated() == 0);
        // importing a newer note should update
        assertTrue(dst.noteCount() == 1);
        assertTrue(dst.getDb().queryString("select flds from notes").startsWith("hello"));
        tmp = Shared.getTestFilePath(getContext(), "update2.apkg");
        imp = new AnkiPackageImporter(dst, tmp);
        imp.run();
        assertTrue(imp.getDupes()== 1);
        assertTrue(imp.getAdded() == 0);
        assertTrue(imp.getUpdated() == 1);
        assertTrue(dst.getDb().queryString("select flds from notes").startsWith("goodbye"));
    }

    // Remove @Suppress when csv importer is implemented
    @Suppress
    public void testCsv() throws IOException {
        Collection deck = Shared.getEmptyCol(getContext());
        String file = Shared.getTestFilePath(getContext(), "text-2fields.txt");
        TextImporter i = new TextImporter(deck, file);
        i.initMapping();
        i.run();
        // four problems - too many & too few fields, a missing front, and a
        // duplicate entry
        assertTrue(i.getLog().size() == 5);
        assertTrue(i.getTotal() == 5);
        // if we run the import again, it should update instead
        i.run();
        assertTrue(i.getLog().size() == 10);
        assertTrue(i.getTotal() == 5);
        // but importing should not clobber tags if they're unmapped
        Note n = deck.getNote(deck.getDb().queryLongScalar("select id from notes"));
        n.addTag("test");
        n.flush();
        i.run();
        n.load();
        assertTrue((n.getTags().size() == 1) && (n.getTags().get(0) == "test"));
        // if add-only mode, count will be 0
        i.setImportMode(1);
        i.run();
        assertTrue(i.getTotal() == 0);
        // and if dupes mode, will reimport everything
        assertTrue(deck.cardCount() == 5);
        i.setImportMode(2);
        i.run();
        // includes repeated field
        assertTrue(i.getTotal() == 6);
        assertTrue(deck.cardCount() == 11);
        deck.close();
    }

    // Remove @Suppress when csv importer is implemented
    @Suppress
    public void testCsv2() throws  IOException, ConfirmModSchemaException {
        Collection deck = Shared.getEmptyCol(getContext());
        Models mm = deck.getModels();
        JSONObject m = mm.current();
        JSONObject f = mm.newField("Three");
        mm.addField(m, f);
        mm.save(m);
        Note n = deck.newNote();
        n.setItem("Front", "1");
        n.setItem("Back", "2");
        n.setItem("Three", "3");
        deck.addNote(n);
        // an update with unmapped fields should not clobber those fields
        String file = Shared.getTestFilePath(getContext(), "text-update.txt");
        TextImporter i = new TextImporter(deck, file);
        i.initMapping();
        i.run();
        n.load();
        assertTrue(n.getItem("Front").equals("1"));
        assertTrue(n.getItem("Back").equals("x"));
        assertTrue(n.getItem("Three").equals("3"));
        deck.close();
    }

    /**
     * Custom tests for AnkiDroid.
     */


    public void testDupeIgnore() throws IOException {
        // create a new empty deck
        Collection dst = Shared.getEmptyCol(getContext());
        String tmp = Shared.getTestFilePath(getContext(), "update1.apkg");
        AnkiPackageImporter imp = new AnkiPackageImporter(dst, tmp);
        imp.run();
        tmp = Shared.getTestFilePath(getContext(), "update3.apkg");
        imp = new AnkiPackageImporter(dst, tmp);
        imp.run();
        // there is a dupe, but it was ignored
        assertTrue(imp.getDupes() == 1);
        assertTrue(imp.getAdded() == 0);
        assertTrue(imp.getUpdated() == 0);
    }
}
/****************************************************************************************
 * Copyright (c) 2014 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/
package com.ichi2.anki.tests.libanki;

import android.test.AndroidTestCase;
import android.test.suitebuilder.annotation.Suppress;

import com.ichi2.anki.BackupManager;
import com.ichi2.anki.tests.Shared;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Media;
import com.ichi2.libanki.Note;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;


/**
 * Unit tests for {@link Media}.
 */
public class MediaTest extends AndroidTestCase {
    public void testAdd() throws IOException {
        // open new empty collection
        Collection d = Shared.getEmptyCol(getContext());
        File dir = Shared.getTestDir(getContext());
        BackupManager.removeDir(dir);
        dir.mkdirs();
        File path = new File(dir, "foo.jpg");
        FileOutputStream os;
        os = new FileOutputStream(path, false);
        os.write("hello".getBytes());
        os.close();
        // new file, should preserve name
        String r = d.getMedia().addFile(path);
        assertEquals("foo.jpg", r);
        // adding the same file again should not create a duplicate
        assertEquals("foo.jpg", d.getMedia().addFile(path));
        // but if it has a different md5, it should
        os = new FileOutputStream(path, false);
        os.write("world".getBytes());
        os.close();
        assertEquals("foo (1).jpg", d.getMedia().addFile(path));
    }


    public void testStrings() throws IOException {
        Collection d = Shared.getEmptyCol(getContext());
        Long mid = d.getModels().getModels().entrySet().iterator().next().getKey();
        List<String> expected;
        List<String> actual;

        expected = Arrays.asList();
        actual = d.getMedia().filesInStr(mid, "aoeu");
        actual.retainAll(expected);
        assertEquals(expected.size(), actual.size());

        expected = Arrays.asList("foo.jpg");
        actual = d.getMedia().filesInStr(mid, "aoeu<img src='foo.jpg'>ao");
        actual.retainAll(expected);
        assertEquals(expected.size(), actual.size());

        expected = Arrays.asList("foo.jpg", "bar.jpg");
        actual = d.getMedia().filesInStr(mid, "aoeu<img src='foo.jpg'><img src=\"bar.jpg\">ao");
        actual.retainAll(expected);
        assertEquals(expected.size(), actual.size());

        expected = Arrays.asList("foo.jpg");
        actual = d.getMedia().filesInStr(mid, "aoeu<img src=foo.jpg style=bar>ao");
        actual.retainAll(expected);
        assertEquals(expected.size(), actual.size());

        expected = Arrays.asList("one", "two");
        actual = d.getMedia().filesInStr(mid, "<img src=one><img src=two>");
        actual.retainAll(expected);
        assertEquals(expected.size(), actual.size());

        expected = Arrays.asList("foo.jpg");
        actual = d.getMedia().filesInStr(mid, "aoeu<img src=\"foo.jpg\">ao");
        actual.retainAll(expected);
        assertEquals(expected.size(), actual.size());

        expected = Arrays.asList("foo.jpg", "fo");
        actual = d.getMedia().filesInStr(mid, "aoeu<img src=\"foo.jpg\"><img class=yo src=fo>ao");
        actual.retainAll(expected);
        assertEquals(expected.size(), actual.size());

        expected = Arrays.asList("foo.mp3");
        actual = d.getMedia().filesInStr(mid, "aou[sound:foo.mp3]aou");
        actual.retainAll(expected);
        assertEquals(expected.size(), actual.size());

        assertEquals("aoeu", d.getMedia().strip("aoeu"));
        assertEquals("aoeuaoeu", d.getMedia().strip("aoeu[sound:foo.mp3]aoeu"));
        assertEquals("aoeu", d.getMedia().strip("a<img src=yo>oeu"));
        assertEquals("aoeu", d.getMedia().escapeImages("aoeu"));
        assertEquals("<img src='http://foo.com'>", d.getMedia().escapeImages("<img src='http://foo.com'>"));
        assertEquals("<img src=\"foo%20bar.jpg\">", d.getMedia().escapeImages("<img src=\"foo bar.jpg\">"));
    }

    public void testDeckIntegration() throws IOException {
        Collection d = Shared.getEmptyCol(getContext());
        // create a media dir
        d.getMedia().dir();
        // Put a file into it
        File file = new File(Shared.getTestDir(getContext()), "fake.png");
        file.createNewFile();
        d.getMedia().addFile(file);
        // add a note which references it
        Note f = d.newNote();
        f.setItem("Front", "one");
        f.setItem("Back", "<img src='fake.png'>");
        d.addNote(f);
        // and one which references a non-existent file
        f = d.newNote();
        f.setItem("Front", "one");
        f.setItem("Back", "<img src='fake2.png'>");
        d.addNote(f);
        // and add another file which isn't used
        FileOutputStream os;
        os = new FileOutputStream(new File(d.getMedia().dir(), "foo.jpg"), false);
        os.write("test".getBytes());
        os.close();
        // check media
        List<List<String>> ret = d.getMedia().check();
        List<String> expected;
        List<String> actual;
        expected = Arrays.asList("fake2.png");
        actual = ret.get(0);
        actual.retainAll(expected);
        assertEquals(expected.size(), actual.size());
        expected = Arrays.asList("foo.jpg");
        actual = ret.get(1);
        actual.retainAll(expected);
        assertEquals(expected.size(), actual.size());
    }


    @Suppress
    private List<String> added(Collection d) {
        return d.getMedia().getDb().queryColumn(String.class, "select fname from media where csum is not null", 0);
    }

    @Suppress
    private List<String> removed(Collection d) {
        return d.getMedia().getDb().queryColumn(String.class, "select fname from media where csum is null", 0);
    }

    public void testChanges() throws IOException {
        Collection d = Shared.getEmptyCol(getContext());
        assertTrue(d.getMedia()._changed() != null);
        assertTrue(added(d).size() == 0);
        assertTrue(removed(d).size() == 0);
        // add a file
        File dir = Shared.getTestDir(getContext());
        File path = new File(dir, "foo.jpg");
        FileOutputStream os;
        os = new FileOutputStream(path, false);
        os.write("hello".getBytes());
        os.close();
        path = new File(d.getMedia().dir(), d.getMedia().addFile(path));
        // should have been logged
        d.getMedia().findChanges();
        assertTrue(added(d).size() > 0);
        assertTrue(removed(d).size() == 0);
        // if we modify it, the cache won't notice
        os = new FileOutputStream(path, true);
        os.write("world".getBytes());
        os.close();
        assertTrue(added(d).size() == 1);
        assertTrue(removed(d).size() == 0);
        // but if we add another file, it will
        path = new File(path.getAbsolutePath()+"2");
        os = new FileOutputStream(path, true);
        os.write("yo".getBytes());
        os.close();
        d.getMedia().findChanges(true);
        assertTrue(added(d).size() == 2);
        assertTrue(removed(d).size() == 0);
        // deletions should get noticed too
        path.delete();
        d.getMedia().findChanges(true);
        assertTrue(added(d).size() == 1);
        assertTrue(removed(d).size() == 1);
    }


    public void testIllegal() throws IOException {
        Collection d = Shared.getEmptyCol(getContext());
        String aString = "a:b|cd\\e/f\0g*h";
        String good = "abcdefgh";
        assertTrue(d.getMedia().stripIllegal(aString).equals(good));
        for (int i = 0; i < aString.length(); i++) {
            char c = aString.charAt(i);
            boolean bad = d.getMedia().hasIllegal("something" + c + "morestring");
            if (bad) {
                assertTrue(good.indexOf(c) == -1);
            } else {
                assertTrue(good.indexOf(c) != -1);
            }
        }
    }
}

package com.ichi2.anim;

import android.annotation.TargetApi;
import android.app.Activity;

import com.ichi2.anki.R;

public class ActivityTransitionAnimation {
    public static int LEFT = 0;
    public static int RIGHT = 1;
    public static int FADE = 2;
    public static int UP = 3;
    public static int DOWN = 4;
    public static int DIALOG_EXIT = 5;
    public static int NONE = 6;


    @TargetApi(5)
    public static void slide(Activity activity, int direction) {
        if (direction == LEFT) {
            activity.overridePendingTransition(R.anim.slide_left_in, R.anim.slide_left_out);
        } else if (direction == RIGHT) {
            activity.overridePendingTransition(R.anim.slide_right_in, R.anim.slide_right_out);
        } else if (direction == FADE) {
            activity.overridePendingTransition(R.anim.fade_out, R.anim.fade_in);
        } else if (direction == UP) {
            activity.overridePendingTransition(R.anim.slide_up_in, R.anim.slide_up_out);
        } else if (direction == DOWN) {
            // this is the default animation, we shouldn't try to override it
        } else if (direction == DIALOG_EXIT) {
            activity.overridePendingTransition(R.anim.none, R.anim.dialog_exit);
        } else if (direction == NONE) {
            activity.overridePendingTransition(R.anim.none, R.anim.none);
        }
    }
}

package com.ichi2.anim;

import android.view.animation.AccelerateInterpolator;
import android.view.animation.AlphaAnimation;
import android.view.animation.Animation;
import android.view.animation.DecelerateInterpolator;
import android.view.animation.TranslateAnimation;

public class ViewAnimation {

    public static final int SLIDE_IN_FROM_RIGHT = 0;
    public static final int SLIDE_OUT_TO_RIGHT = 1;
    public static final int SLIDE_IN_FROM_LEFT = 2;
    public static final int SLIDE_OUT_TO_LEFT = 3;
    public static final int SLIDE_IN_FROM_BOTTOM = 4;
    public static final int SLIDE_IN_FROM_TOP = 5;

    public static final int FADE_IN = 0;
    public static final int FADE_OUT = 1;


    public static Animation slide(int type, int duration, int offset) {
        Animation animation;
        switch (type) {
            case SLIDE_IN_FROM_RIGHT:
                animation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, +1.0f, Animation.RELATIVE_TO_SELF, 0.0f,
                        Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f);
                animation.setInterpolator(new DecelerateInterpolator());
                break;
            case SLIDE_OUT_TO_RIGHT:
                animation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, +1.0f,
                        Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f);
                animation.setInterpolator(new AccelerateInterpolator());
                break;
            case SLIDE_IN_FROM_LEFT:
                animation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, -1.0f, Animation.RELATIVE_TO_SELF, 0.0f,
                        Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f);
                animation.setInterpolator(new DecelerateInterpolator());
                break;
            case SLIDE_OUT_TO_LEFT:
                animation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, -1.0f,
                        Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f);
                animation.setInterpolator(new AccelerateInterpolator());
                break;
            case SLIDE_IN_FROM_BOTTOM:
                animation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f,
                        Animation.RELATIVE_TO_SELF, +1.0f, Animation.RELATIVE_TO_SELF, 0.0f);
                animation.setInterpolator(new DecelerateInterpolator());
                break;
            case SLIDE_IN_FROM_TOP:
                animation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f,
                        Animation.RELATIVE_TO_SELF, -1.0f, Animation.RELATIVE_TO_SELF, 0.0f);
                animation.setInterpolator(new DecelerateInterpolator());
                break;
            default:
                animation = null;
        }
        animation.setDuration(duration);
        animation.setStartOffset(offset);
        return animation;
    }


    public static Animation fade(int type, int duration, int offset) {
        float startValue = type;
        Animation animation = new AlphaAnimation(startValue, 1.0f - startValue);
        animation.setDuration(duration);
        if (type == FADE_IN) {
            animation.setZAdjustment(Animation.ZORDER_TOP);
        }
        animation.setStartOffset(offset);
        return animation;
    }
}
/****************************************************************************************
 * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 * Copyright (c) 2014 Bruno Romero de Azevedo <brunodea@inf.ufsm.br>                    *
 * Copyright (c) 2014鈥
package com.ichi2.anki;

import android.annotation.SuppressLint;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.media.AudioManager;
import android.net.Uri;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;
import android.support.v4.app.LoaderManager;
import android.support.v4.app.NotificationCompat;
import android.support.v4.content.ContextCompat;
import android.support.v4.content.IntentCompat;
import android.support.v4.content.Loader;
import android.support.v7.app.AppCompatActivity;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup.LayoutParams;
import android.view.animation.Animation;
import android.widget.ProgressBar;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.dialogs.AsyncDialogFragment;
import com.ichi2.anki.dialogs.DialogHandler;
import com.ichi2.anki.dialogs.SimpleMessageDialog;
import com.ichi2.async.CollectionLoader;
import com.ichi2.compat.CompatHelper;
import com.ichi2.compat.customtabs.CustomTabActivityHelper;
import com.ichi2.libanki.Collection;
import com.ichi2.themes.Themes;

import timber.log.Timber;

public class AnkiActivity extends AppCompatActivity implements LoaderManager.LoaderCallbacks<Collection>,
        SimpleMessageDialog.SimpleMessageDialogListener {

    public final int SIMPLE_NOTIFICATION_ID = 0;
    public static final int REQUEST_REVIEW = 901;

    private DialogHandler mHandler = new DialogHandler(this);

    // custom tabs
    private CustomTabActivityHelper mCustomTabActivityHelper;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // The hardware buttons should control the music volume
        setVolumeControlStream(AudioManager.STREAM_MUSIC);
        // Set the theme
        Themes.setTheme(this);
        super.onCreate(savedInstanceState);
        mCustomTabActivityHelper = new CustomTabActivityHelper();
    }

    @Override
    protected void onStart() {
        super.onStart();
        mCustomTabActivityHelper.bindCustomTabsService(this);
    }

    @Override
    protected void onStop() {
        super.onStop();
        mCustomTabActivityHelper.unbindCustomTabsService(this);
    }


    @Override
    protected void onResume() {
        super.onResume();
        ((NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE)).cancel(SIMPLE_NOTIFICATION_ID);
        // Show any pending dialogs which were stored persistently
        mHandler.readMessage();
    }


    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Timber.i("Home button pressed");
                finishWithoutAnimation();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }


    // called when the CollectionLoader finishes... usually will be over-ridden
    protected void onCollectionLoaded(Collection col) {
    }


    public Collection getCol() {
        return CollectionHelper.getInstance().getCol(this);
    }

    public boolean colIsOpen() {
        return CollectionHelper.getInstance().colIsOpen();
    }


    public boolean animationDisabled() {
        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(this);
        return preferences.getBoolean("eInkDisplay", false);
    }


    public boolean animationEnabled() {
        return !animationDisabled();
    }


    @Override
    public void setContentView(View view) {
        if (animationDisabled()) {
            view.clearAnimation();
        }
        super.setContentView(view);
    }


    @Override
    public void setContentView(View view, LayoutParams params) {
        if (animationDisabled()) {
            view.clearAnimation();
        }
        super.setContentView(view, params);
    }


    @Override
    public void addContentView(View view, LayoutParams params) {
        if (animationDisabled()) {
            view.clearAnimation();
        }
        super.addContentView(view, params);
    }


    @Deprecated
    @Override
    public void startActivity(Intent intent) {
        super.startActivity(intent);
    }


    public void startActivityWithoutAnimation(Intent intent) {
        disableIntentAnimation(intent);
        super.startActivity(intent);
        disableActivityAnimation();
    }


    public void startActivityWithAnimation(Intent intent, int animation) {
        enableIntentAnimation(intent);
        super.startActivity(intent);
        enableActivityAnimation(animation);
    }


    @Deprecated
    @Override
    public void startActivityForResult(Intent intent, int requestCode) {
        super.startActivityForResult(intent, requestCode);
    }


    public void startActivityForResultWithoutAnimation(Intent intent, int requestCode) {
        disableIntentAnimation(intent);
        super.startActivityForResult(intent, requestCode);
        disableActivityAnimation();
    }


    public void startActivityForResultWithAnimation(Intent intent, int requestCode, int animation) {
        enableIntentAnimation(intent);
        super.startActivityForResult(intent, requestCode);
        enableActivityAnimation(animation);
    }


    @Deprecated
    @Override
    public void finish() {
        super.finish();
    }


    public void finishWithoutAnimation() {
        super.finish();
        disableActivityAnimation();
    }


    public void finishWithAnimation(int animation) {
        super.finish();
        enableActivityAnimation(animation);
    }


    protected void disableViewAnimation(View view) {
        view.clearAnimation();
    }


    protected void enableViewAnimation(View view, Animation animation) {
        if (animationDisabled()) {
            disableViewAnimation(view);
        } else {
            view.setAnimation(animation);
        }
    }


    private void disableIntentAnimation(Intent intent) {
        intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);
    }


    private void disableActivityAnimation() {
        ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.NONE);
    }


    private void enableIntentAnimation(Intent intent) {
        if (animationDisabled()) {
            disableIntentAnimation(intent);
        } else {
            // Nothing for now
        }
    }


    private void enableActivityAnimation(int animation) {
        if (animationDisabled()) {
            disableActivityAnimation();
        } else {
            ActivityTransitionAnimation.slide(this, animation);
        }
    }


    // Method for loading the collection which is inherited by all AnkiActivitys
    public void startLoadingCollection() {
        // Initialize the open collection loader
        Timber.d("AnkiActivity.startLoadingCollection()");
        if (!colIsOpen()) {
            showProgressBar();
        }
        getSupportLoaderManager().restartLoader(0, null, this);
    }


    // Kick user back to DeckPicker on collection load error unless this method is overridden
    protected void onCollectionLoadError() {
        Intent deckPicker = new Intent(this, DeckPicker.class);
        deckPicker.putExtra("collectionLoadError", true); // don't currently do anything with this
        deckPicker.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivityWithAnimation(deckPicker, ActivityTransitionAnimation.LEFT);
    }


    // CollectionLoader Listener callbacks
    @Override
    public Loader<Collection> onCreateLoader(int id, Bundle args) {
        // Currently only using one loader, so ignore id
        return new CollectionLoader(this);
    }


    @Override
    public void onLoadFinished(Loader<Collection> loader, Collection col) {
        hideProgressBar();
        if (col != null && colIsOpen()) {
            onCollectionLoaded(col);
        } else {
            onCollectionLoadError();
        }
    }


    @Override
    public void onLoaderReset(Loader<Collection> arg0) {
        // We don't currently retain any references, so no need to free any data here
    }


    public void showProgressBar() {
        ProgressBar progressBar = (ProgressBar) findViewById(R.id.progress_bar);
        if (progressBar != null) {
            progressBar.setVisibility(View.VISIBLE);
        }
    }


    public void hideProgressBar() {
        ProgressBar progressBar = (ProgressBar) findViewById(R.id.progress_bar);
        if (progressBar != null) {
            progressBar.setVisibility(View.GONE);
        }
    }


    protected void mayOpenUrl(Uri url) {
        boolean success = mCustomTabActivityHelper.mayLaunchUrl(url, null, null);
        if (!success) {
            Timber.w("Couldn't preload url: %s", url.toString());
        }
    }

    protected void openUrl(Uri url) {
        CompatHelper.getCompat().openUrl(this, url);
    }

    public CustomTabActivityHelper getCustomTabActivityHelper() {
        return mCustomTabActivityHelper;
    }


    /**
     * Global method to show dialog fragment including adding it to back stack Note: DO NOT call this from an async
     * task! If you need to show a dialog from an async task, use showAsyncDialogFragment()
     *
     * @param newFragment  the DialogFragment you want to show
     */
    public void showDialogFragment(DialogFragment newFragment) {
        // DialogFragment.show() will take care of adding the fragment
        // in a transaction. We also want to remove any currently showing
        // dialog, so make our own transaction and take care of that here.
        FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
        Fragment prev = getSupportFragmentManager().findFragmentByTag("dialog");
        if (prev != null) {
            ft.remove(prev);
        }
        // save transaction to the back stack
        ft.addToBackStack("dialog");
        newFragment.show(ft, "dialog");
        getSupportFragmentManager().executePendingTransactions();
    }


    /**
     * Global method to show a dialog fragment including adding it to back stack and handling the case where the dialog
     * is shown from an async task, by showing the message in the notification bar if the activity was stopped before the
     * AsyncTask completed
     *
     * @param newFragment  the AsyncDialogFragment you want to show
     */
    public void showAsyncDialogFragment(AsyncDialogFragment newFragment) {
        try {
            showDialogFragment(newFragment);
        } catch (IllegalStateException e) {
            // Store a persistent message to SharedPreferences instructing AnkiDroid to show dialog
            DialogHandler.storeMessage(newFragment.getDialogHandlerMessage());
            // Show a basic notification to the user in the notification bar in the meantime
            String title = newFragment.getNotificationTitle();
            String message = newFragment.getNotificationMessage();
            showSimpleNotification(title, message);
        }
    }


    /**
     * Show a simple message dialog, dismissing the message without taking any further action when OK button is pressed.
     * If a DialogFragment cannot be shown due to the Activity being stopped then the message is shown in the
     * notification bar instead.
     *
     * @param message
     */
    protected void showSimpleMessageDialog(String message) {
        showSimpleMessageDialog(message, false);
    }

    protected void showSimpleMessageDialog(String title, String message){
        showSimpleMessageDialog(title, message, false);
    }



    /**
     * Show a simple message dialog, dismissing the message without taking any further action when OK button is pressed.
     * If a DialogFragment cannot be shown due to the Activity being stopped then the message is shown in the
     * notification bar instead.
     *
     * @param message
     * @param reload flag which forces app to be restarted when true
     */
    protected void showSimpleMessageDialog(String message, boolean reload) {
        AsyncDialogFragment newFragment = SimpleMessageDialog.newInstance(message, reload);
        showAsyncDialogFragment(newFragment);
    }

    protected void showSimpleMessageDialog(String title, String message, boolean reload) {
        AsyncDialogFragment newFragment = SimpleMessageDialog.newInstance(title, message, reload);
        showAsyncDialogFragment(newFragment);
    }


    public void showSimpleNotification(String title, String message) {
        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(this);
        // Don't show notification if disabled in preferences
        if (Integer.parseInt(prefs.getString("minimumCardsDueForNotification", "0")) <= 1000000) {
            // Use the title as the ticker unless the title is simply "AnkiDroid"
            String ticker = title;
            if (title.equals(getResources().getString(R.string.app_name))) {
                ticker = message;
            }
            // Build basic notification
            NotificationCompat.Builder builder = new NotificationCompat.Builder(this)
                    .setSmallIcon(R.drawable.ic_stat_notify)
                    .setContentTitle(title)
                    .setContentText(message)
                    .setColor(ContextCompat.getColor(this, R.color.material_light_blue_500))
                    .setStyle(new NotificationCompat.BigTextStyle().bigText(message))
                    .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
                    .setTicker(ticker);
            // Enable vibrate and blink if set in preferences
            if (prefs.getBoolean("widgetVibrate", false)) {
                builder.setVibrate(new long[] { 1000, 1000, 1000});
            }
            if (prefs.getBoolean("widgetBlink", false)) {
                builder.setLights(Color.BLUE, 1000, 1000);
            }
            // Creates an explicit intent for an Activity in your app
            Intent resultIntent = new Intent(this, DeckPicker.class);
            resultIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | IntentCompat.FLAG_ACTIVITY_CLEAR_TASK);
            PendingIntent resultPendingIntent = PendingIntent.getActivity(this, 0, resultIntent, PendingIntent.FLAG_UPDATE_CURRENT);
            builder.setContentIntent(resultPendingIntent);
            NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
            // mId allows you to update the notification later on.
            notificationManager.notify(SIMPLE_NOTIFICATION_ID, builder.build());
        }

    }

    public DialogHandler getDialogHandler() {
        return mHandler;
    }

    // Handle closing simple message dialog
    @Override
    public void dismissSimpleMessageDialog(boolean reload) {
        dismissAllDialogFragments();
        if (reload) {
            Intent deckPicker = new Intent(this, DeckPicker.class);
            deckPicker.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
            startActivityWithoutAnimation(deckPicker);
        }
    }


    // Dismiss whatever dialog is showing
    public void dismissAllDialogFragments() {
        getSupportFragmentManager().popBackStack("dialog", FragmentManager.POP_BACK_STACK_INCLUSIVE);
    }


    // Restart the activity
    @SuppressLint("NewApi")
    public void restartActivity() {
        Timber.i("AnkiActivity -- restartActivity()");
        Intent intent = new Intent();
        intent.setClass(this, this.getClass());
        intent.putExtras(new Bundle());
        this.startActivityWithoutAnimation(intent);
        this.finishWithoutAnimation();
    }
}

/****************************************************************************************
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 * Copyright (c) 2009 Casey Link <unnamedrambler@gmail.com>                             *
 * Copyright (c) 2014 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.app.Application;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;
import android.util.Log;
import android.view.ViewConfiguration;

import com.ichi2.anki.dialogs.AnkiDroidCrashReportDialog;
import com.ichi2.anki.exception.StorageAccessException;
import com.ichi2.anki.services.BootService;
import com.ichi2.compat.CompatHelper;
import com.ichi2.utils.LanguageUtil;

import org.acra.ACRA;
import org.acra.ACRAConfigurationException;
import org.acra.ReportField;
import org.acra.ReportingInteractionMode;
import org.acra.annotation.ReportsCrashes;
import org.acra.sender.HttpSender;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import timber.log.Timber;

/**
 * Application class.
 */
@ReportsCrashes(
        reportDialogClass = AnkiDroidCrashReportDialog.class,
        httpMethod = HttpSender.Method.PUT,
        reportType = HttpSender.Type.JSON,
        formUri = "https://ankidroid.org/acra/report",
        mode = ReportingInteractionMode.DIALOG,
        resDialogCommentPrompt =  R.string.empty_string,
        resDialogTitle =  R.string.feedback_title,
        resDialogText =  R.string.feedback_default_text,
        resToastText = R.string.feedback_auto_toast_text,
        resDialogPositiveButtonText = R.string.feedback_report,
        additionalSharedPreferences = {"com.ichi2.anki"},
        excludeMatchingSharedPreferencesKeys = {"username","hkey"},
        customReportContent = {
            ReportField.REPORT_ID,
            ReportField.APP_VERSION_CODE,
            ReportField.APP_VERSION_NAME,
            ReportField.PACKAGE_NAME,
            ReportField.FILE_PATH,
            ReportField.PHONE_MODEL,
            ReportField.ANDROID_VERSION,
            ReportField.BUILD,
            ReportField.BRAND,
            ReportField.PRODUCT,
            ReportField.TOTAL_MEM_SIZE,
            ReportField.AVAILABLE_MEM_SIZE,
            ReportField.BUILD_CONFIG,
            ReportField.CUSTOM_DATA,
            ReportField.STACK_TRACE,
            ReportField.STACK_TRACE_HASH,
            //ReportField.INITIAL_CONFIGURATION,
            ReportField.CRASH_CONFIGURATION,
            //ReportField.DISPLAY,
            ReportField.USER_COMMENT,
            ReportField.USER_APP_START_DATE,
            ReportField.USER_CRASH_DATE,
            //ReportField.DUMPSYS_MEMINFO,
            //ReportField.DROPBOX,
            ReportField.LOGCAT,
            //ReportField.EVENTSLOG,
            //ReportField.RADIOLOG,
            //ReportField.IS_SILENT,
            ReportField.INSTALLATION_ID,
            //ReportField.USER_EMAIL,
            //ReportField.DEVICE_FEATURES,
            ReportField.ENVIRONMENT,
            //ReportField.SETTINGS_SYSTEM,
            //ReportField.SETTINGS_SECURE,
            //ReportField.SETTINGS_GLOBAL,
            ReportField.SHARED_PREFERENCES,
            ReportField.APPLICATION_LOG,
            ReportField.MEDIA_CODEC_LIST,
            ReportField.THREAD_DETAILS
            //ReportField.USER_IP
        },
        logcatArguments = { "-t", "100", "-v", "time", "ActivityManager:I", "SQLiteLog:W", AnkiDroidApp.TAG + ":D", "*:S" }
)
public class AnkiDroidApp extends Application {

    public static final String XML_CUSTOM_NAMESPACE = "http://arbitrary.app.namespace/com.ichi2.anki";
    public static final String FEEDBACK_REPORT_ASK = "2";
    public static final String FEEDBACK_REPORT_NEVER = "1";
    public static final String FEEDBACK_REPORT_ALWAYS = "0";

    // Tag for logging messages.
    public static final String TAG = "AnkiDroid";
    // Singleton instance of this class.
    private static AnkiDroidApp sInstance;
    // Constants for gestures
    public static int sSwipeMinDistance = -1;
    public static int sSwipeThresholdVelocity = -1;
    private static int DEFAULT_SWIPE_MIN_DISTANCE;
    private static int DEFAULT_SWIPE_THRESHOLD_VELOCITY;

    /**
     * The latest package version number that included important changes to the database integrity check routine. All
     * collections being upgraded to (or after) this version must run an integrity check as it will contain fixes that
     * all collections should have.
     */
    public static final int CHECK_DB_AT_VERSION = 40;

    /**
     * The latest package version number that included changes to the preferences that requires handling. All
     * collections being upgraded to (or after) this version must update preferences.
     */
    public static final int CHECK_PREFERENCES_AT_VERSION = 20500225;


    /**
     * On application creation.
     */
    @Override
    public void onCreate() {
        super.onCreate();
        // Get preferences
        SharedPreferences preferences = getSharedPrefs(this);

        // Initialize crash reporting module
        ACRA.init(this);

        // Setup logging and crash reporting
        if (BuildConfig.DEBUG) {
            // Enable verbose error logging and do method tracing to put the Class name as log tag
            Timber.plant(new Timber.DebugTree());
            // Disable crash reporting
            setAcraReportingMode(FEEDBACK_REPORT_NEVER);
            preferences.edit().putString("reportErrorMode", FEEDBACK_REPORT_NEVER).commit();
            // Use a wider logcat filter incase crash reporting manually re-enabled
            String [] logcatArgs = { "-t", "300", "-v", "long", "ACRA:S"};
            ACRA.getConfig().setLogcatArguments(logcatArgs);
        } else {
            // Disable verbose error logging and use fixed log tag "AnkiDroid"
            Timber.plant(new ProductionCrashReportingTree());
            // Enable or disable crash reporting based on user setting
            setAcraReportingMode(preferences.getString("reportErrorMode", FEEDBACK_REPORT_ASK));
        }
        Timber.tag(TAG);


        sInstance = this;
        setLanguage(preferences.getString(Preferences.LANGUAGE, ""));

        // Configure WebView to allow file scheme pages to access cookies.
        CompatHelper.getCompat().enableCookiesForFileSchemePages();

        // Prepare Cookies to be synchronized between RAM and permanent storage.
        CompatHelper.getCompat().prepareWebViewCookies(this.getApplicationContext());

        // Set good default values for swipe detection
        final ViewConfiguration vc = ViewConfiguration.get(this);
        DEFAULT_SWIPE_MIN_DISTANCE = vc.getScaledPagingTouchSlop();
        DEFAULT_SWIPE_THRESHOLD_VELOCITY = vc.getScaledMinimumFlingVelocity();

        // Create the AnkiDroid directory if missing. Send exception report if inaccessible.
        if (CollectionHelper.hasStorageAccessPermission(this)) {
            try {
                String dir = CollectionHelper.getCurrentAnkiDroidDirectory(this);
                CollectionHelper.initializeAnkiDroidDirectory(dir);
            } catch (StorageAccessException e) {
                Timber.e(e, "Could not initialize AnkiDroid directory");
                String defaultDir = CollectionHelper.getDefaultAnkiDroidDirectory();
                if (isSdCardMounted() && CollectionHelper.getCurrentAnkiDroidDirectory(this).equals(defaultDir)) {
                    // Don't send report if the user is using a custom directory as SD cards trip up here a lot
                    sendExceptionReport(e, "AnkiDroidApp.onCreate");
                }
            }
        }
        startService(new Intent(this, BootService.class));
    }


    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        // Preserve the language from the settings, e.g. when the device is rotated
        setLanguage(getSharedPrefs(this).getString(Preferences.LANGUAGE, ""));
    }



    /**
     * Convenience method for accessing Shared preferences
     *
     * @param context Context to get preferences for.
     * @return A SharedPreferences object for this instance of the app.
     */
    public static SharedPreferences getSharedPrefs(Context context) {
        return PreferenceManager.getDefaultSharedPreferences(context);
    }


    public static AnkiDroidApp getInstance() {
        return sInstance;
    }


    public static String getCacheStorageDirectory() {
        return sInstance.getCacheDir().getAbsolutePath();
    }

    public static Resources getAppResources() {
        return sInstance.getResources();
    }


    public static boolean isSdCardMounted() {
        return Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState());
    }


    public static void sendExceptionReport(Throwable e, String origin) {
        sendExceptionReport(e, origin, null);
    }


    public static void sendExceptionReport(Throwable e, String origin, String additionalInfo) {
        //CustomExceptionHandler.getInstance().uncaughtException(null, e, origin, additionalInfo);
        SharedPreferences prefs = getSharedPrefs(getInstance());
        // Only send report if we have not sent an identical report before
        try {
            JSONObject sentReports = new JSONObject(prefs.getString("sentExceptionReports", "{}"));
            String hash = getExceptionHash(e);
            if (sentReports.has(hash)) {
                Timber.i("The exception report with hash %s has already been sent from this device", hash);
                return;
            } else {
                sentReports.put(hash, true);
                prefs.edit().putString("sentExceptionReports", sentReports.toString()).apply();
            }
        } catch (JSONException e1) {
            Timber.i(e1, "Could not get cache of sent exception reports");
        }
        ACRA.getErrorReporter().putCustomData("origin", origin);
        ACRA.getErrorReporter().putCustomData("additionalInfo", additionalInfo);
        ACRA.getErrorReporter().handleException(e);
    }

    private static String getExceptionHash(Throwable th) {
        final StringBuilder res = new StringBuilder();
        Throwable cause = th;
        while (cause != null) {
            final StackTraceElement[] stackTraceElements = cause.getStackTrace();
            for (final StackTraceElement e : stackTraceElements) {
                res.append(e.getClassName());
                res.append(e.getMethodName());
            }
            cause = cause.getCause();
        }
        return Integer.toHexString(res.toString().hashCode());
    }


    /**
     * Sets the user language.
     *
     * @param localeCode The locale code of the language to set
     */
    public static void setLanguage(String localeCode) {
        Configuration config = getInstance().getResources().getConfiguration();
        Locale newLocale = LanguageUtil.getLocale(localeCode);
        config.locale = newLocale;
        getInstance().getResources().updateConfiguration(config, getInstance().getResources().getDisplayMetrics());
    }


    public static boolean initiateGestures(SharedPreferences preferences) {
        Boolean enabled = preferences.getBoolean("gestures", false);
        if (enabled) {
            int sensitivity = preferences.getInt("swipeSensitivity", 100);
            if (sensitivity != 100) {
                float sens = 100.0f/sensitivity;
                sSwipeMinDistance = (int) (DEFAULT_SWIPE_MIN_DISTANCE * sens + 0.5f);
                sSwipeThresholdVelocity = (int) (DEFAULT_SWIPE_THRESHOLD_VELOCITY * sens  + 0.5f);
            } else {
                sSwipeMinDistance = DEFAULT_SWIPE_MIN_DISTANCE;
                sSwipeThresholdVelocity = DEFAULT_SWIPE_THRESHOLD_VELOCITY;
            }
        }
        return enabled;
    }


    /**
     * Set the reporting mode for ACRA based on the value of the reportErrorMode preference
     * @param value value of reportErrorMode preference
     */
    public void setAcraReportingMode(String value) {
        SharedPreferences.Editor editor = ACRA.getACRASharedPreferences().edit();
        // Set the ACRA disable value
        if (value.equals(FEEDBACK_REPORT_NEVER)) {
            editor.putBoolean("acra.disable", true);
        } else {
            editor.putBoolean("acra.disable", false);
            // Switch between auto-report via toast and manual report via dialog
            try {
                if (value.equals(FEEDBACK_REPORT_ALWAYS)) {
                    ACRA.getConfig().setMode(ReportingInteractionMode.TOAST);
                    ACRA.getConfig().setResToastText(R.string.feedback_auto_toast_text);
                } else if (value.equals(FEEDBACK_REPORT_ASK)) {
                    ACRA.getConfig().setMode(ReportingInteractionMode.DIALOG);
                    ACRA.getConfig().setResToastText(R.string.feedback_manual_toast_text);
                }
            } catch (ACRAConfigurationException e) {
                Timber.e("Could not set ACRA report mode");
            }
        }
        editor.commit();
    }

    /**
     * Get the url for the feedback page
     * @return
     */
    public static String getFeedbackUrl() {
        if (isCurrentLanguage("ja")) {
            return sInstance.getResources().getString(R.string.link_help_ja);
        } else if (isCurrentLanguage("zh")) {
            return sInstance.getResources().getString(R.string.link_help_zh);
        } else {
            return sInstance.getResources().getString(R.string.link_help);
        }
    }

    /**
     * Get the url for the manual
     * @return
     */
    public static String getManualUrl() {
        if (isCurrentLanguage("ja")) {
            return sInstance.getResources().getString(R.string.link_manual_ja);
        } else if (isCurrentLanguage("zh")) {
            return sInstance.getResources().getString(R.string.link_manual_zh);
        } else {
            return sInstance.getResources().getString(R.string.link_manual);
        }
    }

    /**
     * Check whether l is the currently set language code
     * @param l ISO2 language code
     * @return
     */
    private static boolean isCurrentLanguage(String l) {
        String pref = getSharedPrefs(sInstance).getString(Preferences.LANGUAGE, "");
        return pref.equals(l) || pref.equals("") && Locale.getDefault().getLanguage().equals(l);
    }

    /** A tree which logs necessary data for crash reporting. */
    public static class ProductionCrashReportingTree extends Timber.HollowTree {
        private static final ThreadLocal<String> NEXT_TAG = new ThreadLocal<>();
        private static final Pattern ANONYMOUS_CLASS = Pattern.compile("\\$\\d+$");

        @Override public void e(String message, Object... args) {
            Log.e(TAG, createTag() + "/ " + formatString(message, args)); // Just add to the log.
        }

        @Override public void e(Throwable t, String message, Object... args) {
            Log.e(TAG, createTag() + "/ " + formatString(message, args), t); // Just add to the log.
        }

        @Override public void w(String message, Object... args) {
            Log.w(TAG, createTag() + "/ " + formatString(message, args)); // Just add to the log.
        }

        @Override public void w(Throwable t, String message, Object... args) {
            Log.w(TAG, createTag() + "/ " + formatString(message, args), t); // Just add to the log.
        }

        @Override public void i(String message, Object... args) {
            // Skip createTag() to improve  performance. message should be descriptive enough without it
            Log.i(TAG, formatString(message, args)); // Just add to the log.
        }

        @Override public void i(Throwable t, String message, Object... args) {
            // Skip createTag() to improve  performance. message should be descriptive enough without it
            Log.i(TAG, formatString(message, args), t); // Just add to the log.
        }

        // Ignore logs below INFO level --> Non-overridden methods go to HollowTree

        static String formatString(String message, Object... args) {
            // If no varargs are supplied, treat it as a request to log the string without formatting.
            try {
                return args.length == 0 ? message : String.format(message, args);
            } catch (Exception e) {
                return message;
            }
        }

        private static String createTag() {
            String tag = NEXT_TAG.get();
            if (tag != null) {
                NEXT_TAG.remove();
                return tag;
            }

            StackTraceElement[] stackTrace = new Throwable().getStackTrace();
            if (stackTrace.length < 6) {
                throw new IllegalStateException(
                        "Synthetic stacktrace didn't have enough elements: are you using proguard?");
            }
            tag = stackTrace[5].getClassName();
            Matcher m = ANONYMOUS_CLASS.matcher(tag);
            if (m.find()) {
                tag = m.replaceAll("");
            }
            return tag.substring(tag.lastIndexOf('.') + 1);
        }
    }
}

package com.ichi2.anki;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.res.Resources;
import android.graphics.Typeface;

import android.widget.Toast;

import com.ichi2.libanki.Utils;

import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import timber.log.Timber;

public class AnkiFont {
    private String mName;
    private String mFamily;
    private List<String> mAttributes;
    private String mPath;
    private Boolean mIsDefault;
    private Boolean mIsOverride;
    private static final String fAssetPathPrefix = "/android_asset/fonts/";
    private static Set<String> corruptFonts = new HashSet<>();


    private AnkiFont(String name, String family, List<String> attributes, String path) {
        mName = name;
        mFamily = family;
        mAttributes = attributes;
        mPath = path;
        mIsDefault = false;
        mIsOverride = false;
    }


    /**
     * Factory for AnkiFont creation. Creates a typeface wrapper from a font file representing.
     *
     * @param ctx Activity context, needed to access assets
     * @param path Path to typeface file, needed when this is a custom font.
     * @param fromAssets True if the font is to be found in assets of application
     * @return A new AnkiFont object or null if the file can't be interpreted as typeface.
     */
    public static AnkiFont createAnkiFont(Context ctx, String path, boolean fromAssets) {
        File fontfile = new File(path);
        String name = Utils.splitFilename(fontfile.getName())[0];
        String family = name;
        List<String> attributes = new ArrayList<>();

        if (fromAssets) {
            path = fAssetPathPrefix.concat(fontfile.getName());
        }
        Typeface tf = getTypeface(ctx, path);
        if (tf == null) {
            // unable to create typeface
            return null;
        }

        if (tf.isBold() || name.toLowerCase(Locale.US).contains("bold")) {
            attributes.add("font-weight: bolder;");
            family = family.replaceFirst("(?i)-?Bold", "");
        } else if (name.toLowerCase(Locale.US).contains("light")) {
            attributes.add("font-weight: lighter;");
            family = family.replaceFirst("(?i)-?Light", "");
        } else {
            attributes.add("font-weight: normal;");
        }
        if (tf.isItalic() || name.toLowerCase(Locale.US).contains("italic")) {
            attributes.add("font-style: italic;");
            family = family.replaceFirst("(?i)-?Italic", "");
        } else if (name.toLowerCase(Locale.US).contains("oblique")) {
            attributes.add("font-style: oblique;");
            family = family.replaceFirst("(?i)-?Oblique", "");
        } else {
            attributes.add("font-style: normal;");
        }
        if (name.toLowerCase(Locale.US).contains("condensed") || name.toLowerCase(Locale.US).contains("narrow")) {
            attributes.add("font-stretch: condensed;");
            family = family.replaceFirst("(?i)-?Condensed", "");
            family = family.replaceFirst("(?i)-?Narrow(er)?", "");
        } else if (name.toLowerCase(Locale.US).contains("expanded") || name.toLowerCase(Locale.US).contains("wide")) {
            attributes.add("font-stretch: expanded;");
            family = family.replaceFirst("(?i)-?Expanded", "");
            family = family.replaceFirst("(?i)-?Wide(r)?", "");
        }

        AnkiFont createdFont = new AnkiFont(name, family, attributes, path);

        // determine if override font or default font
        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(ctx);
        String defaultFont = preferences.getString("defaultFont", "");
        boolean overrideFont = preferences.getString("overrideFontBehavior", "0").equals("1");
        if (defaultFont.equalsIgnoreCase(name)) {
            if (overrideFont) {
                createdFont.setAsOverride();
            } else{
                createdFont.setAsDefault();
            }
        }
        return createdFont;
    }


    public String getDeclaration() {
        return "@font-face {" + getCSS(false) + " src: url(\"file://" + mPath + "\");}";
    }


    public String getCSS(boolean override) {
        StringBuilder sb = new StringBuilder("font-family: \"").append(mFamily);
        if (override) {
            sb.append("\" !important;");
        } else {
            sb.append("\";");
        }
        for (String attr : mAttributes) {
            sb.append(" ").append(attr);
            if (override) {
                if (sb.charAt(sb.length() - 1) == ';') {
                    sb.deleteCharAt(sb.length() - 1);
                    sb.append(" !important;");
                } else {
                    Timber.d("AnkiFont.getCSS() - unable to set a font attribute important while override is set.");
                }
            }
        }
        return sb.toString();
    }


    public String getName() {
        return mName;
    }


    public String getPath() {
        return mPath;
    }


    public static Typeface getTypeface(Context ctx, String path) {
        try {
            if (path.startsWith(fAssetPathPrefix)) {
                return Typeface.createFromAsset(ctx.getAssets(), path.replaceFirst("/android_asset/", ""));
            } else {
                return Typeface.createFromFile(path);
            }
        } catch (RuntimeException e) {
            Timber.w(e, "Runtime error in getTypeface for File: %s", path);
            if (!corruptFonts.contains(path)) {
                // Show warning toast
                String name = new File(path).getName();
                Resources res = AnkiDroidApp.getAppResources();
                Toast toast = Toast.makeText(ctx, res.getString(R.string.corrupt_font, name), Toast.LENGTH_LONG);
                toast.show();
                // Don't warn again in this session
                corruptFonts.add(path);
            }
            return null;
        }
    }


    private void setAsDefault() {
        mIsDefault = true;
        mIsOverride = false;
    }


    private void setAsOverride() {
        mIsOverride = true;
        mIsDefault = false;
    }
}
/***************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.SharedPreferences;
import android.os.StatFs;


import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Utils;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Locale;
import java.util.UnknownFormatConversionException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import timber.log.Timber;

public class BackupManager {

    public static final int MIN_FREE_SPACE = 10;
    public static final int MIN_BACKUP_COL_SIZE = 10000; // threshold in bytes to backup a col file

    public final static String BACKUP_SUFFIX = "backup";
    public final static String BROKEN_DECKS_SUFFIX = "broken";

    private static boolean mUseBackups = true;


    /** Number of hours after which a backup new backup is created */
    public static final int BACKUP_INTERVAL = 5;


    /* Prevent class from being instantiated */
    private BackupManager() {
    }


    public static boolean isActivated() {
        return mUseBackups;
    }


    private static File getBackupDirectory(File ankidroidDir) {
        File directory = new File(ankidroidDir, BACKUP_SUFFIX);
        if (!directory.isDirectory()) {
            directory.mkdirs();
        }
        return directory;
    }


    private static File getBrokenDirectory(File ankidroidDir) {
        File directory = new File(ankidroidDir, BROKEN_DECKS_SUFFIX);
        if (!directory.isDirectory()) {
            directory.mkdirs();
        }
        return directory;
    }


    public static boolean performBackupInBackground(String path) {
        return performBackupInBackground(path, BACKUP_INTERVAL, false);
    }


    public static boolean performBackupInBackground(String path, boolean force) {
        return performBackupInBackground(path, BACKUP_INTERVAL, force);
    }


    public static boolean performBackupInBackground(String path, int interval) {
        return performBackupInBackground(path, interval, false);
    }


    public static boolean performBackupInBackground(final String colPath, int interval, boolean force) {
        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext());
        if (prefs.getInt("backupMax", 8) == 0 && !force) {
            Timber.w("backups are disabled");
            return false;
        }
        final File colFile = new File(colPath);
        File[] deckBackups = getBackups(colFile);
        int len = deckBackups.length;
        if (len > 0 && deckBackups[len - 1].lastModified() == colFile.lastModified()) {
            Timber.d("performBackup: No backup necessary due to no collection changes");
            return false;
        }

        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd-HH-mm", Locale.US);
        Calendar cal = new GregorianCalendar();
        cal.setTimeInMillis(System.currentTimeMillis());

        // Abort backup if one was already made less than 5 hours ago
        Date lastBackupDate = null;
        while (lastBackupDate == null && len > 0) {
            try {
                len--;
                lastBackupDate = df.parse(deckBackups[len].getName().replaceAll(
                        "^.*-(\\d{4}-\\d{2}-\\d{2}-\\d{2}-\\d{2}).apkg$", "$1"));
            } catch (ParseException e) {
                lastBackupDate = null;
            }
        }
        if (lastBackupDate != null && lastBackupDate.getTime() + interval * 3600000L > Utils.intNow(1000) && !force) {
            Timber.d("performBackup: No backup created. Last backup younger than 5 hours");
            return false;
        }

        String backupFilename;
        try {
            backupFilename = String.format(Utils.ENGLISH_LOCALE, colFile.getName().replace(".anki2", "")
                    + "-%s.apkg", df.format(cal.getTime()));
        } catch (UnknownFormatConversionException e) {
            Timber.e(e, "performBackup: error on creating backup filename");
            return false;
        }

        // Abort backup if destination already exists (extremely unlikely)
        final File backupFile = new File(getBackupDirectory(colFile.getParentFile()), backupFilename);
        if (backupFile.exists()) {
            Timber.d("performBackup: No new backup created. File already exists");
            return false;
        }

        // Abort backup if not enough free space
        if (getFreeDiscSpace(colFile) < colFile.length() + (MIN_FREE_SPACE * 1024 * 1024)) {
            Timber.e("performBackup: Not enough space on sd card to backup.");
            prefs.edit().putBoolean("noSpaceLeft", true).commit();
            return false;
        }

        // Don't bother trying to do backup if the collection is too small to be valid
        if (colFile.length() < MIN_BACKUP_COL_SIZE) {
            Timber.d("performBackup: No backup created as the collection is too small to be valid");
            return false;
        }


        // TODO: Probably not a good idea to do the backup while the collection is open
        if (CollectionHelper.getInstance().colIsOpen()) {
            Timber.w("Collection is already open during backup... we probably shouldn't be doing this");
        }
        Timber.i("Launching new thread to backup %s to %s", colPath, backupFile.getPath());

        // Backup collection as apkg in new thread
        Thread thread = new Thread() {
            @Override
            public void run() {
                // Save collection file as zip archive
                int BUFFER_SIZE = 1024;
                byte[] buf = new byte[BUFFER_SIZE];
                try {
                    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(colPath), BUFFER_SIZE);
                    ZipOutputStream zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(backupFile)));
                    ZipEntry ze = new ZipEntry("collection.anki2");
                    zos.putNextEntry(ze);
                    int len;
                    while ((len = bis.read(buf, 0, BUFFER_SIZE)) != -1) {
                        zos.write(buf, 0, len);
                    }
                    zos.close();
                    bis.close();
                    // Delete old backup files if needed
                    SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext());
                    deleteDeckBackups(colPath, prefs.getInt("backupMax", 8));
                    // set timestamp of file in order to avoid creating a new backup unless its changed
                    backupFile.setLastModified(colFile.lastModified());
                    Timber.i("Backup created succesfully");
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        };
        thread.start();
        return true;
    }


    public static boolean enoughDiscSpace(String path) {
        return getFreeDiscSpace(path) >= (MIN_FREE_SPACE * 1024 * 1024);
    }

    /**
     * Get free disc space in bytes from path to Collection
     * @param path
     * @return
     */
    public static long getFreeDiscSpace(String path) {
        return getFreeDiscSpace(new File(path));
    }


    private static long getFreeDiscSpace(File file) {
        try {
            StatFs stat = new StatFs(file.getParentFile().getPath());
            long blocks = stat.getAvailableBlocks();
            long blocksize = stat.getBlockSize();
            return blocks * blocksize;
        } catch (IllegalArgumentException e) {
            Timber.e(e, "Free space could not be retrieved");
            return MIN_FREE_SPACE * 1024 * 1024;
        }
    }


    /**
     * Run the sqlite3 command-line-tool (if it exists) on the collection to dump to a text file
     * and reload as a new database. Recently this command line tool isn't available on many devices
     *
     * @param col Collection
     * @return whether the repair was successful
     */
    public static boolean repairCollection(Collection col) {
        String deckPath = col.getPath();
        File deckFile = new File(deckPath);
        if (col != null) {
            col.close();
        }

        // repair file
        String execString = "sqlite3 " + deckPath + " .dump | sqlite3 " + deckPath + ".tmp";
        Timber.i("repairCollection - Execute: " + execString);
        try {
            String[] cmd = { "/system/bin/sh", "-c", execString };
            Process process = Runtime.getRuntime().exec(cmd);
            process.waitFor();

            if (!new File(deckPath + ".tmp").exists()) {
                Timber.e("repairCollection - dump to " + deckPath + ".tmp failed");
                return false;
            }

            if (!moveDatabaseToBrokenFolder(deckPath, false)) {
                Timber.e("repairCollection - could not move corrupt file to broken folder");
                return false;
            }
            Timber.i("repairCollection - moved corrupt file to broken folder");
            File repairedFile = new File(deckPath + ".tmp");
            return repairedFile.renameTo(deckFile);
        } catch (IOException | InterruptedException e) {
            Timber.e("repairCollection - error: " + e.getMessage());
        }
        return false;
    }


    public static boolean moveDatabaseToBrokenFolder(String colPath, boolean moveConnectedFilesToo) {
        File colFile = new File(colPath);

        // move file
        Date value = Utils.genToday(Utils.utcOffset());
        String movedFilename = String.format(Utils.ENGLISH_LOCALE, colFile.getName().replace(".anki2", "")
                + "-corrupt-%tF.anki2", value);
        File movedFile = new File(getBrokenDirectory(colFile.getParentFile()), movedFilename);
        int i = 1;
        while (movedFile.exists()) {
            movedFile = new File(getBrokenDirectory(colFile.getParentFile()), movedFilename.replace(".anki2",
                    "-" + Integer.toString(i) + ".anki2"));
            i++;
        }
        movedFilename = movedFile.getName();
        if (!colFile.renameTo(movedFile)) {
            return false;
        }

        if (moveConnectedFilesToo) {
            // move all connected files (like journals, directories...) too
            String deckName = colFile.getName();
            File directory = new File(colFile.getParent());
            for (File f : directory.listFiles()) {
                if (f.getName().startsWith(deckName)) {
                    if (!f.renameTo(new File(getBrokenDirectory(colFile.getParentFile()), f.getName().replace(deckName,
                            movedFilename)))) {
                        return false;
                    }
                }
            }
        }
        return true;
    }


    public static File[] getBackups(File colFile) {
        File[] files = getBackupDirectory(colFile.getParentFile()).listFiles();
        if (files == null) {
            files = new File[0];
        }
        ArrayList<File> deckBackups = new ArrayList<>();
        for (File aktFile : files) {
            if (aktFile.getName().replaceAll("^(.*)-\\d{4}-\\d{2}-\\d{2}-\\d{2}-\\d{2}.apkg$", "$1.apkg")
                    .equals(colFile.getName().replace(".anki2",".apkg"))) {
                deckBackups.add(aktFile);
            }
        }
        Collections.sort(deckBackups);
        File[] fileList = new File[deckBackups.size()];
        deckBackups.toArray(fileList);
        return fileList;
    }


    public static boolean deleteDeckBackups(String colFile, int keepNumber) {
        return deleteDeckBackups(getBackups(new File(colFile)), keepNumber);
    }


    public static boolean deleteDeckBackups(File colFile, int keepNumber) {
        return deleteDeckBackups(getBackups(colFile), keepNumber);
    }


    public static boolean deleteDeckBackups(File[] backups, int keepNumber) {
        if (backups == null) {
            return false;
        }
        for (int i = 0; i < backups.length - keepNumber; i++) {
            backups[i].delete();
            Timber.e("deleteDeckBackups: backup file "+backups[i].getPath()+ " deleted.");
        }
        return true;
    }


    public static boolean removeDir(File dir) {
        if (dir.isDirectory()) {
            File[] files = dir.listFiles();
            for (File aktFile : files) {
                removeDir(aktFile);
            }
        }
        return dir.delete();
    }
}
/****************************************************************************************
 * Copyright (c) 2010 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 * Copyright (c) 2014 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.res.Resources;
import android.graphics.Typeface;
import android.os.Bundle;
import android.os.SystemClock;
import android.support.annotation.NonNull;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.app.ActionBar;
import android.support.v7.widget.SearchView;
import android.text.TextUtils;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.AbsListView;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.AdapterView.OnItemLongClickListener;
import android.widget.AdapterView.OnItemSelectedListener;
import android.widget.ArrayAdapter;
import android.widget.BaseAdapter;
import android.widget.ListView;
import android.widget.Spinner;
import android.widget.TextView;

import com.afollestad.materialdialogs.DialogAction;
import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.dialogs.CardBrowserContextMenu;
import com.ichi2.anki.dialogs.CardBrowserMySearchesDialog;
import com.ichi2.anki.dialogs.CardBrowserOrderDialog;
import com.ichi2.anki.dialogs.TagsDialog;
import com.ichi2.anki.dialogs.TagsDialog.TagsDialogListener;
import com.ichi2.anki.receiver.SdCardReceiver;
import com.ichi2.anki.widgets.DeckDropDownAdapter;
import com.ichi2.async.DeckTask;
import com.ichi2.async.DeckTask.TaskData;
import com.ichi2.compat.Compat;
import com.ichi2.compat.CompatHelper;
import com.ichi2.libanki.Card;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Note;
import com.ichi2.libanki.Utils;
import com.ichi2.themes.Themes;
import com.ichi2.upgrade.Upgrade;
import com.ichi2.widget.WidgetStatus;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import timber.log.Timber;

public class CardBrowser extends NavigationDrawerActivity implements
        DeckDropDownAdapter.SubtitleListener {

    private List<Map<String, String>> mCards;
    private HashMap<String, String> mDeckNames;
    private ArrayList<JSONObject> mDropDownDecks;
    private ListView mCardsListView;
    private SearchView mSearchView;
    private MultiColumnListAdapter mCardsAdapter;
    private String mSearchTerms;
    private String mRestrictOnDeck;

    private MenuItem mSearchItem;
    private MenuItem mSaveSearchItem;
    private MenuItem mMySearchesItem;

    public static Card sCardBrowserCard;

    private int mPositionInCardsList;

    private int mOrder;
    private boolean mOrderAsc;
    private int mColumn1Index;
    private int mColumn2Index;

    private static final int BACKGROUND_NORMAL = 0;
    private static final int BACKGROUND_MARKED = 1;
    private static final int BACKGROUND_SUSPENDED = 2;
    private static final int BACKGROUND_MARKED_SUSPENDED = 3;

    private static final int EDIT_CARD = 0;
    private static final int ADD_NOTE = 1;
    private static final int DEFAULT_FONT_SIZE_RATIO = 100;
    // Should match order of R.array.card_browser_order_labels
    public static final int CARD_ORDER_NONE = 0;
    private static final String[] fSortTypes = new String[] {
        "",
        "noteFld",
        "noteCrt",
        "noteMod",
        "cardMod",
        "cardDue",
        "cardIvl",
        "cardEase",
        "cardReps",
        "cardLapses"};
    // list of available keys in mCards corresponding to the column names in R.array.browser_column2_headings.
    // Note: the last 6 are currently hidden
    private static final String[] COLUMN1_KEYS = {"question", "sfld"};
    private static final String[] COLUMN2_KEYS = {"answer",
        "card",
        "deck",
        "note",
        "question",
        "tags",
        "lapses",
        "reviews",
        "changed",
        "created",
        "due",
        "ease",
        "edited",
        "interval"};
    private long mLastRenderStart = 0;
    private DeckDropDownAdapter mDropDownAdapter;
    private Spinner mActionBarSpinner;
    private boolean mReloadRequired = false;

    /**
     * Broadcast that informs us when the sd card is about to be unmounted
     */
    private BroadcastReceiver mUnmountReceiver = null;

    private MaterialDialog.ListCallback mContextMenuListener = new MaterialDialog.ListCallback() {
        @Override
        public void onSelection(MaterialDialog materialDialog, View view, int which,
        CharSequence charSequence) {
            if (getCards().size() == 0) {
                // Don't do anything if mCards empty
                searchCards();
                return;
            }
            final Card card = getCol().getCard(Long.parseLong(getCards().get(mPositionInCardsList).get("id")));
            Resources res;
            switch (which) {
                case CardBrowserContextMenu.CONTEXT_MENU_MARK:
                    onMark(card);
                    updateCardInList(card, null);
                    return;

                case CardBrowserContextMenu.CONTEXT_MENU_SUSPEND:
                    if (currentCardInUseByReviewer()) {
                        mReloadRequired = true;
                    }
                    DeckTask.launchDeckTask(
                            DeckTask.TASK_TYPE_DISMISS,
                            mSuspendCardHandler,
                            new DeckTask.TaskData(new Object[]{card, Collection.DismissType.SUSPEND_CARD}));
                    return;

                case CardBrowserContextMenu.CONTEXT_MENU_MOVE_FIRST:
                    res = getResources();
                    new MaterialDialog.Builder(CardBrowser.this)
                            .title(res.getString(R.string.move_to_first_card_title))
                            .iconAttr(R.attr.dialogErrorIcon)
                            .content(res.getString(R.string.move_to_first_card_message, getCards().get(mPositionInCardsList)
                                    .get("sfld")))
                            .positiveText(res.getString(R.string.dialog_positive_set))
                            .negativeText(res.getString(R.string.dialog_cancel))
                            .onPositive(new MaterialDialog.SingleButtonCallback() {
                                @Override
                                public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
                                    moveCardToFirst(card);
                                    updateCardInList(card, null);
                                    //DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DISMISS,
                                    //        mDeleteNoteHandler,
                                    //        new DeckTask.TaskData(new Object[]{card, Collection.DismissType.DELETE_NOTE}));
                                }
                            })
                            .build().show();
                    return;

                case CardBrowserContextMenu.CONTEXT_MENU_DELETE:
                    res = getResources();
                    new MaterialDialog.Builder(CardBrowser.this)
                            .title(res.getString(R.string.delete_card_title))
                            .iconAttr(R.attr.dialogErrorIcon)
                            .content(res.getString(R.string.delete_card_message, getCards().get(mPositionInCardsList)
                                    .get("sfld")))
                            .positiveText(res.getString(R.string.dialog_positive_delete))
                            .negativeText(res.getString(R.string.dialog_cancel))
                            .onPositive(new MaterialDialog.SingleButtonCallback() {
                                @Override
                                public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
                                    deleteNote(card);
                                    DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DISMISS,
                                            mDeleteNoteHandler,
                                            new DeckTask.TaskData(new Object[]{card, Collection.DismissType.DELETE_NOTE}));
                                }
                            })
                            .build().show();
                    return;

                case CardBrowserContextMenu.CONTEXT_MENU_DETAILS:
                    Long cardId = Long.parseLong(getCards().get(mPositionInCardsList).get("id"));
                    Intent previewer = new Intent(CardBrowser.this, Previewer.class);
                    previewer.putExtra("index", mPositionInCardsList);
                    previewer.putExtra("cardList", getCardIds());
                    startActivityWithoutAnimation(previewer);
            }
        }
    };


    private MaterialDialog.ListCallbackSingleChoice mOrderDialogListener =
            new MaterialDialog.ListCallbackSingleChoice() {
        @Override
        public boolean onSelection(MaterialDialog materialDialog, View view, int which,
                CharSequence charSequence) {
            if (which != mOrder) {
                mOrder = which;
                mOrderAsc = false;
                try {
                    if (mOrder == 0) {
                        getCol().getConf().put("sortType", fSortTypes[1]);
                        AnkiDroidApp.getSharedPrefs(getBaseContext()).edit()
                                .putBoolean("cardBrowserNoSorting", true)
                                .commit();
                    } else {
                        getCol().getConf().put("sortType", fSortTypes[mOrder]);
                        AnkiDroidApp.getSharedPrefs(getBaseContext()).edit()
                                .putBoolean("cardBrowserNoSorting", false)
                                .commit();
                    }
                    // default to descending for non-text fields
                    if (fSortTypes[mOrder].equals("noteFld")) {
                        mOrderAsc = true;
                    }
                    getCol().getConf().put("sortBackwards", mOrderAsc);
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
                searchCards();
            } else if (which != CARD_ORDER_NONE) {
                mOrderAsc = !mOrderAsc;
                try {
                    getCol().getConf().put("sortBackwards", mOrderAsc);
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
                Collections.reverse(mCards);
                updateList();
            }
            return true;
        }
    };

    private CardBrowserMySearchesDialog.MySearchesDialogListener mMySearchesDialogListener =
            new CardBrowserMySearchesDialog.MySearchesDialogListener() {
        @Override
        public void OnSelection(String searchName) {
            JSONObject savedFiltersObj = getCol().getConf().optJSONObject("savedFilters");
            if (savedFiltersObj != null) {
                mSearchTerms = savedFiltersObj.optString(searchName);
                mSearchView.setQuery(mSearchTerms, false);
                MenuItemCompat.expandActionView(mSearchItem);
                searchCards();
            }
        }

        @Override
        public void OnRemoveSearch(String searchName) {
            try {
                JSONObject savedFiltersObj = getCol().getConf().optJSONObject("savedFilters");
                if (savedFiltersObj != null && savedFiltersObj.has(searchName)) {
                    savedFiltersObj.remove(searchName);
                    getCol().getConf().put("savedFilters", savedFiltersObj);
                    getCol().flush();
                    if (savedFiltersObj.length() == 0) {
                        mMySearchesItem.setVisible(false);
                    }
                }

            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }

        @Override
        public void OnSaveSearch(String searchName, String searchTerms) {
            if (TextUtils.isEmpty(searchName)) {
                UIUtils.showThemedToast(CardBrowser.this,
                        getString(R.string.card_browser_list_my_searches_new_search_error_empty_name), true);
                return;
            }
            try {
                JSONObject savedFiltersObj = getCol().getConf().optJSONObject("savedFilters");
                boolean should_save = false;
                if (savedFiltersObj == null) {
                    savedFiltersObj = new JSONObject();
                    savedFiltersObj.put(searchName, searchTerms);
                    should_save = true;
                } else if (!savedFiltersObj.has(searchName)) {
                    savedFiltersObj.put(searchName, searchTerms);
                    should_save = true;
                } else {
                    UIUtils.showThemedToast(CardBrowser.this,
                            getString(R.string.card_browser_list_my_searches_new_search_error_dup), true);
                }
                if (should_save) {
                    getCol().getConf().put("savedFilters", savedFiltersObj);
                    getCol().flush();
                    mSearchView.setQuery("", false);
                    mMySearchesItem.setVisible(true);
                }
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }
    };


    private void onSearch() {
        mSearchTerms = mSearchView.getQuery().toString();
        if (mSearchTerms.length() == 0) {
            mSearchView.setQueryHint(getResources().getString(R.string.downloaddeck_search));
        }
        searchCards();
    }

    private void onMark(Card card) {
        Note note = card.note();
        if (note.hasTag("marked")) {
            note.delTag("marked");
        } else {
            note.addTag("marked");
        }
        note.flush();
    }

    private void moveCardToFirst(Card card){
        card.setDue(0);
        card.flush();
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Timber.d("onCreate()");
        setContentView(R.layout.card_browser);
        initNavigationDrawer(findViewById(android.R.id.content));
        startLoadingCollection();
    }


    // Finish initializing the activity after the collection has been correctly loaded
    @Override
    protected void onCollectionLoaded(Collection col) {
        super.onCollectionLoaded(col);
        Timber.d("onCollectionLoaded()");
        mDeckNames = new HashMap<>();
        for (long did : getCol().getDecks().allIds()) {
            mDeckNames.put(String.valueOf(did), getCol().getDecks().name(did));
        }
        registerExternalStorageListener();

        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());

        // Add drop-down menu to select deck to action bar.
        mDropDownDecks = getCol().getDecks().allSorted();
        mDropDownAdapter = new DeckDropDownAdapter(this, mDropDownDecks);
        ActionBar mActionBar = getSupportActionBar();
        if (mActionBar != null) {
            mActionBar.setDisplayShowTitleEnabled(false);
        }
        mActionBarSpinner = (Spinner) findViewById(R.id.toolbar_spinner);
        mActionBarSpinner.setAdapter(mDropDownAdapter);
        mActionBarSpinner.setOnItemSelectedListener(new OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                selectDropDownItem(position);
            }

            @Override
            public void onNothingSelected(AdapterView<?> parent) {
                // do nothing
            }
        });
        mActionBarSpinner.setVisibility(View.VISIBLE);

        try {
            mOrder = CARD_ORDER_NONE;
            String colOrder = getCol().getConf().getString("sortType");
            for (int c = 0; c < fSortTypes.length; ++c) {
                if (fSortTypes[c].equals(colOrder)) {
                    mOrder = c;
                    break;
                }
            }
            if (mOrder == 1 && preferences.getBoolean("cardBrowserNoSorting", false)) {
                mOrder = 0;
            }
            mOrderAsc = Upgrade.upgradeJSONIfNecessary(getCol(), getCol().getConf(), "sortBackwards", false);
            // default to descending for non-text fields
            if (fSortTypes[mOrder].equals("noteFld")) {
                mOrderAsc = !mOrderAsc;
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }

        mCards = new ArrayList<>();
        mCardsListView = (ListView) findViewById(R.id.card_browser_list);
        // Create a spinner for column1
        Spinner cardsColumn1Spinner = (Spinner) findViewById(R.id.browser_column1_spinner);
        ArrayAdapter<CharSequence> column1Adapter = ArrayAdapter.createFromResource(this,
                R.array.browser_column1_headings, android.R.layout.simple_spinner_item);
        column1Adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        cardsColumn1Spinner.setAdapter(column1Adapter);
        mColumn1Index = AnkiDroidApp.getSharedPrefs(getBaseContext()).getInt("cardBrowserColumn1", 0);
        cardsColumn1Spinner.setOnItemSelectedListener(new OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {
                // If a new column was selected then change the key used to map from mCards to the column TextView
                if (pos != mColumn1Index) {
                    mColumn1Index = pos;
                    AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()
                            .putInt("cardBrowserColumn1", mColumn1Index).commit();
                    String[] fromMap = mCardsAdapter.getFromMapping();
                    fromMap[0] = COLUMN1_KEYS[mColumn1Index];
                    mCardsAdapter.setFromMapping(fromMap);
                }
            }

            @Override
            public void onNothingSelected(AdapterView<?> parent) {
                // Do Nothing
            }
        });
        // Load default value for column2 selection
        mColumn2Index = AnkiDroidApp.getSharedPrefs(getBaseContext()).getInt("cardBrowserColumn2", 0);
        // Setup the column 2 heading as a spinner so that users can easily change the column type
        Spinner cardsColumn2Spinner = (Spinner) findViewById(R.id.browser_column2_spinner);
        ArrayAdapter<CharSequence> column2Adapter = ArrayAdapter.createFromResource(this,
                R.array.browser_column2_headings, android.R.layout.simple_spinner_item);
        column2Adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        cardsColumn2Spinner.setAdapter(column2Adapter);
        // Create a new list adapter with updated column map any time the user changes the column
        cardsColumn2Spinner.setOnItemSelectedListener(new OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {
                // If a new column was selected then change the key used to map from mCards to the column TextView
                if (pos != mColumn2Index) {
                    mColumn2Index = pos;
                    AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()
                            .putInt("cardBrowserColumn2", mColumn2Index).commit();
                    String[] fromMap = mCardsAdapter.getFromMapping();
                    fromMap[1] = COLUMN2_KEYS[mColumn2Index];
                    mCardsAdapter.setFromMapping(fromMap);
                }
            }

            @Override
            public void onNothingSelected(AdapterView<?> parent) {
                // Do Nothing
            }
        });
        // get the font and font size from the preferences
        int sflRelativeFontSize = preferences.getInt("relativeCardBrowserFontSize", DEFAULT_FONT_SIZE_RATIO);
        String sflCustomFont = preferences.getString("browserEditorFont", "");
        // make a new list adapter mapping the data in mCards to column1 and column2 of R.layout.card_item_browser
        mCardsAdapter = new MultiColumnListAdapter(
                this,
                R.layout.card_item_browser,
                new String[] {COLUMN1_KEYS[mColumn1Index], COLUMN2_KEYS[mColumn2Index]},
                new int[] {R.id.card_sfld, R.id.card_column2},
                "flags",
                sflRelativeFontSize,
                sflCustomFont);
        // link the adapter to the main mCardsListView
        mCardsListView.setAdapter(mCardsAdapter);
        // make the items (e.g. question & answer) render dynamically when scrolling
        mCardsListView.setOnScrollListener(new RenderOnScroll());
        // set the spinner index
        cardsColumn1Spinner.setSelection(mColumn1Index);
        cardsColumn2Spinner.setSelection(mColumn2Index);


        mCardsListView.setOnItemClickListener(new OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                // load up the card selected on the list
                mPositionInCardsList = position;
                long cardId = Long.parseLong(getCards().get(mPositionInCardsList).get("id"));
                sCardBrowserCard = getCol().getCard(cardId);
                // start note editor using the card we just loaded
                Intent editCard = new Intent(CardBrowser.this, NoteEditor.class);
                editCard.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_CARDBROWSER_EDIT);
                editCard.putExtra(NoteEditor.EXTRA_CARD_ID, sCardBrowserCard.getId());
                startActivityForResultWithAnimation(editCard, EDIT_CARD, ActivityTransitionAnimation.LEFT);
            }
        });
        mCardsListView.setOnItemLongClickListener(new OnItemLongClickListener() {
            @Override
            public boolean onItemLongClick(AdapterView<?> adapterView, View view, int position, long id) {
                mPositionInCardsList = position;
                Map<String, String> card = getCards().get(mPositionInCardsList);
                int flags = Integer.parseInt(card.get("flags"));
                String cardName = card.get("sfld");
                boolean isMarked = (flags == 2 || flags == 3);
                boolean isSuspended = (flags == 1 || flags == 3);
                showDialogFragment(CardBrowserContextMenu
                        .newInstance(cardName, isMarked, isSuspended, mContextMenuListener));
                return true;
            }
        });

        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);

        // initialize mSearchTerms to a default value
        mSearchTerms = "";

        // set the currently selected deck
        selectDropDownItem(getDeckPositionFromDeckId(getIntent().getLongExtra("defaultDeckId", -1)));
    }


    @Override
    protected void onStop() {
        Timber.d("onStop()");
        // cancel rendering the question and answer, which has shared access to mCards
        DeckTask.cancelTask(DeckTask.TASK_TYPE_SEARCH_CARDS);
        DeckTask.cancelTask(DeckTask.TASK_TYPE_RENDER_BROWSER_QA);
        super.onStop();
        if (!isFinishing()) {
            WidgetStatus.update(this);
            UIUtils.saveCollectionInBackground(this);
        }
    }


    @Override
    protected void onDestroy() {
        Timber.d("onDestroy()");
        super.onDestroy();
        if (mUnmountReceiver != null) {
            unregisterReceiver(mUnmountReceiver);
        }
    }


    @Override
    public void onBackPressed() {
        if (isDrawerOpen()) {
            super.onBackPressed();
        } else {
            Timber.i("Back key pressed");
            Intent data = new Intent();
            if (mReloadRequired) {
                // Add reload flag to result intent so that schedule reset when returning to note editor
                data.putExtra("reloadRequired", true);
            }
            closeCardBrowser(RESULT_OK, data);
        }
    }
    
    @Override
    protected void onResume() {
        Timber.d("onResume()");
        super.onResume();
        selectNavigationItem(R.id.nav_browser);
    }


    @Override
    public boolean onCreateOptionsMenu(final Menu menu) {
        getMenuInflater().inflate(R.menu.card_browser, menu);
        mSaveSearchItem = menu.findItem(R.id.action_save_search);
        mSaveSearchItem.setVisible(false); //the searchview's query always starts empty.
        mMySearchesItem = menu.findItem(R.id.action_list_my_searches);
        JSONObject savedFiltersObj = getCol().getConf().optJSONObject("savedFilters");
        mMySearchesItem.setVisible(savedFiltersObj != null && savedFiltersObj.length() > 0);
        mSearchItem = menu.findItem(R.id.action_search);
        MenuItemCompat.setOnActionExpandListener(mSearchItem, new MenuItemCompat.OnActionExpandListener() {
            @Override
            public boolean onMenuItemActionExpand(MenuItem item) {
                return true;
            }

            @Override
            public boolean onMenuItemActionCollapse(MenuItem item) {
                // SearchView doesn't support empty queries so we always reset the search when collapsing
                mSearchTerms = "";
                mSearchView.setQuery(mSearchTerms, false);
                searchCards();
                // invalidate options menu so that disappeared icons would appear again
                supportInvalidateOptionsMenu();
                return true;
            }
        });
        mSearchView = (SearchView) MenuItemCompat.getActionView(mSearchItem);
        mSearchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {
            @Override
            public boolean onQueryTextChange(String newText) {
                mSaveSearchItem.setVisible(!TextUtils.isEmpty(newText));
                return true;
            }


            @Override
            public boolean onQueryTextSubmit(String query) {
                onSearch();
                mSearchView.clearFocus();
                return true;
            }
        });
        mSearchView.setOnSearchClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                // Provide SearchView with the previous search terms
                mSearchView.setQuery(mSearchTerms, false);
            }
        });

        // Maybe we were called from ACTION_PROCESS_TEXT.
        // In that case we already fill in the search.
        Intent intent = getIntent();
        Compat compat = CompatHelper.getCompat();
        if (intent.getAction() == compat.ACTION_PROCESS_TEXT) {
            CharSequence search = intent.getCharSequenceExtra(compat.EXTRA_PROCESS_TEXT);
            if (search != null && search.length() != 0) {
                Timber.d("CardBrowser :: Called with search intent: %s", search.toString());
                mSearchView.setQuery(search, true);
            }
        }

        return super.onCreateOptionsMenu(menu);
    }


    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (getDrawerToggle().onOptionsItemSelected(item)) {
            return true;
        }
        switch (item.getItemId()) {

            case R.id.action_add_card_from_card_browser:
                Intent intent = new Intent(CardBrowser.this, NoteEditor.class);
                intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_CARDBROWSER_ADD);
                startActivityForResultWithAnimation(intent, ADD_NOTE, ActivityTransitionAnimation.LEFT);
                return true;

            case R.id.action_save_search:
                String searchTerms = mSearchView.getQuery().toString();
                showDialogFragment(CardBrowserMySearchesDialog.newInstance(null, mMySearchesDialogListener,
                        searchTerms, CardBrowserMySearchesDialog.CARD_BROWSER_MY_SEARCHES_TYPE_SAVE));
                return true;

            case R.id.action_list_my_searches:
                JSONObject savedFiltersObj = getCol().getConf().optJSONObject("savedFilters");
                HashMap<String, String> savedFilters = new HashMap<>();
                if (savedFiltersObj != null) {
                    Iterator<String> it = savedFiltersObj.keys();
                    while (it.hasNext()) {
                        String searchName = it.next();
                        savedFilters.put(searchName, savedFiltersObj.optString(searchName));
                    }
                }
                showDialogFragment(CardBrowserMySearchesDialog.newInstance(savedFilters, mMySearchesDialogListener,
                        "", CardBrowserMySearchesDialog.CARD_BROWSER_MY_SEARCHES_TYPE_LIST));
                return true;
            case R.id.action_sort_by_size:
                showDialogFragment(CardBrowserOrderDialog
                        .newInstance(mOrder, mOrderAsc, mOrderDialogListener));
                return true;

            case R.id.action_show_marked:
                mSearchTerms = "tag:marked";
                mSearchView.setQuery("", false);
                mSearchView.setQueryHint(getResources().getString(R.string.card_browser_show_marked));
                searchCards();
                return true;

            case R.id.action_show_suspended:
                mSearchTerms = "is:suspended";
                mSearchView.setQuery("", false);
                mSearchView.setQueryHint(getResources().getString(R.string.card_browser_show_suspended));
                searchCards();
                return true;

            case R.id.action_search_by_tag:
                showTagsDialog();
                return true;

            default:
                return super.onOptionsItemSelected(item);

        }
    }


    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        // FIXME:
        Timber.d("onActivityResult(requestCode=%d, resultCode=%d)", requestCode, resultCode);
        super.onActivityResult(requestCode, resultCode, data);

        if (resultCode == DeckPicker.RESULT_DB_ERROR) {
            closeCardBrowser(DeckPicker.RESULT_DB_ERROR);
        }

        if (requestCode == EDIT_CARD && resultCode != RESULT_CANCELED) {
            Timber.i("CardBrowser:: CardBrowser: Saving card...");
            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UPDATE_FACT, mUpdateCardHandler,
                    new DeckTask.TaskData(sCardBrowserCard, false));
        } else if (requestCode == ADD_NOTE && resultCode == RESULT_OK) {
            if (mSearchView != null) {
                mSearchTerms = mSearchView.getQuery().toString();
                searchCards();
            } else {
                Timber.w("Note was added from browser and on return mSearchView == null");
            }

        }

        if (requestCode == EDIT_CARD &&  data!=null && data.hasExtra("reloadRequired")) {
            // if reloadRequired flag was sent from note editor then reload card list
            searchCards();
            // keep track of changes for reviewer
            if (currentCardInUseByReviewer()) {
                mReloadRequired = true;
            }
        }
    }

    private boolean currentCardInUseByReviewer() {
        if (getIntent().hasExtra("currentCard") && getCards().size() > mPositionInCardsList
                && getCards().get(mPositionInCardsList) != null) {
            long reviewerCard = getIntent().getExtras().getLong("currentCard");
            long selectedCard = Long.parseLong(getCards().get(mPositionInCardsList).get("id"));
            return selectedCard == reviewerCard;
        }
        return false;
    }

    private void showTagsDialog() {
        TagsDialog dialog = com.ichi2.anki.dialogs.TagsDialog.newInstance(
            TagsDialog.TYPE_FILTER_BY_TAG, new ArrayList<String>(), new ArrayList<>(getCol().getTags().all()));
        dialog.setTagsDialogListener(new TagsDialogListener() {
            @Override
            public void onPositive(List<String> selectedTags, int option) {
                mSearchView.setQuery("", false);
                String tags = selectedTags.toString();
                mSearchView.setQueryHint(getResources().getString(R.string.card_browser_tags_shown,
                        tags.substring(1, tags.length() - 1)));
                StringBuilder sb = new StringBuilder();
                switch (option) {
                    case 1:
                        sb.append("is:new ");
                        break;
                    case 2:
                        sb.append("is:due ");
                        break;
                    default:
                        // Logging here might be appropriate : )
                        break;
                }
                int i = 0;
                for (String tag : selectedTags) {
                    if (i != 0) {
                        sb.append("or ");
                    } else {
                        sb.append("("); // Only if we really have selected tags
                    }
                    sb.append("tag:").append(tag).append(" ");
                    i++;
                }
                if (i > 0) {
                    sb.append(")"); // Only if we added anything to the tag list
                }
                mSearchTerms = sb.toString();
                searchCards();
            }
        });
        showDialogFragment(dialog);
    }


    public void selectDropDownItem(int position) {
        mActionBarSpinner.setSelection(position);
        if (position == 0) {
            mRestrictOnDeck = "";
        } else {
            JSONObject deck = mDropDownDecks.get(position - 1);
            String deckName;
            try {
                deckName = deck.getString("name");
            } catch (JSONException e) {
                throw new RuntimeException();
            }
            try {
                getCol().getDecks().select(deck.getLong("id"));
            } catch (JSONException e) {
                Timber.e(e, "Could not get ID from deck");
            }
            mRestrictOnDeck = "deck:\"" + deckName + "\" ";
        }
        searchCards();
    }

    private void searchCards() {
        // cancel the previous search & render tasks if still running
        DeckTask.cancelTask(DeckTask.TASK_TYPE_SEARCH_CARDS);
        DeckTask.cancelTask(DeckTask.TASK_TYPE_RENDER_BROWSER_QA);
        String searchText;
        if (mSearchTerms.contains("deck:")) {
            searchText = mSearchTerms;
        } else {
            searchText = mRestrictOnDeck + mSearchTerms;
        }
        if (colIsOpen() && mCardsAdapter!= null) {
            // clear the existing card list
            getCards().clear();
            mCardsAdapter.notifyDataSetChanged();
            //  estimate maximum number of cards that could be visible (assuming worst-case minimum row height of 20dp)
            int numCardsToRender = (int) Math.ceil(mCardsListView.getHeight()/
                    TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 20, getResources().getDisplayMetrics())) + 5;
            // Perform database query to get all card ids
            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SEARCH_CARDS, mSearchCardsHandler, new DeckTask.TaskData(
                    new Object[] { mDeckNames, searchText, ((mOrder != CARD_ORDER_NONE)),  numCardsToRender}));
        }
    }


    private void updateList() {
        mCardsAdapter.notifyDataSetChanged();
        mDropDownAdapter.notifyDataSetChanged();
    }

    /**
     * @return text to be used in the subtitle of the drop-down deck selector
     */
    public String getSubtitleText() {
        int count = getCards().size();
        return getResources().getQuantityString(R.plurals.card_browser_subtitle, count, count);
    }


    private int getPosition(List<Map<String, String>> list, long cardId) {
        String cardid = Long.toString(cardId);
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i).get("id").equals(cardid)) {
                return i;
            }
        }
        return -1;
    }


    /**
     * Get the index in the deck spinner for a given deck ID
     * @param did the id of a deck
     * @return the corresponding index in the deck spinner, or 0 if not found
     */
    private int getDeckPositionFromDeckId(long did) {
        for (int dropDownDeckIdx = 0; dropDownDeckIdx < mDropDownDecks.size(); dropDownDeckIdx++) {
            JSONObject deck = mDropDownDecks.get(dropDownDeckIdx);
            long cdid;
            try {
                cdid = deck.getLong("id");
            } catch (JSONException e) {
                throw new RuntimeException();
            }
            if (cdid == did) {
                // NOTE: mDropDownDecks.get(0) is the first deck, whereas index 0 in mActionBarSpinner is "All Decks"
                return dropDownDeckIdx + 1;
            }
        }
        // Fall back on "All Decks" if did wasn't found
        return 0;
    }


    private void updateCardInList(Card card, String updatedCardTags) {
        Note note = card.note();
        int pos;
        for (Card c : note.cards()) {
            // get position in the mCards search results HashMap
            pos = getPosition(getCards(), c.getId());
            if (pos < 0 || pos >= getCards().size()) {
                continue;
            }
            // update tags
            if (updatedCardTags != null) {
                getCards().get(pos).put("tags", updatedCardTags);
            }
            // update sfld
            String sfld = note.getSFld();
            getCards().get(pos).put("sfld", sfld);
            // update Q & A etc
            updateSearchItemQA(getCards().get(pos), c);
            // update deck
            String deckName;
            try {
                deckName = getCol().getDecks().get(card.getDid()).getString("name");
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            getCards().get(pos).put("deck", deckName);
            // update flags (marked / suspended / etc) which determine color
            String flags = Integer.toString((c.getQueue() == -1 ? 1 : 0) + (note.hasTag("marked") ? 2 : 0));
            getCards().get(pos).put("flags", flags);
        }
        updateList();
    }

    private DeckTask.TaskListener mUpdateCardHandler = new DeckTask.TaskListener() {
        @Override
        public void onPreExecute() {
            showProgressBar();
        }


        @Override
        public void onProgressUpdate(DeckTask.TaskData... values) {
            updateCardInList(values[0].getCard(), values[0].getString());
        }


        @Override
        public void onPostExecute(DeckTask.TaskData result) {
            Timber.d("Card Browser - mUpdateCardHandler.onPostExecute()");
            if (!result.getBoolean()) {
                closeCardBrowser(DeckPicker.RESULT_DB_ERROR);
            }
            hideProgressBar();
        }


        @Override
        public void onCancelled() {
        }
    };

    public static void updateSearchItemQA(Map<String, String> item, Card c) {
        // render question and answer
        Map<String, String> qa = c._getQA(true, true);
        // Render full question / answer if the bafmt (i.e. "browser appearance") setting forced blank result
        if (qa.get("q").equals("") || qa.get("a").equals("")) {
            HashMap<String, String> qaFull = c._getQA(true, false);
            if (qa.get("q").equals("")) {
                qa.put("q", qaFull.get("q"));
            }
            if (qa.get("a").equals("")) {
                qa.put("a", qaFull.get("a"));
            }
        }
        // update the original hash map to include rendered question & answer
        String q = qa.get("q");
        String a = qa.get("a");
        // remove the question from the start of the answer if it exists
        if (a.startsWith(q)) {
            a = a.replaceFirst(Pattern.quote(q), "");
        }
        // put all of the fields in except for those that have already been pulled out straight from the
        // database
        item.put("answer", formatQA(a));
        item.put("card", c.template().optString("name"));
        // item.put("changed",strftime("%Y-%m-%d", localtime(c.getMod())));
        // item.put("created",strftime("%Y-%m-%d", localtime(c.note().getId()/1000)));
        // item.put("due",getDueString(c));
        // item.put("ease","");
        // item.put("edited",strftime("%Y-%m-%d", localtime(c.note().getMod())));
        // item.put("interval","");
        item.put("lapses", Integer.toString(c.getLapses()));
        item.put("note", c.model().optString("name"));
        item.put("question", formatQA(q));
        item.put("reviews", Integer.toString(c.getReps()));
    }


    private static String formatQA(String txt) {
        /* Strips all formatting from the string txt for use in displaying question/answer in browser */
        String s = txt.replace("<br>", " ");
        s = s.replace("<br />", " ");
        s = s.replace("<div>", " ");
        s = s.replace("\n", " ");
        s = s.replaceAll("\\[sound:[^]]+\\]", "");
        s = s.replaceAll("\\[\\[type:[^]]+\\]\\]", "");
        s = Utils.stripHTMLMedia(s);
        s = s.trim();
        return s;
    }

    private void deleteNote(Card card) {
        if (currentCardInUseByReviewer()) {
            mReloadRequired = true;
        }
        ArrayList<Card> cards = card.note().cards();
        int pos;
        for (Card c : cards) {
            pos = getPosition(getCards(), c.getId());
            if (pos >= 0 && pos < getCards().size()) {
                getCards().remove(pos);
            }
        }
        // Delete itself if not deleted
        pos = getPosition(getCards(), card.getId());
        if (pos >= 0 && pos < getCards().size()) {
            getCards().remove(pos);
        }
        updateList();
    }


    private DeckTask.TaskListener mSuspendCardHandler = new DeckTask.TaskListener() {
        @Override
        public void onPreExecute() {
            showProgressBar();
        }


        @Override
        public void onProgressUpdate(DeckTask.TaskData... values) {
        }


        @Override
        public void onPostExecute(DeckTask.TaskData result) {
            if (result.getBoolean()) {
                updateCardInList(getCol().getCard(Long.parseLong(getCards().get(mPositionInCardsList).get("id"))), null);
            } else {
                closeCardBrowser(DeckPicker.RESULT_DB_ERROR);
            }
            hideProgressBar();
        }


        @Override
        public void onCancelled() {
        }
    };

    private DeckTask.TaskListener mDeleteNoteHandler = new DeckTask.TaskListener() {
        @Override
        public void onPreExecute() {
            showProgressBar();
        }


        @Override
        public void onProgressUpdate(DeckTask.TaskData... values) {
        }


        @Override
        public void onPostExecute(DeckTask.TaskData result) {
            hideProgressBar();
        }


        @Override
        public void onCancelled() {
        }
    };

    private DeckTask.TaskListener mSearchCardsHandler = new DeckTask.TaskListener() {
        @Override
        public void onProgressUpdate(TaskData... values) {
            if (values[0] != null) {
                mCards = values[0].getCards();
                updateList();
            }
        }


        @Override
        public void onPreExecute() {
            showProgressBar();
        }


        @Override
        public void onPostExecute(TaskData result) {            
            if (result != null && mCards != null) {
                Timber.i("CardBrowser:: Completed doInBackgroundSearchCards Successfuly");
                updateList();
                if (!mSearchView.isIconified()) {
                    UIUtils.showSimpleSnackbar(CardBrowser.this, getSubtitleText(), false);
                }
            }
            hideProgressBar();
        }
        
        @Override
        public void onCancelled(){
            Timber.d("doInBackgroundSearchCards onCancelled() called");
        }
    };

    private DeckTask.TaskListener mRenderQAHandler = new DeckTask.TaskListener() {
        @Override
        public void onProgressUpdate(TaskData... values) {
            // Note: This is called every time a card is rendered.
            // It blocks the long-click callback while the task is running, so usage of the task should be minimized
            mCardsAdapter.notifyDataSetChanged();
        }


        @Override
        public void onPreExecute() {
            Timber.d("Starting Q&A background rendering");
        }


        @Override
        public void onPostExecute(TaskData result) {
            if (result != null) {
                hideProgressBar();
                mCardsAdapter.notifyDataSetChanged();
                Timber.d("Completed doInBackgroundRenderBrowserQA Successfuly");
            } else {
                // Might want to do something more proactive here like show a message box?
                Timber.e("doInBackgroundRenderBrowserQA was not successful... continuing anyway");
            }
        }


        @Override
        public void onCancelled() {
            hideProgressBar();
        }
    };


    private void closeCardBrowser(int result) {
        closeCardBrowser(result, null);
    }

    private void closeCardBrowser(int result, Intent data) {
        // Pass the originally selected deck back so that the calling Activity can switch back to it
        if (getIntent().hasExtra("selectedDeck")) {
            data.putExtra("originalDeck", getIntent().getLongExtra("selectedDeck", 0L));
        }
        // Pass a flag to say whether "All Decks" was selected so that the calling Activity can remember it
        data.putExtra("allDecksSelected", mActionBarSpinner.getSelectedItemPosition() == 0);
        // Set result and finish
        setResult(result, data);
        finishWithAnimation(ActivityTransitionAnimation.RIGHT);
    }

    /**
     * Render the second column whenever the user stops scrolling
     */
    private final class RenderOnScroll implements AbsListView.OnScrollListener {
        @Override
        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
            // Show the progress bar if scrolling to given position requires rendering of the question / answer
            int lastVisibleItem = firstVisibleItem + visibleItemCount;
            int size = getCards().size();
            if (size > 0 && firstVisibleItem < size && lastVisibleItem - 1 < size) {
                String firstAns = getCards().get(firstVisibleItem).get("answer");
                // Note: max value of lastVisibleItem is totalItemCount, so need to subtract 1
                String lastAns = getCards().get(lastVisibleItem - 1).get("answer");
                if (firstAns != null && firstAns.equals("") || lastAns != null && lastAns.equals("")) {
                    showProgressBar();
                    // Also start rendering the items on the screen every 300ms while scrolling
                    long currentTime = SystemClock.elapsedRealtime ();
                    if ((currentTime - mLastRenderStart > 300 || lastVisibleItem >= totalItemCount)) {
                        mLastRenderStart = currentTime;
                        DeckTask.cancelTask(DeckTask.TASK_TYPE_RENDER_BROWSER_QA);
                        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_RENDER_BROWSER_QA, mRenderQAHandler,
                                new DeckTask.TaskData(new Object[]{getCards(), firstVisibleItem, visibleItemCount}));
                    }
                }
            }
        }

        @Override
        public void onScrollStateChanged(AbsListView listView, int scrollState) {
            // TODO: Try change to RecyclerView as currently gets stuck a lot when using scrollbar on right of ListView
            // Start rendering the question & answer every time the user stops scrolling
            if (scrollState == SCROLL_STATE_IDLE) {
                int startIdx = listView.getFirstVisiblePosition();
                int numVisible = listView.getLastVisiblePosition() - startIdx;
                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_RENDER_BROWSER_QA, mRenderQAHandler,
                        new DeckTask.TaskData(new Object[]{getCards(), startIdx - 5, 2 * numVisible + 5}));
            }
        }
    }

    private final class MultiColumnListAdapter extends BaseAdapter {
        private final int mResource;
        private String[] mFromKeys;
        private final int[] mToIds;
        private final String mColorFlagKey;
        private float mOriginalTextSize = -1.0f;
        private final int mFontSizeScalePcent;
        private Typeface mCustomTypeface = null;
        private LayoutInflater mInflater;


        public MultiColumnListAdapter(Context context, int resource, String[] from, int[] to, String colorFlagKey,
                                      int fontSizeScalePcent, String customFont) {
            mResource = resource;
            mFromKeys = from;
            mToIds = to;
            mColorFlagKey = colorFlagKey;
            mFontSizeScalePcent = fontSizeScalePcent;
            if (!customFont.equals("")) {
                mCustomTypeface = AnkiFont.getTypeface(context, customFont);
            }
            mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        }


        public View getView(int position, View convertView, ViewGroup parent) {
            // Get the main container view if it doesn't already exist, and call bindView
            View v;
            if (convertView == null) {
                v = mInflater.inflate(mResource, parent, false);
                final int count = mToIds.length;
                final View[] columns = new View[count];
                for (int i = 0; i < count; i++) {
                    columns[i] = v.findViewById(mToIds[i]);
                }
                v.setTag(columns);
            } else {
                v = convertView;
            }
            bindView(position, v);
            return v;
        }


        private void bindView(int position, View v) {
            // Draw the content in the columns
            View[] columns = (View[]) v.getTag();
            final Map<String, String> dataSet = getCards().get(position);
            final int colorIdx = getColor(dataSet.get(mColorFlagKey));
            int[] colors = Themes.getColorFromAttr(CardBrowser.this, new int[]{android.R.attr.colorBackground,
                    R.attr.markedColor, R.attr.suspendedColor, R.attr.markedColor});
            for (int i = 0; i < mToIds.length; i++) {
                TextView col = (TextView) columns[i];
                // set font for column
                setFont(col);
                // set background color for column
                col.setBackgroundColor(colors[colorIdx]);
                // set text for column
                col.setText(dataSet.get(mFromKeys[i]));
            }
        }


        private void setFont(TextView v) {
            // Set the font and font size for a TextView v
            float currentSize = v.getTextSize();
            if (mOriginalTextSize < 0) {
                mOriginalTextSize = v.getTextSize();
            }
            // do nothing when pref is 100% and apply scaling only once
            if (mFontSizeScalePcent != 100 && Math.abs(mOriginalTextSize - currentSize) < 0.1) {
                v.setTextSize(TypedValue.COMPLEX_UNIT_SP, mOriginalTextSize * (mFontSizeScalePcent / 100.0f));
            }

            if (mCustomTypeface != null) {
                v.setTypeface(mCustomTypeface);
            }
        }

        /**
         * Get the index that specifies the background color of items in the card list based on the String tag
         * @param flag a string flag
         * @return index into TypedArray specifying the background color
         */
        private int getColor(String flag) {
            if (flag == null) {
                return BACKGROUND_NORMAL;
            }
            switch (flag) {
                case "1":
                    return BACKGROUND_SUSPENDED;
                case "2":
                    return  BACKGROUND_MARKED;
                case "3":
                    return  BACKGROUND_MARKED_SUSPENDED;
                default:
                    return BACKGROUND_NORMAL;
            }
        }


        public void setFromMapping(String[] from) {
            mFromKeys = from;
            notifyDataSetChanged();
        }


        public String[] getFromMapping() {
            return mFromKeys;
        }


        @Override
        public int getCount() {
            return getCards().size();
        }


        @Override
        public Object getItem(int position) {
            return getCards().get(position);
        }


        @Override
        public long getItemId(int position) {
            return position;
        }
    }


    private List<Map<String, String>> getCards() {
        if (mCards == null) {
            mCards = new ArrayList<>();
        }
        return mCards;
    }

    private long[] getCardIds() {
        long[] l = new long[mCards.size()];
        for (int i = 0; i < mCards.size(); i++) {
            l[i] = Long.parseLong(mCards.get(i).get("id"));
        }
        return l;
    }


    /**
     * Show/dismiss dialog when sd card is ejected/remounted (collection is saved by SdCardReceiver)
     */
    private void registerExternalStorageListener() {
        if (mUnmountReceiver == null) {
            mUnmountReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    if (intent.getAction().equals(SdCardReceiver.MEDIA_EJECT)) {
                        finishWithoutAnimation();
                    }
                }
            };
            IntentFilter iFilter = new IntentFilter();
            iFilter.addAction(SdCardReceiver.MEDIA_EJECT);
            registerReceiver(mUnmountReceiver, iFilter);
        }
    }

}
/***************************************************************************************
 *                                                                                      *
 * Copyright (c) 2014 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.Context;
import android.content.Intent;
import android.content.res.Resources;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.view.PagerAdapter;
import android.support.v4.view.ViewPager;
import android.support.v7.widget.Toolbar;
import android.text.Editable;
import android.text.TextWatcher;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.inputmethod.InputMethodManager;
import android.widget.EditText;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.dialogs.ConfirmationDialog;
import com.ichi2.anki.exception.ConfirmModSchemaException;
import com.ichi2.async.DeckTask;
import com.ichi2.libanki.Card;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Models;
import com.ichi2.libanki.Note;
import com.ichi2.themes.Themes;
import com.ichi2.ui.SlidingTabLayout;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import timber.log.Timber;


/**
 * Allows the user to view the template for the current note type
 */
public class CardTemplateEditor extends AnkiActivity {
    private TemplatePagerAdapter mTemplateAdapter;
    private JSONObject mModelBackup = null;
    private ViewPager mViewPager;
    private SlidingTabLayout mSlidingTabLayout;
    private long mModelId;
    private long mNoteId;
    private static final int REQUEST_PREVIEWER = 0;
    private static final String DUMMY_TAG = "DUMMY_NOTE_TO_DELETE_x0-90-fa";


    // ----------------------------------------------------------------------------
    // Listeners
    // ----------------------------------------------------------------------------

    /* Used for updating the collection when a reverse card is added */
    private DeckTask.TaskListener mUpdateTemplateHandler = new DeckTask.TaskListener() {
        @Override
        public void onPreExecute() {
            showProgressBar();
        }

        @Override
        public void onProgressUpdate(DeckTask.TaskData... values) {
        }

        @Override
        public void onPostExecute(DeckTask.TaskData result) {
            hideProgressBar();
            if (result.getBoolean()) {
                // Refresh the GUI -- setting the last template as the active tab
                try {
                    selectTemplate(getCol().getModels().get(mModelId).getJSONArray("tmpls").length());
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
            } else if (result.getString() != null && result.getString().equals("removeTemplateFailed")) {
                // Failed to remove template
                String message = getResources().getString(R.string.card_template_editor_would_delete_note);
                UIUtils.showThemedToast(CardTemplateEditor.this, message, false);
            } else {
                // RuntimeException occurred
                setResult(RESULT_CANCELED);
                finishWithoutAnimation();
            }
        }

        @Override
        public void onCancelled() {
            hideProgressBar();
        }
    };


    // ----------------------------------------------------------------------------
    // ANDROID METHODS
    // ----------------------------------------------------------------------------

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Timber.d("onCreate()");
        super.onCreate(savedInstanceState);
        setContentView(R.layout.card_template_editor_activity);
        // Load the args either from the intent or savedInstanceState bundle
        if (savedInstanceState == null) {
            // get model id
            mModelId = getIntent().getLongExtra("modelId", -1L);
            if (mModelId == -1) {
                Timber.e("CardTemplateEditor :: no model ID was provided");
                finishWithoutAnimation();
                return;
            }
            // get id for currently edited card (optional)
            mNoteId = getIntent().getLongExtra("noteId", -1L);
        } else {
            mModelId = savedInstanceState.getLong("modelId");
            mNoteId = savedInstanceState.getLong("noteId");
            try {
                mModelBackup = new JSONObject(savedInstanceState.getString("modelBackup"));
            } catch (JSONException e) {
                Timber.e(e, "Malformed model in savedInstanceState");
            }
        }

        // Disable the home icon
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        if (toolbar != null) {
            setSupportActionBar(toolbar);
        }
        startLoadingCollection();
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        if (mModelBackup != null) {
            outState.putString("modelBackup", mModelBackup.toString());
        }
        outState.putLong("modelId", mModelId);
        outState.putLong("noteId", mNoteId);
        super.onSaveInstanceState(outState);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home: {
                if (modelHasChanged()) {
                    showDiscardChangesDialog();
                } else {
                    finishWithAnimation(ActivityTransitionAnimation.RIGHT);
                }
                return true;
            }
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public void showProgressBar() {
        super.showProgressBar();
        findViewById(R.id.progress_description).setVisibility(View.VISIBLE);
        findViewById(R.id.fragment_parent).setVisibility(View.INVISIBLE);
    }

    @Override
    public void hideProgressBar() {
        super.hideProgressBar();
        findViewById(R.id.progress_description).setVisibility(View.INVISIBLE);
        findViewById(R.id.fragment_parent).setVisibility(View.VISIBLE);
    }

    /**
     * Callback used to finish initializing the activity after the collection has been correctly loaded
     * @param col Collection which has been loaded
     */
    @Override
    protected void onCollectionLoaded(Collection col) {
        super.onCollectionLoaded(col);
        // Create the adapter that will return a fragment for each of the three
        // primary sections of the activity.
        mTemplateAdapter = new TemplatePagerAdapter(getSupportFragmentManager());
        mTemplateAdapter.setModel(col.getModels().get(mModelId));
        // Set up the ViewPager with the sections adapter.
        mViewPager = (ViewPager) findViewById(R.id.pager);
        mViewPager.setAdapter(mTemplateAdapter);
        mViewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
            @Override
            public void onPageScrolled(final int position, final float v, final int i2) {
            }

            @Override
            public void onPageSelected(final int position) {
                CardTemplateFragment fragment = (CardTemplateFragment) mTemplateAdapter.instantiateItem(mViewPager, position);
                if (fragment != null) {
                    fragment.updateCss();
                }
            }

            @Override
            public void onPageScrollStateChanged(final int position) {
            }
        });
        mSlidingTabLayout = (SlidingTabLayout) findViewById(R.id.sliding_tabs);
        mSlidingTabLayout.setViewPager(mViewPager);
        // Set activity title
        if (getSupportActionBar() != null) {
            getSupportActionBar().setTitle(R.string.title_activity_template_editor);
            getSupportActionBar().setSubtitle(col.getModels().get(mModelId).optString("name"));
        }
        // Make backup of the model for cancellation purposes
        try {
            if (mModelBackup == null) {
                mModelBackup = new JSONObject(col.getModels().get(mModelId).toString());
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        // Close collection opening dialog if needed
        Timber.i("CardTemplateEditor:: Card template editor successfully started for model id %d", mModelId);
    }

    public boolean modelHasChanged() {
        JSONObject newModel = getCol().getModels().get(mModelId);
        return mModelBackup != null && !mModelBackup.toString().equals(newModel.toString());
    }

    private void showDiscardChangesDialog() {
        new MaterialDialog.Builder(this)
                .content(R.string.discard_unsaved_changes)
                .positiveText(R.string.dialog_ok)
                .negativeText(R.string.dialog_cancel)
                .callback(new MaterialDialog.ButtonCallback() {
                    @Override
                    public void onPositive(MaterialDialog dialog) {
                        Timber.i("TemplateEditor:: OK button pressed to confirm discard changes");
                        getCol().getModels().update(CardTemplateEditor.this.mModelBackup);
                        getCol().getModels().flush();
                        getCol().reset();
                        finishWithAnimation(ActivityTransitionAnimation.RIGHT);
                    }
                })
                .build().show();
    }


    // ----------------------------------------------------------------------------
    // CUSTOM METHODS
    // ----------------------------------------------------------------------------

    /**
     * Refresh list of templates and select position
     * @param idx index of template to select
     */
    public void selectTemplate(int idx) {
        // invalidate all existing fragments
        mTemplateAdapter.notifyChangeInPosition(1);
        // notify of new data set
        mTemplateAdapter.notifyDataSetChanged();
        // reload the list of tabs
        mSlidingTabLayout.setViewPager(mViewPager);
        // select specified tab
        mViewPager.setCurrentItem(idx);
    }


    // ----------------------------------------------------------------------------
    // INNER CLASSES
    // ----------------------------------------------------------------------------

    /**
     * A {@link android.support.v4.app.FragmentPagerAdapter} that returns a fragment corresponding to
     * one of the tabs.
     */
    public class TemplatePagerAdapter extends FragmentPagerAdapter {
        private JSONObject mModel;
        private long baseId = 0;

        public TemplatePagerAdapter(FragmentManager fm) {
            super(fm);
        }

        //this is called when notifyDataSetChanged() is called
        @Override
        public int getItemPosition(Object object) {
            // refresh all tabs when data set changed
            return PagerAdapter.POSITION_NONE;
        }

        @Override
        public Fragment getItem(int position) {
            return CardTemplateFragment.newInstance(position, mModelId, mNoteId);
        }

        @Override
        public long getItemId(int position) {
            // give an ID different from position when position has been changed
            return baseId + position;
        }

        @Override
        public int getCount() {
            try {
                return mModel.getJSONArray("tmpls").length();
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }


        @Override
        public CharSequence getPageTitle(int position) {
            try {
                return mModel.getJSONArray("tmpls").getJSONObject(position).getString("name");
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }

        /**
         * Notify that the position of a fragment has been changed.
         * Create a new ID for each position to force recreation of the fragment
         * @see <a href="http://stackoverflow.com/questions/10396321/remove-fragment-page-from-viewpager-in-android/26944013#26944013">stackoverflow</a>
         * @param n number of items which have been changed
         */
        public void notifyChangeInPosition(int n) {
            // shift the ID returned by getItemId outside the range of all previous fragments
            baseId += getCount() + n;
        }

        public void setModel(JSONObject model) {
            mModel = model;
        }
    }


    public static class CardTemplateFragment extends Fragment{
        EditText mFront;
        EditText mCss;
        EditText mBack;
        JSONObject mModel;
        public static CardTemplateFragment newInstance(int position, long modelId, long noteId) {
            CardTemplateFragment f = new CardTemplateFragment();
            Bundle args = new Bundle();
            args.putInt("position", position);
            args.putLong("modelId",modelId);
            args.putLong("noteId",noteId);
            f.setArguments(args);
            return f;
        }

        @Override
        public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
            View mainView = inflater.inflate(R.layout.card_template_editor_item, container, false);
            final int position = getArguments().getInt("position");
            try {
                // Load template
                long mid = getArguments().getLong("modelId");
                mModel = ((AnkiActivity) getActivity()).getCol().getModels().get(mid);
                final JSONArray tmpls = mModel.getJSONArray("tmpls");
                final JSONObject template = tmpls.getJSONObject(position);
                // Load EditText Views
                mFront = ((EditText) mainView.findViewById(R.id.front_edit));
                mCss = ((EditText) mainView.findViewById(R.id.styling_edit));
                mBack = ((EditText) mainView.findViewById(R.id.back_edit));
                // Set EditText content
                mFront.setText(template.getString("qfmt"));
                mCss.setText(mModel.getString("css"));
                mBack.setText(template.getString("afmt"));
                // Set text change listeners
                TextWatcher templateEditorWatcher = new TextWatcher() {
                    @Override
                    public void afterTextChanged(Editable arg0) {
                        try {
                            template.put("qfmt", mFront.getText());
                            template.put("afmt", mBack.getText());
                            mModel.put("css", mCss.getText());
                            tmpls.put(position, template);
                            mModel.put("tmpls", tmpls);
                        } catch (JSONException e) {
                            Timber.e(e, "Could not update card template");
                        }
                    }
                    @Override
                    public void beforeTextChanged(CharSequence arg0, int arg1, int arg2, int arg3) {}
                    @Override
                    public void onTextChanged(CharSequence arg0, int arg1, int arg2, int arg3) {}
                };
                mFront.addTextChangedListener(templateEditorWatcher);
                mCss.addTextChangedListener(templateEditorWatcher);
                mBack.addTextChangedListener(templateEditorWatcher);
                // Enable menu
                setHasOptionsMenu(true);
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            return mainView;
        }

        @Override
        public void onResume() {
            super.onResume();
        }

        private void updateCss() {
            if (mCss != null && mModel!= null) {
                try {
                    mCss.setText(mModel.getString("css"));
                } catch (JSONException e) {
                    // do nothing
                }
            }
        }

        @Override
        public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
            inflater.inflate(R.menu.card_template_editor, menu);
            super.onCreateOptionsMenu(menu, inflater);
        }


        @Override
        public boolean onOptionsItemSelected(MenuItem item) {
            final Collection col = ((AnkiActivity) getActivity()).getCol();
            final JSONObject model = getModel();
            switch (item.getItemId()) {
                case R.id.action_add:
                    Timber.i("CardTemplateEditor:: Add template button pressed");
                    addNewTemplateWithCheck(getModel());
                    return true;
                case R.id.action_delete: {
                    Timber.i("CardTemplateEditor:: Delete template button pressed");
                    Resources res = getResources();
                    int position = getArguments().getInt("position");
                    try {
                        JSONArray tmpls = model.getJSONArray("tmpls");
                        final JSONObject template = tmpls.getJSONObject(position);
                        // Don't do anything if only one template
                        if (tmpls.length() < 2) {
                            UIUtils.showThemedToast(getActivity(), res.getString(R.string.card_template_editor_cant_delete), false);
                            return true;
                        }
                        // Show confirmation dialog
                        int numAffectedCards = col.getModels().tmplUseCount(model, position);
                        confirmDeleteCards(template, model, numAffectedCards);
                    } catch (JSONException e) {
                        throw new RuntimeException(e);
                    }
                    return true;
                }
                case R.id.action_preview: {
                    Timber.i("CardTemplateEditor:: Preview model button pressed");
                    // Save the model if necessary
                    if (modelHasChanged()) {
                        col.getModels().save(model, false);
                    }
                    // Create intent for the previewer and add some arguments
                    Intent i = new Intent(getActivity(), Previewer.class);
                    int pos = getArguments().getInt("position");
                    long cid;
                    if (getArguments().getLong("noteId") != -1L && pos <
                            col.getNote(getArguments().getLong("noteId")).cards().size()) {
                        // Give the card ID if we started from an actual note and it has a card generated in this pos
                        cid = col.getNote(getArguments().getLong("noteId")).cards().get(pos).getId();
                    } else {
                        // Otherwise create a dummy card to show the effect of formatting
                        Card dummyCard = getDummyCard();
                        if (dummyCard != null) {
                            cid = dummyCard.getId();
                        } else {
                            UIUtils.showSimpleSnackbar(getActivity(), R.string.invalid_template, false);
                            return true;
                        }
                    }
                    // Launch intent
                    i.putExtra("cardList", new long[] {cid});
                    i.putExtra("index", 0);
                    startActivityForResult(i, REQUEST_PREVIEWER);
                    return true;
                }
                case R.id.action_confirm:
                    Timber.i("CardTemplateEditor:: Save model button pressed");
                    if (modelHasChanged()) {
                        // regenerate the cards of the model
                        DeckTask.TaskData args = new DeckTask.TaskData(new Object[] {model});
                        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SAVE_MODEL, mSaveModelAndExitHandler, args);
                    } else {
                        ((AnkiActivity) getActivity()).finishWithAnimation(ActivityTransitionAnimation.RIGHT);
                    }

                    return true;
                default:
                    return super.onOptionsItemSelected(item);
            }
        }

        /**
         * Get a dummy card
         * @return
         */
        private Card getDummyCard() {
            Timber.d("Creating dummy note");
            JSONObject model = getCol().getModels().get(getArguments().getLong("modelId"));
            Note n =getCol().newNote(model);
            ArrayList<String> fieldNames = getCol().getModels().fieldNames(model);
            for (int i = 0; i < fieldNames.size(); i++) {
                n.setField(i, fieldNames.get(i));
            }
            n.addTag(DUMMY_TAG);
            getCol().addNote(n);
            if (n.cards().size() <= getArguments().getInt("position")) {
                return null;
            }
            return getCol().getCard(n.cards().get(getArguments().getInt("position")).getId());
        }

        private void deleteDummyCards() {
            // TODO: make into an async task
            List<Long> remnantNotes = getCol().findNotes("tag:" + DUMMY_TAG);
            if (remnantNotes.size() > 0) {
                long[] nids = new long[remnantNotes.size()];
                for (int i = 0; i < remnantNotes.size(); i++) {
                    nids[i] = remnantNotes.get(i);
                }
                getCol().remNotes(nids);
                getCol().save();
            }
        }

        @Override
        public void onActivityResult(int requestCode, int resultCode, Intent data) {
            super.onActivityResult(requestCode, resultCode, data);
            deleteDummyCards();
        }

        /* Used for updating the collection when a model has been edited */
        private DeckTask.TaskListener mSaveModelAndExitHandler = new DeckTask.TaskListener() {
            @Override
            public void onPreExecute() {
                ((AnkiActivity) getActivity()).showProgressBar();
                final InputMethodManager imm = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);
                imm.hideSoftInputFromWindow(getView().getWindowToken(), 0);
            }

            @Override
            public void onProgressUpdate(DeckTask.TaskData... values) {
            }

            @Override
            public void onPostExecute(DeckTask.TaskData result) {
                if (result.getBoolean()) {
                    getActivity().setResult(RESULT_OK);
                    ((AnkiActivity) getActivity()).finishWithAnimation(ActivityTransitionAnimation.RIGHT);
                } else {
                    // RuntimeException occurred
                    getActivity().setResult(RESULT_CANCELED);
                    ((AnkiActivity) getActivity()).finishWithoutAnimation();
                }
            }

            @Override
            public void onCancelled() {}
        };

        private boolean modelHasChanged() {
            return ((CardTemplateEditor) getActivity()).modelHasChanged();
        }

        /**
         * Load the model from the collection
         * @return the model we are editing
         */
        private JSONObject getModel() {
            long mid = getArguments().getLong("modelId");
            return ((AnkiActivity) getActivity()).getCol().getModels().get(mid);
        }

        /**
         * Get the collection
         * @return
         */
        private Collection getCol() {
            return ((AnkiActivity) getActivity()).getCol();
        }

        /**
         * Confirm if the user wants to delete all the cards associated with current template
         *
         * @param tmpl template to remove
         * @param model model to remove from
         * @param numAffectedCards number of cards which will be affected
         */
        private void confirmDeleteCards(final JSONObject tmpl, final JSONObject model,  int numAffectedCards) {
            ConfirmationDialog d = new ConfirmationDialog();
            Resources res = getResources();
            String msg = String.format(res.getQuantityString(R.plurals.card_template_editor_confirm_delete,
                            numAffectedCards), numAffectedCards, tmpl.optString("name"));
            d.setArgs(msg);
            Runnable confirm = new Runnable() {
                @Override
                public void run() {
                    deleteTemplateWithCheck(tmpl, model);
                }
            };
            d.setConfirm(confirm);
            ((AnkiActivity) getActivity()).showDialogFragment(d);
        }

        /**
         * Delete tmpl from model, asking user to confirm again if it's going to require a full sync
         *
         * @param tmpl template to remove
         * @param model model to remove from
         */
        private void deleteTemplateWithCheck(final JSONObject tmpl, final JSONObject model) {
            try {
                ((CardTemplateEditor) getActivity()).getCol().modSchema(true);
                deleteTemplate(tmpl, model);
            } catch (ConfirmModSchemaException e) {
                ConfirmationDialog d = new ConfirmationDialog();
                d.setArgs(getResources().getString(R.string.full_sync_confirmation));
                Runnable confirm = new Runnable() {
                    @Override
                    public void run() {
                        deleteTemplate(tmpl, model);
                    }
                };
                d.setConfirm(confirm);
                ((AnkiActivity) getActivity()).showDialogFragment(d);
            }
        }

        /**
         * Launch background task to delete tmpl from model
         * @param tmpl template to remove
         * @param model model to remove from
         */
        private void deleteTemplate(JSONObject tmpl, JSONObject model) {
            CardTemplateEditor activity = ((CardTemplateEditor) getActivity());
            activity.getCol().modSchemaNoCheck();
            Object [] args = new Object[] {model, tmpl};
            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REMOVE_TEMPLATE,
                    activity.mUpdateTemplateHandler,  new DeckTask.TaskData(args));
            activity.dismissAllDialogFragments();
        }

        /**
         * Add new template to model, asking user to confirm if it's going to require a full sync
         *
         * @param model model to add new template to
         */
        private void addNewTemplateWithCheck(final JSONObject model) {
            try {
                ((CardTemplateEditor) getActivity()).getCol().modSchema(true);
                addNewTemplate(model);
            } catch (ConfirmModSchemaException e) {
                ConfirmationDialog d = new ConfirmationDialog();
                d.setArgs(getResources().getString(R.string.full_sync_confirmation));
                Runnable confirm = new Runnable() {
                    @Override
                    public void run() {
                        addNewTemplate(model);
                    }
                };
                d.setConfirm(confirm);
                ((AnkiActivity) getActivity()).showDialogFragment(d);
            }
        }


        /**
         * Launch background task to add new template to model
         * @param model model to add new template to
         */
        private void addNewTemplate(JSONObject model) {
            CardTemplateEditor activity = ((CardTemplateEditor) getActivity());
            activity.getCol().modSchemaNoCheck();
            Models mm = activity.getCol().getModels();
            // Build new template
            JSONObject newTemplate;
            try {
                int oldPosition = getArguments().getInt("position");
                JSONArray templates = model.getJSONArray("tmpls");
                JSONObject oldTemplate = templates.getJSONObject(oldPosition);
                newTemplate = mm.newTemplate(newCardName(templates));
                // Set up question & answer formats
                newTemplate.put("qfmt", oldTemplate.get("qfmt"));
                newTemplate.put("afmt", oldTemplate.get("afmt"));
                // Reverse the front and back if only one template
                if (templates.length() == 1) {
                    flipQA(newTemplate);
                }
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            // Add new template to the current model via AsyncTask
            Object [] args = new Object[] {model, newTemplate};
            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ADD_TEMPLATE,
                    activity.mUpdateTemplateHandler,  new DeckTask.TaskData(args));
            activity.dismissAllDialogFragments();
        }

        /**
         * Flip the question and answer side of the template
         * @param template template to flip
         */
        private void flipQA (JSONObject template) {
            try {
                String qfmt = template.getString("qfmt");
                String afmt = template.getString("afmt");
                Matcher m = Pattern.compile("(?s)(.+)<hr id=answer>(.+)").matcher(afmt);
                if (!m.find()) {
                    template.put("qfmt", afmt.replace("{{FrontSide}}",""));
                } else {
                    template.put("qfmt",m.group(2).trim());
                }
                template.put("afmt","{{FrontSide}}\n\n<hr id=answer>\n\n" + qfmt);
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }

        /**
         * Get name for new template
         * @param templates array of templates which is being added to
         * @return name for new template
         */
        private String newCardName(JSONArray templates) {
            String name;
            // Start by trying to set the name to "Card n" where n is the new num of templates
            int n = templates.length() + 1;
            // If the starting point for name already exists, iteratively increase n until we find a unique name
            while (true) {
                // Get new name
                name = "Card " + Integer.toString(n);
                // Cycle through all templates checking if new name exists
                boolean exists = false;
                for (int i = 0; i < templates.length(); i++) {
                    try {
                        exists = exists || name.equals(templates.getJSONObject(i).getString("name"));
                    } catch (JSONException e) {
                        throw new RuntimeException(e);
                    }
                }
                if (!exists) {
                    break;
                }
                n+=1;
            }
            return name;
        }
    }
}
/***************************************************************************************
 * Copyright (c) 2015 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.Manifest;
import android.content.Context;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.os.Environment;
import android.preference.PreferenceManager;
import android.support.v4.content.ContextCompat;

import com.ichi2.anki.exception.StorageAccessException;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Storage;

import java.io.File;
import java.io.IOException;

import timber.log.Timber;

/**
 * Singleton which opens, stores, and closes the reference to the Collection.
 */
public class CollectionHelper {

    // Collection instance belonging to sInstance
    private Collection mCollection;
    // Path to collection, cached for the reopenCollection() method
    private String mPath;
    // Name of anki2 file
    public static final String COLLECTION_FILENAME = "collection.anki2";

    /**
     * Prevents {@link com.ichi2.async.CollectionLoader} from spuriously re-opening the {@link Collection}.
     *
     * <p>Accessed only from synchronized methods.
     */
    private boolean mCollectionLocked;
    public synchronized void lockCollection() {
        mCollectionLocked = true;
    }
    public synchronized void unlockCollection() {
        mCollectionLocked = false;
    }
    public synchronized boolean isCollectionLocked() {
        return mCollectionLocked;
    }


    /**
     * Lazy initialization holder class idiom. High performance and thread safe way to create singleton.
     */
    private static class LazyHolder {
        private static final CollectionHelper INSTANCE = new CollectionHelper();
    }

    /**
     * @return Singleton instance of the helper class
     */
    public static CollectionHelper getInstance() {
        return LazyHolder.INSTANCE;
    }


    /**
     * Get the single instance of the {@link Collection}, creating it if necessary  (lazy initialization).
     * @param context context which can be used to get the setting for the path to the Collection
     * @return instance of the Collection
     */
    public synchronized Collection getCol(Context context) {
        // Open collection
        String path = getCollectionPath(context);
        if (!colIsOpen()) {
            // Check that the directory has been created and initialized
            try {
                initializeAnkiDroidDirectory(getParentDirectory(path));
                mPath = path;
            } catch (StorageAccessException e) {
                Timber.e(e, "Could not initialize AnkiDroid directory");
                return null;
            }
            // Open the database
            Timber.i("openCollection: %s", path);
            mCollection = Storage.Collection(context, path, false, true);
        }
        return mCollection;
    }

    /**
     * Call getCol(context) inside try / catch statement.
     * Send exception report and return null if there was an exception.
     * @param context
     * @return
     */
    public synchronized Collection getColSafe(Context context) {
        try {
            return getCol(context);
        } catch (Exception e) {
            AnkiDroidApp.sendExceptionReport(e, "CollectionHelper.getColSafe");
            return null;
        }
    }

    /**
     * Checks whether or not the Android 1MB limit for the cursor size was exceeded
     * @param context
     * @return
     */
    public synchronized boolean exceededCursorSizeLimit(Context context) {
        try {
            getCol(context);
        } catch (IllegalStateException e) {
            return true;
        }
        return false;
    }


    /**
     * Close the {@link Collection}, optionally saving
     * @param save whether or not save before closing
     */
    public synchronized void closeCollection(boolean save) {
        Timber.i("closeCollection");
        if (mCollection != null) {
            mCollection.close(save);
        }
    }

    /**
     * @return Whether or not {@link Collection} and its child database are open.
     */
    public boolean colIsOpen() {
        return mCollection != null && mCollection.getDb() != null &&
                mCollection.getDb().getDatabase() != null && mCollection.getDb().getDatabase().isOpen();
    }

    /**
     * Create the AnkiDroid directory if it doesn't exist and add a .nomedia file to it if needed.
     *
     * The AnkiDroid directory is a user preference stored under the "deckPath" key, and a sensible
     * default is chosen if the preference hasn't been created yet (i.e., on the first run).
     *
     * The presence of a .nomedia file indicates to media scanners that the directory must be
     * excluded from their search. We need to include this to avoid media scanners including
     * media files from the collection.media directory. The .nomedia file works at the directory
     * level, so placing it in the AnkiDroid directory will ensure media scanners will also exclude
     * the collection.media sub-directory.
     *
     * @param path  Directory to initialize
     * @throws StorageAccessException If no write access to directory
     */
    public static synchronized void initializeAnkiDroidDirectory(String path) throws StorageAccessException {
        // Create specified directory if it doesn't exit
        File dir = new File(path);
        if (!dir.exists() && !dir.mkdirs()) {
            throw new StorageAccessException("Failed to create AnkiDroid directory");
        }
        if (!dir.canWrite()) {
            throw new StorageAccessException("No write access to AnkiDroid directory");
        }
        // Add a .nomedia file to it if it doesn't exist
        File nomedia = new File(dir, ".nomedia");
        if (!nomedia.exists()) {
            try {
                nomedia.createNewFile();
            } catch (IOException e) {
                throw new StorageAccessException("Failed to create .nomedia file");
            }
        }
    }

    /**
     * Try to access the current AnkiDroid directory
     * @return whether or not dir is accessible
     * @param context to get directory with
     */
    public static boolean isCurrentAnkiDroidDirAccessible(Context context) {
        try {
            initializeAnkiDroidDirectory(getCurrentAnkiDroidDirectory(context));
            return true;
        } catch (StorageAccessException e) {
            return false;
        }
    }


    /**
     * Get the absolute path to a directory that is suitable to be the default starting location
     * for the AnkiDroid folder. This is a folder named "AnkiDroid" at the top level of the
     * external storage directory.
     * @return the folder path
     */
    public static String getDefaultAnkiDroidDirectory() {
        return new File(Environment.getExternalStorageDirectory(), "AnkiDroid").getAbsolutePath();
    }

    /**
     *
     * @return the path to the actual {@link Collection} file
     */
    public static String getCollectionPath(Context context) {
        return new File(getCurrentAnkiDroidDirectory(context), COLLECTION_FILENAME).getAbsolutePath();
    }


    /**
     * @return the absolute path to the AnkiDroid directory.
     */
    public static String getCurrentAnkiDroidDirectory(Context context) {
        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context.getApplicationContext());
        return preferences.getString("deckPath", getDefaultAnkiDroidDirectory());
    }

    /**
     * Get parent directory given the {@link Collection} path.
     * @param path path to AnkiDroid collection
     * @return path to AnkiDroid folder
     */
    private static String getParentDirectory(String path) {
        return new File(path).getParentFile().getAbsolutePath();
    }

    /**
     * Check if we have permission to access the external storage
     * @param context
     * @return
     */
    public static boolean hasStorageAccessPermission(Context context) {
        return ContextCompat.checkSelfPermission(context, Manifest.permission.WRITE_EXTERNAL_STORAGE)
                == PackageManager.PERMISSION_GRANTED;
    }
}
/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.os.Environment;
import android.os.StatFs;
import android.text.TextUtils;


import java.io.File;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.TimeZone;

import timber.log.Timber;

public class CustomExceptionHandler implements Thread.UncaughtExceptionHandler {

    private static CustomExceptionHandler sInstance;
    private Thread.UncaughtExceptionHandler mPreviousHandler;
    private Context mCurContext;
    // private Random randomGenerator = new Random();

    private HashMap<String, String> mInformation = new HashMap<>(20);


    static CustomExceptionHandler getInstance() {
        if (sInstance == null) {
            sInstance = new CustomExceptionHandler();
            Timber.i("New instance of custom exception handler");
        }

        return sInstance;
    }


    public void init(Context context) {
        mPreviousHandler = Thread.getDefaultUncaughtExceptionHandler();
        Thread.setDefaultUncaughtExceptionHandler(this);
        mCurContext = context;
    }


    private long getAvailableInternalMemorySize() {
        File path = Environment.getDataDirectory();
        StatFs stat = new StatFs(path.getPath());
        long blockSize = stat.getBlockSize();
        long availableBlocks = stat.getAvailableBlocks();
        return availableBlocks * blockSize;
    }


    private long getTotalInternalMemorySize() {
        File path = Environment.getDataDirectory();
        StatFs stat = new StatFs(path.getPath());
        long blockSize = stat.getBlockSize();
        long totalBlocks = stat.getBlockCount();
        return totalBlocks * blockSize;
    }


    private void collectInformation() {
        Timber.i("collectInformation");

        if (mCurContext == null) {
            return;
        }

        try {
            Timber.i("collecting information");

            PackageManager pm = mCurContext.getPackageManager();
            PackageInfo pi = pm.getPackageInfo(mCurContext.getPackageName(), 0);

            mInformation.put("VersionName", pi.versionName); // Version
            mInformation.put("PackageName", pi.packageName); // Package name
            mInformation.put("AndroidVersion", android.os.Build.VERSION.RELEASE); // Android version
            mInformation.put("Board", android.os.Build.BOARD);
            mInformation.put("Brand", android.os.Build.BRAND);
            mInformation.put("Device", android.os.Build.DEVICE);
            mInformation.put("Display", android.os.Build.DISPLAY);
            // mInformation.put("FingerPrint", android.os.Build.FINGERPRINT);
            mInformation.put("Host", android.os.Build.HOST);
            mInformation.put("ID", android.os.Build.ID);
            mInformation.put("Model", android.os.Build.MODEL);
            mInformation.put("Product", android.os.Build.PRODUCT);
            // mInformation.put("Tags", android.os.Build.TAGS);
            mInformation.put("Time", Long.toString(android.os.Build.TIME));
            // mInformation.put("Type", android.os.Build.TYPE);
            // mInformation.put("User", android.os.Build.USER);
            mInformation.put("TotalInternalMemory", Long.toString(getTotalInternalMemorySize()));
            mInformation.put("AvailableInternalMemory", Long.toString(getAvailableInternalMemorySize()));
            mInformation.put("Locale", AnkiDroidApp.getAppResources().getConfiguration().locale.toString());
            Timber.i("Information collected");
        } catch (Exception e) {
            Timber.i(e.toString());
        }
    }


    @Override
    public void uncaughtException(Thread t, Throwable e) {
        uncaughtException(t, e, null);
    }


    public void uncaughtException(Thread t, Throwable e, String origin) {
        uncaughtException(t, e, origin, null);
    }


    public void uncaughtException(Thread t, Throwable e, String origin, String additionalInfo) {
        Timber.i("uncaughtException");

        collectInformation();

        Date ts = new Date();
        TimeZone tz = TimeZone.getDefault();

        SimpleDateFormat df1 = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS", Locale.US);
        SimpleDateFormat df2 = new SimpleDateFormat("Z", Locale.US);

        df1.setTimeZone(TimeZone.getTimeZone("UTC"));

        String reportgeneratedutc = String.format("%s", df1.format(ts));
        String reportgeneratedtzoffset = String.format("%s", df2.format(ts));
        String reportgeneratedtz = String.format("%s", tz.getID());

        StringBuilder reportInformation = new StringBuilder(10000);

        reportInformation.append(String.format("reportgeneratedutc=%s\n", reportgeneratedutc));
        reportInformation.append(String.format("reportgeneratedtzoffset=%s\n", reportgeneratedtzoffset));
        reportInformation.append(String.format("reportgeneratedtz=%s\n", reportgeneratedtz));

        if (origin != null && origin.length() > 0) {
            reportInformation.append(String.format("origin=%s\n", origin));
        }

        for (String key : mInformation.keySet()) {
            String value = mInformation.get(key);

            reportInformation.append(String.format(Locale.US, "%s=%s\n", key.toLowerCase(Locale.US), value));
        }

        if (additionalInfo != null && !TextUtils.isEmpty(additionalInfo)) {
            reportInformation.append(String.format("additionalinformation=%s\n", additionalInfo));
        }

        reportInformation.append("stacktrace=\nBegin Stacktrace\n");

        // Stack trace
        final Writer result = new StringWriter();
        final PrintWriter printWriter = new PrintWriter(result);
        e.printStackTrace(printWriter);
        reportInformation.append(String.format("%s\n", result.toString()));

        reportInformation.append("End Stacktrace\n\nBegin Inner exceptions\n");

        // Cause, inner exceptions
        Throwable cause = e.getCause();
        while (cause != null) {
            cause.printStackTrace(printWriter);
            reportInformation.append(String.format("%s\n", result.toString()));
            cause = cause.getCause();
        }
        reportInformation.append("End Inner exceptions");

        printWriter.close();

        Timber.i("report infomation string created");
        saveReportToFile(reportInformation.toString());

        if (t != null) {
            mPreviousHandler.uncaughtException(t, e);
        }
    }


    private void saveReportToFile(String reportInformation) {
        try {
            Timber.i("saveReportFile");

            Date currentDate = new Date();
            SimpleDateFormat formatter = new SimpleDateFormat("yyyyMMddHHmmss");
            String filename = String.format("ad-%s.stacktrace", formatter.format(currentDate));

            Timber.i("No external storage available");
            FileOutputStream trace = mCurContext.openFileOutput(filename, Context.MODE_PRIVATE);
            trace.write(reportInformation.getBytes());
            trace.close();

            Timber.i("report saved");
        } catch (Exception e) {
            Timber.i(e.toString());
        }
    }
}

package com.ichi2.anki;

/****************************************************************************************
 * Copyright (c) 2009 Casey Link <unnamedrambler@gmail.com>                             *
 * Copyright (c) 2012 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
import android.content.res.Resources;
import android.os.Build;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.ListPreference;
import android.preference.Preference;
import android.preference.PreferenceScreen;
import android.text.TextUtils;

import android.view.KeyEvent;
import android.view.MenuItem;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.exception.ConfirmModSchemaException;
import com.ichi2.anki.receiver.ReminderReceiver;
import com.ichi2.anki.receiver.SdCardReceiver;
import com.ichi2.anki.services.ReminderService;
import com.ichi2.async.DeckTask;
import com.ichi2.libanki.Collection;
import com.ichi2.preferences.StepsPreference;
import com.ichi2.preferences.TimePreference;
import com.ichi2.themes.StyledProgressDialog;
import com.ichi2.themes.Themes;
import com.ichi2.ui.AppCompatPreferenceActivity;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;

import timber.log.Timber;

/**
 * Preferences for the current deck.
 */
public class DeckOptions extends AppCompatPreferenceActivity implements OnSharedPreferenceChangeListener {

    private JSONObject mOptions;
    private JSONObject mDeck;
    private Collection mCol;
    private boolean mPreferenceChanged = false;

    private BroadcastReceiver mUnmountReceiver = null;

    public class DeckPreferenceHack implements SharedPreferences {

        private Map<String, String> mValues = new HashMap<>();
        private Map<String, String> mSummaries = new HashMap<>();
        private MaterialDialog mProgressDialog;


        public DeckPreferenceHack() {
            this.cacheValues();
        }


        protected void cacheValues() {
            Timber.i("DeckOptions - CacheValues");

            try {
                mOptions = mCol.getDecks().confForDid(mDeck.getLong("id"));

                mValues.put("name", mDeck.getString("name"));
                mValues.put("desc", mDeck.getString("desc"));
                mValues.put("deckConf", mDeck.getString("conf"));
                // general
                mValues.put("maxAnswerTime", mOptions.getString("maxTaken"));
                mValues.put("showAnswerTimer", Boolean.toString(mOptions.getInt("timer") == 1));
                mValues.put("autoPlayAudio", Boolean.toString(mOptions.getBoolean("autoplay")));
                mValues.put("replayQuestion", Boolean.toString(mOptions.optBoolean("replayq", true)));
                // new
                JSONObject newOptions = mOptions.getJSONObject("new");
                mValues.put("newSteps", StepsPreference.convertFromJSON(newOptions.getJSONArray("delays")));
                mValues.put("newGradIvl", newOptions.getJSONArray("ints").getString(0));
                mValues.put("newEasy", newOptions.getJSONArray("ints").getString(1));
                mValues.put("newFactor", Integer.toString(newOptions.getInt("initialFactor") / 10));
                mValues.put("newOrder", newOptions.getString("order"));
                mValues.put("newPerDay", newOptions.getString("perDay"));
                mValues.put("newBury", Boolean.toString(newOptions.optBoolean("bury", true)));
                // rev
                JSONObject revOptions = mOptions.getJSONObject("rev");
                mValues.put("revPerDay", revOptions.getString("perDay"));
                mValues.put("easyBonus", Integer.toString((int) (revOptions.getDouble("ease4") * 100)));
                mValues.put("revIvlFct", Integer.toString((int) (revOptions.getDouble("ivlFct") * 100)));
                mValues.put("revMaxIvl", revOptions.getString("maxIvl"));
                mValues.put("revBury", Boolean.toString(revOptions.optBoolean("bury", true)));
                // lapse
                JSONObject lapOptions = mOptions.getJSONObject("lapse");
                mValues.put("lapSteps", StepsPreference.convertFromJSON(lapOptions.getJSONArray("delays")));
                mValues.put("lapNewIvl", Integer.toString((int) (lapOptions.getDouble("mult") * 100)));
                mValues.put("lapMinIvl", lapOptions.getString("minInt"));
                mValues.put("lapLeechThres", lapOptions.getString("leechFails"));
                mValues.put("lapLeechAct", lapOptions.getString("leechAction"));
                // options group management
                mValues.put("currentConf", mCol.getDecks().getConf(mDeck.getLong("conf")).getString("name"));
                // reminders
                if (mOptions.has("reminder")) {
                    final JSONObject reminder = mOptions.getJSONObject("reminder");
                    final JSONArray reminderTime = reminder.getJSONArray("time");

                    mValues.put("reminderEnabled", Boolean.toString(reminder.getBoolean("enabled")));
                    mValues.put("reminderTime", String.format("%1$02d:%2$02d", reminderTime.get(0), reminderTime.get(1)));
                } else {
                    mValues.put("reminderEnabled", "false");
                    mValues.put("reminderTime", TimePreference.DEFAULT_VALUE);
                }
            } catch (JSONException e) {
                finish();
            }
        }

        public class Editor implements SharedPreferences.Editor {

            private ContentValues mUpdate = new ContentValues();


            @Override
            public SharedPreferences.Editor clear() {
                Timber.d("clear()");
                mUpdate = new ContentValues();
                return this;
            }


            @Override
            public boolean commit() {
                Timber.d("DeckOptions - commit() changes back to database");

                try {
                    for (Entry<String, Object> entry : mUpdate.valueSet()) {
                        String key = entry.getKey();
                        Object value = entry.getValue();
                        Timber.i("Change value for key '" + key + "': " + value);

                        if (key.equals("maxAnswerTime")) {
                            mOptions.put("maxTaken", value);
                        } else if (key.equals("newFactor")) {
                            mOptions.getJSONObject("new").put("initialFactor", (Integer) value * 10);
                        } else if (key.equals("newOrder")) {
                            int newValue = Integer.parseInt((String) value);
                            // Sorting is slow, so only do it if we change order
                            int oldValue = mOptions.getJSONObject("new").getInt("order");
                            if (oldValue != newValue) {
                                mOptions.getJSONObject("new").put("order", newValue);
                                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REORDER, mConfChangeHandler,
                                        new DeckTask.TaskData(new Object[] { mOptions }));
                            }
                            mOptions.getJSONObject("new").put("order", Integer.parseInt((String) value));
                        } else if (key.equals("newPerDay")) {
                            mOptions.getJSONObject("new").put("perDay", value);
                        } else if (key.equals("newGradIvl")) {
                            JSONArray ja = new JSONArray(); // [graduating, easy]
                            ja.put(value);
                            ja.put(mOptions.getJSONObject("new").getJSONArray("ints").get(1));
                            mOptions.getJSONObject("new").put("ints", ja);
                        } else if (key.equals("newEasy")) {
                            JSONArray ja = new JSONArray(); // [graduating, easy]
                            ja.put(mOptions.getJSONObject("new").getJSONArray("ints").get(0));
                            ja.put(value);
                            mOptions.getJSONObject("new").put("ints", ja);
                        } else if (key.equals("newBury")) {
                            mOptions.getJSONObject("new").put("bury", value);
                        } else if (key.equals("revPerDay")) {
                            mOptions.getJSONObject("rev").put("perDay", value);
                        } else if (key.equals("easyBonus")) {
                            mOptions.getJSONObject("rev").put("ease4", (Integer) value / 100.0f);
                        } else if (key.equals("revIvlFct")) {
                            mOptions.getJSONObject("rev").put("ivlFct", (Integer) value / 100.0f);
                        } else if (key.equals("revMaxIvl")) {
                            mOptions.getJSONObject("rev").put("maxIvl", value);
                        } else if (key.equals("revBury")) {
                            mOptions.getJSONObject("rev").put("bury", value);
                        } else if (key.equals("lapMinIvl")) {
                            mOptions.getJSONObject("lapse").put("minInt", value);
                        } else if (key.equals("lapLeechThres")) {
                            mOptions.getJSONObject("lapse").put("leechFails", value);
                        } else if (key.equals("lapLeechAct")) {
                            mOptions.getJSONObject("lapse").put("leechAction", Integer.parseInt((String) value));
                        } else if (key.equals("lapNewIvl")) {
                            mOptions.getJSONObject("lapse").put("mult", (Integer) value / 100.0f);
                        } else if (key.equals("showAnswerTimer")) {
                            mOptions.put("timer", (Boolean) value ? 1 : 0);
                        } else if (key.equals("autoPlayAudio")) {
                            mOptions.put("autoplay", value);
                        } else if (key.equals("replayQuestion")) {
                            mOptions.put("replayq", value);
                        } else if (key.equals("desc")) {
                            mDeck.put("desc", value);
                            mCol.getDecks().save(mDeck);
                        } else if (key.equals("newSteps")) {
                            mOptions.getJSONObject("new").put("delays", StepsPreference.convertToJSON((String) value));
                        } else if (key.equals("lapSteps")) {
                            mOptions.getJSONObject("lapse")
                                    .put("delays", StepsPreference.convertToJSON((String) value));
                        } else if (key.equals("deckConf")) {
                            long newConfId = Long.parseLong((String) value);
                            mOptions = mCol.getDecks().getConf(newConfId);
                            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CONF_CHANGE, mConfChangeHandler,
                                    new DeckTask.TaskData(new Object[] { mDeck, mOptions }));
                        } else if (key.equals("confRename")) {
                            String newName = (String) value;
                            if (!TextUtils.isEmpty(newName)) {
                                mOptions.put("name", newName);
                            }
                        } else if (key.equals("confReset")) {
                            if ((Boolean) value) {
                                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CONF_RESET, mConfChangeHandler,
                                        new DeckTask.TaskData(new Object[] { mOptions }));
                            }
                        } else if (key.equals("confAdd")) {
                            String newName = (String) value;
                            if (!TextUtils.isEmpty(newName)) {
                                // New config clones current config
                                long id = mCol.getDecks().confId(newName, mOptions.toString());
                                mDeck.put("conf", id);
                                mCol.getDecks().save(mDeck);
                            }
                        } else if (key.equals("confRemove")) {
                            if (mOptions.getLong("id") == 1) {
                                // Don't remove the options group if it's the default group
                                UIUtils.showThemedToast(DeckOptions.this,
                                        getResources().getString(R.string.default_conf_delete_error), false);
                            } else {
                                // Remove options group, handling the case where the user needs to confirm full sync
                                try {
                                    remConf();
                                } catch (ConfirmModSchemaException e) {
                                    // Libanki determined that a full sync will be required, so confirm with the user before proceeding
                                    // TODO : Use ConfirmationDialog DialogFragment -- not compatible with PreferenceActivity
                                    new MaterialDialog.Builder(DeckOptions.this)
                                            .content(R.string.full_sync_confirmation)
                                            .positiveText(R.string.dialog_ok)
                                            .negativeText(R.string.dialog_cancel)
                                            .callback(new MaterialDialog.ButtonCallback() {
                                                @Override
                                                public void onPositive(MaterialDialog dialog) {
                                                    mCol.modSchemaNoCheck();
                                                    try {
                                                        remConf();
                                                    } catch (ConfirmModSchemaException e) {
                                                        // This should never be reached as we just forced modSchema
                                                        throw new RuntimeException(e);
                                                    }
                                                }
                                            })
                                            .build().show();
                                }
                            }
                        } else if (key.equals("confSetSubdecks")) {
                            if ((Boolean) value) {
                                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CONF_SET_SUBDECKS, mConfChangeHandler,
                                        new DeckTask.TaskData(new Object[] { mDeck, mOptions }));
                            }
                        } else if (key.equals("reminderEnabled")) {
                            final JSONObject reminder = new JSONObject();

                            reminder.put("enabled", value);
                            if (mOptions.has("reminder")) {
                                reminder.put("time", mOptions.getJSONObject("reminder").getJSONArray("time"));
                            } else {
                                reminder.put("time", new JSONArray()
                                        .put(TimePreference.parseHours(TimePreference.DEFAULT_VALUE))
                                        .put(TimePreference.parseMinutes(TimePreference.DEFAULT_VALUE)));
                            }

                            mOptions.put("reminder", reminder);

                            final AlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE);
                            final PendingIntent reminderIntent = PendingIntent.getBroadcast(
                                    getApplicationContext(),
                                    (int) mDeck.getLong("id"),
                                    new Intent(getApplicationContext(), ReminderReceiver.class).putExtra
                                            (ReminderService.EXTRA_DECK_ID, mDeck.getLong("id")),
                                    0
                            );

                            alarmManager.cancel(reminderIntent);
                            if ((Boolean) value) {
                                final Calendar calendar = Calendar.getInstance();

                                calendar.set(Calendar.HOUR_OF_DAY, reminder.getJSONArray("time").getInt(0));
                                calendar.set(Calendar.MINUTE, reminder.getJSONArray("time").getInt(1));
                                calendar.set(Calendar.SECOND, 0);

                                alarmManager.setInexactRepeating(
                                        AlarmManager.RTC_WAKEUP,
                                        calendar.getTimeInMillis(),
                                        AlarmManager.INTERVAL_DAY,
                                        reminderIntent
                                );
                            }
                        } else if (key.equals("reminderTime")) {
                            final JSONObject reminder = new JSONObject();

                            reminder.put("enabled", true);
                            reminder.put("time", new JSONArray().put(TimePreference.parseHours((String) value))
                                    .put(TimePreference.parseMinutes((String) value)));

                            mOptions.put("reminder", reminder);

                            final AlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE);
                            final PendingIntent reminderIntent = PendingIntent.getBroadcast(
                                    getApplicationContext(),
                                    (int) mDeck.getLong("id"),
                                    new Intent(getApplicationContext(), ReminderReceiver.class).putExtra
                                            (ReminderService.EXTRA_DECK_ID, mDeck.getLong("id")),
                                    0
                            );

                            alarmManager.cancel(reminderIntent);

                            final Calendar calendar = Calendar.getInstance();

                            calendar.set(Calendar.HOUR_OF_DAY, reminder.getJSONArray("time").getInt(0));
                            calendar.set(Calendar.MINUTE, reminder.getJSONArray("time").getInt(1));
                            calendar.set(Calendar.SECOND, 0);

                            alarmManager.setInexactRepeating(
                                    AlarmManager.RTC_WAKEUP,
                                    calendar.getTimeInMillis(),
                                    AlarmManager.INTERVAL_DAY,
                                    reminderIntent
                            );
                        }
                    }
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }

                // save conf
                try {
                    mCol.getDecks().save(mOptions);
                } catch (RuntimeException e) {
                    Timber.e("DeckOptions - RuntimeException on saving conf: " + e);
                    AnkiDroidApp.sendExceptionReport(e, "DeckOptionsSaveConf");
                    setResult(DeckPicker.RESULT_DB_ERROR);
                    finish();
                }

                // make sure we refresh the parent cached values
                cacheValues();
                buildLists();
                updateSummaries();

                // and update any listeners
                for (OnSharedPreferenceChangeListener listener : listeners) {
                    listener.onSharedPreferenceChanged(DeckPreferenceHack.this, null);
                }

                return true;
            }


            @Override
            public SharedPreferences.Editor putBoolean(String key, boolean value) {
                mUpdate.put(key, value);
                return this;
            }


            @Override
            public SharedPreferences.Editor putFloat(String key, float value) {
                mUpdate.put(key, value);
                return this;
            }


            @Override
            public SharedPreferences.Editor putInt(String key, int value) {
                mUpdate.put(key, value);
                return this;
            }


            @Override
            public SharedPreferences.Editor putLong(String key, long value) {
                mUpdate.put(key, value);
                return this;
            }


            @Override
            public SharedPreferences.Editor putString(String key, String value) {
                mUpdate.put(key, value);
                return this;
            }


            @Override
            public SharedPreferences.Editor remove(String key) {
                Timber.d("Editor.remove(key=%s)", key);
                mUpdate.remove(key);
                return this;
            }


            public void apply() {
                commit();
            }


            // @Override On Android 1.5 this is not Override
            public android.content.SharedPreferences.Editor putStringSet(String arg0, Set<String> arg1) {
                // TODO Auto-generated method stub
                return null;
            }

            private DeckTask.TaskListener mConfChangeHandler = new DeckTask.TaskListener() {
                @Override
                public void onPreExecute() {
                    Resources res = getResources();
                    mProgressDialog = StyledProgressDialog.show(DeckOptions.this, "",
                            res.getString(R.string.reordering_cards), false);
                }


                @Override
                public void onProgressUpdate(DeckTask.TaskData... values) {
                }


                @Override
                public void onPostExecute(DeckTask.TaskData result) {
                    cacheValues();
                    buildLists();
                    updateSummaries();
                    mProgressDialog.dismiss();
                    // Restart to reflect the new preference values
                    restartActivity();
                }


                @Override
                public void onCancelled() {
                    // TODO Auto-generated method stub
                    
                }
            };

            /**
             * Remove the currently selected options group
             * @throws ConfirmModSchemaException
             */
            private void remConf() throws ConfirmModSchemaException {
                try {
                    // Remove options group, asking user to confirm full sync if necessary
                    mCol.getDecks().remConf(mOptions.getLong("id"));
                    // Run the CPU intensive re-sort operation in a background thread
                    DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CONF_REMOVE, mConfChangeHandler,
                            new DeckTask.TaskData(new Object[] { mOptions }));
                    mDeck.put("conf", 1);
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
            }
        }


        @Override
        public boolean contains(String key) {
            return mValues.containsKey(key);
        }


        @Override
        public Editor edit() {
            return new Editor();
        }


        @Override
        public Map<String, ?> getAll() {
            return mValues;
        }


        @Override
        public boolean getBoolean(String key, boolean defValue) {
            return Boolean.valueOf(this.getString(key, Boolean.toString(defValue)));
        }


        @Override
        public float getFloat(String key, float defValue) {
            return Float.valueOf(this.getString(key, Float.toString(defValue)));
        }


        @Override
        public int getInt(String key, int defValue) {
            return Integer.valueOf(this.getString(key, Integer.toString(defValue)));
        }


        @Override
        public long getLong(String key, long defValue) {
            return Long.valueOf(this.getString(key, Long.toString(defValue)));
        }


        @Override
        public String getString(String key, String defValue) {
            Timber.d("getString(key=%s, defValue=%s)", key, defValue);
            if (!mValues.containsKey(key)) {
                return defValue;
            }
            return mValues.get(key);
        }

        public List<OnSharedPreferenceChangeListener> listeners = new LinkedList<>();


        @Override
        public void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {
            listeners.add(listener);
        }


        @Override
        public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {
            listeners.remove(listener);
        }


        // @Override On Android 1.5 this is not Override
        public Set<String> getStringSet(String arg0, Set<String> arg1) {
            // TODO Auto-generated method stub
            return null;
        }

    }

    private DeckPreferenceHack mPref;


    @Override
    public SharedPreferences getSharedPreferences(String name, int mode) {
        Timber.d("getSharedPreferences(name=%s)", name);
        return mPref;
    }


    @Override
    protected void onCreate(Bundle icicle) {
        Themes.setThemeLegacy(this);
        super.onCreate(icicle);

        mCol = CollectionHelper.getInstance().getCol(this);
        if (mCol == null) {
            finish();
            return;
        }
        Bundle extras = getIntent().getExtras();
        if (extras != null && extras.containsKey("did")) {
            mDeck = mCol.getDecks().get(extras.getLong("did"));
        } else {
            mDeck = mCol.getDecks().current();
        }
        registerExternalStorageListener();

        if (mCol == null) {
            Timber.w("DeckOptions - No Collection loaded");
            finish();
        } else {
            mPref = new DeckPreferenceHack();
            mPref.registerOnSharedPreferenceChangeListener(this);

            this.addPreferencesFromResource(R.xml.deck_options);
            this.buildLists();
            this.updateSummaries();
            // Set the activity title to include the name of the deck
            String title = getResources().getString(R.string.deckpreferences_title);
            if (title.contains("XXX")) {
                try {
                    title = title.replace("XXX", mDeck.getString("name"));
                } catch (JSONException e) {
                    title = title.replace("XXX", "???");
                }
            }
            this.setTitle(title);
        }

        // Add a home button to the actionbar
        getSupportActionBar().setHomeButtonEnabled(true);
        getSupportActionBar().setDisplayHomeAsUpEnabled(true);

    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                closeWithResult();
                return true;
        }
        return false;
    }


    @Override
    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
        // update values on changed preference
        mPreferenceChanged = true;
        this.updateSummaries();
    }

    // Workaround for bug 4611: http://code.google.com/p/android/issues/detail?id=4611
    @SuppressWarnings("deprecation")
    @Override
    public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference)
    {
        super.onPreferenceTreeClick(preferenceScreen, preference);
        if (preference!=null)
            if (preference instanceof PreferenceScreen) {
                if (((PreferenceScreen) preference).getDialog() != null) {
                    ((PreferenceScreen) preference).getDialog().getWindow().getDecorView().setBackgroundDrawable(
                            this.getWindow().getDecorView().getBackground().getConstantState().newDrawable());
                }
            }
        return false;
    }


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
            Timber.i("DeckOptions - onBackPressed()");
            closeWithResult();
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }

    private void closeWithResult() {
        if (mPreferenceChanged) {
            setResult(RESULT_OK);
        } else {
            setResult(RESULT_CANCELED);
        }
        finish();
        ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.FADE);
    }


    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mUnmountReceiver != null) {
            unregisterReceiver(mUnmountReceiver);
        }
    }


    protected void updateSummaries() {
        Resources res = getResources();
        // for all text preferences, set summary as current database value
        for (String key : mPref.mValues.keySet()) {
            Preference pref = this.findPreference(key);
            if (key.equals("deckConf")) {
                String groupName = getOptionsGroupName();
                int count = getOptionsGroupCount();
                // Escape "%" in groupName as it's treated as a token
                groupName = groupName.replaceAll("%", "%%");
                pref.setSummary(res.getQuantityString(R.plurals.deck_conf_group_summ, count, groupName, count));
                continue;
            }

            String value = null;
            if (pref == null) {
                continue;
            } else if (pref instanceof CheckBoxPreference) {
                continue;
            } else if (pref instanceof ListPreference) {
                ListPreference lp = (ListPreference) pref;
                value = lp.getEntry() != null ? lp.getEntry().toString() : "";
            } else {
                value = this.mPref.getString(key, "");
            }
            // update summary
            if (!mPref.mSummaries.containsKey(key)) {
                CharSequence s = pref.getSummary();
                mPref.mSummaries.put(key, s != null ? pref.getSummary().toString() : null);
            }
            String summ = mPref.mSummaries.get(key);
            if (summ != null && summ.contains("XXX")) {
                pref.setSummary(summ.replace("XXX", value));
            } else {
                pref.setSummary(value);
            }
        }
        // Update summaries of preference items that don't have values (aren't in mValues)
        int subDeckCount = getSubdeckCount();
        this.findPreference("confSetSubdecks").setSummary(
                res.getQuantityString(R.plurals.deck_conf_set_subdecks_summ, subDeckCount, subDeckCount));
    }


    protected void buildLists() {
        ListPreference deckConfPref = (ListPreference) findPreference("deckConf");
        ArrayList<JSONObject> confs = mCol.getDecks().allConf();
        Collections.sort(confs, new JSONNameComparator());
        String[] confValues = new String[confs.size()];
        String[] confLabels = new String[confs.size()];
        try {
            for (int i = 0; i < confs.size(); i++) {
                JSONObject o = confs.get(i);
                confValues[i] = o.getString("id");
                confLabels[i] = o.getString("name");
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        deckConfPref.setEntries(confLabels);
        deckConfPref.setEntryValues(confValues);
        deckConfPref.setValue(mPref.getString("deckConf", "0"));

        ListPreference newOrderPref = (ListPreference) findPreference("newOrder");
        newOrderPref.setEntries(R.array.new_order_labels);
        newOrderPref.setEntryValues(R.array.new_order_values);
        newOrderPref.setValue(mPref.getString("newOrder", "0"));

        ListPreference leechActPref = (ListPreference) findPreference("lapLeechAct");
        leechActPref.setEntries(R.array.leech_action_labels);
        leechActPref.setEntryValues(R.array.leech_action_values);
        leechActPref.setValue(mPref.getString("lapLeechAct", "0"));
    }


    /**
     * Returns the number of decks using the options group of the current deck.
     */
    private int getOptionsGroupCount() {
        int count = 0;
        try {
            long conf = mDeck.getLong("conf");
            for (JSONObject deck : mCol.getDecks().all()) {
                if (deck.getInt("dyn") == 1) {
                    continue;
                }
                if (deck.getLong("conf") == conf) {
                    count++;
                }
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return count;
    }


    /**
     * Get the name of the currently set options group
     */
    private String getOptionsGroupName() {
        long confId = mPref.getLong("deckConf", 0);
        try {
            return mCol.getDecks().getConf(confId).getString("name");
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Get the number of (non-dynamic) subdecks for the current deck
     */
    private int getSubdeckCount() {
        try {
            int count = 0;
            long did = mDeck.getLong("id");
            TreeMap<String, Long> children = mCol.getDecks().children(did);
            for (Map.Entry<String, Long> entry : children.entrySet()) {
                JSONObject child = mCol.getDecks().get(entry.getValue());
                if (child.getInt("dyn") == 1) {
                    continue;
                }
                count++;
            }
            return count;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public class JSONNameComparator implements Comparator<JSONObject> {
        @Override
        public int compare(JSONObject lhs, JSONObject rhs) {
            String o1;
            String o2;
            try {
                o1 = lhs.getString("name");
                o2 = rhs.getString("name");
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            return o1.compareToIgnoreCase(o2);
        }
    }


    /**
     * finish when sd card is ejected
     */
    private void registerExternalStorageListener() {
        if (mUnmountReceiver == null) {
            mUnmountReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    if (intent.getAction().equals(SdCardReceiver.MEDIA_EJECT)) {
                        finish();
                    }
                }
            };
            IntentFilter iFilter = new IntentFilter();
            iFilter.addAction(SdCardReceiver.MEDIA_EJECT);
            registerReceiver(mUnmountReceiver, iFilter);
        }
    }


    private void restartActivity() {
        if (Build.VERSION.SDK_INT >= 11) {
            recreate();
        } else {
            Intent intent = getIntent();
            intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);
            finish();
            overridePendingTransition(0, 0);
            startActivity(intent);
            overridePendingTransition(0, 0);
        }
    }
}
/****************************************************************************************
 * Copyright (c) 2009 Andrew Dubya <andrewdubya@gmail.com>                              *
 * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 * Copyright (c) 2009 Daniel Svard <daniel.svard@gmail.com>                             *
 * Copyright (c) 2010 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2014 Timothy Rae <perceptualchaos2@gmail.com>
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.Manifest;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.database.SQLException;
import android.graphics.PixelFormat;
import android.net.Uri;
import android.os.Bundle;
import android.os.Message;
import android.provider.Settings;
import android.support.design.widget.Snackbar;
import android.support.v4.app.ActivityCompat;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentTransaction;
import android.support.v4.app.ShareCompat;
import android.support.v4.widget.SwipeRefreshLayout;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.text.TextUtils;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

import com.afollestad.materialdialogs.MaterialDialog;
import com.getbase.floatingactionbutton.FloatingActionButton;
import com.getbase.floatingactionbutton.FloatingActionsMenu;
import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.StudyOptionsFragment.StudyOptionsListener;
import com.ichi2.anki.dialogs.AsyncDialogFragment;
import com.ichi2.anki.dialogs.ConfirmationDialog;
import com.ichi2.anki.dialogs.CustomStudyDialog;
import com.ichi2.anki.dialogs.DatabaseErrorDialog;
import com.ichi2.anki.dialogs.DeckPickerBackupNoSpaceLeftDialog;
import com.ichi2.anki.dialogs.DeckPickerConfirmDeleteDeckDialog;
import com.ichi2.anki.dialogs.DeckPickerContextMenu;
import com.ichi2.anki.dialogs.DeckPickerExportCompleteDialog;
import com.ichi2.anki.dialogs.DeckPickerNoSpaceLeftDialog;
import com.ichi2.anki.dialogs.DialogHandler;
import com.ichi2.anki.dialogs.ExportDialog;
import com.ichi2.anki.dialogs.ImportDialog;
import com.ichi2.anki.dialogs.MediaCheckDialog;
import com.ichi2.anki.dialogs.SyncErrorDialog;
import com.ichi2.anki.exception.ConfirmModSchemaException;
import com.ichi2.anki.exception.DeckRenameException;
import com.ichi2.anki.receiver.SdCardReceiver;
import com.ichi2.anki.stats.AnkiStatsTaskHandler;
import com.ichi2.anki.widgets.DeckAdapter;
import com.ichi2.async.Connection;
import com.ichi2.async.Connection.Payload;
import com.ichi2.async.DeckTask;
import com.ichi2.async.DeckTask.TaskData;
import com.ichi2.compat.CompatHelper;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Models;
import com.ichi2.libanki.Sched;
import com.ichi2.libanki.Utils;
import com.ichi2.libanki.importer.AnkiPackageImporter;
import com.ichi2.themes.StyledProgressDialog;
import com.ichi2.ui.DividerItemDecoration;
import com.ichi2.utils.VersionUtils;
import com.ichi2.widget.WidgetStatus;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.TreeMap;

import timber.log.Timber;

public class DeckPicker extends NavigationDrawerActivity implements
        StudyOptionsListener, SyncErrorDialog.SyncErrorDialogListener, ImportDialog.ImportDialogListener,
        MediaCheckDialog.MediaCheckDialogListener, ExportDialog.ExportDialogListener,
        ActivityCompat.OnRequestPermissionsResultCallback, CustomStudyDialog.CustomStudyListener {


    /**
     * Result codes from other activities
     */
    public static final int RESULT_MEDIA_EJECTED = 202;
    public static final int RESULT_DB_ERROR = 203;


    /**
     * Available options performed by other activities (request codes for onActivityResult())
     */
    private static final int REQUEST_STORAGE_PERMISSION = 0;
    private static final int REQUEST_PATH_UPDATE = 1;
    public static final int REPORT_FEEDBACK = 4;
    private static final int LOG_IN_FOR_SYNC = 6;
    private static final int SHOW_INFO_WELCOME = 8;
    private static final int SHOW_INFO_NEW_VERSION = 9;
    private static final int REPORT_ERROR = 10;
    public static final int SHOW_STUDYOPTIONS = 11;
    private static final int ADD_NOTE = 12;

    // For automatic syncing
    // 10 minutes in milliseconds.
    public static final long AUTOMATIC_SYNC_MIN_INTERVAL = 600000;

    private static final int SWIPE_TO_SYNC_TRIGGER_DISTANCE = 400;

    private MaterialDialog mProgressDialog;
    private View mStudyoptionsFrame;
    private RecyclerView mRecyclerView;
    private LinearLayoutManager mRecyclerViewLayoutManager;
    private DeckAdapter mDeckListAdapter;
    private FloatingActionsMenu mActionsMenu;   // Note this will be null below SDK 14

    private SwipeRefreshLayout mPullToSyncWrapper;

    private TextView mReviewSummaryTextView;

    private BroadcastReceiver mUnmountReceiver = null;

    private long mContextMenuDid;

    private EditText mDialogEditText;

    // flag asking user to do a full sync which is used in upgrade path
    boolean mRecommendFullSync = false;

    // flag keeping track of when the app has been paused
    private boolean mActivityPaused = false;

    /**
     * Flag to indicate whether the activity will perform a sync in its onResume.
     * Since syncing closes the database, this flag allows us to avoid doing any
     * work in onResume that might use the database and go straight to syncing.
     */
    private boolean mSyncOnResume = false;

    /**
     * Keep track of which deck was last given focus in the deck list. If we find that this value
     * has changed between deck list refreshes, we need to recenter the deck list to the new current
     * deck.
     */
    private long mFocusedDeck;



    // ----------------------------------------------------------------------------
    // LISTENERS
    // ----------------------------------------------------------------------------

    private final OnClickListener mDeckExpanderClickListener = new OnClickListener() {
        @Override
        public void onClick(View view) {
            Long did = (Long) view.getTag();
            if (getCol().getDecks().children(did).size() > 0) {
                getCol().getDecks().collpase(did);
                updateDeckList();
                dismissAllDialogFragments();
            }
        }
    };

    private final OnClickListener mDeckClickListener = new OnClickListener() {
        @Override
        public void onClick(View v) {
            long deckId = (long) v.getTag();
            Timber.i("DeckPicker:: Selected deck with id %d", deckId);
            if (mActionsMenu != null && mActionsMenu.isExpanded()) {
                mActionsMenu.collapse();
            }
            handleDeckSelection(deckId, false);
            if (mFragmented || !CompatHelper.isLollipop()) {
                // Calling notifyDataSetChanged() will update the color of the selected deck.
                // This interferes with the ripple effect, so we don't do it if lollipop and not tablet view
                mDeckListAdapter.notifyDataSetChanged();
            }
        }
    };

    private final OnClickListener mCountsClickListener = new OnClickListener() {
        @Override
        public void onClick(View v) {
            long deckId = (long) v.getTag();
            Timber.i("DeckPicker:: Selected deck with id %d", deckId);
            if (mActionsMenu != null && mActionsMenu.isExpanded()) {
                mActionsMenu.collapse();
            }
            handleDeckSelection(deckId, true);
            if (mFragmented || !CompatHelper.isLollipop()) {
                // Calling notifyDataSetChanged() will update the color of the selected deck.
                // This interferes with the ripple effect, so we don't do it if lollipop and not tablet view
                mDeckListAdapter.notifyDataSetChanged();
            }
        }
    };

    private final View.OnLongClickListener mDeckLongClickListener = new View.OnLongClickListener() {
        @Override
        public boolean onLongClick(View v) {
            long deckId = (long) v.getTag();
            Timber.i("DeckPicker:: Long tapped on deck with id %d", deckId);
            mContextMenuDid = deckId;
            showDialogFragment(DeckPickerContextMenu.newInstance(deckId));
            return true;
        }
    };

    DeckTask.TaskListener mImportAddListener = new DeckTask.TaskListener() {
        @Override
        public void onPostExecute(DeckTask.TaskData result) {
            if (mProgressDialog != null && mProgressDialog.isShowing()) {
                mProgressDialog.dismiss();
            }
            AnkiPackageImporter imp = (AnkiPackageImporter) result.getObjArray()[0];
            showSimpleMessageDialog(TextUtils.join("\n", imp.getLog()));
            updateDeckList();
        }


        @Override
        public void onPreExecute() {
            if (mProgressDialog == null || !mProgressDialog.isShowing()) {
                mProgressDialog = StyledProgressDialog.show(DeckPicker.this,
                        getResources().getString(R.string.import_title), null, false);
            }
        }


        @Override
        public void onProgressUpdate(DeckTask.TaskData... values) {
            mProgressDialog.setContent(values[0].getString());
        }


        @Override
        public void onCancelled() {
        }
    };

    DeckTask.TaskListener mImportReplaceListener = new DeckTask.TaskListener() {
        @SuppressWarnings("unchecked")
        @Override
        public void onPostExecute(DeckTask.TaskData result) {
            if (mProgressDialog != null && mProgressDialog.isShowing()) {
                mProgressDialog.dismiss();
            }
            Resources res = getResources();
            if (result != null && result.getBoolean()) {
                int code = result.getInt();
                if (code == -2) {
                    // not a valid apkg file
                    showSimpleMessageDialog(res.getString(R.string.import_log_no_apkg));
                }
                updateDeckList();
            } else {
                showSimpleMessageDialog(res.getString(R.string.import_log_no_apkg), true);
            }
        }


        @Override
        public void onPreExecute() {
            if (mProgressDialog == null || !mProgressDialog.isShowing()) {
                mProgressDialog = StyledProgressDialog.show(DeckPicker.this,
                        getResources().getString(R.string.import_title),
                        getResources().getString(R.string.import_replacing), false);
            }
        }


        @Override
        public void onProgressUpdate(DeckTask.TaskData... values) {
            mProgressDialog.setContent(values[0].getString());
        }


        @Override
        public void onCancelled() {
        }
    };

    DeckTask.TaskListener mExportListener = new DeckTask.TaskListener() {

        @Override
        public void onPreExecute() {
            mProgressDialog = StyledProgressDialog.show(DeckPicker.this, "",
                    getResources().getString(R.string.export_in_progress), false);
        }


        @Override
        public void onPostExecute(DeckTask.TaskData result) {
            if (mProgressDialog != null && mProgressDialog.isShowing()) {
                mProgressDialog.dismiss();
            }
            String exportPath = result.getString();
            if (exportPath != null) {
                showAsyncDialogFragment(DeckPickerExportCompleteDialog.newInstance(exportPath));
            } else {
                UIUtils.showThemedToast(DeckPicker.this, getResources().getString(R.string.export_unsuccessful), true);
            }
        }


        @Override
        public void onProgressUpdate(TaskData... values) {
        }


        @Override
        public void onCancelled() {
        }
    };


    // ----------------------------------------------------------------------------
    // ANDROID ACTIVITY METHODS
    // ----------------------------------------------------------------------------

    /** Called when the activity is first created. */
    @SuppressWarnings("StatementWithEmptyBody")
    @Override
    protected void onCreate(Bundle savedInstanceState) throws SQLException {
        Timber.d("onCreate()");
        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());
        // Open Collection on UI thread while splash screen is showing
        boolean colOpen = firstCollectionOpen();

        // Then set theme and content view
        super.onCreate(savedInstanceState);
        setContentView(R.layout.homescreen);
        View mainView = findViewById(android.R.id.content);

        // check, if tablet layout
        mStudyoptionsFrame = findViewById(R.id.studyoptions_fragment);
        // set protected variable from NavigationDrawerActivity
        mFragmented = mStudyoptionsFrame != null && mStudyoptionsFrame.getVisibility() == View.VISIBLE;

        registerExternalStorageListener();

        // create inherited navigation drawer layout here so that it can be used by parent class
        initNavigationDrawer(mainView);
        setTitle(getResources().getString(R.string.app_name));

        mRecyclerView = (RecyclerView) findViewById(R.id.files);
        mRecyclerView.addItemDecoration(new DividerItemDecoration(this));

        // specify a LinearLayoutManager for the RecyclerView
        mRecyclerViewLayoutManager = new LinearLayoutManager(this);
        mRecyclerView.setLayoutManager(mRecyclerViewLayoutManager);

        // create and set an adapter for the RecyclerView
        mDeckListAdapter = new DeckAdapter(getLayoutInflater(), this);
        mDeckListAdapter.setDeckClickListener(mDeckClickListener);
        mDeckListAdapter.setCountsClickListener(mCountsClickListener);
        mDeckListAdapter.setDeckExpanderClickListener(mDeckExpanderClickListener);
        mDeckListAdapter.setDeckLongClickListener(mDeckLongClickListener);
        mRecyclerView.setAdapter(mDeckListAdapter);

        mPullToSyncWrapper = (SwipeRefreshLayout) findViewById(R.id.pull_to_sync_wrapper);
        mPullToSyncWrapper.setDistanceToTriggerSync(SWIPE_TO_SYNC_TRIGGER_DISTANCE);
        mPullToSyncWrapper.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
            @Override
            public void onRefresh() {
                mPullToSyncWrapper.setRefreshing(false);
                sync();
            }
        });

        // Setup the FloatingActionButtons
        mActionsMenu = (FloatingActionsMenu) findViewById(R.id.add_content_menu);
        if (mActionsMenu != null) {
            mActionsMenu.findViewById(R.id.fab_expand_menu_button).setContentDescription(getString(R.string.menu_add));
            configureFloatingActionsMenu();
        } else {
            // FloatingActionsMenu only works properly on Android 14+ so fallback on a context menu below API 14
            Timber.w("Falling back on design support library FloatingActionButton");
            android.support.design.widget.FloatingActionButton addButton;
            addButton = (android.support.design.widget.FloatingActionButton)findViewById(R.id.add_note_action);
            addButton.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    CompatHelper.getCompat().supportAddContentMenu(DeckPicker.this);
                }
            });
        }

        mReviewSummaryTextView = (TextView) findViewById(R.id.today_stats_text_view);

        // Hide the fragment until the counts have been loaded so that the Toolbar fills the whole screen on tablets
        if (mFragmented) {
            mStudyoptionsFrame.setVisibility(View.GONE);
        }


        if (colOpen) {
            // Show any necessary dialogs (e.g. changelog, special messages, etc)
            showStartupScreensAndDialogs(preferences, 0);
        } else {
            // Show error dialogs
            if (!CollectionHelper.hasStorageAccessPermission(this)) {
                // This case is handled by onRequestPermissionsResult() so don't need to do anything
            } else if (!AnkiDroidApp.isSdCardMounted()) {
                // SD card not mounted
                onSdCardNotMounted();
            } else if (!CollectionHelper.isCurrentAnkiDroidDirAccessible(this)) {
                // AnkiDroid directory inaccessible
                Intent i = CompatHelper.getCompat().getPreferenceSubscreenIntent(this, "com.ichi2.anki.prefs.advanced");
                startActivityForResultWithoutAnimation(i, REQUEST_PATH_UPDATE);
                Toast.makeText(this, R.string.directory_inaccessible, Toast.LENGTH_LONG).show();
            } else if (CollectionHelper.getInstance().exceededCursorSizeLimit(this)) {
                showDatabaseErrorDialog(DatabaseErrorDialog.DIALOG_CURSOR_SIZE_LIMIT_EXCEEDED);
            } else {
                showDatabaseErrorDialog(DatabaseErrorDialog.DIALOG_LOAD_FAILED);
            }
        }
    }

    /**
     * Try to open the Collection for the first time, and do some error handling if it wasn't successful
     * @return whether or not we were successful
     */
    private boolean firstCollectionOpen() {
        if (CollectionHelper.hasStorageAccessPermission(this)) {
            // Show error dialog if collection could not be opened
            if (CollectionHelper.getInstance().getColSafe(this) == null) {
                return false;
            }
        } else {
            // Request storage permission if we don't have it (e.g. on Android 6.0+)
            ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.WRITE_EXTERNAL_STORAGE},
                    REQUEST_STORAGE_PERMISSION);
            return false;
        }
        return true;
    }

    private void configureFloatingActionsMenu() {
        final FloatingActionButton addDeckButton = (FloatingActionButton) findViewById(R.id.add_deck_action);
        final FloatingActionButton addSharedButton = (FloatingActionButton) findViewById(R.id.add_shared_action);
        final FloatingActionButton addNoteButton = (FloatingActionButton) findViewById(R.id.add_note_action);
        addDeckButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                if (mActionsMenu == null) {
                    return;
                }
                mActionsMenu.collapse();
                mDialogEditText = new EditText(DeckPicker.this);
                mDialogEditText.setSingleLine(true);
                // mDialogEditText.setFilters(new InputFilter[] { mDeckNameFilter });
                new MaterialDialog.Builder(DeckPicker.this)
                        .title(R.string.new_deck)
                        .positiveText(R.string.dialog_ok)
                        .customView(mDialogEditText, true)
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                String deckName = mDialogEditText.getText().toString();
                                Timber.i("DeckPicker:: Creating new deck...");
                                getCol().getDecks().id(deckName, true);
                                updateDeckList();
                            }
                        })
                        .negativeText(R.string.dialog_cancel)
                        .show();
            }
        });
        addSharedButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                mActionsMenu.collapse();
                addSharedDeck();
            }
        });
        addNoteButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                mActionsMenu.collapse();
                addNote();
            }
        });
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        // Null check to prevent crash when col inaccessible
        if (CollectionHelper.getInstance().getColSafe(this) == null) {
            return false;
        }
        // Show / hide undo
        if (mFragmented || !getCol().undoAvailable()) {
            menu.findItem(R.id.action_undo).setVisible(false);
        } else {
            Resources res = getResources();
            menu.findItem(R.id.action_undo).setVisible(true);
            String undo = res.getString(R.string.studyoptions_congrats_undo, getCol().undoName(res));
            menu.findItem(R.id.action_undo).setTitle(undo);
        }
        return super.onPrepareOptionsMenu(menu);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.deck_picker, menu);
        boolean sdCardAvailable = AnkiDroidApp.isSdCardMounted();
        menu.findItem(R.id.action_sync).setEnabled(sdCardAvailable);
        menu.findItem(R.id.action_new_filtered_deck).setEnabled(sdCardAvailable);
        menu.findItem(R.id.action_check_database).setEnabled(sdCardAvailable);
        menu.findItem(R.id.action_check_media).setEnabled(sdCardAvailable);
        menu.findItem(R.id.action_empty_cards).setEnabled(sdCardAvailable);

        // Hide import, export, and restore backup on ChromeOS as users
        // don't have access to the file system.
        if (CompatHelper.isChromebook()) {
            menu.findItem(R.id.action_restore_backup).setVisible(false);
            menu.findItem(R.id.action_import).setVisible(false);
            menu.findItem(R.id.action_export).setVisible(false);
        }
        return super.onCreateOptionsMenu(menu);
    }


    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        Resources res = getResources();
        if (getDrawerToggle().onOptionsItemSelected(item)) {
            return true;
        }
        switch (item.getItemId()) {

            case R.id.action_undo:
                Timber.i("DeckPicker:: Undo button pressed");
                undo();
                return true;

            case R.id.action_sync:
                Timber.i("DeckPicker:: Sync button pressed");
                sync();
                return true;

            case R.id.action_import:
                Timber.i("DeckPicker:: Import button pressed");
                showImportDialog(ImportDialog.DIALOG_IMPORT_HINT);
                return true;

            case R.id.action_new_filtered_deck:
                Timber.i("DeckPicker:: New filtered deck button pressed");
                mDialogEditText = new EditText(DeckPicker.this);
                ArrayList<String> names = getCol().getDecks().allNames();
                int n = 1;
                String name = String.format(Locale.getDefault(), "%s %d", res.getString(R.string.filtered_deck_name), n);
                while (names.contains(name)) {
                    n++;
                    name = String.format(Locale.getDefault(), "%s %d", res.getString(R.string.filtered_deck_name), n);
                }
                mDialogEditText.setText(name);
                // mDialogEditText.setFilters(new InputFilter[] { mDeckNameFilter });
                new MaterialDialog.Builder(DeckPicker.this)
                        .title(res.getString(R.string.new_deck))
                        .customView(mDialogEditText, true)
                        .positiveText(res.getString(R.string.create))
                        .negativeText(res.getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                String filteredDeckName = mDialogEditText.getText().toString();
                                Timber.i("DeckPicker:: Creating filtered deck...");
                                getCol().getDecks().newDyn(filteredDeckName);
                                openStudyOptions(true);
                            }
                        })
                        .show();
                return true;

            case R.id.action_check_database:
                Timber.i("DeckPicker:: Check database button pressed");
                showDatabaseErrorDialog(DatabaseErrorDialog.DIALOG_CONFIRM_DATABASE_CHECK);
                return true;

            case R.id.action_check_media:
                Timber.i("DeckPicker:: Check media button pressed");
                showMediaCheckDialog(MediaCheckDialog.DIALOG_CONFIRM_MEDIA_CHECK);
                return true;

            case R.id.action_empty_cards:
                Timber.i("DeckPicker:: Empty cards button pressed");
                handleEmptyCards();
                return true;

            case R.id.action_model_browser_open:
                Timber.i("DeckPicker:: Model browser button pressed");
                Intent noteTypeBrowser = new Intent(this, ModelBrowser.class);
                startActivityForResultWithAnimation(noteTypeBrowser, 0, ActivityTransitionAnimation.LEFT);
                return true;

            case R.id.action_restore_backup:
                Timber.i("DeckPicker:: Restore from backup button pressed");
                showDatabaseErrorDialog(DatabaseErrorDialog.DIALOG_CONFIRM_RESTORE_BACKUP);
                return true;

            case R.id.action_export:
                Timber.i("DeckPicker:: Export collection button pressed");
                String msg = getResources().getString(R.string.confirm_apkg_export);
                showDialogFragment(ExportDialog.newInstance(msg));
                return true;
            default:
                return super.onOptionsItemSelected(item);

        }
    }


    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
        super.onActivityResult(requestCode, resultCode, intent);

        if (resultCode == RESULT_MEDIA_EJECTED) {
            onSdCardNotMounted();
            return;
        } else if (resultCode == RESULT_DB_ERROR) {
            handleDbError();
            return;
        }

        if (requestCode == REPORT_ERROR) {
            showStartupScreensAndDialogs(AnkiDroidApp.getSharedPrefs(getBaseContext()), 4);
        } else if (requestCode == SHOW_INFO_WELCOME || requestCode == SHOW_INFO_NEW_VERSION) {
            if (resultCode == RESULT_OK) {
                showStartupScreensAndDialogs(AnkiDroidApp.getSharedPrefs(getBaseContext()),
                        requestCode == SHOW_INFO_WELCOME ? 2 : 3);
            } else {
                finishWithAnimation();
            }
        } else if (requestCode == LOG_IN_FOR_SYNC && resultCode == RESULT_OK) {
            mSyncOnResume = true;
        } else if ((requestCode == REQUEST_REVIEW || requestCode == SHOW_STUDYOPTIONS)
                && resultCode == Reviewer.RESULT_NO_MORE_CARDS) {
            // Show a message when reviewing has finished
            int[] studyOptionsCounts = getCol().getSched().counts();
            if (studyOptionsCounts[0] + studyOptionsCounts[1] + studyOptionsCounts[2] == 0) {
                UIUtils.showSimpleSnackbar(this, R.string.studyoptions_congrats_finished, false);
            } else {
                UIUtils.showSimpleSnackbar(this, R.string.studyoptions_no_cards_due, false);
            }
        } else if (requestCode == REQUEST_BROWSE_CARDS) {
            // Store the selected deck after opening browser
            if (intent != null && intent.getBooleanExtra("allDecksSelected", false)) {
                AnkiDroidApp.getSharedPrefs(this).edit().putLong("browserDeckIdFromDeckPicker", -1L).apply();
            } else {
                long selectedDeck = getCol().getDecks().selected();
                AnkiDroidApp.getSharedPrefs(this).edit().putLong("browserDeckIdFromDeckPicker", selectedDeck).apply();
            }
        } else if (requestCode == REQUEST_PATH_UPDATE) {
            // The collection path was inaccessible on startup so just close the activity and let user restart
            finishWithoutAnimation();
        }
    }


    public void onRequestPermissionsResult (int requestCode, String[] permissions, int[] grantResults) {
        if (requestCode == REQUEST_STORAGE_PERMISSION && permissions.length == 1) {
            if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                showStartupScreensAndDialogs(AnkiDroidApp.getSharedPrefs(this), 0);
            } else {
                // User denied access to the SD card so show error toast and finish activity
                Toast.makeText(this, R.string.directory_inaccessible, Toast.LENGTH_LONG).show();
                finishWithoutAnimation();
                // Open the Android settings page for our app so that the user can grant the missing permission
                Intent intent = new Intent();
                intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
                Uri uri = Uri.fromParts("package", getPackageName(), null);
                intent.setData(uri);
                startActivityWithoutAnimation(intent);
            }
        }
    }


    @Override
    protected void onResume() {
        Timber.d("onResume()");
        super.onResume();
        mActivityPaused = false;
        if (mSyncOnResume) {
            sync();
            mSyncOnResume = false;
        } else if (colIsOpen()) {
            selectNavigationItem(R.id.nav_decks);
            updateDeckList();
            setTitle(getResources().getString(R.string.app_name));
        }
    }


    @Override
    public void onSaveInstanceState(Bundle savedInstanceState) {
        super.onSaveInstanceState(savedInstanceState);
        savedInstanceState.putLong("mContextMenuDid", mContextMenuDid);
    }


    @Override
    public void onRestoreInstanceState(Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
        mContextMenuDid = savedInstanceState.getLong("mContextMenuDid");
    }


    @Override
    protected void onPause() {
        Timber.d("onPause()");
        mActivityPaused = true;
        super.onPause();
    }


    @Override
    protected void onStop() {
        Timber.d("onStop()");
        super.onStop();
        if (colIsOpen()) {
            WidgetStatus.update(this);
            UIUtils.saveCollectionInBackground(this);
        }
    }


    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mUnmountReceiver != null) {
            unregisterReceiver(mUnmountReceiver);
        }
        if (mProgressDialog != null && mProgressDialog.isShowing()) {
            mProgressDialog.dismiss();
        }
        Timber.d("onDestroy()");
    }

    private void automaticSync() {
        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());

        // Check whether the option is selected, the user is signed in and last sync was AUTOMATIC_SYNC_TIME ago
        // (currently 10 minutes)
        String hkey = preferences.getString("hkey", "");
        long lastSyncTime = preferences.getLong("lastSyncTime", 0);
        if (hkey.length() != 0 && preferences.getBoolean("automaticSyncMode", false) &&
                Connection.isOnline() && Utils.intNow(1000) - lastSyncTime > AUTOMATIC_SYNC_MIN_INTERVAL) {
            sync();
        }
    }

    @Override
    public void onBackPressed() {
        if (isDrawerOpen()) {
            super.onBackPressed();
        } else {
            Timber.i("Back key pressed");
            if (mActionsMenu != null && mActionsMenu.isExpanded()) {
                mActionsMenu.collapse();
            } else {
                automaticSync();
                finishWithAnimation();
            }
        }
    }


    private void finishWithAnimation() {
        super.finishWithAnimation(ActivityTransitionAnimation.DOWN);
    }


    // ----------------------------------------------------------------------------
    // CUSTOM METHODS
    // ----------------------------------------------------------------------------


    /**
     * Perform the following tasks:
     * Automatic backup
     * loadStudyOptionsFragment() if tablet
     * Automatic sync
     */
    private void onFinishedStartup() {
        // create backup in background if needed
        BackupManager.performBackupInBackground(getCol().getPath());

        // Force a full sync if flag was set in upgrade path, asking the user to confirm if necessary
        if (mRecommendFullSync) {
            mRecommendFullSync = false;
            try {
                getCol().modSchema();
            } catch (ConfirmModSchemaException e) {
                // If libanki determines it's necessary to confirm the full sync then show a confirmation dialog
                // We have to show the dialog via the DialogHandler since this method is called via a Loader
                Resources res = getResources();
                Message handlerMessage = Message.obtain();
                handlerMessage.what = DialogHandler.MSG_SHOW_FORCE_FULL_SYNC_DIALOG;
                Bundle handlerMessageData = new Bundle();
                handlerMessageData.putString("message", res.getString(R.string.full_sync_confirmation_upgrade) +
                        "\n\n" + res.getString(R.string.full_sync_confirmation));
                handlerMessage.setData(handlerMessageData);
                getDialogHandler().sendMessage(handlerMessage);
            }
        }
        // Open StudyOptionsFragment if in fragmented mode
        if (mFragmented) {
            loadStudyOptionsFragment(false);
        }
        automaticSync();
    }

    @Override
    protected void onCollectionLoadError() {
        getDialogHandler().sendEmptyMessage(DialogHandler.MSG_SHOW_COLLECTION_LOADING_ERROR_DIALOG);
    }


    public void addNote() {
        Intent intent = new Intent(DeckPicker.this, NoteEditor.class);
        intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_DECKPICKER);
        startActivityForResultWithAnimation(intent, ADD_NOTE, ActivityTransitionAnimation.LEFT);
    }


    private void showStartupScreensAndDialogs(SharedPreferences preferences, int skip) {
        if (!BackupManager.enoughDiscSpace(CollectionHelper.getCurrentAnkiDroidDirectory(this))) {
            // Not enough space to do backup
            showDialogFragment(DeckPickerNoSpaceLeftDialog.newInstance());
        } else if (preferences.getBoolean("noSpaceLeft", false)) {
            // No space left
            showDialogFragment(DeckPickerBackupNoSpaceLeftDialog.newInstance());
            preferences.edit().remove("noSpaceLeft").commit();
        } else if (preferences.getString("lastVersion", "").equals("")) {
            // Fresh install
            preferences.edit().putString("lastVersion", VersionUtils.getPkgVersionName()).commit();
            onFinishedStartup();
        } else if (skip < 2 && !preferences.getString("lastVersion", "").equals(VersionUtils.getPkgVersionName())) {
            // AnkiDroid is being updated and a collection already exists. We check if we are upgrading
            // to a version that contains additions to the database integrity check routine that we would
            // like to run on all collections. A missing version number is assumed to be a fresh
            // installation of AnkiDroid and we don't run the check.
            int current = VersionUtils.getPkgVersionCode();
            int previous;
            if (!preferences.contains("lastUpgradeVersion")) {
                // Fresh install
                previous = current;
            } else {
                try {
                    previous = preferences.getInt("lastUpgradeVersion", current);
                } catch (ClassCastException e) {
                    // Previous versions stored this as a string.
                    String s = preferences.getString("lastUpgradeVersion", "");
                    // The last version of AnkiDroid that stored this as a string was 2.0.2.
                    // We manually set the version here, but anything older will force a DB
                    // check.
                    if (s.equals("2.0.2")) {
                        previous = 40;
                    } else {
                        previous = 0;
                    }
                }
            }
            preferences.edit().putInt("lastUpgradeVersion", current).commit();
            preferences.edit().remove("sentExceptionReports").commit();     // clear cache of sent exception reports
            // Delete the media database made by any version before 2.3 beta due to upgrade errors.
            // It is rebuilt on the next sync or media check
            if (previous < 20300200) {
                File mediaDb = new File(CollectionHelper.getCurrentAnkiDroidDirectory(this), "collection.media.ad.db2");
                if (mediaDb.exists()) {
                    mediaDb.delete();
                }
            }
            // Recommend the user to do a full-sync if they're upgrading from before 2.3.1beta8
            if (previous < 20301208) {
                mRecommendFullSync = true;
            }

            // Fix "font-family" definition in templates created by AnkiDroid before 2.6alhpa23
            if (previous < 20600123) {
                try {
                    Models models = getCol().getModels();
                    for (JSONObject m : models.all()) {
                        String css = m.getString("css");
                        if (css.contains("font-familiy")) {
                            m.put("css", css.replace("font-familiy", "font-family"));
                            models.save(m);
                        }
                    }
                    models.flush();
                } catch (JSONException e) {
                    Timber.e(e, "Failed to upgrade css definitions.");
                }
            }

            // Check if preference upgrade or database check required, otherwise go to new feature screen
            int upgradePrefsVersion = AnkiDroidApp.CHECK_PREFERENCES_AT_VERSION;
            int upgradeDbVersion = AnkiDroidApp.CHECK_DB_AT_VERSION;

            if (previous < upgradeDbVersion || previous < upgradePrefsVersion) {
                if (previous < upgradePrefsVersion && current >= upgradePrefsVersion) {
                    Timber.d("Upgrading preferences");
                    CompatHelper.removeHiddenPreferences(this.getApplicationContext());
                    upgradePreferences(previous);
                }
                // Integrity check loads asynchronously and then restart deckpicker when finished
                if (previous < upgradeDbVersion && current >= upgradeDbVersion) {
                    integrityCheck();
                } else if (previous < upgradePrefsVersion && current >= upgradePrefsVersion) {
                    // If integrityCheck() doesn't occur, but we did update preferences we should restart DeckPicker to
                    // proceed
                    restartActivity();
                }
            } else {
                // If no changes are required we go to the new features activity
                // There the "lastVersion" is set, so that this code is not reached again
                if (VersionUtils.isReleaseVersion()) {
                    Intent infoIntent = new Intent(this, Info.class);
                    infoIntent.putExtra(Info.TYPE_EXTRA, Info.TYPE_NEW_VERSION);

                    if (skip != 0) {
                        startActivityForResultWithAnimation(infoIntent, SHOW_INFO_NEW_VERSION,
                                ActivityTransitionAnimation.LEFT);
                    } else {
                        startActivityForResultWithoutAnimation(infoIntent, SHOW_INFO_NEW_VERSION);
                    }
                } else {
                    // Don't show new features dialog for development builds
                    preferences.edit().putString("lastVersion", VersionUtils.getPkgVersionName()).apply();
                    String ver = getResources().getString(R.string.updated_version, VersionUtils.getPkgVersionName());
                    UIUtils.showSnackbar(this, ver, true, -1, null, findViewById(R.id.root_layout), null);
                    showStartupScreensAndDialogs(preferences, 2);
                }
            }
        } else {
            // This is the main call when there is nothing special required
            onFinishedStartup();
        }
    }


    private void upgradePreferences(int previousVersionCode) {
        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());
        // clear all prefs if super old version to prevent any errors
        if (previousVersionCode < 20300130) {
            preferences.edit().clear().commit();
        }
        // when upgrading from before 2.5alpha35
        if (previousVersionCode < 20500135) {
            // Card zooming behaviour was changed the preferences renamed
            int oldCardZoom = preferences.getInt("relativeDisplayFontSize", 100);
            int oldImageZoom = preferences.getInt("relativeImageSize", 100);
            preferences.edit().putInt("cardZoom", oldCardZoom).commit();
            preferences.edit().putInt("imageZoom", oldImageZoom).commit();
            if (!preferences.getBoolean("useBackup", true)) {
                preferences.edit().putInt("backupMax", 0).commit();
            }
            preferences.edit().remove("useBackup").commit();
            preferences.edit().remove("intentAdditionInstantAdd").commit();
        }

        if (preferences.contains("fullscreenReview")) {
            // clear fullscreen flag as we use a integer
            try {
                boolean old = preferences.getBoolean("fullscreenReview", false);
                preferences.edit().putString("fullscreenMode", old ? "1": "0").commit();
            } catch (ClassCastException e) {
                // TODO:  can remove this catch as it was only here to fix an error in the betas
                preferences.edit().remove("fullscreenMode").commit();
            }
            preferences.edit().remove("fullscreenReview").commit();
        }
    }

    private void undo() {
        String undoReviewString = getResources().getString(R.string.undo_action_review);
        final boolean isReview = undoReviewString.equals(getCol().undoName(getResources()));
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UNDO, new DeckTask.TaskListener() {
            @Override
            public void onCancelled() {
                hideProgressBar();
            }

            @Override
            public void onPreExecute() {
                showProgressBar();
            }

            @Override
            public void onPostExecute(TaskData result) {
                hideProgressBar();
                if (isReview) {
                    openReviewer();
                }
            }

            @Override
            public void onProgressUpdate(TaskData... values) {
            }
        });
    }


    // Show dialogs to deal with database loading issues etc
    public void showDatabaseErrorDialog(int id) {
        AsyncDialogFragment newFragment = DatabaseErrorDialog.newInstance(id);
        showAsyncDialogFragment(newFragment);
    }


    @Override
    public void showMediaCheckDialog(int id) {
        showAsyncDialogFragment(MediaCheckDialog.newInstance(id));
    }


    @Override
    public void showMediaCheckDialog(int id, List<List<String>> checkList) {
        showAsyncDialogFragment(MediaCheckDialog.newInstance(id, checkList));
    }


    /**
     * Show a specific sync error dialog
     * @param id id of dialog to show
     */
    @Override
    public void showSyncErrorDialog(int id) {
        showSyncErrorDialog(id, "");
    }

    /**
     * Show a specific sync error dialog
     * @param id id of dialog to show
     * @param message text to show
     */
    @Override
    public void showSyncErrorDialog(int id, String message) {
        AsyncDialogFragment newFragment = SyncErrorDialog.newInstance(id, message);
        showAsyncDialogFragment(newFragment);
    }

    /**
     *  Show simple error dialog with just the message and OK button. Reload the activity when dialog closed.
     * @param message
     */
    private void showSyncErrorMessage(String message) {
        String title = getResources().getString(R.string.sync_error);
        showSimpleMessageDialog(title, message, true);
    }

    /**
     *  Show a simple snackbar message or notification if the activity is not in foreground
     * @param messageResource String resource for message
     */
    private void showSyncLogMessage(int messageResource, String syncMessage) {
        if (mActivityPaused) {
            Resources res = AnkiDroidApp.getAppResources();
            showSimpleNotification(res.getString(R.string.app_name), res.getString(messageResource));
        } else {
            if (syncMessage == null || syncMessage.length() == 0) {
                UIUtils.showSimpleSnackbar(this, messageResource, false);
            } else {
                Resources res = AnkiDroidApp.getAppResources();
                showSimpleMessageDialog(res.getString(messageResource), syncMessage, false);
            }
        }
    }


    @Override
    public void showImportDialog(int id) {
        showImportDialog(id, "");
    }


    @Override
    public void showImportDialog(int id, String message) {
        DialogFragment newFragment = ImportDialog.newInstance(id, message);
        showDialogFragment(newFragment);
    }

    public void onSdCardNotMounted() {
        UIUtils.showThemedToast(this, getResources().getString(R.string.sd_card_not_mounted), false);
        finishWithoutAnimation();
    }

    // Callback method to submit error report
    public void sendErrorReport() {
        AnkiDroidApp.sendExceptionReport(new RuntimeException(), "DeckPicker.sendErrorReport");
    }


    // Callback method to handle repairing deck
    public void repairDeck() {
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REPAIR_DECK, new DeckTask.TaskListener() {

            @Override
            public void onPreExecute() {
                mProgressDialog = StyledProgressDialog.show(DeckPicker.this, "",
                        getResources().getString(R.string.backup_repair_deck_progress), false);
            }


            @Override
            public void onPostExecute(DeckTask.TaskData result) {
                if (mProgressDialog != null && mProgressDialog.isShowing()) {
                    mProgressDialog.dismiss();
                }
                if (result == null || !result.getBoolean()) {
                    UIUtils.showThemedToast(DeckPicker.this, getResources().getString(R.string.deck_repair_error), true);
                    onCollectionLoadError();
                }
            }


            @Override
            public void onProgressUpdate(TaskData... values) {
            }


            @Override
            public void onCancelled() {
            }
        });
    }


    // Callback method to handle database integrity check
    public void integrityCheck() {
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CHECK_DATABASE, new DeckTask.TaskListener() {
            @Override
            public void onPreExecute() {
                mProgressDialog = StyledProgressDialog.show(DeckPicker.this, "",
                        getResources().getString(R.string.check_db_message), false);
            }


            @Override
            public void onPostExecute(TaskData result) {
                if (mProgressDialog != null && mProgressDialog.isShowing()) {
                    mProgressDialog.dismiss();
                }
                if (result != null && result.getBoolean()) {
                    String msg = "";
                    long shrunk = Math.round(result.getLong() / 1024.0);
                    if (shrunk > 0.0) {
                        msg = String.format(Locale.getDefault(),
                                getResources().getString(R.string.check_db_acknowledge_shrunk), (int) shrunk);
                    } else {
                        msg = getResources().getString(R.string.check_db_acknowledge);
                    }
                    // Show result of database check and restart the app
                    showSimpleMessageDialog(msg, true);
                } else {
                    handleDbError();
                }
            }


            @Override
            public void onProgressUpdate(TaskData... values) {
            }


            @Override
            public void onCancelled() {
            }
        });
    }


    @Override
    public void mediaCheck() {
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CHECK_MEDIA, new DeckTask.TaskListener() {
            @Override
            public void onPreExecute() {
                mProgressDialog = StyledProgressDialog.show(DeckPicker.this, "",
                        getResources().getString(R.string.check_media_message), false);
            }


            @Override
            public void onPostExecute(TaskData result) {
                if (mProgressDialog != null && mProgressDialog.isShowing()) {
                    mProgressDialog.dismiss();
                }
                if (result != null && result.getBoolean()) {
                    @SuppressWarnings("unchecked")
                    List<List<String>> checkList = (List<List<String>>) result.getObjArray()[0];
                    showMediaCheckDialog(MediaCheckDialog.DIALOG_MEDIA_CHECK_RESULTS, checkList);
                } else {
                    showSimpleMessageDialog(getResources().getString(R.string.check_media_failed));
                }
            }


            @Override
            public void onProgressUpdate(TaskData... values) {
            }


            @Override
            public void onCancelled() {
            }
        });
    }


    @Override
    public void deleteUnused(List<String> unused) {
        com.ichi2.libanki.Media m = getCol().getMedia();
        for (String fname : unused) {
            m.removeFile(fname);
        }
        showSimpleMessageDialog(String.format(getResources().getString(R.string.check_media_deleted), unused.size()));
    }


    public void exit() {
        CollectionHelper.getInstance().closeCollection(false);
        finishWithoutAnimation();
        System.exit(0);
    }


    public void handleDbError() {
        showDatabaseErrorDialog(DatabaseErrorDialog.DIALOG_LOAD_FAILED);
    }


    public void restoreFromBackup(String path) {
        importReplace(path);
    }


    // Helper function to check if there are any saved stacktraces
    public boolean hasErrorFiles() {
        for (String file : this.fileList()) {
            if (file.endsWith(".stacktrace")) {
                return true;
            }
        }
        return false;
    }


    // Sync with Anki Web
    @Override
    public void sync() {
        sync(null);
    }


    /**
     * The mother of all syncing attempts. This might be called from sync() as first attempt to sync a collection OR
     * from the mSyncConflictResolutionListener if the first attempt determines that a full-sync is required.
     *
     * @param syncConflictResolution Either "upload" or "download", depending on the user's choice.
     */
    @Override
    public void sync(String syncConflictResolution) {
        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());
        String hkey = preferences.getString("hkey", "");
        if (hkey.length() == 0) {
            mPullToSyncWrapper.setRefreshing(false);
            showSyncErrorDialog(SyncErrorDialog.DIALOG_USER_NOT_LOGGED_IN_SYNC);
        } else {
            Connection.sync(mSyncListener,
                    new Connection.Payload(new Object[] { hkey, preferences.getBoolean("syncFetchesMedia", true),
                            syncConflictResolution }));
        }
    }


    private Connection.TaskListener mSyncListener = new Connection.CancellableTaskListener() {
        String currentMessage;
        long countUp;
        long countDown;

        @Override
        public void onDisconnected() {
            showSyncLogMessage(R.string.youre_offline, "");
        }

        @Override
        public void onCancelled() {
            mProgressDialog.dismiss();
            showSyncLogMessage(R.string.sync_cancelled, "");
            // update deck list in case sync was cancelled during media sync and main sync was actually successful
            updateDeckList();
        }

        @Override
        public void onPreExecute() {
            countUp = 0;
            countDown = 0;
            // Store the current time so that we don't bother the user with a sync prompt for another 10 minutes
            // Note: getLs() in Libanki doesn't take into account the case when no changes were found, or sync cancelled
            SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());
            final long syncStartTime = System.currentTimeMillis();
            preferences.edit().putLong("lastSyncTime", syncStartTime).apply();

            if (mProgressDialog == null || !mProgressDialog.isShowing()) {
                mProgressDialog = StyledProgressDialog
                        .show(DeckPicker.this, getResources().getString(R.string.sync_title),
                                getResources().getString(R.string.sync_title) + "\n"
                                        + getResources().getString(R.string.sync_up_down_size, countUp, countDown),
                                false);

                // Override the back key so that the user can cancel a sync which is in progress
                mProgressDialog.setOnKeyListener(new DialogInterface.OnKeyListener() {
                    @Override
                    public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
                        // Make sure our method doesn't get called twice
                        if (event.getAction()!=KeyEvent.ACTION_DOWN) {
                            return true;
                        }

                        if (keyCode == KeyEvent.KEYCODE_BACK && Connection.isCancellable() &&
                                !Connection.getIsCancelled()) {
                            // If less than 2s has elapsed since sync started then don't ask for confirmation
                            if (System.currentTimeMillis() - syncStartTime < 2000) {
                                Connection.cancel();
                                mProgressDialog.setContent(R.string.sync_cancel_message);
                                return true;
                            }
                            // Show confirmation dialog to check if the user wants to cancel the sync
                            MaterialDialog.Builder builder = new MaterialDialog.Builder(mProgressDialog.getContext());
                            builder.content(R.string.cancel_sync_confirm)
                                    .cancelable(false)
                                    .positiveText(R.string.dialog_ok)
                                    .negativeText(R.string.continue_sync)
                                    .callback(new MaterialDialog.ButtonCallback() {
                                        @Override
                                        public void onPositive(MaterialDialog dialog) {
                                            mProgressDialog.setContent(R.string.sync_cancel_message);
                                            Connection.cancel();
                                        }
                                    });
                            builder.show();
                            return true;
                        } else {
                            return false;
                        }
                    }
                });
            }
        }


        @Override
        public void onProgressUpdate(Object... values) {
            Resources res = getResources();
            if (values[0] instanceof Boolean) {
                // This is the part Download missing media of syncing
                int total = (Integer) values[1];
                int done = (Integer) values[2];
                values[0] = (values[3]);
                values[1] = res.getString(R.string.sync_downloading_media, done, total);
            } else if (values[0] instanceof Integer) {
                int id = (Integer) values[0];
                if (id != 0) {
                    currentMessage = res.getString(id);
                }
                if (values.length >= 3) {
                    countUp = (Long) values[1];
                    countDown = (Long) values[2];
                }
            } else if (values[0] instanceof String) {
                currentMessage = (String) values[0];
                if (values.length >= 3) {
                    countUp = (Long) values[1];
                    countDown = (Long) values[2];
                }
            }
            if (mProgressDialog != null && mProgressDialog.isShowing()) {
                // mProgressDialog.setTitle((String) values[0]);
                mProgressDialog.setContent(currentMessage + "\n"
                        + res
                        .getString(R.string.sync_up_down_size, countUp / 1024, countDown / 1024));
            }
        }


        @SuppressWarnings("unchecked")
        @Override
        public void onPostExecute(Payload data) {
            mPullToSyncWrapper.setRefreshing(false);
            String dialogMessage = "";
            String syncMessage = "";
            Timber.d("Sync Listener onPostExecute()");
            Resources res = getResources();
            try {
                if (mProgressDialog != null && mProgressDialog.isShowing()) {
                    mProgressDialog.dismiss();
                }
            } catch (IllegalArgumentException e) {
                Timber.e(e, "Could not dismiss mProgressDialog. The Activity must have been destroyed while the AsyncTask was running");
                AnkiDroidApp.sendExceptionReport(e, "DeckPicker.onPostExecute", "Could not dismiss mProgressDialog");
            }
            syncMessage = data.message;
            if (!data.success) {
                Object[] result = (Object[]) data.result;
                if (result[0] instanceof String) {
                    String resultType = (String) result[0];
                    if (resultType.equals("badAuth")) {
                        // delete old auth information
                        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());
                        Editor editor = preferences.edit();
                        editor.putString("username", "");
                        editor.putString("hkey", "");
                        editor.commit();
                        // then show not logged in dialog
                        showSyncErrorDialog(SyncErrorDialog.DIALOG_USER_NOT_LOGGED_IN_SYNC);
                    } else if (resultType.equals("noChanges")) {
                        // show no changes message, use false flag so we don't show "sync error" as the Dialog title
                        showSyncLogMessage(R.string.sync_no_changes_message, "");
                    } else if (resultType.equals("clockOff")) {
                        long diff = (Long) result[1];
                        if (diff >= 86100) {
                            // The difference if more than a day minus 5 minutes acceptable by ankiweb error
                            dialogMessage = res.getString(R.string.sync_log_clocks_unsynchronized, diff,
                                    res.getString(R.string.sync_log_clocks_unsynchronized_date));
                        } else if (Math.abs((diff % 3600.0) - 1800.0) >= 1500.0) {
                            // The difference would be within limit if we adjusted the time by few hours
                            // It doesn't work for all timezones, but it covers most and it's a guess anyway
                            dialogMessage = res.getString(R.string.sync_log_clocks_unsynchronized, diff,
                                    res.getString(R.string.sync_log_clocks_unsynchronized_tz));
                        } else {
                            dialogMessage = res.getString(R.string.sync_log_clocks_unsynchronized, diff, "");
                        }
                        showSyncErrorMessage(joinSyncMessages(dialogMessage, syncMessage));
                    } else if (resultType.equals("fullSync")) {
                        if (getCol().isEmpty()) {
                            // don't prompt user to resolve sync conflict if local collection empty
                            sync("download");
                            // TODO: Also do reverse check to see if AnkiWeb collection is empty if Anki Desktop
                            // implements it
                        } else {
                            // If can't be resolved then automatically then show conflict resolution dialog
                            showSyncErrorDialog(SyncErrorDialog.DIALOG_SYNC_CONFLICT_RESOLUTION);
                        }
                    } else if (resultType.equals("dbError")  || resultType.equals("basicCheckFailed")) {
                        String repairUrl = res.getString(R.string.repair_deck);
                        dialogMessage = res.getString(R.string.sync_corrupt_database, repairUrl);
                        showSyncErrorMessage(joinSyncMessages(dialogMessage, syncMessage));
                    } else if (resultType.equals("overwriteError")) {
                        dialogMessage = res.getString(R.string.sync_overwrite_error);
                        showSyncErrorMessage(joinSyncMessages(dialogMessage, syncMessage));
                    } else if (resultType.equals("remoteDbError")) {
                        dialogMessage = res.getString(R.string.sync_remote_db_error);
                        showSyncErrorMessage(joinSyncMessages(dialogMessage, syncMessage));
                    } else if (resultType.equals("sdAccessError")) {
                        dialogMessage = res.getString(R.string.sync_write_access_error);
                        showSyncErrorMessage(joinSyncMessages(dialogMessage, syncMessage));
                    } else if (resultType.equals("finishError")) {
                        dialogMessage = res.getString(R.string.sync_log_finish_error);
                        showSyncErrorMessage(joinSyncMessages(dialogMessage, syncMessage));
                    } else if (resultType.equals("connectionError")) {
                        dialogMessage = res.getString(R.string.sync_connection_error);
                        showSyncErrorMessage(joinSyncMessages(dialogMessage, syncMessage));
                    } else if (resultType.equals("IOException")) {
                        handleDbError();
                    } else if (resultType.equals("genericError")) {
                        dialogMessage = res.getString(R.string.sync_generic_error);
                        showSyncErrorMessage(joinSyncMessages(dialogMessage, syncMessage));
                    } else if (resultType.equals("OutOfMemoryError")) {
                        dialogMessage = res.getString(R.string.error_insufficient_memory);
                        showSyncErrorMessage(joinSyncMessages(dialogMessage, syncMessage));
                    } else if (resultType.equals("sanityCheckError")) {
                        dialogMessage = res.getString(R.string.sync_sanity_failed);
                        showSyncErrorDialog(SyncErrorDialog.DIALOG_SYNC_SANITY_ERROR,
                                joinSyncMessages(dialogMessage, syncMessage));
                    } else if (resultType.equals("serverAbort")) {
                        // syncMsg has already been set above, no need to fetch it here.
                        showSyncErrorMessage(joinSyncMessages(dialogMessage, syncMessage));
                    } else if (resultType.equals("mediaSyncServerError")) {
                        dialogMessage = res.getString(R.string.sync_media_error_check);
                        showSyncErrorDialog(SyncErrorDialog.DIALOG_MEDIA_SYNC_ERROR,
                                joinSyncMessages(dialogMessage, syncMessage));
                    } else {
                        if (result.length > 1 && result[1] instanceof Integer) {
                            int type = (Integer) result[1];
                            switch (type) {
                                case 501:
                                    dialogMessage = res.getString(R.string.sync_error_501_upgrade_required);
                                    break;
                                case 503:
                                    dialogMessage = res.getString(R.string.sync_too_busy);
                                    break;
                                case 409:
                                    dialogMessage = res.getString(R.string.sync_error_409);
                                    break;
                                default:
                                    dialogMessage = res.getString(R.string.sync_log_error_specific,
                                            Integer.toString(type), result[2]);
                                    break;
                            }
                        } else if (result[0] instanceof String) {
                            dialogMessage = res.getString(R.string.sync_log_error_specific, Integer.toString(-1), result[0]);
                        } else {
                            dialogMessage = res.getString(R.string.sync_generic_error);
                        }
                        showSyncErrorMessage(joinSyncMessages(dialogMessage, syncMessage));
                    }
                }
            } else {
                // Sync was successful!
                if (data.data[2] != null && !data.data[2].equals("")) {
                    // There was a media error, so show it
                    String message = res.getString(R.string.sync_database_acknowledge) + "\n\n" + data.data[2];
                    showSimpleMessageDialog(message);
                } else if (data.data.length > 0 && data.data[0] instanceof String
                        && ((String) data.data[0]).length() > 0) {
                    // A full sync occurred
                    String dataString = (String) data.data[0];
                    if (dataString.equals("upload")) {
                        showSyncLogMessage(R.string.sync_log_uploading_message, syncMessage);
                    } else if (dataString.equals("download")) {
                        showSyncLogMessage(R.string.sync_log_downloading_message, syncMessage);
                    } else {
                        showSyncLogMessage(R.string.sync_database_acknowledge, syncMessage);
                    }
                } else {
                    // Regular sync completed successfully
                    showSyncLogMessage(R.string.sync_database_acknowledge, syncMessage);
                }
                updateDeckList();
                WidgetStatus.update(DeckPicker.this);
                if (mFragmented) {
                    try {
                        loadStudyOptionsFragment(false);
                    } catch (IllegalStateException e) {
                        // Activity was stopped or destroyed when the sync finished. Losing the
                        // fragment here is fine since we build a fresh fragment on resume anyway.
                        Timber.w(e, "Failed to load StudyOptionsFragment after sync.");
                    }
                }
            }
        }
    };


    private String joinSyncMessages(String dialogMessage, String syncMessage) {
        // If both strings have text, separate them by a new line, otherwise return whichever has text
        if (!TextUtils.isEmpty(dialogMessage) && !TextUtils.isEmpty(syncMessage)) {
            return dialogMessage + "\n\n" + syncMessage;
        } else if (!TextUtils.isEmpty(dialogMessage)) {
            return dialogMessage;
        } else {
            return syncMessage;
        }
    }


    @Override
    public void loginToSyncServer() {
        Intent myAccount = new Intent(this, MyAccount.class);
        myAccount.putExtra("notLoggedIn", true);
        startActivityForResultWithAnimation(myAccount, LOG_IN_FOR_SYNC, ActivityTransitionAnimation.FADE);
    }


    // Callback to import a file -- adding it to existing collection
    @Override
    public void importAdd(String importPath) {
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_IMPORT, mImportAddListener,
                new TaskData(importPath, false));
    }


    // Callback to import a file -- replacing the existing collection
    @Override
    public void importReplace(String importPath) {
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_IMPORT_REPLACE, mImportReplaceListener, new TaskData(importPath));
    }


    @Override
    public void exportApkg(String filename, Long did, boolean includeSched, boolean includeMedia) {
        // Export the file to sdcard/AnkiDroid/export regardless of actual col directory, so that we can use FileProvider API
        File exportDir = new File(CollectionHelper.getDefaultAnkiDroidDirectory(), "export");
        exportDir.mkdirs();
        File exportPath;
        if (filename != null) {
            // filename has been explicitly specified
            exportPath = new File(exportDir, filename);
        } else if (did != null) {
            // filename not explicitly specified, but a deck has been specified so use deck name
            try {
                exportPath = new File(exportDir, getCol().getDecks().get(did).getString("name").replaceAll("\\W+", "_") + ".apkg");
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        } else if (!includeSched) {
            // full export without scheduling is assumed to be shared with someone else -- use "All Decks.apkg"
            exportPath = new File(exportDir, "All Decks.apkg");
        } else {
            // full collection export -- use "collection.apkg"
            File colPath = new File(getCol().getPath());
            exportPath = new File(exportDir, colPath.getName().replace(".anki2", ".apkg"));
        }
        // add input arguments to new generic structure
        Object[] inputArgs = new Object[5];
        inputArgs[0] = getCol();
        inputArgs[1] = exportPath.getPath();
        inputArgs[2] = did;
        inputArgs[3] = includeSched;
        inputArgs[4] = includeMedia;
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_EXPORT_APKG, mExportListener, new TaskData(inputArgs));
    }


    public void emailFile(String path) {
        // Make sure the file actually exists
        File attachment = new File(path);
        if (!attachment.exists()) {
            Timber.e("Specified apkg file %s does not exist", path);
            UIUtils.showThemedToast(this, getResources().getString(R.string.apk_share_error), false);
            return;
        }
        // Get a URI for the file to be shared via the FileProvider API
        Uri uri;
        try {
            uri = CompatHelper.getCompat().getExportUri(DeckPicker.this, attachment);
        } catch (IllegalArgumentException e) {
            Timber.e("Could not generate a valid URI for the apkg file");
            UIUtils.showThemedToast(this, getResources().getString(R.string.apk_share_error), false);
            return;
        }
        Intent shareIntent = ShareCompat.IntentBuilder.from(DeckPicker.this)
                .setType("application/apkg")
                .setStream(uri)
                .setSubject(getString(R.string.export_email_subject, attachment.getName()))
                .setHtmlText(getString(R.string.export_email_text))
                .getIntent();
        if (shareIntent.resolveActivity(getPackageManager()) != null) {
            startActivityWithoutAnimation(shareIntent);
        } else {
            Timber.e("Could not find appropriate application to share apkg with");
            UIUtils.showThemedToast(this, getResources().getString(R.string.apk_share_error), false);
        }
    }


    /**
     * Load a new studyOptionsFragment. If withDeckOptions is true, the deck options activity will
     * be loaded on top of it. Use this flag when creating a new filtered deck to allow the user to
     * modify the filter settings before being shown the fragment. The fragment itself will handle
     * rebuilding the deck if the settings change.
     */
    private void loadStudyOptionsFragment(boolean withDeckOptions) {
        StudyOptionsFragment details = StudyOptionsFragment.newInstance(withDeckOptions);
        FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
        ft.replace(R.id.studyoptions_fragment, details);
        ft.commit();
    }


    public StudyOptionsFragment getFragment() {
        Fragment frag = getSupportFragmentManager().findFragmentById(R.id.studyoptions_fragment);
        if (frag != null && (frag instanceof StudyOptionsFragment)) {
            return (StudyOptionsFragment) frag;
        }
        return null;
    }


    /**
     * Show a message when the SD card is ejected
     */
    private void registerExternalStorageListener() {
        if (mUnmountReceiver == null) {
            mUnmountReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    if (intent.getAction().equals(SdCardReceiver.MEDIA_EJECT)) {
                        onSdCardNotMounted();
                    } else if (intent.getAction().equals(SdCardReceiver.MEDIA_MOUNT)) {
                        restartActivity();
                    }
                }
            };
            IntentFilter iFilter = new IntentFilter();
            iFilter.addAction(SdCardReceiver.MEDIA_EJECT);
            iFilter.addAction(SdCardReceiver.MEDIA_MOUNT);
            registerReceiver(mUnmountReceiver, iFilter);
        }
    }


    public void addSharedDeck() {
        openUrl(Uri.parse(getResources().getString(R.string.shared_decks_url)));
    }


    private void openStudyOptions(boolean withDeckOptions) {
        if (mFragmented) {
            // The fragment will show the study options screen instead of launching a new activity.
            loadStudyOptionsFragment(withDeckOptions);
        } else {
            Intent intent = new Intent();
            intent.putExtra("withDeckOptions", withDeckOptions);
            intent.setClass(this, StudyOptionsActivity.class);
            startActivityForResultWithAnimation(intent, SHOW_STUDYOPTIONS, ActivityTransitionAnimation.LEFT);
        }
    }

    @Override
    protected void openCardBrowser() {
        Intent cardBrowser = new Intent(this, CardBrowser.class);
        cardBrowser.putExtra("selectedDeck", getCol().getDecks().selected());
        long lastDeckId = AnkiDroidApp.getSharedPrefs(this).getLong("browserDeckIdFromDeckPicker", -1L);
        cardBrowser.putExtra("defaultDeckId", lastDeckId);
        startActivityForResultWithAnimation(cardBrowser, REQUEST_BROWSE_CARDS, ActivityTransitionAnimation.LEFT);
    }


    private void handleDeckSelection(long did, boolean dontSkipStudyOptions) {
        // Clear the undo history when selecting a new deck
        if (getCol().getDecks().selected() != did) {
            getCol().clearUndo();
        }
        // Select the deck
        getCol().getDecks().select(did);
        // Reset the schedule so that we get the counts for the currently selected deck
        getCol().getSched().reset();
        mFocusedDeck = did;
        // Get some info about the deck to handle special cases
        int pos = mDeckListAdapter.findDeckPosition(did);
        Sched.DeckDueTreeNode deckDueTreeNode = mDeckListAdapter.getDeckList().get(pos);
        int[] studyOptionsCounts = getCol().getSched().counts();
        // Figure out what action to take
        if (deckDueTreeNode.newCount + deckDueTreeNode.lrnCount + deckDueTreeNode.revCount > 0) {
            // If there are cards to study then either go to Reviewer or StudyOptions
            if (mFragmented || dontSkipStudyOptions) {
                // Go to StudyOptions screen when tablet or deck counts area was clicked
                openStudyOptions(false);
            } else {
                // Otherwise jump straight to the reviewer
                openReviewer();
            }
        } else if (studyOptionsCounts[0] + studyOptionsCounts[1] + studyOptionsCounts[2] > 0) {
            // If there are cards due that can't be studied yet (due to the learn ahead limit) then go to study options
            openStudyOptions(false);
        } else if (getCol().getSched().newDue() || getCol().getSched().revDue()) {
            // If there are no cards to review because of the daily study limit then give "Study more" option
            UIUtils.showSnackbar(this, R.string.studyoptions_limit_reached, false, R.string.study_more, new OnClickListener() {
                @Override
                public void onClick(View v) {
                    CustomStudyDialog d = CustomStudyDialog.newInstance(
                            CustomStudyDialog.CONTEXT_MENU_LIMITS,
                            getCol().getDecks().selected(), true);
                    showDialogFragment(d);
                }
            }, findViewById(R.id.root_layout), mSnackbarShowHideCallback);
            // Check if we need to update the fragment or update the deck list. The same checks
            // are required for all snackbars below.
            if (mFragmented) {
                // Tablets must always show the study options that corresponds to the current deck,
                // regardless of whether the deck is currently reviewable or not.
                openStudyOptions(false);
            } else {
                // On phones, we update the deck list to ensure the currently selected deck is
                // highlighted correctly.
                updateDeckList();
            }
        } else if (getCol().getDecks().isDyn(did)) {
            // Go to the study options screen if filtered deck with no cards to study
            openStudyOptions(false);
        } else if (deckDueTreeNode.children.size() == 0 && getCol().cardCount(new Long[]{did}) == 0) {
            // If the deck is empty and has no children then show a message saying it's empty
            final Uri helpUrl = Uri.parse(getResources().getString(R.string.link_manual_getting_started));
            mayOpenUrl(helpUrl);
            UIUtils.showSnackbar(this, R.string.empty_deck, false, R.string.help, new OnClickListener() {
                @Override
                public void onClick(View v) {
                    openUrl(helpUrl);
                }
            }, findViewById(R.id.root_layout), mSnackbarShowHideCallback);
            if (mFragmented) {
                openStudyOptions(false);
            } else {
                updateDeckList();
            }
        } else {
            // Otherwise say there are no cards scheduled to study, and give option to do custom study
            UIUtils.showSnackbar(this, R.string.studyoptions_empty_schedule, false, R.string.custom_study, new OnClickListener() {
                @Override
                public void onClick(View v) {
                    CustomStudyDialog d = CustomStudyDialog.newInstance(
                            CustomStudyDialog.CONTEXT_MENU_EMPTY_SCHEDULE,
                            getCol().getDecks().selected(), true);
                    showDialogFragment(d);
                }
            }, findViewById(R.id.root_layout), mSnackbarShowHideCallback);
            if (mFragmented) {
                openStudyOptions(false);
            } else {
                updateDeckList();
            }
        }
    }


    /**
     * Scroll the deck list so that it is centered on the current deck.
     *
     * @param did The deck ID of the deck to select.
     */
    private void scrollDecklistToDeck(long did) {
        int position = mDeckListAdapter.findDeckPosition(did);
        mRecyclerViewLayoutManager.scrollToPositionWithOffset(position, (mRecyclerView.getHeight() / 2));
    }


    /**
     * Launch an asynchronous task to rebuild the deck list and recalculate the deck counts. Use this
     * after any change to a deck (e.g., rename, collapse, add/delete) that needs to be reflected
     * in the deck list.
     *
     * This method also triggers an update for the widget to reflect the newly calculated counts.
     */
    private void updateDeckList() {
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK_COUNTS, new DeckTask.TaskListener() {

            @Override
            public void onPreExecute() {
                if (!colIsOpen()) {
                    showProgressBar();
                }
                Timber.d("Refreshing deck list");
            }

            @Override
            public void onPostExecute(TaskData result) {
                hideProgressBar();
                // Make sure the fragment is visible
                if (mFragmented) {
                    mStudyoptionsFrame.setVisibility(View.VISIBLE);
                }
                if (result == null) {
                    Timber.e("null result loading deck counts");
                    onCollectionLoadError();
                    return;
                }
                List<Sched.DeckDueTreeNode> nodes = (List<Sched.DeckDueTreeNode>) result.getObjArray()[0];
                mDeckListAdapter.buildDeckList(nodes, getCol());

                // Set the "x due in y minutes" subtitle
                try {
                    int eta = mDeckListAdapter.getEta();
                    int due = mDeckListAdapter.getDue();
                    Resources res = getResources();
                    if (getCol().cardCount() != -1) {
                        String time = "-";
                        if (eta != -1) {
                            time = res.getString(R.string.time_quantity_minutes, eta);
                        }
                        if (getSupportActionBar() != null) {
                            getSupportActionBar().setSubtitle(res.getQuantityString(R.plurals.deckpicker_title, due, due, time));
                        }
                    }
                } catch (RuntimeException e) {
                    Timber.e(e, "RuntimeException setting time remaining");
                }

                long current = getCol().getDecks().current().optLong("id");
                if (mFocusedDeck != current) {
                    scrollDecklistToDeck(current);
                    mFocusedDeck = current;
                }

                // Update the mini statistics bar as well
                AnkiStatsTaskHandler.createReviewSummaryStatistics(getCol(), mReviewSummaryTextView);
            }

            @Override
            public void onProgressUpdate(TaskData... values) {
            }

            @Override
            public void onCancelled() {
            }

        });
    }


    // Callback to show study options for currently selected deck
    public void showContextMenuDeckOptions() {
        // open deck options
        if (getCol().getDecks().isDyn(mContextMenuDid)) {
            // open cram options if filtered deck
            Intent i = new Intent(DeckPicker.this, FilteredDeckOptions.class);
            i.putExtra("did", mContextMenuDid);
            startActivityWithAnimation(i, ActivityTransitionAnimation.FADE);
        } else {
            // otherwise open regular options
            Intent i = new Intent(DeckPicker.this, DeckOptions.class);
            i.putExtra("did", mContextMenuDid);
            startActivityWithAnimation(i, ActivityTransitionAnimation.FADE);
        }
    }


    // Callback to show export dialog for currently selected deck
    public void showContextMenuExportDialog() {
        exportDeck(mContextMenuDid);
    }
    public void exportDeck(long did) {
        String msg;
        try {
            msg = getResources().getString(R.string.confirm_apkg_export_deck, getCol().getDecks().get(did).get("name"));
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        showDialogFragment(ExportDialog.newInstance(msg, did));
    }


    // Callback to show dialog to rename the current deck
    public void renameDeckDialog() {
        renameDeckDialog(mContextMenuDid);
    }

    public void renameDeckDialog(final long did) {
        final Resources res = getResources();
        mDialogEditText = new EditText(DeckPicker.this);
        mDialogEditText.setSingleLine();
        final String currentName = getCol().getDecks().name(did);
        mDialogEditText.setText(currentName);
        mDialogEditText.setSelection(mDialogEditText.getText().length());
        new MaterialDialog.Builder(DeckPicker.this)
                .title(res.getString(R.string.rename_deck))
                .customView(mDialogEditText, true)
                .positiveText(res.getString(R.string.rename))
                .negativeText(res.getString(R.string.dialog_cancel))
                .callback(new MaterialDialog.ButtonCallback() {
                    @Override
                    public void onPositive(MaterialDialog dialog) {
                        String newName = mDialogEditText.getText().toString().replaceAll("\"", "");
                        Collection col = getCol();
                        if (!TextUtils.isEmpty(newName) && !newName.equals(currentName)) {
                            try {
                                col.getDecks().rename(col.getDecks().get(did), newName);
                            } catch (DeckRenameException e) {
                                // We get a localized string from libanki to explain the error
                                UIUtils.showThemedToast(DeckPicker.this, e.getLocalizedMessage(res), false);
                            }
                        }
                        dismissAllDialogFragments();
                        mDeckListAdapter.notifyDataSetChanged();
                        updateDeckList();
                        if (mFragmented) {
                            loadStudyOptionsFragment(false);
                        }
                    }

                    @Override
                    public void onNegative(MaterialDialog dialog) {
                        dismissAllDialogFragments();
                    }
                })
                .build().show();
    }


    // Callback to show confirm deck deletion dialog before deleting currently selected deck
    public void confirmDeckDeletion() {
        confirmDeckDeletion(mContextMenuDid);
    }

    public void confirmDeckDeletion(long did) {
        Resources res = getResources();
        if (!colIsOpen()) {
            return;
        }
        if (did == 1) {
            UIUtils.showSimpleSnackbar(this, R.string.delete_deck_default_deck, true);
            dismissAllDialogFragments();
            return;
        }
        // Get the number of cards contained in this deck and its subdecks
        TreeMap<String, Long> children = getCol().getDecks().children(did);
        long[] dids = new long[children.size() + 1];
        dids[0] = did;
        int i = 1;
        for (Long l : children.values()) {
            dids[i++] = l;
        }
        String ids = Utils.ids2str(dids);
        int cnt = getCol().getDb().queryScalar(
                "select count() from cards where did in " + ids + " or odid in " + ids);
        // Delete empty decks without warning
        if (cnt == 0) {
            deleteDeck(did);
            dismissAllDialogFragments();
            return;
        }
        // Otherwise we show a warning and require confirmation
        String msg;
        String deckName = "\'" + getCol().getDecks().name(did) + "\'";
        boolean isDyn = getCol().getDecks().isDyn(did);
        if (isDyn) {
            msg = res.getString(R.string.delete_cram_deck_message, deckName);
        } else {
            msg = res.getQuantityString(R.plurals.delete_deck_message, cnt, deckName, cnt);
        }
        showDialogFragment(DeckPickerConfirmDeleteDeckDialog.newInstance(msg));
    }


    // Callback to delete currently selected deck
    public void deleteContextMenuDeck() {
        deleteDeck(mContextMenuDid);
    }
    public void deleteDeck(final long did) {
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DELETE_DECK, new DeckTask.TaskListener() {
            // Flag to indicate if the deck being deleted is the current deck.
            private boolean removingCurrent;

            @Override
            public void onPreExecute() {
                mProgressDialog = StyledProgressDialog.show(DeckPicker.this, "",
                        getResources().getString(R.string.delete_deck), false);
                if (did == getCol().getDecks().current().optLong("id")) {
                    removingCurrent = true;
                }
            }


            @SuppressWarnings("unchecked")
            @Override
            public void onPostExecute(TaskData result) {
                if (result == null) {
                    return;
                }
                // In fragmented mode, if the deleted deck was the current deck, we need to reload
                // the study options fragment with a valid deck and re-center the deck list to the
                // new current deck. Otherwise we just update the list normally.
                if (mFragmented && removingCurrent) {
                    updateDeckList();
                    openStudyOptions(false);
                } else {
                    updateDeckList();
                }

                if (mProgressDialog != null && mProgressDialog.isShowing()) {
                    try {
                        mProgressDialog.dismiss();
                    } catch (Exception e) {
                        Timber.e(e, "onPostExecute - Exception dismissing dialog");
                    }
                }
                // TODO: if we had "undo delete note" like desktop client then we won't need this.
                getCol().clearUndo();
            }


            @Override
            public void onProgressUpdate(TaskData... values) {
            }


            @Override
            public void onCancelled() {
            }
        }, new TaskData(did));
    }

    /**
     * Show progress bars and rebuild deck list on completion
     */
    DeckTask.TaskListener mSimpleProgressListener = new DeckTask.TaskListener() {

        @Override
        public void onPreExecute() {
            showProgressBar();
        }


        @Override
        public void onPostExecute(DeckTask.TaskData result) {
            updateDeckList();
            if (mFragmented) {
                loadStudyOptionsFragment(false);
            }
        }


        @Override
        public void onProgressUpdate(TaskData... values) {
        }


        @Override
        public void onCancelled() {
        }
    };

    public void rebuildFiltered() {
        getCol().getDecks().select(mContextMenuDid);
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REBUILD_CRAM, mSimpleProgressListener,
                new DeckTask.TaskData(mFragmented));
    }

    public void emptyFiltered() {
        getCol().getDecks().select(mContextMenuDid);
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_EMPTY_CRAM, mSimpleProgressListener,
                new DeckTask.TaskData(mFragmented));
    }

    @Override
    public void onAttachedToWindow() {

        if (!mFragmented) {
            Window window = getWindow();
            window.setFormat(PixelFormat.RGBA_8888);
        }
    }


    @Override
    public void onRequireDeckListUpdate() {
        updateDeckList();
    }


    private void openReviewer() {
        Intent reviewer = new Intent(this, Reviewer.class);
        startActivityForResultWithAnimation(reviewer, REQUEST_REVIEW, ActivityTransitionAnimation.LEFT);
        getCol().startTimebox();
    }

    @Override
    public void onCreateCustomStudySession() {
        updateDeckList();
        openStudyOptions(false);
    }

    @Override
    public void onExtendStudyLimits() {
        if (mFragmented) {
            getFragment().refreshInterface(true);
        }
        updateDeckList();
    }

    /**
     * FAB can't be animated to move out of the way of the snackbar button on API < 11
     */
    Snackbar.Callback mSnackbarShowHideCallback = new Snackbar.Callback() {
        @Override
        public void onDismissed(Snackbar snackbar, int event) {
            if (!CompatHelper.isHoneycomb()) {
                final android.support.design.widget.FloatingActionButton b;
                b = (android.support.design.widget.FloatingActionButton) findViewById(R.id.add_note_action);
                b.setEnabled(true);
            }
        }

        @Override
        public void onShown(Snackbar snackbar) {
            if (!CompatHelper.isHoneycomb()) {
                final android.support.design.widget.FloatingActionButton b;
                b = (android.support.design.widget.FloatingActionButton) findViewById(R.id.add_note_action);
                b.setEnabled(false);
            }
        }
    };

    public void handleEmptyCards() {
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_FIND_EMPTY_CARDS, new DeckTask.Listener() {
            @Override
            public void onPreExecute(DeckTask task) {
                mProgressDialog = StyledProgressDialog.show(DeckPicker.this, "",
                        getResources().getString(R.string.emtpy_cards_finding), false);
            }

            @Override
            public void onPostExecute(DeckTask task, TaskData result) {
                final List<Long> cids = (List<Long>) result.getObjArray()[0];
                if (cids.size() == 0) {
                    showSimpleMessageDialog(getResources().getString(R.string.empty_cards_none));
                } else {
                    String msg = String.format(getResources().getString(R.string.empty_cards_count), cids.size());
                    ConfirmationDialog dialog = new ConfirmationDialog();
                    dialog.setArgs(msg);
                    Runnable confirm = new Runnable() {
                        @Override
                        public void run() {
                            getCol().remCards(Utils.arrayList2array(cids));
                            UIUtils.showSimpleSnackbar(DeckPicker.this, String.format(
                                    getResources().getString(R.string.empty_cards_deleted), cids.size()), false);
                        }
                    };
                    dialog.setConfirm(confirm);
                    showDialogFragment(dialog);
                }

                if (mProgressDialog != null && mProgressDialog.isShowing()) {
                    mProgressDialog.dismiss();
                }
            }

            @Override
            public void onProgressUpdate(DeckTask task, TaskData... values) {

            }

            @Override
            public void onCancelled() {

            }
        });
    }
}

package com.ichi2.anki;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.util.AttributeSet;
import android.widget.EditText;
import android.widget.TextView;

import com.ichi2.themes.Themes;


public class FieldEditText extends EditText {

    public static final String NEW_LINE = System.getProperty("line.separator");
    public static final String NL_MARK = "newLineMark";

    private String mName;
    private int mOrd;
    private Drawable mOrigBackground;


    public FieldEditText(Context context) {
        super(context);
    }


    public FieldEditText(Context context, AttributeSet attr) {
        super(context, attr);
    }


    public FieldEditText(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }


    public FieldEditText(Context context, int ord, String name, String content) {
        super(context);
        init(ord, name, content);
    }


    public TextView getLabel() {
        TextView label = new TextView(this.getContext());
        label.setText(mName);
        return label;
    }


    public int getOrd() {
        return mOrd;
    }


    public String getName() {
        return mName;
    }


    public void init(int ord, String name, String content) {
        mOrd = ord;
        mName = name;

        if (content == null) {
            content = "";
        } else {
            content = content.replaceAll("<br(\\s*\\/*)>", NEW_LINE);
        }
        setText(content);
        setContentDescription(name);
        setMinimumWidth(400);
        mOrigBackground = getBackground();
        // Fixes bug where new instances of this object have wrong colors, probably
        // from some reuse mechanic in Android.
        setDefaultStyle();
    }

    /**
     * Modify the style of this view to represent a duplicate field.
     */
    public void setDupeStyle() {
        setBackgroundColor(Themes.getColorFromAttr(getContext(), R.attr.duplicateColor));
    }


    /**
     * Restore the default style of this view.
     */
    public void setDefaultStyle() {
        setBackgroundDrawable(mOrigBackground);
    }
}

package com.ichi2.anki;

/****************************************************************************************
 * Copyright (c) 2009 Casey Link <unnamedrambler@gmail.com>                             *
 * Copyright (c) 2012 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

import android.content.BroadcastReceiver;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.EditTextPreference;
import android.preference.ListPreference;
import android.preference.Preference;
import android.view.KeyEvent;
import android.view.MenuItem;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.receiver.SdCardReceiver;
import com.ichi2.libanki.Collection;
import com.ichi2.preferences.StepsPreference;
import com.ichi2.themes.Themes;
import com.ichi2.ui.AppCompatPreferenceActivity;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import timber.log.Timber;

/**
 * Preferences for the current deck.
 */
public class FilteredDeckOptions extends AppCompatPreferenceActivity implements OnSharedPreferenceChangeListener {

    private JSONObject mDeck;
    private Collection mCol;
    private boolean mAllowCommit = true;
    private boolean mPrefChanged = false;

    private BroadcastReceiver mUnmountReceiver = null;

    // TODO: not anymore used in libanki?
    private String[] dynExamples = new String[] { null,
            "{'search'=\"is:new\", 'resched'=False, 'steps'=\"1\", 'order'=5}",
            "{'search'=\"added:1\", 'resched'=False, 'steps'=\"1\", 'order'=5}",
            "{'search'=\"rated:1:1\", 'order'=4}",
            "{'search'=\"prop:due<=2\", 'order'=6}",
            "{'search'=\"is:due tag:TAG\", 'order'=6}",
            "{'search'=\"is:due\", 'order'=3}",
            "{'search'=\"\", 'steps'=\"1 10 20\", 'order'=0}" };

    public class DeckPreferenceHack implements SharedPreferences {

        private Map<String, String> mValues = new HashMap<>();
        private Map<String, String> mSummaries = new HashMap<>();


        public DeckPreferenceHack() {
            this.cacheValues();
        }


        protected void cacheValues() {
            Timber.d("cacheValues()");

            try {
                JSONArray ar = mDeck.getJSONArray("terms").getJSONArray(0);
                mValues.put("search", ar.getString(0));
                mValues.put("limit", ar.getString(1));
                mValues.put("order", ar.getString(2));
                JSONArray delays = mDeck.optJSONArray("delays");
                if (delays != null) {
                    mValues.put("steps", StepsPreference.convertFromJSON(delays));
                    mValues.put("stepsOn", Boolean.toString(true));
                } else {
                    mValues.put("steps", "1 10");
                    mValues.put("stepsOn", Boolean.toString(false));
                }
                mValues.put("resched", Boolean.toString(mDeck.getBoolean("resched")));
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }

        public class Editor implements SharedPreferences.Editor {

            private ContentValues mUpdate = new ContentValues();


            @Override
            public SharedPreferences.Editor clear() {
                Timber.d("clear()");
                mUpdate = new ContentValues();
                return this;
            }


            @Override
            public boolean commit() {
                Timber.d("commit() changes back to database");

                try {
                    for (Entry<String, Object> entry : mUpdate.valueSet()) {
                        Timber.i("Change value for key '" + entry.getKey() + "': " + entry.getValue());
                        if (entry.getKey().equals("search")) {
                            JSONArray ar = mDeck.getJSONArray("terms");
                            ar.getJSONArray(0).put(0, entry.getValue());
                            mDeck.put("terms", ar);
                        } else if (entry.getKey().equals("limit")) {
                            JSONArray ar = mDeck.getJSONArray("terms");
                            ar.getJSONArray(0).put(1, entry.getValue());
                            mDeck.put("terms", ar);
                        } else if (entry.getKey().equals("order")) {
                            JSONArray ar = mDeck.getJSONArray("terms");
                            ar.getJSONArray(0).put(2, Integer.parseInt((String) entry.getValue()));
                            mDeck.put("terms", ar);
                        } else if (entry.getKey().equals("resched")) {
                            mDeck.put("resched", entry.getValue());
                        } else if (entry.getKey().equals("stepsOn")) {
                            boolean on = (Boolean) entry.getValue();
                            if (on) {
                                JSONArray steps =  StepsPreference.convertToJSON(mValues.get("steps"));
                                if (steps.length() > 0) {
                                    mDeck.put("delays", steps);
                                }
                            } else {
                                mDeck.put("delays", JSONObject.NULL);
                            }
                        } else if (entry.getKey().equals("steps")) {
                            mDeck.put("delays", StepsPreference.convertToJSON((String) entry.getValue()));
                        } else if (entry.getKey().equals("preset")) {
                            int i = Integer.parseInt((String) entry.getValue());
                            if (i > 0) {
                                JSONObject presetValues = new JSONObject(dynExamples[i]);
                                JSONArray ar = presetValues.names();
                                for (int j = 0; j < ar.length(); j++) {
                                    String name = ar.getString(j);
                                    if (name.equals("steps")) {
                                        mUpdate.put("stepsOn", true);
                                    }
                                    if (name.equals("resched")) {
                                        mUpdate.put(name, presetValues.getBoolean(name));
                                        mValues.put(name, Boolean.toString(presetValues.getBoolean(name)));
                                    } else {
                                        mUpdate.put(name, presetValues.getString(name));
                                        mValues.put(name, presetValues.getString(name));
                                    }
                                }
                                mUpdate.put("preset", "0");
                                commit();
                            }
                        }
                    }
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }

                // save deck
                try {
                    mCol.getDecks().save(mDeck);
                } catch (RuntimeException e) {
                    Timber.e(e, "RuntimeException on saving deck");
                    AnkiDroidApp.sendExceptionReport(e, "FilteredDeckOptionsSaveDeck");
                    setResult(DeckPicker.RESULT_DB_ERROR);
                    finish();
                }

                // make sure we refresh the parent cached values
                cacheValues();
                updateSummaries();

                // and update any listeners
                for (OnSharedPreferenceChangeListener listener : listeners) {
                    listener.onSharedPreferenceChanged(DeckPreferenceHack.this, null);
                }

                return true;
            }


            @Override
            public SharedPreferences.Editor putBoolean(String key, boolean value) {
                mUpdate.put(key, value);
                return this;
            }


            @Override
            public SharedPreferences.Editor putFloat(String key, float value) {
                mUpdate.put(key, value);
                return this;
            }


            @Override
            public SharedPreferences.Editor putInt(String key, int value) {
                mUpdate.put(key, value);
                return this;
            }


            @Override
            public SharedPreferences.Editor putLong(String key, long value) {
                mUpdate.put(key, value);
                return this;
            }


            @Override
            public SharedPreferences.Editor putString(String key, String value) {
                mUpdate.put(key, value);
                return this;
            }


            @Override
            public SharedPreferences.Editor remove(String key) {
                Timber.d("Editor.remove(key=%s)", key);
                mUpdate.remove(key);
                return this;
            }


            public void apply() {
                if (mAllowCommit) {
                    commit();
                }
            }


            // @Override On Android 1.5 this is not Override
            public android.content.SharedPreferences.Editor putStringSet(String arg0, Set<String> arg1) {
                // TODO Auto-generated method stub
                return null;
            }

        }


        @Override
        public boolean contains(String key) {
            return mValues.containsKey(key);
        }


        @Override
        public Editor edit() {
            return new Editor();
        }


        @Override
        public Map<String, ?> getAll() {
            return mValues;
        }


        @Override
        public boolean getBoolean(String key, boolean defValue) {
            return Boolean.valueOf(this.getString(key, Boolean.toString(defValue)));
        }


        @Override
        public float getFloat(String key, float defValue) {
            return Float.valueOf(this.getString(key, Float.toString(defValue)));
        }


        @Override
        public int getInt(String key, int defValue) {
            return Integer.valueOf(this.getString(key, Integer.toString(defValue)));
        }


        @Override
        public long getLong(String key, long defValue) {
            return Long.valueOf(this.getString(key, Long.toString(defValue)));
        }


        @Override
        public String getString(String key, String defValue) {
            Timber.d("getString(key=%s, defValue=%s)", key, defValue);
            if (!mValues.containsKey(key)) {
                return defValue;
            }
            return mValues.get(key);
        }

        public List<OnSharedPreferenceChangeListener> listeners = new LinkedList<>();


        @Override
        public void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {
            listeners.add(listener);
        }


        @Override
        public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {
            listeners.remove(listener);
        }


        // @Override On Android 1.5 this is not Override
        public Set<String> getStringSet(String arg0, Set<String> arg1) {
            // TODO Auto-generated method stub
            return null;
        }

    }

    private DeckPreferenceHack mPref;


    @Override
    public SharedPreferences getSharedPreferences(String name, int mode) {
        Timber.d("getSharedPreferences(name=%s)", name);
        return mPref;
    }


    @Override
    protected void onCreate(Bundle icicle) {
        Themes.setThemeLegacy(this);
        super.onCreate(icicle);

        mCol = CollectionHelper.getInstance().getCol(this);
        if (mCol == null) {
            finish();
            return;
        }
        Bundle extras = getIntent().getExtras();
        if (extras != null && extras.containsKey("did")) {
            mDeck = mCol.getDecks().get(extras.getLong("did"));
        } else {
            mDeck = mCol.getDecks().current();
        }

        registerExternalStorageListener();

        try {
            if (mCol == null || mDeck.getInt("dyn") != 1) {
                Timber.w("No Collection loaded or deck is not a dyn deck");
                finish();
                return;
            } else {
                mPref = new DeckPreferenceHack();
                mPref.registerOnSharedPreferenceChangeListener(this);

                this.addPreferencesFromResource(R.xml.cram_deck_options);
                this.buildLists();
                this.updateSummaries();
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        
        // Set the activity title to include the name of the deck
        String title = getResources().getString(R.string.deckpreferences_title);
        if (title.contains("XXX")) {
            try {
                title = title.replace("XXX", mDeck.getString("name"));
            } catch (JSONException e) {
                title = title.replace("XXX", "???");
            }
        }
        this.setTitle(title);

        // Add a home button to the actionbar
        getSupportActionBar().setHomeButtonEnabled(true);
        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                closeDeckOptions();
                return true;
        }
        return false;
    }


    @Override
    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
        // update values on changed preference
        this.updateSummaries();
        mPrefChanged = true;
    }


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
            Timber.i("DeckOptions - onBackPressed()");
            closeDeckOptions();
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }

    private void closeDeckOptions() {
        if (mPrefChanged) {
            // Rebuild the filtered deck if a setting has changed
            mCol.getSched().rebuildDyn(mCol.getDecks().selected());
        }
        finish();
        ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.FADE);
    }


    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mUnmountReceiver != null) {
            unregisterReceiver(mUnmountReceiver);
        }
    }


    protected void updateSummaries() {
        mAllowCommit = false;
        // for all text preferences, set summary as current database value
        for (String key : mPref.mValues.keySet()) {
            Preference pref = this.findPreference(key);
            String value = null;
            if (pref == null) {
                continue;
            } else if (pref instanceof CheckBoxPreference) {
                continue;
            } else if (pref instanceof ListPreference) {
                ListPreference lp = (ListPreference) pref;
                CharSequence entry = lp.getEntry();
                if (entry != null) {
                    value = entry.toString();
                } else {
                    value = "";
                }
            } else {
                value = this.mPref.getString(key, "");
            }
            // update value for EditTexts
            if (pref instanceof EditTextPreference) {
                ((EditTextPreference) pref).setText(value);
            }
            // update summary
            if (!mPref.mSummaries.containsKey(key)) {
                CharSequence s = pref.getSummary();
                mPref.mSummaries.put(key, s != null ? pref.getSummary().toString() : null);
            }
            String summ = mPref.mSummaries.get(key);
            if (summ != null && summ.contains("XXX")) {
                pref.setSummary(summ.replace("XXX", value));
            } else {
                pref.setSummary(value);
            }
        }
        mAllowCommit = true;
    }


    protected void buildLists() {
        ListPreference newOrderPref = (ListPreference) findPreference("order");
        newOrderPref.setEntries(R.array.cram_deck_conf_order_labels);
        newOrderPref.setEntryValues(R.array.cram_deck_conf_order_values);
        newOrderPref.setValue(mPref.getString("order", "0"));
    }

    /**
     * finish when sd card is ejected
     */
    private void registerExternalStorageListener() {
        if (mUnmountReceiver == null) {
            mUnmountReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    if (intent.getAction().equals(SdCardReceiver.MEDIA_EJECT)) {
                        finish();
                    }
                }
            };
            IntentFilter iFilter = new IntentFilter();
            iFilter.addAction(SdCardReceiver.MEDIA_EJECT);
            registerReceiver(mUnmountReceiver, iFilter);
        }
    }

}
/***************************************************************************************
 * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 * Copyright (c) 2015 Tim Rae <perceptualchaos2@gmail.com>                              *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.Context;
import android.content.Intent;
import android.content.res.Resources;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.support.v7.widget.Toolbar;
import android.text.ClipboardManager;
import android.util.TypedValue;
import android.view.KeyEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.webkit.WebChromeClient;
import android.webkit.WebView;
import android.widget.Button;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.compat.CompatHelper;
import com.ichi2.utils.VersionUtils;

import org.acra.util.Installation;

import timber.log.Timber;

/**
 * Shows an about box, which is a small HTML page.
 */

public class Info extends AnkiActivity {

    public static final String TYPE_EXTRA = "infoType";

    public static final int TYPE_ABOUT = 0;
    public static final int TYPE_NEW_VERSION = 2;

    private int mType;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Timber.d("onCreate()");
        super.onCreate(savedInstanceState);

        Resources res = getResources();
        WebView webView;

        mType = getIntent().getIntExtra(TYPE_EXTRA, TYPE_ABOUT);

        setContentView(R.layout.info);
        final View mainView = findViewById(android.R.id.content);
        Toolbar toolbar = (Toolbar) mainView.findViewById(R.id.toolbar);
        if (toolbar != null) {
            setSupportActionBar(toolbar);
        }

        setTitle(String.format("%s v%s", VersionUtils.getAppName(), VersionUtils.getPkgVersionName()));
        webView = (WebView) findViewById(R.id.info);
        webView.setWebChromeClient(new WebChromeClient() {
            public void onProgressChanged(WebView view, int progress) {
                // Hide the progress indicator when the page has finished loaded
                if (progress == 100) {
                    mainView.findViewById(R.id.progress_bar).setVisibility(View.GONE);
                }
            }
        });

        Button marketButton = (Button) findViewById(R.id.market);
        marketButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View arg0) {
                if (mType == TYPE_ABOUT) {
                    if (CompatHelper.isKindle()) {
                        Intent intent = new Intent("android.intent.action.VIEW",
                                Uri.parse("http://www.amazon.com/gp/mas/dl/android?p=com.ichi2.anki"));
                        startActivity(intent);
                    } else {
                        Info.this.startActivity(new Intent(Intent.ACTION_VIEW, Uri
                                .parse("market://details?id=com.ichi2.anki")));
                    }
                    return;
                }
                setResult(RESULT_OK);
                switch (mType) {
                    case TYPE_NEW_VERSION:
                        AnkiDroidApp.getSharedPrefs(Info.this.getBaseContext()).edit()
                                .putString("lastVersion", VersionUtils.getPkgVersionName()).commit();
                        break;
                }
                finishWithAnimation();
            }
        });

        StringBuilder sb = new StringBuilder();
        switch (mType) {
            case TYPE_ABOUT:
                String[] content = res.getStringArray(R.array.about_content);

                // Apply theme colours.
                TypedValue typedValue = new TypedValue();
                getTheme().resolveAttribute(android.R.attr.colorBackground, typedValue, true);
                webView.setBackgroundColor(typedValue.data);
                getTheme().resolveAttribute(android.R.attr.textColor, typedValue, true);
                String textColor = String.format("#%06X", (0xFFFFFF & typedValue.data)); // Color to hex string
                sb.append("<html><style>body {color:"+textColor+";}</style>");

                sb.append("<body text=\"#000000\" link=\"#E37068\" alink=\"#E37068\" vlink=\"#E37068\">");
                sb.append(
                        String.format(content[0], res.getString(R.string.app_name), res.getString(R.string.link_anki)))
                        .append("<br/><br/>");
                sb.append(
                        String.format(content[1], res.getString(R.string.link_issue_tracker),
                                res.getString(R.string.link_wiki), res.getString(R.string.link_forum))).append(
                        "<br/><br/>");
                sb.append(
                        String.format(content[2], res.getString(R.string.link_wikipedia_open_source),
                                res.getString(R.string.link_contribution))).append(" ");
                sb.append(
                        String.format(content[3], res.getString(R.string.link_translation),
                                res.getString(R.string.link_donation))).append("<br/><br/>");
                sb.append(
                        String.format(content[4], res.getString(R.string.licence_wiki),
                                res.getString(R.string.link_source))).append("<br/><br/>");
                sb.append("</body></html>");
                webView.loadDataWithBaseURL("", sb.toString(), "text/html", "utf-8", null);
                ((Button) findViewById(R.id.market)).setText(res.getString(R.string.info_rate));
                Button debugCopy = ((Button) findViewById(R.id.debug_info));
                debugCopy.setText(res.getString(R.string.feedback_copy_debug));
                debugCopy.setVisibility(View.VISIBLE);
                debugCopy.setOnClickListener(new OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        copyDebugInfo();
                    }
                });
                break;

            case TYPE_NEW_VERSION:
                getSupportActionBar().setDisplayHomeAsUpEnabled(false);
                webView.loadUrl("file:///android_asset/changelog.html");
                //webView.loadUrl("https://ankidroid.org/docs/changelog.html");
                break;

            default:
                finish();
                break;
        }
    }


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
            Timber.i("onBackPressed()");
            setResult(RESULT_CANCELED);
            finishWithAnimation();
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }


    private void finishWithAnimation() {
        finishWithAnimation(ActivityTransitionAnimation.LEFT);
    }


    /**
     * Copy debug information about the device to the clipboard
     * @return debugInfo
     */
    public String copyDebugInfo() {
        StringBuilder sb = new StringBuilder();
        // AnkiDroid Version
        sb.append("AnkiDroid Version = ").append(VersionUtils.getPkgVersionName()).append("\n\n");
        // Android SDK
        sb.append("Android Version = " + Build.VERSION.RELEASE).append("\n\n");
        // ACRA install ID
        sb.append("ACRA UUID = ").append(Installation.id(this)).append("\n");
        String debugInfo = sb.toString();
        ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
        clipboard.setText(debugInfo);
        return debugInfo;
    }
}
package com.ichi2.anki;

import android.app.Activity;
import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.os.Message;
import android.provider.OpenableColumns;
import android.support.v4.content.IntentCompat;

import com.afollestad.materialdialogs.MaterialDialog;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.dialogs.DialogHandler;
import com.ichi2.anki.services.ReminderService;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import timber.log.Timber;

/**
 * Class which handles how the application responds to different intents, forcing it to always be single task,
 * but allowing custom behavior depending on the intent
 * 
 * @author Tim
 *
 */

public class IntentHandler extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.progress_bar);
        Intent intent = getIntent();
        Timber.v(intent.toString());
        Intent reloadIntent = new Intent(this, DeckPicker.class);
        reloadIntent.setDataAndType(getIntent().getData(), getIntent().getType());
        String action = intent.getAction();
        if (Intent.ACTION_VIEW.equals(action)) {
            // This intent is used for opening apkg package files
            // We want to go immediately to DeckPicker, clearing any history in the process
            Timber.i("IntentHandler/ User requested to view a file");
            boolean successful = false;
            String errorMessage = getResources().getString(R.string.import_error_content_provider, AnkiDroidApp.getManualUrl() + "#importing");
            // If the file is being sent from a content provider we need to read the content before we can open the file
            if (intent.getData().getScheme().equals("content")) {
                // Get the original filename from the content provider URI
                String filename = null;
                Cursor cursor = null;
                try {
                    cursor = this.getContentResolver().query(intent.getData(), new String[]{OpenableColumns.DISPLAY_NAME}, null, null, null);
                    if (cursor != null && cursor.moveToFirst()) {
                        filename = cursor.getString(0);
                    }
                } finally {
                    if (cursor != null)
                        cursor.close();
                }

                // Hack to fix bug where ContentResolver not returning filename correctly
                if (filename == null) {
                    if (intent.getType().equals("application/apkg") || hasValidZipFile(intent)) {
                        // Set a dummy filename if MIME type provided or is a valid zip file
                        filename = "unknown_filename.apkg";
                        Timber.w("Could not retrieve filename from ContentProvider, but was valid zip file so we try to continue");
                    } else {
                        Timber.e("Could not retrieve filename from ContentProvider or read content as ZipFile");
                        AnkiDroidApp.sendExceptionReport(new RuntimeException("Could not import apkg from ContentProvider"), "IntentHandler.java", "apkg import failed");
                    }
                }

                if (filename != null && !filename.toLowerCase().endsWith(".apkg")) {
                    // Don't import if not apkg file
                    errorMessage = getResources().getString(R.string.import_error_not_apkg_extension, filename);
                } else if (filename != null) {
                    // Copy to temporary file
                    String tempOutDir = Uri.fromFile(new File(getCacheDir(), filename)).getEncodedPath();
                    successful = copyFileToCache(intent, tempOutDir);
                    // Show import dialog
                    if (successful) {
                        sendShowImportFileDialogMsg(tempOutDir);
                    } else {
                        AnkiDroidApp.sendExceptionReport(new RuntimeException("Error importing apkg file"), "IntentHandler.java", "apkg import failed");
                    }
                }
            } else if (intent.getData().getScheme().equals("file")) {
                // When the VIEW intent is sent as a file, we can open it directly without copying from content provider                
                String filename = intent.getData().getPath();
                if (filename != null && filename.endsWith(".apkg")) {
                    // If file has apkg extension then send message to show Import dialog
                    sendShowImportFileDialogMsg(filename);
                    successful = true;
                } else {
                    errorMessage = getResources().getString(R.string.import_error_not_apkg_extension, filename);
                }
            }
            // Start DeckPicker if we correctly processed ACTION_VIEW
            if (successful) {
                reloadIntent.setAction(action);
                reloadIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
                startActivity(reloadIntent);
                finishWithFade();
            } else {
                // Don't import the file if it didn't load properly or doesn't have apkg extension
                //Themes.showThemedToast(this, getResources().getString(R.string.import_log_no_apkg), true);
                String title = getResources().getString(R.string.import_log_no_apkg);
                new MaterialDialog.Builder(this)
                        .title(title)
                        .content(errorMessage)
                        .positiveText(getResources().getString(R.string.dialog_ok))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                finishWithFade();
                            }
                        })
                        .build().show();
            }
        } else if ("com.ichi2.anki.DO_SYNC".equals(action)) {
            sendDoSyncMsg();
            reloadIntent.setAction(action);
            reloadIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
            startActivity(reloadIntent);
            finishWithFade();
        } else if (intent.hasExtra(ReminderService.EXTRA_DECK_ID)) {
            final Intent reviewIntent = new Intent(this, Reviewer.class);

            CollectionHelper.getInstance().getCol(this).getDecks().select(intent.getLongExtra(ReminderService.EXTRA_DECK_ID, 0));
            startActivity(reviewIntent);
            finishWithFade();
        } else {
            // Launcher intents should start DeckPicker if no other task exists,
            // otherwise go to previous task
            reloadIntent.setAction(Intent.ACTION_MAIN);
            reloadIntent.addCategory(Intent.CATEGORY_LAUNCHER);
            reloadIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | IntentCompat.FLAG_ACTIVITY_CLEAR_TASK);
            startActivityIfNeeded(reloadIntent, 0);
            finishWithFade();
        }
    }


    /**
     * Send a Message to AnkiDroidApp so that the DialogMessageHandler shows the Import apkg dialog.
     * @param path path to apkg file which will be imported
     */
    private void sendShowImportFileDialogMsg(String path) {
        // Get the filename from the path
        File f = new File(path);
        String filename = f.getName();

        // Create a new message for DialogHandler so that we see the appropriate import dialog in DeckPicker
        Message handlerMessage = Message.obtain();
        Bundle msgData = new Bundle();
        msgData.putString("importPath", path);
        handlerMessage.setData(msgData);
        if (filename.equals("collection.apkg")) {
            // Show confirmation dialog asking to confirm import with replace when file called "collection.apkg"
            handlerMessage.what = DialogHandler.MSG_SHOW_COLLECTION_IMPORT_REPLACE_DIALOG;
        } else {
            // Otherwise show confirmation dialog asking to confirm import with add
            handlerMessage.what = DialogHandler.MSG_SHOW_COLLECTION_IMPORT_ADD_DIALOG;
        }
        // Store the message in AnkiDroidApp message holder, which is loaded later in AnkiActivity.onResume
        DialogHandler.storeMessage(handlerMessage);
    }

    /**
     * Send a Message to AnkiDroidApp so that the DialogMessageHandler forces a sync
     */
    private void sendDoSyncMsg() {
        // Create a new message for DialogHandler
        Message handlerMessage = Message.obtain();
        handlerMessage.what = DialogHandler.MSG_DO_SYNC;
        // Store the message in AnkiDroidApp message holder, which is loaded later in AnkiActivity.onResume
        DialogHandler.storeMessage(handlerMessage);
    }

    /** Finish Activity using FADE animation **/
    private void finishWithFade() {
    	finish();
    	ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.UP);
    }

    /**
     * Check if the InputStream is to a valid non-empty zip file
     * @param intent intent from which to get input stream
     * @return whether or not valid zip file
     */
    private boolean hasValidZipFile(Intent intent) {
        // Get an input stream to the data in ContentProvider
        InputStream in = null;
        try {
            in = getContentResolver().openInputStream(intent.getData());
        } catch (FileNotFoundException e) {
            Timber.e(e, "Could not open input stream to intent data");
        }
        // Make sure it's not null
        if (in == null) {
            Timber.e("Could not open input stream to intent data");
            return false;
        }
        // Open zip input stream
        ZipInputStream zis = new ZipInputStream(in);
        boolean ok = false;
        try {
            try {
                ZipEntry ze = zis.getNextEntry();
                if (ze != null) {
                    // set ok flag to true if there are any valid entries in the zip file
                    ok = true;
                }
            } catch (IOException e) {
                // don't set ok flag
                Timber.d(e, "Error checking if provided file has a zip entry");
            }
        } finally {
            // close the input streams
            try {
                zis.close();
                in.close();
            } catch (Exception e) {
                Timber.d(e, "Error closing the InputStream");
            }
        }
        return ok;
    }


    /**
     * Copy the data from the intent to a temporary file
     * @param intent intent from which to get input stream
     * @param tempPath temporary path to store the cached file
     * @return whether or not copy was successful
     */
    private boolean copyFileToCache(Intent intent, String tempPath) {
        // Get an input stream to the data in ContentProvider
        InputStream in;
        try {
            in = getContentResolver().openInputStream(intent.getData());
        } catch (FileNotFoundException e) {
            Timber.e(e, "Could not open input stream to intent data");
            return false;
        }
        // Check non-null
        if (in == null) {
            return false;
        }
        // Create new output stream in temporary path
        OutputStream out;
        try {
            out = new FileOutputStream(tempPath);
        } catch (FileNotFoundException e) {
            Timber.e(e, "Could not access destination file %s", tempPath);
            return false;
        }

        try {
            // Copy the input stream to temporary file
            byte[] buf = new byte[1024];
            int len;
            while ((len = in.read(buf)) > 0) {
                out.write(buf, 0, len);
            }
            in.close();
        } catch (IOException e) {
            Timber.e(e, "Could not copy file to %s", tempPath);
            return false;
        } finally {
            try {
                out.close();
            } catch (IOException e) {
                Timber.e(e, "Error closing tempOutDir %s", tempPath);
            }
        }
        return true;
    }
}
package com.ichi2.anki;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.Uri;
import android.view.View;

import com.afollestad.materialdialogs.MaterialDialog;

import com.ichi2.libanki.Utils;

import timber.log.Timber;

public class Lookup {

    /**
     * Searches
     */
    private static final int DICTIONARY_NONE = 0;    // use no dictionary
    private static final int DICTIONARY_AEDICT = 1;  // Japanese dictionary
    private static final int DICTIONARY_EIJIRO_WEB = 2; // japanese web dictionary
    private static final int DICTIONARY_LEO_WEB = 3; // German web dictionary for English, French, Spanish, Italian,
                                                     // Chinese, Russian
    private static final int DICTIONARY_LEO_APP = 4; // German web dictionary for English, French, Spanish, Italian,
                                                     // Chinese, Russian
    private static final int DICTIONARY_COLORDICT = 5;
    private static final int DICTIONARY_FORA = 6;
    private static final int DICTIONARY_NCIKU_WEB = 7; // chinese web dictionary

    private static Context mContext;
    private static boolean mIsDictionaryAvailable;
    private static String mDictionaryAction;
    private static int mDictionary;
    private static String mLookupText;


    public static boolean initialize(Context context) {
        mContext = context;
        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext());
        mDictionary = Integer.parseInt(preferences.getString("dictionary", Integer.toString(DICTIONARY_NONE)));
        switch (mDictionary) {
            case DICTIONARY_NONE:
                mIsDictionaryAvailable = false;
                break;
            case DICTIONARY_AEDICT:
                mDictionaryAction = "sk.baka.aedict.action.ACTION_SEARCH_EDICT";
                mIsDictionaryAvailable = Utils.isIntentAvailable(mContext, mDictionaryAction);
                break;
            case DICTIONARY_LEO_WEB:
            case DICTIONARY_NCIKU_WEB:
            case DICTIONARY_EIJIRO_WEB:
                mDictionaryAction = "android.intent.action.VIEW";
                mIsDictionaryAvailable = Utils.isIntentAvailable(mContext, mDictionaryAction);
                break;
            case DICTIONARY_LEO_APP:
                mDictionaryAction = "android.intent.action.SEND";
                mIsDictionaryAvailable = Utils.isIntentAvailable(mContext, mDictionaryAction, new ComponentName(
                        "org.leo.android.dict", "org.leo.android.dict.LeoDict"));
                break;
            case DICTIONARY_COLORDICT:
                mDictionaryAction = "colordict.intent.action.SEARCH";
                mIsDictionaryAvailable = Utils.isIntentAvailable(mContext, mDictionaryAction);
                break;
            case DICTIONARY_FORA:
                mDictionaryAction = "com.ngc.fora.action.LOOKUP";
                mIsDictionaryAvailable = Utils.isIntentAvailable(mContext, mDictionaryAction);
                break;
            default:
                mIsDictionaryAvailable = false;
                break;
        }
        Timber.v("Is intent available = %b", mIsDictionaryAvailable);
        return mIsDictionaryAvailable;
    }


    public static boolean lookUp(String text) {
        if (!mIsDictionaryAvailable) {
            return false;
        }
        // clear text from leading and closing dots, commas, brackets etc.
        text = text.trim().replaceAll("[,;:\\s\\(\\[\\)\\]\\.]*$", "").replaceAll("^[,;:\\s\\(\\[\\)\\]\\.]*", "");
        switch (mDictionary) {
            case DICTIONARY_NONE:
                return false;
            case DICTIONARY_AEDICT:
                Intent aedictSearchIntent = new Intent(mDictionaryAction);
                aedictSearchIntent.putExtra("kanjis", text);
                mContext.startActivity(aedictSearchIntent);
                return true;
            case DICTIONARY_LEO_WEB:
            case DICTIONARY_LEO_APP:
                mLookupText = text;
                // localisation is needless here since leo.org translates only into or out of German
                final CharSequence[] itemValues = { "en", "fr", "es", "it", "ch", "ru" };
                String language = getLanguage(MetaDB.LANGUAGES_QA_UNDEFINED);
                if (language.length() > 0) {
                    for (CharSequence itemValue : itemValues) {
                        if (language.equals(itemValue)) {
                            lookupLeo(language, mLookupText);
                            mLookupText = "";
                            return true;
                        }
                    }
                }
                final String[] items = { "Englisch", "Franz枚sisch", "Spanisch", "Italienisch", "Chinesisch", "Russisch" };
                new MaterialDialog.Builder(mContext)
                        .title("\"" + mLookupText + "\" nachschlagen")
                        .items(items)
                        .itemsCallback(new MaterialDialog.ListCallback() {
                            @Override
                            public void onSelection(MaterialDialog materialDialog, View view,
                                    int item, CharSequence charSequence) {
                                String language = itemValues[item].toString();
                                storeLanguage(language, MetaDB.LANGUAGES_QA_UNDEFINED);
                                lookupLeo(language, mLookupText);
                                mLookupText = "";
                            }
                        })
                        .build().show();
                return true;
            case DICTIONARY_COLORDICT:
                Intent colordictSearchIntent = new Intent(mDictionaryAction);
                colordictSearchIntent.putExtra("EXTRA_QUERY", text);
                mContext.startActivity(colordictSearchIntent);
                return true;
            case DICTIONARY_FORA:
                Intent foraSearchIntent = new Intent(mDictionaryAction);
                foraSearchIntent.putExtra("HEADWORD", text.trim());
                mContext.startActivity(foraSearchIntent);
                return true;
            case DICTIONARY_NCIKU_WEB:
                Intent ncikuWebIntent = new Intent(mDictionaryAction, Uri.parse("http://m.nciku.com/en/entry/?query="
                        + text));
                mContext.startActivity(ncikuWebIntent);
                return true;
            case DICTIONARY_EIJIRO_WEB:
                Intent eijiroWebIntent = new Intent(mDictionaryAction, Uri.parse("http://eow.alc.co.jp/" + text));
                mContext.startActivity(eijiroWebIntent);
                return true;
        }
        return false;
    }


    private static void lookupLeo(String language, CharSequence text) {
        switch (mDictionary) {
            case DICTIONARY_LEO_WEB:
                Intent leoSearchIntent = new Intent(mDictionaryAction, Uri.parse("http://pda.leo.org/?lp=" + language
                        + "de&search=" + text));
                mContext.startActivity(leoSearchIntent);
                break;
            case DICTIONARY_LEO_APP:
                Intent leoAppSearchIntent = new Intent(mDictionaryAction);
                leoAppSearchIntent.putExtra("org.leo.android.dict.DICTIONARY", language + "de");
                leoAppSearchIntent.putExtra(Intent.EXTRA_TEXT, text);
                leoAppSearchIntent.setComponent(new ComponentName("org.leo.android.dict",
                        "org.leo.android.dict.LeoDict"));
                mContext.startActivity(leoAppSearchIntent);
                break;
            default:
        }
    }


    public static String getSearchStringTitle() {
        return String.format(mContext.getString(R.string.menu_search),
                mContext.getResources().getStringArray(R.array.dictionary_labels)[mDictionary]);
    }


    public static boolean isAvailable() {
        return mIsDictionaryAvailable;
    }


    private static String getLanguage(int questionAnswer) {
        // if (mCurrentCard == null) {
        return "";
        // } else {
        // return MetaDB.getLanguage(mContext, mDeckFilename, Models.getModel(DeckManager.getMainDeck(),
        // mCurrentCard.getCardModelId(), false).getId(), mCurrentCard.getCardModelId(), questionAnswer);
        // }
    }


    private static void storeLanguage(String language, int questionAnswer) {
        // if (mCurrentCard != null) {
        // MetaDB.storeLanguage(mContext, mDeckFilename, Models.getModel(DeckManager.getMainDeck(),
        // mCurrentCard.getCardModelId(), false).getId(), mCurrentCard.getCardModelId(), questionAnswer, language);
        // }
    }

}

package com.ichi2.anki;

import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.util.Pair;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import timber.log.Timber;

/**
 * Used to store additional information besides what is stored in the deck itself.
 * <p>
 * Currently it used to store:
 * <ul>
 * <li>The languages associated with questions and answers.</li>
 * <li>The state of the whiteboard.</li>
 * <li>The cached state of the widget.</li>
 * </ul>
 */
public class MetaDB {
    /** The name of the file storing the meta-db. */
    private static final String DATABASE_NAME = "ankidroid.db";

    /** The Database Version, increase if you want updates to happen on next upgrade. */
    private static final int DATABASE_VERSION = 4;

    // Possible values for the qa column of the languages table.
    /** The language refers to the question. */
    public static final int LANGUAGES_QA_QUESTION = 0;
    /** The language refers to the answer. */
    public static final int LANGUAGES_QA_ANSWER = 1;
    /** The language does not refer to either the question or answer. */
    public static final int LANGUAGES_QA_UNDEFINED = 2;

    /** The pattern used to remove quotes from file names. */
    private static final Pattern quotePattern = Pattern.compile("[\"']");

    /** The database object used by the meta-db. */
    private static SQLiteDatabase mMetaDb = null;


    /** Remove any pairs of quotes from the given text. */
    private static String stripQuotes(String text) {
        Matcher matcher = quotePattern.matcher(text);
        text = matcher.replaceAll("");
        return text;
    }


    /** Open the meta-db */
    private static void openDB(Context context) {
        try {
            mMetaDb = context.openOrCreateDatabase(DATABASE_NAME, 0, null);
            if (mMetaDb.needUpgrade(DATABASE_VERSION)) {
                mMetaDb = upgradeDB(mMetaDb, DATABASE_VERSION);
            }
            Timber.v("Opening MetaDB");
        } catch (Exception e) {
            Timber.e(e, "Error opening MetaDB ");
        }
    }


    /** Creating any table that missing and upgrading necessary tables. */
    private static SQLiteDatabase upgradeDB(SQLiteDatabase mMetaDb, int databaseVersion) {
        Timber.i("MetaDB:: Upgrading Internal Database..");
        // if (mMetaDb.getVersion() == 0) {
        Timber.i("MetaDB:: Applying changes for version: 0");

        if (mMetaDb.getVersion() < 4) {
            mMetaDb.execSQL("DROP TABLE IF EXISTS languages;");
            mMetaDb.execSQL("DROP TABLE IF EXISTS customDictionary;");
            mMetaDb.execSQL("DROP TABLE IF EXISTS whiteboardState;");
        }

        // Create tables if not exist
        mMetaDb.execSQL("CREATE TABLE IF NOT EXISTS languages (" + " _id INTEGER PRIMARY KEY AUTOINCREMENT, "
                + "did INTEGER NOT NULL, ord INTEGER, " + "qa INTEGER, " + "language TEXT)");
        mMetaDb.execSQL("CREATE TABLE IF NOT EXISTS whiteboardState (" + "_id INTEGER PRIMARY KEY AUTOINCREMENT, "
                + "did INTEGER NOT NULL, " + "state INTEGER)");
        mMetaDb.execSQL("CREATE TABLE IF NOT EXISTS customDictionary (" + "_id INTEGER PRIMARY KEY AUTOINCREMENT, "
                + "did INTEGER NOT NULL, " + "dictionary INTEGER)");
        mMetaDb.execSQL("CREATE TABLE IF NOT EXISTS smallWidgetStatus (" + "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                + "due INTEGER NOT NULL, eta INTEGER NOT NULL)");
        // Use pragma to get info about widgetStatus.
        Cursor c = null;
        try {
             c = mMetaDb.rawQuery("PRAGMA table_info(widgetStatus)", null);
            int columnNumber = c.getCount();
            if (columnNumber > 0) {
                if (columnNumber < 7) {
                    mMetaDb.execSQL("ALTER TABLE widgetStatus " + "ADD COLUMN eta INTEGER NOT NULL DEFAULT '0'");
                    mMetaDb.execSQL("ALTER TABLE widgetStatus " + "ADD COLUMN time INTEGER NOT NULL DEFAULT '0'");
                }
            } else {
                mMetaDb.execSQL("CREATE TABLE IF NOT EXISTS widgetStatus (" + "deckId INTEGER NOT NULL PRIMARY KEY, "
                        + "deckName TEXT NOT NULL, " + "newCards INTEGER NOT NULL, " + "lrnCards INTEGER NOT NULL, "
                        + "dueCards INTEGER NOT NULL, " + "progress INTEGER NOT NULL, " + "eta INTEGER NOT NULL)");
            }
            mMetaDb.setVersion(databaseVersion);
            Timber.i("MetaDB:: Upgrading Internal Database finished. New version: %d", databaseVersion);
            return mMetaDb;
        } finally {
            if (c != null) {
                c.close();
            }
        }
    }


    /** Open the meta-db but only if it currently closed. */
    private static void openDBIfClosed(Context context) {
        if (mMetaDb == null || !mMetaDb.isOpen()) {
            openDB(context);
        }
    }


    /** Close the meta-db. */
    public static void closeDB() {
        if (mMetaDb != null && mMetaDb.isOpen()) {
            mMetaDb.close();
            mMetaDb = null;
            Timber.d("Closing MetaDB");
        }
    }


    /** Reset the content of the meta-db, erasing all its content. */
    public static boolean resetDB(Context context) {
        openDBIfClosed(context);
        try {
            mMetaDb.execSQL("DROP TABLE IF EXISTS languages;");
            Timber.i("MetaDB:: Resetting all language assignment");
            mMetaDb.execSQL("DROP TABLE IF EXISTS whiteboardState;");
            Timber.i("MetaDB:: Resetting whiteboard state");
            mMetaDb.execSQL("DROP TABLE IF EXISTS customDictionary;");
            Timber.i("MetaDB:: Resetting custom Dictionary");
            mMetaDb.execSQL("DROP TABLE IF EXISTS widgetStatus;");
            Timber.i("MetaDB:: Resetting widget status");
            mMetaDb.execSQL("DROP TABLE IF EXISTS smallWidgetStatus;");
            Timber.i("MetaDB:: Resetting small widget status");
            mMetaDb.execSQL("DROP TABLE IF EXISTS intentInformation;");
            Timber.i("MetaDB:: Resetting intentInformation");
            upgradeDB(mMetaDb, DATABASE_VERSION);
            return true;
        } catch (Exception e) {
            Timber.e(e, "Error resetting MetaDB ");
        }
        return false;
    }


    /** Reset the language associations for all the decks and card models. */
    public static boolean resetLanguages(Context context) {
        if (mMetaDb == null || !mMetaDb.isOpen()) {
            openDB(context);
        }
        try {
            Timber.i("MetaDB:: Resetting all language assignments");
            mMetaDb.execSQL("DROP TABLE IF EXISTS languages;");
            upgradeDB(mMetaDb, DATABASE_VERSION);
            return true;
        } catch (Exception e) {
            Timber.e(e, "Error resetting MetaDB ");
        }
        return false;
    }


    /** Reset the widget status. */
    public static boolean resetWidget(Context context) {
        if (mMetaDb == null || !mMetaDb.isOpen()) {
            openDB(context);
        }
        try {
            Timber.i("MetaDB:: Resetting widget status");
            mMetaDb.execSQL("DROP TABLE IF EXISTS widgetStatus;");
            mMetaDb.execSQL("DROP TABLE IF EXISTS smallWidgetStatus;");
            upgradeDB(mMetaDb, DATABASE_VERSION);
            return true;
        } catch (Exception e) {
            Timber.e(e, "Error resetting widgetStatus and smallWidgetStatus");
        }
        return false;
    }


    /**
     * Associates a language to a deck, model, and card model for a given type.
     * 
     * @param qa the part of the card for which to store the association, {@link #LANGUAGES_QA_QUESTION},
     *            {@link #LANGUAGES_QA_ANSWER}, or {@link #LANGUAGES_QA_UNDEFINED}
     * @param language the language to associate, as a two-characters, lowercase string
     */
    public static void storeLanguage(Context context, long did, int ord, int qa, String language) {
        openDBIfClosed(context);
        try {
            mMetaDb.execSQL("INSERT INTO languages (did, ord, qa, language) " + " VALUES (?, ?, ?, ?);", new Object[] {
                    did, ord, qa, language });
            Timber.v("Store language for deck %d", did);
        } catch (Exception e) {
            Timber.e(e,"Error storing language in MetaDB ");
        }
    }

    /**
     * Associates a language to a deck, model, and card model for a given type.
     *
     * @param qa the part of the card for which to store the association, {@link #LANGUAGES_QA_QUESTION},
     *            {@link #LANGUAGES_QA_ANSWER}, or {@link #LANGUAGES_QA_UNDEFINED}
     * @param language the language to associate, as a two-characters, lowercase string
     */
    public static void updateLanguage(Context context, long did, int ord, int qa, String language) {
        openDBIfClosed(context);
        try {
            mMetaDb.execSQL("UPDATE languages SET language = ? WHERE did = ? AND ord = ? AND qa = ?;", new Object[] {
                    language, did, ord, qa});
            Timber.v("Update language for deck %d", did);
        } catch (Exception e) {
            Timber.e(e,"Error updating language in MetaDB ");
        }
    }


    /**
     * Returns the language associated with the given deck, model and card model, for the given type.
     * 
     * @param qa the part of the card for which to store the association, {@link #LANGUAGES_QA_QUESTION},
     *            {@link #LANGUAGES_QA_ANSWER}, or {@link #LANGUAGES_QA_UNDEFINED} return the language associate with
     *            the type, as a two-characters, lowercase string, or the empty string if no association is defined
     */
    public static String getLanguage(Context context, long did, int ord, int qa) {
        openDBIfClosed(context);
        String language = "";
        Cursor cur = null;
        try {
            String query = "SELECT language FROM languages " + "WHERE did = " + did + " AND ord = " + ord
                    + " AND qa = " + qa + " " + "LIMIT 1";
            cur = mMetaDb.rawQuery(query, null);
            Timber.v("getLanguage: %s", query);
            if (cur.moveToNext()) {
                language = cur.getString(0);
            }
        } catch (Exception e) {
            Timber.e(e, "Error fetching language ");
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        return language;
    }


    /**
     * Resets all the language associates for a given deck.
     * 
     * @return whether an error occurred while resetting the language for the deck
     */
    public static boolean resetDeckLanguages(Context context, long did) {
        openDBIfClosed(context);
        try {
            mMetaDb.execSQL("DELETE FROM languages WHERE did = " + did + ";");
            Timber.i("MetaDB:: Resetting language assignment for deck %d", did);
            return true;
        } catch (Exception e) {
            Timber.e(e, "Error resetting deck language");
        }
        return false;
    }


    /**
     * Returns the state of the whiteboard for the given deck.
     * 
     * @return 1 if the whiteboard should be shown, 0 otherwise
     */
    public static boolean getWhiteboardState(Context context, long did) {
        openDBIfClosed(context);
        Cursor cur = null;
        try {
            cur = mMetaDb.rawQuery("SELECT state FROM whiteboardState" + " WHERE did = " + did, null);
            if (cur.moveToNext()) {
                return cur.getInt(0) > 0;
            } else {
                return false;
            }
        } catch (Exception e) {
            Timber.e(e, "Error retrieving whiteboard state from MetaDB ");
            return false;
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
    }


    /**
     * Stores the state of the whiteboard for a given deck.
     *
     * @param did deck id to store whiteboard state for
     * @param whiteboardState 1 if the whiteboard should be shown, 0 otherwise
     */
    public static void storeWhiteboardState(Context context, long did, boolean whiteboardState) {
        int state = (whiteboardState) ? 1 : 0;
        openDBIfClosed(context);
        Cursor cur = null;
        try {
            cur = mMetaDb.rawQuery("SELECT _id FROM whiteboardState" + " WHERE did  = " + did, null);
            if (cur.moveToNext()) {
                mMetaDb.execSQL("UPDATE whiteboardState " + "SET did = " + did + ", " + "state="
                        + Integer.toString(state) + " " + "WHERE _id=" + cur.getString(0) + ";");
                Timber.d("Store whiteboard state (%d) for deck %d", state, did);
            } else {
                mMetaDb.execSQL("INSERT INTO whiteboardState (did, state) VALUES (?, ?)", new Object[] { did, state });
                Timber.d("Store whiteboard state (%d) for deck %d", state, did);
            }
        } catch (Exception e) {
            Timber.e(e,"Error storing whiteboard state in MetaDB ");
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
    }


    /**
     * Returns a custom dictionary associated to a deck
     * 
     * @return integer number of dictionary, -1 if not set (standard dictionary will be used)
     */
    public static int getLookupDictionary(Context context, long did) {
        openDBIfClosed(context);
        Cursor cur = null;
        try {
            cur = mMetaDb.rawQuery("SELECT dictionary FROM customDictionary" + " WHERE did = " + did, null);
            if (cur.moveToNext()) {
                return cur.getInt(0);
            } else {
                return -1;
            }
        } catch (Exception e) {
            Timber.e(e, "Error retrieving custom dictionary from MetaDB ");
            return -1;
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
    }


    /**
     * Stores a custom dictionary for a given deck.
     * 
     * @param dictionary integer number of dictionary, -1 if not set (standard dictionary will be used)
     */
    public static void storeLookupDictionary(Context context, long did, int dictionary) {
        openDBIfClosed(context);
        Cursor cur = null;
        try {
            cur = mMetaDb.rawQuery("SELECT _id FROM customDictionary" + " WHERE did = " + did, null);
            if (cur.moveToNext()) {
                mMetaDb.execSQL("UPDATE customDictionary " + "SET did = " + did + ", " + "dictionary="
                        + Integer.toString(dictionary) + " " + "WHERE _id=" + cur.getString(0) + ";");
                Timber.i("MetaDB:: Store custom dictionary (%d) for deck %d", dictionary, did);
            } else {
                mMetaDb.execSQL("INSERT INTO customDictionary (did, dictionary) VALUES (?, ?)", new Object[] { did,
                        dictionary });
                Timber.i("MetaDB:: Store custom dictionary (%d) for deck %d", dictionary, did);
            }
        } catch (Exception e) {
            Timber.e(e, "Error storing custom dictionary to MetaDB ");
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
    }


    /**
     * Return the current status of the widget.
     * 
     * @return [due, eta]
     */
    public static int[] getWidgetSmallStatus(Context context) {
        openDBIfClosed(context);
        Cursor cursor = null;
        try {
            cursor = mMetaDb.query("smallWidgetStatus", new String[] { "due", "eta" },
                    null, null, null, null, null);
            while (cursor.moveToNext()) {
                return new int[]{cursor.getInt(0), cursor.getInt(1)};
            }
        } catch (SQLiteException e) {
            Timber.e(e, "Error while querying widgetStatus");
        } finally {
            if (cursor != null && !cursor.isClosed()) {
                cursor.close();
            }
        }
        return new int[]{0, 0};
    }


    public static int getNotificationStatus(Context context) {
        openDBIfClosed(context);
        Cursor cursor = null;
        int due = 0;
        try {
            cursor = mMetaDb.query("smallWidgetStatus", new String[] { "due" }, null, null, null, null, null);
            if (cursor.moveToFirst()) {
                return cursor.getInt(0);
            }
        } catch (SQLiteException e) {
            Timber.e(e, "Error while querying widgetStatus");
        } finally {
            if (cursor != null && !cursor.isClosed()) {
                cursor.close();
            }
        }
        return due;
    }


    public static void storeSmallWidgetStatus(Context context, Pair<Integer, Integer> status) {
        openDBIfClosed(context);
        try {
            mMetaDb.beginTransaction();
            try {
                // First clear all the existing content.
                mMetaDb.execSQL("DELETE FROM smallWidgetStatus");
                mMetaDb.execSQL("INSERT INTO smallWidgetStatus(due, eta) VALUES (?, ?)",
                        new Object[]{status.first, status.second});
                mMetaDb.setTransactionSuccessful();
            } finally {
                mMetaDb.endTransaction();
            }
        } catch (IllegalStateException e) {
            Timber.e(e, "MetaDB.storeSmallWidgetStatus: failed");
        } catch (SQLiteException e) {
            Timber.e(e, "MetaDB.storeSmallWidgetStatus: failed");
            closeDB();
            Timber.i("MetaDB:: Trying to reset Widget: " + resetWidget(context));
        }
    }
}
/****************************************************************************************
 * Copyright (c) 2015 Ryan Annis <squeenix@live.ca>                                     *
 * Copyright (c) 2015 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/
package com.ichi2.anki;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.support.v7.widget.Toolbar;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemLongClickListener;
import android.widget.ArrayAdapter;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.Toast;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.dialogs.ConfirmationDialog;
import com.ichi2.anki.dialogs.ModelBrowserContextMenu;
import com.ichi2.anki.exception.ConfirmModSchemaException;
import com.ichi2.async.DeckTask;
import com.ichi2.async.DeckTask.TaskData;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Models;
import com.ichi2.widget.WidgetStatus;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Random;

import timber.log.Timber;


public class ModelBrowser extends AnkiActivity {

    public static final int REQUEST_TEMPLATE_EDIT = 3;

    DisplayPairAdapter mModelDisplayAdapter;
    private ListView mModelListView;

    // Of the currently selected model
    private long mCurrentID;
    private int mModelListPosition;

    //Used exclusively to display model name
    private ArrayList<JSONObject> mModels;
    private ArrayList<Integer> mCardCounts;
    private ArrayList<Long> mModelIds;
    private ArrayList<DisplayPair> mModelDisplayList;

    private Collection col;
    private ActionBar mActionBar;

    //Dialogue used in renaming
    private EditText mModelNameInput;

    private ModelBrowserContextMenu mContextMenu;

    private ArrayList<String> mNewModelNames;
    private ArrayList<String> mNewModelLabels;


    // ----------------------------------------------------------------------------
    // AsyncTask methods
    // ----------------------------------------------------------------------------


    /*
     * Displays the loading bar when loading the mModels and displaying them
     * loading bar is necessary because card count per model is not cached *
     */
    private DeckTask.TaskListener mLoadingModelsHandler = new DeckTask.TaskListener() {
        @Override
        public void onCancelled() {
            hideProgressBar();
        }

        @Override
        public void onPreExecute() {
            showProgressBar();
        }

        @Override
        public void onPostExecute(TaskData result) {

            if (!result.getBoolean()) {
                throw new RuntimeException();
            }
            hideProgressBar();
            mModels = (ArrayList<JSONObject>) result.getObjArray()[0];
            mCardCounts = (ArrayList<Integer>) result.getObjArray()[1];

            fillModelList();
        }

        @Override
        public void onProgressUpdate(TaskData... values) {
            //This decktask does not publish updates
        }
    };

    /*
     * Displays loading bar when deleting a model loading bar is needed
     * because deleting a model also deletes all of the associated cards/notes *
     */
    private DeckTask.TaskListener mDeleteModelHandler = new DeckTask.TaskListener() {

        @Override
        public void onCancelled() {
            //This decktask can not be interrupted
        }

        @Override
        public void onPreExecute() {
            showProgressBar();
        }

        @Override
        public void onPostExecute(TaskData result) {
            if (!result.getBoolean()) {
                throw new RuntimeException();
            }
            hideProgressBar();
            refreshList();
        }

        @Override
        public void onProgressUpdate(TaskData... values) {
            //This decktask does not publish updates
        }
    };

    /*
     * Listens to long hold context menu for main list items
     */
    private MaterialDialog.ListCallback mContextMenuListener = new MaterialDialog.ListCallback() {
        @Override
        public void onSelection(MaterialDialog materialDialog, View view, int selection, CharSequence charSequence) {
            switch (selection) {
                case ModelBrowserContextMenu.MODEL_DELETE:
                    deleteModelDialog();
                    break;
                case ModelBrowserContextMenu.MODEL_RENAME:
                    renameModelDialog();
                    break;
                case ModelBrowserContextMenu.MODEL_TEMPLATE:
                    openTemplateEditor();
                    break;
            }
        }
    };


    // ----------------------------------------------------------------------------
    // ANDROID METHODS
    // ----------------------------------------------------------------------------
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.model_browser);
        mModelListView = (ListView) findViewById(R.id.note_type_browser_list);
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        if (toolbar != null) {
            setSupportActionBar(toolbar);
        }
        mActionBar = getSupportActionBar();
        startLoadingCollection();
    }


    @Override
    public void onResume() {
        Timber.d("onResume()");
        super.onResume();
    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.model_browser, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                onBackPressed();
                return true;
            case R.id.action_add_new_note_type:
                addNewNoteTypeDialog();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public void onStop() {
        super.onStop();
        if (!isFinishing()) {
            WidgetStatus.update(this);
            UIUtils.saveCollectionInBackground(this);
        }
    }


    // ----------------------------------------------------------------------------
    // ANKI METHODS
    // ----------------------------------------------------------------------------
    @Override
    public void onCollectionLoaded(Collection col) {
        super.onCollectionLoaded(col);
        this.col = col;
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_COUNT_MODELS, mLoadingModelsHandler);
    }



    // ----------------------------------------------------------------------------
    // HELPER METHODS
    // ----------------------------------------------------------------------------

    /*
     * Fills the main list view with model names.
     * Handles filling the ArrayLists and attaching
     * ArrayAdapters to main ListView
     */
    private void fillModelList() {
        //Anonymous class for handling list item clicks
        mModelDisplayList = new ArrayList<>();
        mModelIds = new ArrayList<>();

        for (int i = 0; i < mModels.size(); i++) {
            try {
                mModelIds.add(mModels.get(i).getLong("id"));
                mModelDisplayList.add(new DisplayPair(mModels.get(i).getString("name"), mCardCounts.get(i)));
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }

        mModelDisplayAdapter = new DisplayPairAdapter(this, mModelDisplayList);
        mModelListView.setAdapter(mModelDisplayAdapter);

        mModelListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                long noteTypeID = mModelIds.get(position);
                mModelListPosition = position;
                Intent noteOpenIntent = new Intent(ModelBrowser.this, ModelFieldEditor.class);
                noteOpenIntent.putExtra("title", mModelDisplayList.get(position).getName());
                noteOpenIntent.putExtra("noteTypeID", noteTypeID);
                startActivityForResultWithAnimation(noteOpenIntent, 0, ActivityTransitionAnimation.LEFT);
            }
        });

        mModelListView.setOnItemLongClickListener(new OnItemLongClickListener() {
            public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id) {
                String cardName = mModelDisplayList.get(position).getName();
                mCurrentID = mModelIds.get(position);
                mModelListPosition = position;
                mContextMenu = ModelBrowserContextMenu.newInstance(cardName, mContextMenuListener);
                showDialogFragment(mContextMenu);
                return true;
            }
        });
        updateSubtitleText();
    }

    /*
     * Updates the subtitle showing the amount of mModels available
     * ONLY CALL THIS AFTER initializing the main list
     */
    private void updateSubtitleText() {
        int count = mModelIds.size();
        mActionBar.setSubtitle(getResources().getQuantityString(R.plurals.model_browser_types_available, count, count));
    }


    /*
     *Creates the dialogue box to select a note type, add a name, and then clone it
     */
    private void addNewNoteTypeDialog() {

        String add = getResources().getString(R.string.model_browser_add_add);
        String clone = getResources().getString(R.string.model_browser_add_clone);

        // AnkiDroid doesn't have stdmodels class or model name localization, this could be much cleaner if implemented
        final String basicName = "Basic";
        final String addForwardReverseName = "Basic (and reversed card)";
        final String addForwardOptionalReverseName = "Basic (optional reversed card)";
        final String addClozeModelName = "Cloze";

        //Populates arrayadapters listing the mModels (includes prefixes/suffixes)
        mNewModelLabels = new ArrayList<>();

        //Used to fetch model names
        mNewModelNames = new ArrayList<>();
        mNewModelLabels.add(String.format(add, basicName));
        mNewModelLabels.add(String.format(add, addForwardReverseName));
        mNewModelLabels.add(String.format(add, addForwardOptionalReverseName));
        mNewModelLabels.add(String.format(add, addClozeModelName));

        mNewModelNames.add(basicName);
        mNewModelNames.add(addForwardReverseName);
        mNewModelNames.add(addForwardOptionalReverseName);
        mNewModelNames.add(addClozeModelName);

        final int numStdModels = mNewModelLabels.size();

        if (mModels != null) {
            for (JSONObject model : mModels) {
                try {
                    mNewModelLabels.add(String.format(clone, model.getString("name")));
                    mNewModelNames.add(model.getString("name"));
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
            }
        }

        final Spinner addSelectionSpinner = new Spinner(this);
        ArrayAdapter<String> mNewModelAdapter = new ArrayAdapter<>(this, R.layout.dropdown_deck_item, mNewModelLabels);

        addSelectionSpinner.setAdapter(mNewModelAdapter);

        new MaterialDialog.Builder(this)
                .title(R.string.model_browser_add)
                .positiveText(R.string.dialog_ok)
                .customView(addSelectionSpinner, true)
                .callback(new MaterialDialog.ButtonCallback() {
                    @Override
                    public void onPositive(MaterialDialog dialog) {
                        mModelNameInput = new EditText(ModelBrowser.this);
                        mModelNameInput.setSingleLine();

                        //Temporary workaround - Lack of stdmodels class
                        if (addSelectionSpinner.getSelectedItemPosition() < numStdModels) {
                            mModelNameInput.setText(randomizeName(mNewModelNames.get(addSelectionSpinner.getSelectedItemPosition())));
                        } else {
                            mModelNameInput.setText(mNewModelNames.get(addSelectionSpinner.getSelectedItemPosition()) +
                                    " " + getResources().getString(R.string.model_clone_suffix));
                        }

                        mModelNameInput.setSelection(mModelNameInput.getText().length());

                        //Create textbox to name new model
                        new MaterialDialog.Builder(ModelBrowser.this)
                                .title(R.string.model_browser_add)
                                .positiveText(R.string.dialog_ok)
                                .customView(mModelNameInput, true)
                                .callback(new MaterialDialog.ButtonCallback() {
                                    @Override
                                    public void onPositive(MaterialDialog dialog) {
                                        String modelName = mModelNameInput.getText().toString();
                                        addNewNoteType(modelName, addSelectionSpinner.getSelectedItemPosition());
                                    }
                                })
                                .negativeText(R.string.dialog_cancel)
                                .show();
                    }
                })
                .negativeText(R.string.dialog_cancel)
                .show();
    }

    /**
     * Add a new note type
     * @param modelName name of the new model
     * @param position position in dialog the user selected to add / clone the model type from
     */
    private void addNewNoteType(String modelName, int position) {
        //Temporary workaround - Lack of stdmodels class, so can only handle 4 default English mModels
        //like Ankidroid but unlike desktop Anki
        JSONObject model;
        try {
            if (modelName.length() > 0) {
                switch (position) {
                    //Basic Model
                    case (0):
                        model = Models.addBasicModel(col);
                        break;
                    //Add forward reverse model
                    case (1):
                        model = Models.addForwardReverse(col);
                        break;
                    //Add forward optional reverse model
                    case (2):
                        model = Models.addForwardOptionalReverse(col);
                        break;
                    //Close model
                    case (3):
                        model = Models.addClozeModel(col);
                        break;
                    default:
                        //New model
                        //Model that is being cloned
                        JSONObject oldModel = new JSONObject(mModels.get(position - 4).toString());
                        JSONObject newModel = Models.addBasicModel(col);
                        oldModel.put("id", newModel.get("id"));
                        model = oldModel;

                }
                model.put("name", modelName);
                col.getModels().update(model);
                fullRefresh();
            } else {
                showToast(getResources().getString(R.string.toast_empty_name));
            }
        } catch (ConfirmModSchemaException e) {
            //We should never get here since we're only modifying new mModels
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /*
     * Displays a confirmation box asking if you want to delete the note type and then deletes it if confirmed
     */
    private void deleteModelDialog() {
        if (mModelIds.size() > 1) {
            Runnable confirm = new Runnable() {
                @Override
                public void run() {
                    try {
                        col.modSchema(false);
                        deleteModel();
                    } catch (ConfirmModSchemaException e) {
                        //This should never be reached because modSchema() didn't throw an exception
                    }
                    dismissContextMenu();
                }
            };
            Runnable cancel = new Runnable() {
                @Override
                public void run() {
                    dismissContextMenu();
                }
            };

            try {
                col.modSchema();
                ConfirmationDialog d = new ConfirmationDialog();
                d.setArgs(getResources().getString(R.string.model_delete_warning));
                d.setConfirm(confirm);
                d.setCancel(cancel);
                ModelBrowser.this.showDialogFragment(d);
            } catch (ConfirmModSchemaException e) {
                ConfirmationDialog c = new ConfirmationDialog();
                c.setArgs(getResources().getString(R.string.full_sync_confirmation));
                c.setConfirm(confirm);
                c.setCancel(cancel);
                showDialogFragment(c);
            }
        }

        // Prevent users from deleting last model
        else {
            showToast(getString(R.string.toast_last_model));
        }
    }

    /*
     * Displays a confirmation box asking if you want to rename the note type and then renames it if confirmed
     */
    private void renameModelDialog() {
        try {
            mModelNameInput = new EditText(this);
            mModelNameInput.setSingleLine(true);
            mModelNameInput.setText(mModels.get(mModelListPosition).getString("name"));
            mModelNameInput.setSelection(mModelNameInput.getText().length());
            new MaterialDialog.Builder(this)
                                .title(R.string.rename_model)
                                .positiveText(R.string.rename)
                                .negativeText(R.string.dialog_cancel)
                                .customView(mModelNameInput, true)
                                .callback(new MaterialDialog.ButtonCallback() {
                                    @Override
                                    public void onPositive(MaterialDialog dialog) {
                                        JSONObject model = mModels.get(mModelListPosition);
                                        String deckName = mModelNameInput.getText().toString()
                                                .replaceAll("[\'\"\\n\\r\\[\\]\\(\\)]", "");
                                        getCol().getDecks().id(deckName, false);
                                        if (deckName.length() > 0) {
                                            try {
                                                model.put("name", deckName);
                                                col.getModels().update(model);
                                                mModels.get(mModelListPosition).put("name", deckName);
                                                mModelDisplayList.set(mModelListPosition,
                                                        new DisplayPair(mModels.get(mModelListPosition).getString("name"),
                                                                mCardCounts.get(mModelListPosition)));
                                            } catch (JSONException e) {
                                                throw new RuntimeException(e);
                                            }
                                            refreshList();
                                        } else {
                                            showToast(getResources().getString(R.string.toast_empty_name));
                                        }
                                    }
                                }).show();
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }

    private void dismissContextMenu() {
        if (mContextMenu != null) {
            mContextMenu.dismiss();
            mContextMenu = null;
        }
    }


    /*
     * Opens the Template Editor (Card Editor) to allow
     * the user to edit the current note's templates.
     */
    private void openTemplateEditor() {
        Intent intent = new Intent(this, CardTemplateEditor.class);
        intent.putExtra("modelId", mCurrentID);
        startActivityForResultWithAnimation(intent, REQUEST_TEMPLATE_EDIT, ActivityTransitionAnimation.LEFT);
    }

    // ----------------------------------------------------------------------------
    // HANDLERS
    // ----------------------------------------------------------------------------

    /*
     * Updates the ArrayAdapters for the main ListView.
     * ArrayLists must be manually updated.
     */
    private void refreshList() {
        mModelDisplayAdapter.notifyDataSetChanged();
        updateSubtitleText();
    }

    /*
     * Reloads everything
     */
    private void fullRefresh() {
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_COUNT_MODELS, mLoadingModelsHandler);
    }

    /*
     * Deletes the currently selected model
     */
    private void deleteModel() throws ConfirmModSchemaException {
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DELETE_MODEL, mDeleteModelHandler,
                new DeckTask.TaskData(mCurrentID));
        mModels.remove(mModelListPosition);
        mModelIds.remove(mModelListPosition);
        mModelDisplayList.remove(mModelListPosition);
        mCardCounts.remove(mModelListPosition);
        refreshList();
    }


    /*
     * Generates a random alphanumeric sequence of 6 characters
     * Used to append to the end of new note types to dissuade
     * User from reusing names (which are technically not unique however
     */
    private String randomizeName(String s) {
        char[] charSet = "123456789abcdefghijklmnopqrstuvqxwzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();

        char[] randomString = new char[6];
        Random random = new Random();
        for (int i = 0; i < 6; i++) {
            int randomIndex = random.nextInt(charSet.length);
            randomString[i] = charSet[randomIndex];
        }

        return s + " " + new String(randomString);
    }


    private void showToast(CharSequence text) {
        int duration = Toast.LENGTH_SHORT;
        Toast toast = Toast.makeText(this, text, duration);
        toast.show();
    }


    // ----------------------------------------------------------------------------
    // CUSTOM ADAPTERS
    // ----------------------------------------------------------------------------


    /*
     * Used so that the main ListView is able to display the number of notes using the model
     * along with the name.
     */
    public class DisplayPair {
        private String name;
        private int count;

        public DisplayPair(String name, int count) {
            this.name = name;
            this.count = count;
        }

        public String getName() {
            return name;
        }

        public int getCount() {
            return count;
        }

        @Override
        public String toString() {
            return getName();
        }
    }


    /*
     * For display in the main list via an ArrayAdapter
     */
    public class DisplayPairAdapter extends ArrayAdapter<DisplayPair> {
        public DisplayPairAdapter(Context context, ArrayList<DisplayPair> items) {
            super(context, R.layout.model_browser_list_item, R.id.model_list_item_1, items);
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            DisplayPair item = getItem(position);

            if (convertView == null) {
                convertView = LayoutInflater.from(getContext()).inflate(R.layout.model_browser_list_item, parent, false);
            }

            TextView tvName = (TextView) convertView.findViewById(R.id.model_list_item_1);
            TextView tvHome = (TextView) convertView.findViewById(R.id.model_list_item_2);

            int count = item.getCount();

            tvName.setText(item.getName());
            tvHome.setText(getResources().getQuantityString(R.plurals.model_browser_of_type, count, count));

            return convertView;
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == REQUEST_TEMPLATE_EDIT) {
            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_COUNT_MODELS, mLoadingModelsHandler);
        }
    }
}/****************************************************************************************
 * Copyright (c) 2015 Ryan Annis <squeenix@live.ca>                                     *
 * Copyright (c) 2015 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/
package com.ichi2.anki;

import android.os.Bundle;
import android.support.v7.widget.Toolbar;
import android.text.InputType;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.Toast;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.dialogs.ConfirmationDialog;
import com.ichi2.anki.dialogs.ModelEditorContextMenu;
import com.ichi2.anki.exception.ConfirmModSchemaException;
import com.ichi2.async.DeckTask;
import com.ichi2.libanki.Collection;
import com.ichi2.themes.StyledProgressDialog;
import com.ichi2.widget.WidgetStatus;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;

public class ModelFieldEditor extends AnkiActivity {

    private final static int NORMAL_EXIT = 100001;

    //Position of the current field selected
    private int mCurrentPos;

    private ListView mFieldLabelView;
    private ArrayList<String> mFieldLabels;
    private MaterialDialog mProgressDialog;

    private Collection mCol;
    private JSONArray mNoteFields;
    private JSONObject mMod;

    private ModelEditorContextMenu mContextMenu;
    private EditText mFieldNameInput;

    private Runnable mConfirmDialogCancel = new Runnable() {
        @Override
        public void run() {
            dismissContextMenu();
        }
    };

    // ----------------------------------------------------------------------------
    // ANDROID METHODS
    // ----------------------------------------------------------------------------


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.model_field_editor);
        startLoadingCollection();

        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        mFieldLabelView = (ListView) findViewById(R.id.note_type_editor_fields);

        if (toolbar != null) {
            setSupportActionBar(toolbar);
        }


        if (getSupportActionBar() != null) {
            getSupportActionBar().setTitle(R.string.model_field_editor_title);
            getSupportActionBar().setSubtitle(getIntent().getStringExtra("title"));
        }
    }


    @Override
    protected void onStop() {
        super.onStop();
        if (!isFinishing()) {
            WidgetStatus.update(this);
            UIUtils.saveCollectionInBackground(this);
        }
    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.model_editor, menu);
        return true;
    }


    // ----------------------------------------------------------------------------
    // ANKI METHODS
    // ----------------------------------------------------------------------------


    @Override
    protected void onCollectionLoaded(Collection col) {
        this.mCol = col;
        setupLabels();
        createfieldLabels();
    }


    // ----------------------------------------------------------------------------
    // UI SETUP
    // ----------------------------------------------------------------------------


    /*
     * Sets up the main ListView and ArrayAdapters
     * Containing clickable labels for the fields
     */
    private void createfieldLabels() {
        ArrayAdapter<String> mFieldLabelAdapter = new ArrayAdapter<>(this, R.layout.model_field_editor_list_item, mFieldLabels);
        mFieldLabelView.setAdapter(mFieldLabelAdapter);
        mFieldLabelView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                mContextMenu = ModelEditorContextMenu.newInstance(mFieldLabels.get(position), mContextMenuListener);
                showDialogFragment(mContextMenu);
                mCurrentPos = position;
            }
        });
    }


    /*
      * Sets up the ArrayList containing the text for the main ListView
      */
    private void setupLabels() {
        long noteTypeID = getIntent().getLongExtra("noteTypeID", 0);
        mMod = mCol.getModels().get(noteTypeID);

        mFieldLabels = new ArrayList<>();
        try {
            mNoteFields = mMod.getJSONArray("flds");
            for (int i = 0; i < mNoteFields.length(); i++) {
                JSONObject o = mNoteFields.getJSONObject(i);
                mFieldLabels.add(o.getString("name"));
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    // ----------------------------------------------------------------------------
    // CONTEXT MENU DIALOGUES
    // ----------------------------------------------------------------------------


    /*
    * Creates a dialog to rename the currently selected field, short loading ti
    * Processing time scales with number of items
    */
    private void addFieldDialog() {
        mFieldNameInput = new EditText(this);
        mFieldNameInput.setSingleLine(true);

        new MaterialDialog.Builder(this)
                .title(R.string.model_field_editor_add)
                .positiveText(R.string.dialog_ok)
                .customView(mFieldNameInput, true)
                .callback(new MaterialDialog.ButtonCallback() {

                    @Override
                    public void onPositive(MaterialDialog dialog) {
                        String fieldName = mFieldNameInput.getText().toString()
                                .replaceAll("[\'\"\\n\\r\\[\\]\\(\\)]", "");

                        if (fieldName.length() == 0) {
                            showToast(getResources().getString(R.string.toast_empty_name));
                        } else if (containsField(fieldName)) {
                            showToast(getResources().getString(R.string.toast_duplicate_field));
                        } else {
                            //Name is valid, now field is added
                            try {
                                mCol.modSchema();
                                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ADD_FIELD, mChangeFieldHandler,
                                        new DeckTask.TaskData(new Object[]{mMod, fieldName}));
                            } catch (ConfirmModSchemaException e) {

                                //Create dialogue to for schema change
                                ConfirmationDialog c = new ConfirmationDialog();
                                c.setArgs(getResources().getString(R.string.full_sync_confirmation));
                                Runnable confirm = new Runnable() {
                                    @Override
                                    public void run() {
                                        mCol.modSchemaNoCheck();
                                        String fieldName = mFieldNameInput.getText().toString()
                                                .replaceAll("[\'\"\\n\\r\\[\\]\\(\\)]", "");
                                        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ADD_FIELD, mChangeFieldHandler,
                                                new DeckTask.TaskData(new Object[]{mMod, fieldName}));
                                        dismissContextMenu();
                                    }
                                };

                                c.setConfirm(confirm);
                                c.setCancel(mConfirmDialogCancel);
                                ModelFieldEditor.this.showDialogFragment(c);
                            }
                            mCol.getModels().update(mMod);
                            fullRefreshList();
                        }
                    }
                })
                .negativeText(R.string.dialog_cancel)
                .show();
    }


    /*
     * Creates a dialog to rename the currently selected field, short loading ti
     * Processing time scales with number of items
     */
    private void deleteFieldDialog() {
        Runnable confirm = new Runnable() {
            @Override
            public void run() {
                try {
                    mCol.modSchema(false);
                    deleteField();
                } catch (ConfirmModSchemaException e) {
                    //This should never be reached because modSchema() didn't throw an exception
                }
                dismissContextMenu();
            }
        };


        if (mFieldLabels.size() < 2) {
            showToast(getResources().getString(R.string.toast_last_field));
        } else {
            try {
                mCol.modSchema();
                ConfirmationDialog d = new ConfirmationDialog();
                d.setArgs(getResources().getString(R.string.field_delete_warning));
                d.setConfirm(confirm);
                d.setCancel(mConfirmDialogCancel);
                showDialogFragment(d);
            } catch (ConfirmModSchemaException e) {
                ConfirmationDialog c = new ConfirmationDialog();
                c.setConfirm(confirm);
                c.setCancel(mConfirmDialogCancel);
                c.setArgs(getResources().getString(R.string.full_sync_confirmation));
                showDialogFragment(c);
            }
        }
    }

    private void deleteField() {
        try {
            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DELETE_FIELD, mChangeFieldHandler,
                    new DeckTask.TaskData(new Object[]{mMod, mNoteFields.getJSONObject(mCurrentPos)}));
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /*
     * Creates a dialog to rename the currently selected field, short loading ti
     * Processing time is constant
     */
    private void renameFieldDialog() {
        mFieldNameInput = new EditText(this);
        mFieldNameInput.setSingleLine(true);
        mFieldNameInput.setText(mFieldLabels.get(mCurrentPos));
        mFieldNameInput.setSelection(mFieldNameInput.getText().length());
        new MaterialDialog.Builder(this)
                .title(R.string.rename_model)
                .positiveText(R.string.rename)
                .customView(mFieldNameInput, true)
                .callback(new MaterialDialog.ButtonCallback() {
                    @Override
                    public void onPositive(MaterialDialog dialog) {

                        String fieldLabel = mFieldNameInput.getText().toString()
                                .replaceAll("[\'\"\\n\\r\\[\\]\\(\\)]", "");
                        if (fieldLabel.length() == 0) {
                            showToast(getResources().getString(R.string.toast_empty_name));
                        } else if (containsField(fieldLabel)) {
                            showToast(getResources().getString(R.string.toast_duplicate_field));
                        } else {
                            //Field is valid, now rename
                            try {
                                renameField();
                            } catch (ConfirmModSchemaException e) {

                                // Handler mod schema confirmation
                                ConfirmationDialog c = new ConfirmationDialog();
                                c.setArgs(getResources().getString(R.string.full_sync_confirmation));
                                Runnable confirm = new Runnable() {
                                    @Override
                                    public void run() {
                                        try {
                                            mCol.modSchema(false);
                                            renameField();
                                        } catch (ConfirmModSchemaException e) {
                                            //This should never be thrown
                                        }
                                        dismissContextMenu();
                                    }
                                };
                                c.setConfirm(confirm);
                                c.setCancel(mConfirmDialogCancel);
                                ModelFieldEditor.this.showDialogFragment(c);
                            }
                        }
                    }
                })
                .negativeText(R.string.dialog_cancel)
                .show();
    }


    /*
     * Allows the user to select a number less than the number of fields in the current model to
     * reposition the current field to
     * Processing time is scales with number of items
     */
    private void repositionFieldDialog() {
        mFieldNameInput = new EditText(this);
        mFieldNameInput.setRawInputType(InputType.TYPE_CLASS_NUMBER);
        new MaterialDialog.Builder(this)
                .title(String.format(getResources().getString(R.string.model_field_editor_reposition), 1, mFieldLabels.size()))
                .positiveText(R.string.dialog_ok)
                .customView(mFieldNameInput, true)
                .callback(new MaterialDialog.ButtonCallback() {
                    @Override
                    public void onPositive(MaterialDialog dialog) {
                        String newPosition = mFieldNameInput.getText().toString();
                        int pos;
                        try {
                            pos = Integer.parseInt(newPosition);
                        } catch (NumberFormatException n) {
                            showToast(getResources().getString(R.string.toast_out_of_range));
                            return;
                        }

                        if (pos < 1 || pos > mFieldLabels.size()) {
                            showToast(getResources().getString(R.string.toast_out_of_range));
                        } else {
                            // Input is valid, now attempt to modify
                            try {
                                mCol.modSchema();
                                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REPOSITION_FIELD, mChangeFieldHandler,
                                        new DeckTask.TaskData(new Object[]{mMod,
                                                mNoteFields.getJSONObject(mCurrentPos), pos - 1}));
                            } catch (ConfirmModSchemaException e) {

                                // Handle mod schema confirmation
                                ConfirmationDialog c = new ConfirmationDialog();
                                c.setArgs(getResources().getString(R.string.full_sync_confirmation));
                                Runnable confirm = new Runnable() {
                                    @Override
                                    public void run() {
                                        try {
                                            mCol.modSchemaNoCheck();
                                            String newPosition = mFieldNameInput.getText().toString();
                                            int pos = Integer.parseInt(newPosition);
                                            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REPOSITION_FIELD,
                                                    mChangeFieldHandler, new DeckTask.TaskData(new Object[]{mMod,
                                                            mNoteFields.getJSONObject(mCurrentPos),pos - 1}));
                                            dismissContextMenu();
                                        } catch (JSONException e) {
                                            throw new RuntimeException(e);
                                        }
                                    }
                                };
                                c.setConfirm(confirm);
                                c.setCancel(mConfirmDialogCancel);
                                ModelFieldEditor.this.showDialogFragment(c);
                            } catch (JSONException e) {
                                throw new RuntimeException(e);
                            }
                        }
                    }
                })
                .negativeText(R.string.dialog_cancel)
                .show();
    }


    // ----------------------------------------------------------------------------
    // HELPER METHODS
    // ----------------------------------------------------------------------------


    /*
     * Useful when a confirmation dialog is created within another dialog
     */
    private void dismissContextMenu() {
        if (mContextMenu != null) {
            mContextMenu.dismiss();
            mContextMenu = null;
        }
    }


    private void dismissProgressBar() {
        if (mProgressDialog != null) {
            mProgressDialog.dismiss();
        }
        mProgressDialog = null;
    }


    /*
     * Renames the current field
     */
    private void renameField() throws ConfirmModSchemaException {
        try {
            String fieldLabel = mFieldNameInput.getText().toString()
                    .replaceAll("[\'\"\\n\\r\\[\\]\\(\\)]", "");
            JSONObject field = (JSONObject) mNoteFields.get(mCurrentPos);
            mCol.getModels().renameField(mMod, field, fieldLabel);
            mCol.getModels().save();
            fullRefreshList();
        } catch (JSONException e) {
            throw new RuntimeException();
        }
    }


    /*
     * Changes the sort field (that displays in card browser) to the current field
     */
    private void sortByField() {
        try {
            mCol.modSchema();
            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CHANGE_SORT_FIELD, mChangeFieldHandler,
                    new DeckTask.TaskData(new Object[]{mMod, mCurrentPos}));
        } catch (ConfirmModSchemaException e) {
            // Handler mMod schema confirmation
            ConfirmationDialog c = new ConfirmationDialog();
            c.setArgs(getResources().getString(R.string.full_sync_confirmation));
            Runnable confirm = new Runnable() {
                @Override
                public void run() {
                    mCol.modSchemaNoCheck();
                    DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CHANGE_SORT_FIELD, mChangeFieldHandler,
                            new DeckTask.TaskData(new Object[]{mMod, mCurrentPos}));
                    dismissContextMenu();
                }
            };
            c.setConfirm(confirm);
            c.setCancel(mConfirmDialogCancel);
            ModelFieldEditor.this.showDialogFragment(c);
        }
    }


    /*
     * Reloads everything
     */
    private void fullRefreshList() {
        setupLabels();
        createfieldLabels();
    }


    /*
     * Checks if there exists a field with this name in the current model
     */
    private boolean containsField(String field) {
        for (String s : mFieldLabels) {
            if (field.compareTo(s) == 0) {
                return true;
            }
        }
        return false;
    }


    private void showToast(CharSequence text) {
        int duration = Toast.LENGTH_SHORT;
        Toast toast = Toast.makeText(this, text, duration);
        toast.show();
    }


    // ----------------------------------------------------------------------------
    // HANDLERS
    // ----------------------------------------------------------------------------


    /*
     * Called during the desk task when any field is modified
     */
    private DeckTask.TaskListener mChangeFieldHandler = new DeckTask.TaskListener() {

        @Override
        public void onCancelled() {
            //This decktask can not be interrupted
        }

        @Override
        public void onPreExecute() {
            if (mProgressDialog == null) {
                mProgressDialog = StyledProgressDialog.show(ModelFieldEditor.this, getIntent().getStringExtra("title"),
                        getResources().getString(R.string.model_field_editor_changing), false);
            }
        }

        @Override
        public void onPostExecute(DeckTask.TaskData result) {
            if (!result.getBoolean()) {
                closeActivity(DeckPicker.RESULT_DB_ERROR);
            }

            dismissProgressBar();
            fullRefreshList();
        }

        @Override
        public void onProgressUpdate(DeckTask.TaskData... values) {
            //This decktask does not publish updates
        }
    };


    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                onBackPressed();
                return true;
            case R.id.action_add_new_model:
                addFieldDialog();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }


    public void closeActivity() {
        closeActivity(NORMAL_EXIT);
    }


    private void closeActivity(int reason) {
        switch (reason) {
            case NORMAL_EXIT:
                finishWithAnimation(ActivityTransitionAnimation.RIGHT);
                break;
            default:
                finishWithAnimation(ActivityTransitionAnimation.RIGHT);
                break;
        }
    }


    @Override
    public void onBackPressed() {
        closeActivity();
    }


    private MaterialDialog.ListCallback mContextMenuListener = new MaterialDialog.ListCallback() {
        @Override
        public void onSelection(MaterialDialog materialDialog, View view, int selection, CharSequence charSequence) {
            switch (selection) {
                case ModelEditorContextMenu.SORT_FIELD:
                    sortByField();
                    break;
                case ModelEditorContextMenu.FIELD_REPOSITION:
                    repositionFieldDialog();
                    break;
                case ModelEditorContextMenu.FIELD_DELETE:
                    deleteFieldDialog();
                    break;
                case ModelEditorContextMenu.FIELD_RENAME:
                    renameFieldDialog();
                    break;
            }
        }
    };
}/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.database.sqlite.SQLiteException;
import android.net.Uri;
import android.os.Bundle;
import android.support.v7.widget.Toolbar;
import android.view.KeyEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.async.Connection;
import com.ichi2.async.Connection.Payload;
import com.ichi2.themes.StyledProgressDialog;

import timber.log.Timber;

public class MyAccount extends AnkiActivity {
    private final static int STATE_LOG_IN  = 1;
    private final static int STATE_LOGGED_IN = 2;

    private View mLoginToMyAccountView;
    private View mLoggedIntoMyAccountView;

    private EditText mUsername;
    private EditText mPassword;

    private TextView mUsernameLoggedIn;

    private MaterialDialog mProgressDialog;
    Toolbar mToolbar = null;


    private void switchToState(int newState) {
        switch (newState) {
            case STATE_LOGGED_IN:
                String username = AnkiDroidApp.getSharedPrefs(getBaseContext()).getString("username", "");
                mUsernameLoggedIn.setText(username);
                mToolbar = (Toolbar) mLoggedIntoMyAccountView.findViewById(R.id.toolbar);
                if (mToolbar!= null) {
                    mToolbar.setTitle(getString(R.string.sync_account));  // This can be cleaned up if all three main layouts are guaranteed to share the same toolbar object
                    setSupportActionBar(mToolbar);
                }
                setContentView(mLoggedIntoMyAccountView);
                break;

            case STATE_LOG_IN:
                mToolbar = (Toolbar) mLoginToMyAccountView.findViewById(R.id.toolbar);
                if (mToolbar!= null) {
                    mToolbar.setTitle(getString(R.string.sync_account));  // This can be cleaned up if all three main layouts are guaranteed to share the same toolbar object
                    setSupportActionBar(mToolbar);
                }
                setContentView(mLoginToMyAccountView);
                break;
        }


        supportInvalidateOptionsMenu();  // Needed?
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mayOpenUrl(Uri.parse(getResources().getString(R.string.register_url)));
        initAllContentViews();

        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());
        if (preferences.getString("hkey", "").length() > 0) {
            switchToState(STATE_LOGGED_IN);
        } else {
            switchToState(STATE_LOG_IN);
        }
    }


    // Commented awaiting the resolution of the next issue: http://code.google.com/p/anki/issues/detail?id=1932
    // private boolean isUsernameAndPasswordValid(String username, String password) {
    // return isLoginFieldValid(username) && isLoginFieldValid(password);
    // }
    //
    //
    // private boolean isLoginFieldValid(String loginField) {
    // boolean loginFieldValid = false;
    //
    // if (loginField.length() >= 2 && loginField.matches("[A-Za-z0-9]+")) {
    // loginFieldValid = true;
    // }
    //
    // return loginFieldValid;
    // }

    private void saveUserInformation(String username, String hkey) {
        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());
        Editor editor = preferences.edit();
        editor.putString("username", username);
        editor.putString("hkey", hkey);
        editor.commit();
    }


    private void login() {
        // Hide soft keyboard
        InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
        inputMethodManager.hideSoftInputFromWindow(mUsername.getWindowToken(), 0);

        String username = mUsername.getText().toString().trim(); // trim spaces, issue 1586
        String password = mPassword.getText().toString();

        /*
         * Commented awaiting the resolution of the next issue: http://code.google.com/p/anki/issues/detail?id=1932
         * if(isUsernameAndPasswordValid(username, password)) { Connection.login(loginListener, new
         * Connection.Payload(new Object[] {username, password})); } else { mInvalidUserPassAlert.show(); }
         */

        if (!"".equalsIgnoreCase(username) && !"".equalsIgnoreCase(password)) {
            Connection.login(loginListener, new Connection.Payload(new Object[]{username, password}));
        } else {
            UIUtils.showSimpleSnackbar(this, R.string.invalid_username_password, true);
        }
    }


    private void logout() {
        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());
        Editor editor = preferences.edit();
        editor.putString("username", "");
        editor.putString("hkey", "");
        editor.commit();
        //  force media resync on deauth
        getCol().getMedia().forceResync();
        switchToState(STATE_LOG_IN);
    }


    private void resetPassword() {
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setData(Uri.parse(getResources().getString(R.string.resetpw_url)));
        startActivity(intent);
    }


    private void initAllContentViews() {
        mLoginToMyAccountView = getLayoutInflater().inflate(R.layout.my_account, null);
        mUsername = (EditText) mLoginToMyAccountView.findViewById(R.id.username);
        mPassword = (EditText) mLoginToMyAccountView.findViewById(R.id.password);

        Button loginButton = (Button) mLoginToMyAccountView.findViewById(R.id.login_button);
        loginButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                login();
            }

        });

        Button resetPWButton = (Button) mLoginToMyAccountView.findViewById(R.id.reset_password_button);
        resetPWButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                resetPassword();
            }
        });

        Button signUpButton = (Button) mLoginToMyAccountView.findViewById(R.id.sign_up_button);
        signUpButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                openUrl(Uri.parse(getResources().getString(R.string.register_url)));
            }

        });

        mLoggedIntoMyAccountView = getLayoutInflater().inflate(R.layout.my_account_logged_in, null);
        mUsernameLoggedIn = (TextView) mLoggedIntoMyAccountView.findViewById(R.id.username_logged_in);
        Button logoutButton = (Button) mLoggedIntoMyAccountView.findViewById(R.id.logout_button);
        logoutButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                logout();
            }

        });
    }


    /**
     * Listeners
     */
    Connection.TaskListener loginListener = new Connection.TaskListener() {

        @Override
        public void onProgressUpdate(Object... values) {
            // Pass
        }


        @Override
        public void onPreExecute() {
            Timber.d("loginListener.onPreExcecute()");
            if (mProgressDialog == null || !mProgressDialog.isShowing()) {
                mProgressDialog = StyledProgressDialog.show(MyAccount.this, "",
                        getResources().getString(R.string.alert_logging_message), false);
            }
        }


        @Override
        public void onPostExecute(Payload data) {
            if (mProgressDialog != null) {
                mProgressDialog.dismiss();
            }

            if (data.success) {
                Timber.i("User successfully logged in!");
                saveUserInformation((String) data.data[0], (String) data.data[1]);

                Intent i = MyAccount.this.getIntent();
                if (i.hasExtra("notLoggedIn") && i.getExtras().getBoolean("notLoggedIn", false)) {
                    MyAccount.this.setResult(RESULT_OK, i);
                    finishWithAnimation(ActivityTransitionAnimation.FADE);
                } else {
                    // Show logged view
                    mUsernameLoggedIn.setText((String) data.data[0]);
                    switchToState(STATE_LOGGED_IN);
                }
            } else {
                Timber.e("Login failed, error code %d",data.returnType);
                if (data.returnType == 403) {
                    UIUtils.showSimpleSnackbar(MyAccount.this, R.string.invalid_username_password, true);
                } else {
                    UIUtils.showSimpleSnackbar(MyAccount.this, R.string.connection_error_message, true);
                }
            }
        }


        @Override
        public void onDisconnected() {
            UIUtils.showSimpleSnackbar(MyAccount.this, R.string.youre_offline, true);
        }
    };


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
            Timber.i("MyAccount - onBackPressed()");
            finishWithAnimation(ActivityTransitionAnimation.FADE);
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }

}
/****************************************************************************************
 * Copyright (c) 2014 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/
package com.ichi2.anki;

import android.content.Intent;
import android.content.SharedPreferences;
import android.content.res.Configuration;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.support.design.widget.NavigationView;
import android.support.v4.view.GravityCompat;
import android.support.v4.view.MenuItemCompat;
import android.support.v4.widget.DrawerLayout;
import android.support.v7.app.ActionBarDrawerToggle;
import android.support.v7.widget.SwitchCompat;
import android.support.v7.widget.Toolbar;
import android.view.Gravity;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.CompoundButton;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.compat.CompatHelper;
import com.ichi2.themes.Themes;

import timber.log.Timber;


public class NavigationDrawerActivity extends AnkiActivity implements NavigationView.OnNavigationItemSelectedListener {

    /** Navigation Drawer */
    protected CharSequence mTitle;
    protected Boolean mFragmented = false;
    private boolean mNavButtonGoesBack = false;
    // Other members
    private String mOldColPath;
    private int mOldTheme;
    // Navigation drawer list item entries
    private DrawerLayout mDrawerLayout;
    private NavigationView mNavigationView;
    private ActionBarDrawerToggle mDrawerToggle;
    private SwitchCompat mNightModeSwitch;
    // Intent request codes
    public static final int REQUEST_PREFERENCES_UPDATE = 100;
    public static final int REQUEST_BROWSE_CARDS = 101;
    public static final int REQUEST_STATISTICS = 102;

    /**
     * runnable that will be executed after the drawer has been closed.
     */
    private Runnable pendingRunnable;

    // Navigation drawer initialisation
    protected void initNavigationDrawer(View mainView){
        // Create inherited navigation drawer layout here so that it can be used by parent class
        mDrawerLayout = (DrawerLayout) mainView.findViewById(R.id.drawer_layout);
        // set a custom shadow that overlays the main content when the drawer opens
        mDrawerLayout.setDrawerShadow(R.drawable.drawer_shadow, GravityCompat.START);
        mNavigationView = (NavigationView) mDrawerLayout.findViewById(R.id.navdrawer_items_container);
        mNavigationView.setNavigationItemSelectedListener(this);
        Toolbar toolbar = (Toolbar) mainView.findViewById(R.id.toolbar);
        if (toolbar != null) {
            setSupportActionBar(toolbar);
            // enable ActionBar app icon to behave as action to toggle nav drawer
            getSupportActionBar().setDisplayHomeAsUpEnabled(true);
            getSupportActionBar().setHomeButtonEnabled(true);

            // Decide which action to take when the navigation button is tapped.
            toolbar.setNavigationOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (mNavButtonGoesBack) {
                        finishWithAnimation(ActivityTransitionAnimation.RIGHT);
                    } else {
                        mDrawerLayout.openDrawer(Gravity.LEFT);
                    }
                }
            });
        }
        // Configure night-mode switch
        final SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(NavigationDrawerActivity.this);
        View actionLayout = MenuItemCompat.getActionView(mNavigationView.getMenu().findItem(R.id.nav_night_mode));
        mNightModeSwitch = (SwitchCompat) actionLayout.findViewById(R.id.switch_compat);
        mNightModeSwitch.setChecked(preferences.getBoolean("invertedColors", false));
        mNightModeSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            @Override
            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                if (isChecked) {
                    Timber.i("StudyOptionsFragment:: Night mode was enabled");
                    preferences.edit().putBoolean("invertedColors", true).commit();
                } else {
                    Timber.i("StudyOptionsFragment:: Night mode was disabled");
                    preferences.edit().putBoolean("invertedColors", false).commit();
                }
                CompatHelper.getCompat().restartActivityInvalidateBackstack(NavigationDrawerActivity.this);
            }
        });
        // ActionBarDrawerToggle ties together the the proper interactions
        // between the sliding drawer and the action bar app icon
        mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout, 0, 0) {
            @Override
            public void onDrawerClosed(View drawerView) {
                super.onDrawerClosed(drawerView);
                supportInvalidateOptionsMenu();

                if(pendingRunnable != null) {
                    new Handler().post(pendingRunnable);
                    pendingRunnable = null;
                }
            }


            @Override
            public void onDrawerOpened(View drawerView) {
                super.onDrawerOpened(drawerView);
                supportInvalidateOptionsMenu();
            }
        };

        mDrawerLayout.addDrawerListener(mDrawerToggle);
    }



    /** Sets selected navigation drawer item */
    protected void selectNavigationItem(int itemId) {
        if (mNavigationView == null) {
            Timber.e("Could not select item in navigation drawer as NavigationView null");
            return;
        }
        Menu menu = mNavigationView.getMenu();
        if (itemId == -1) {
            for (int i = 0; i < menu.size(); i++) {
                menu.getItem(i).setChecked(false);
            }
        } else {
            MenuItem item = menu.findItem(itemId);
            if (item != null) {
                item.setChecked(true);
            } else {
                Timber.e("Could not find item %d", itemId);
            }
        }
    }



    @Override
    public void setTitle(CharSequence title) {
        mTitle = title;
        if (getSupportActionBar() != null) {
            getSupportActionBar().setTitle(mTitle);
        }
    }

    /**
     * When using the ActionBarDrawerToggle, you must call it during
     * onPostCreate() and onConfigurationChanged()...
     */

    @Override
    protected void onPostCreate(Bundle savedInstanceState) {
        super.onPostCreate(savedInstanceState);
        // Sync the toggle state after onRestoreInstanceState has occurred.
        if (mDrawerToggle != null) {
            mDrawerToggle.syncState();
        }
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        // Pass any configuration change to the drawer toggles
        if (mDrawerToggle != null) {
            mDrawerToggle.onConfigurationChanged(newConfig);
        }
    }


    public ActionBarDrawerToggle getDrawerToggle() {
        return mDrawerToggle;
    }

    /**
     * This function locks the navigation drawer closed in regards to swipes,
     * but continues to allowed it to be opened via it's indicator button. This
     * function in a noop if the drawer hasn't been initialized.
     */
    protected void disableDrawerSwipe() {
        if (mDrawerLayout != null) {
            mDrawerLayout.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED);
        }
    }

    /**
     * This function allows swipes to open the navigation drawer. This
     * function in a noop if the drawer hasn't been initialized.
     */
    protected void enableDrawerSwipe() {
        if (mDrawerLayout != null) {
            mDrawerLayout.setDrawerLockMode(DrawerLayout.LOCK_MODE_UNLOCKED);
        }
    }


    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(this);
        // Update language
        AnkiDroidApp.setLanguage(preferences.getString(Preferences.LANGUAGE, ""));
        // Restart the activity on preference change
        if (requestCode == REQUEST_PREFERENCES_UPDATE) {
            if (mOldColPath!=null && CollectionHelper.getCurrentAnkiDroidDirectory(this).equals(mOldColPath)) {
                // collection path hasn't been changed so just restart the current activity
                if ((this instanceof Reviewer) && preferences.getBoolean("tts", false)) {
                    // Workaround to kick user back to StudyOptions after opening settings from Reviewer
                    // because onDestroy() of old Activity interferes with TTS in new Activity
                    finishWithoutAnimation();
                } else if (mOldTheme != Themes.getCurrentTheme(getApplicationContext())) {
                    // The current theme was changed, so need to reload the stack with the new theme
                    CompatHelper.getCompat().restartActivityInvalidateBackstack(NavigationDrawerActivity.this);
                } else {
                    restartActivity();
                }
            } else {
                // collection path has changed so kick the user back to the DeckPicker
                CollectionHelper.getInstance().closeCollection(true);
                CompatHelper.getCompat().restartActivityInvalidateBackstack(this);
            }
        } else {
            super.onActivityResult(requestCode, resultCode, data);
        }
    }


    @Override
    public void onBackPressed() {
        if (isDrawerOpen()) {
            Timber.i("Back key pressed");
            mDrawerLayout.closeDrawers();
        } else {
            super.onBackPressed();
        }
    }

    @Override
    public boolean onNavigationItemSelected(final MenuItem item) {
        // Don't do anything if user selects already selected position
        if (item.isChecked()) {
            return true;
        }

        /*
         * This runnable will be executed in onDrawerClosed(...)
         * to make the animation more fluid on older devices.
         */
        pendingRunnable = new Runnable() {
            @Override
            public void run() {
                // Take action if a different item selected
                switch (item.getItemId()) {
                    case R.id.nav_decks:
                        Intent deckPicker = new Intent(NavigationDrawerActivity.this, DeckPicker.class);
                        deckPicker.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);    // opening DeckPicker should clear back history
                        startActivityWithAnimation(deckPicker, ActivityTransitionAnimation.RIGHT);
                        break;
                    case R.id.nav_browser:
                        openCardBrowser();
                        break;
                    case R.id.nav_stats:
                        Intent intent = new Intent(NavigationDrawerActivity.this, Statistics.class);
                        intent.putExtra("selectedDeck", getCol().getDecks().selected());
                        startActivityForResultWithAnimation(intent, REQUEST_STATISTICS, ActivityTransitionAnimation.LEFT);
                        break;
                    case R.id.nav_night_mode:
                        mNightModeSwitch.performClick();
                        break;
                    case R.id.nav_settings:
                        mOldColPath = CollectionHelper.getCurrentAnkiDroidDirectory(NavigationDrawerActivity.this);
                        // Remember the theme we started with so we can restart the Activity if it changes
                        mOldTheme = Themes.getCurrentTheme(getApplicationContext());
                        startActivityForResultWithAnimation(new Intent(NavigationDrawerActivity.this, Preferences.class), REQUEST_PREFERENCES_UPDATE, ActivityTransitionAnimation.FADE);
                        break;
                    case R.id.nav_help:
                        openUrl(Uri.parse(AnkiDroidApp.getManualUrl()));
                        break;
                    case R.id.nav_feedback:
                        openUrl(Uri.parse(AnkiDroidApp.getFeedbackUrl()));
                        break;
                    default:
                        break;
                }
            }
        };

        mDrawerLayout.closeDrawers();
        return true;
    }

    /**
     * Open the card browser. Override this method to pass it custom arguments
     */
    protected void openCardBrowser() {
        Intent cardBrowser = new Intent(this, CardBrowser.class);
        cardBrowser.putExtra("selectedDeck", getCol().getDecks().selected());
        startActivityForResultWithAnimation(cardBrowser, REQUEST_BROWSE_CARDS, ActivityTransitionAnimation.LEFT);
    }

    protected void showBackIcon() {
        if (mDrawerToggle != null) {
            mDrawerToggle.setDrawerIndicatorEnabled(false);
        }
        if (getSupportActionBar() != null) {
            getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        }
        mNavButtonGoesBack = true;
    }

    public boolean isDrawerOpen() {
        return mDrawerLayout.isDrawerOpen(GravityCompat.START);
    }
}/***************************************************************************************
 *                                                                                      *
 * Copyright (c) 2012 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2014 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.res.Resources;
import android.graphics.PorterDuff;
import android.graphics.Typeface;
import android.os.Bundle;
import android.support.v4.content.ContextCompat;
import android.support.v7.widget.PopupMenu;
import android.support.v7.widget.PopupMenu.OnMenuItemClickListener;
import android.support.v7.widget.Toolbar;
import android.text.Editable;
import android.text.Html;
import android.text.TextUtils;
import android.text.TextWatcher;

import android.util.Pair;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.WindowManager;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.widget.ArrayAdapter;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.Spinner;
import android.widget.TextView;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.dialogs.NoteEditorRescheduleCard;
import com.ichi2.anki.dialogs.ConfirmationDialog;
import com.ichi2.anki.dialogs.TagsDialog;
import com.ichi2.anki.dialogs.TagsDialog.TagsDialogListener;
import com.ichi2.anki.exception.ConfirmModSchemaException;
import com.ichi2.anki.multimediacard.IMultimediaEditableNote;
import com.ichi2.anki.multimediacard.activity.MultimediaEditFieldActivity;
import com.ichi2.anki.multimediacard.fields.AudioField;
import com.ichi2.anki.multimediacard.fields.EFieldType;
import com.ichi2.anki.multimediacard.fields.IField;
import com.ichi2.anki.multimediacard.fields.ImageField;
import com.ichi2.anki.multimediacard.fields.TextField;
import com.ichi2.anki.multimediacard.impl.MultimediaEditableNote;
import com.ichi2.anki.receiver.SdCardReceiver;
import com.ichi2.anki.servicelayer.NoteService;
import com.ichi2.async.DeckTask;
import com.ichi2.libanki.Card;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Note;
import com.ichi2.libanki.Utils;
import com.ichi2.themes.StyledProgressDialog;
import com.ichi2.themes.Themes;
import com.ichi2.anki.widgets.PopupMenuWithIcons;
import com.ichi2.widget.WidgetStatus;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import timber.log.Timber;

/**
 * Allows the user to edit a fact, for instance if there is a typo. A card is a presentation of a fact, and has two
 * sides: a question and an answer. Any number of fields can appear on each side. When you add a fact to Anki, cards
 * which show that fact are generated. Some models generate one card, others generate more than one.
 *
 * @see <a href="http://ankisrs.net/docs/manual.html#cards">the Anki Desktop manual</a>
 */
public class NoteEditor extends AnkiActivity {

//    public static final String SOURCE_LANGUAGE = "SOURCE_LANGUAGE";
//    public static final String TARGET_LANGUAGE = "TARGET_LANGUAGE";
    public static final String SOURCE_TEXT = "SOURCE_TEXT";
    public static final String TARGET_TEXT = "TARGET_TEXT";
    public static final String EXTRA_CALLER = "CALLER";
    public static final String EXTRA_CARD_ID = "CARD_ID";
    public static final String EXTRA_CONTENTS = "CONTENTS";
    public static final String EXTRA_ID = "ID";

    private static final String ACTION_CREATE_FLASHCARD = "org.openintents.action.CREATE_FLASHCARD";
    private static final String ACTION_CREATE_FLASHCARD_SEND = "android.intent.action.SEND";

    // calling activity
    public static final int CALLER_NOCALLER = 0;

    public static final int CALLER_REVIEWER = 1;
    public static final int CALLER_STUDYOPTIONS = 2;
    public static final int CALLER_DECKPICKER = 3;
    public static final int CALLER_REVIEWER_ADD = 11;

    public static final int CALLER_CARDBROWSER_EDIT = 6;
    public static final int CALLER_CARDBROWSER_ADD = 7;

    public static final int CALLER_CARDEDITOR = 8;
    public static final int CALLER_CARDEDITOR_INTENT_ADD = 10;

    public static final int REQUEST_ADD = 0;
    public static final int REQUEST_MULTIMEDIA_EDIT = 2;
    public static final int REQUEST_TEMPLATE_EDIT = 3;

    private boolean mChanged = false;
    private boolean mTagsEdited = false;
    private boolean mFieldEdited = false;

    /**
     * Flag which forces the calling activity to rebuild it's definition of current card from scratch
     */
    private boolean mReloadRequired = false;


    /**
     * Broadcast that informs us when the sd card is about to be unmounted
     */
    private BroadcastReceiver mUnmountReceiver = null;

    private LinearLayout mFieldsLayoutContainer;

    private TextView mTagsButton;
    private TextView mCardsButton;
    private Spinner mNoteTypeSpinner;
    private Spinner mNoteDeckSpinner;

    private Note mEditorNote;
    public static Card mCurrentEditedCard;
    private List<String> mSelectedTags;
    private long mCurrentDid;
    private ArrayList<Long> mAllDeckIds;
    private ArrayList<Long> mAllModelIds;
    private Map<Integer, Integer> mModelChangeFieldMap;
    private Map<Integer, Integer> mModelChangeCardMap;

    /* indicates if a new fact is added or a card is edited */
    private boolean mAddNote;

    private boolean mAedictIntent;

    /* indicates which activity called Note Editor */
    private int mCaller;

    private LinkedList<FieldEditText> mEditFields;

    private MaterialDialog mProgressDialog;

    private String[] mSourceText;


    // A bundle that maps field ords to the text content of that field for use in
    // restoring the Activity.
    private Bundle mSavedFields;

    private DeckTask.TaskListener mSaveFactHandler = new DeckTask.TaskListener() {
        private boolean mCloseAfter = false;
        private Intent mIntent;


        @Override
        public void onPreExecute() {
            Resources res = getResources();
            mProgressDialog = StyledProgressDialog
                    .show(NoteEditor.this, "", res.getString(R.string.saving_facts), false);
        }


        @Override
        public void onProgressUpdate(DeckTask.TaskData... values) {
            int count = values[0].getInt();
            if (count > 0) {
                mChanged = true;
                mSourceText = null;
                Note oldNote = mEditorNote.clone();
                setNote();
                // Respect "Remember last input when adding" field option.
                JSONArray flds;
                try {
                    flds = mEditorNote.model().getJSONArray("flds");
                    if (oldNote != null) {
                        for (int fldIdx = 0; fldIdx < flds.length(); fldIdx++) {
                            if (flds.getJSONObject(fldIdx).getBoolean("sticky")) {
                                mEditFields.get(fldIdx).setText(oldNote.getFields()[fldIdx]);
                            }
                        }
                    }
                } catch (JSONException e) {
                    throw new RuntimeException();
                }
                UIUtils.showThemedToast(NoteEditor.this,
                        getResources().getQuantityString(R.plurals.factadder_cards_added, count, count), true);
            } else {
                UIUtils.showThemedToast(NoteEditor.this, getResources().getString(R.string.factadder_saving_error), true);
            }
            if (!mAddNote || mCaller == CALLER_CARDEDITOR || mAedictIntent) {
                mChanged = true;
                mCloseAfter = true;
            } else if (mCaller == CALLER_CARDEDITOR_INTENT_ADD) {
                if (count > 0) {
                    mChanged = true;
                }
                mCloseAfter = true;
                mIntent = new Intent();
                mIntent.putExtra(EXTRA_ID, getIntent().getStringExtra(EXTRA_ID));
            } else if (!mEditFields.isEmpty()) {
                mEditFields.getFirst().requestFocus();
            }
            if (!mCloseAfter) {
                if (mProgressDialog != null && mProgressDialog.isShowing()) {
                    try {
                        mProgressDialog.dismiss();
                    } catch (IllegalArgumentException e) {
                        Timber.e(e, "Note Editor: Error on dismissing progress dialog");
                    }
                }
            }
        }


        @Override
        public void onPostExecute(DeckTask.TaskData result) {
            if (result.getBoolean()) {
                if (mProgressDialog != null && mProgressDialog.isShowing()) {
                    try {
                        mProgressDialog.dismiss();
                    } catch (IllegalArgumentException e) {
                        Timber.e(e, "Note Editor: Error on dismissing progress dialog");
                    }
                }
                if (mCloseAfter) {
                    if (mIntent != null) {
                        closeNoteEditor(mIntent);
                    } else {
                        closeNoteEditor();
                    }
                } else {
                    // Reset check for changes to fields
                    mFieldEdited = false;
                    mTagsEdited = false;
                }
            } else {
                // RuntimeException occured on adding note
                closeNoteEditor(DeckPicker.RESULT_DB_ERROR);
            }
        }


        @Override
        public void onCancelled() {
        }
    };


    // ----------------------------------------------------------------------------
    // ANDROID METHODS
    // ----------------------------------------------------------------------------

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Timber.d("onCreate()");
        super.onCreate(savedInstanceState);
        setContentView(R.layout.note_editor);
        Intent intent = getIntent();
        if (savedInstanceState != null) {
            mCaller = savedInstanceState.getInt("caller");
            mAddNote = savedInstanceState.getBoolean("addFact");
            mCurrentDid = savedInstanceState.getLong("did");
            mSelectedTags = new ArrayList<>(Arrays.asList(savedInstanceState.getStringArray("tags")));
            mSavedFields = savedInstanceState.getBundle("editFields");
        } else {
            mCaller = intent.getIntExtra(EXTRA_CALLER, CALLER_NOCALLER);
            if (mCaller == CALLER_NOCALLER) {
                String action = intent.getAction();
                if (action != null
                        && (ACTION_CREATE_FLASHCARD.equals(action) || ACTION_CREATE_FLASHCARD_SEND.equals(action))) {
                    mCaller = CALLER_CARDEDITOR_INTENT_ADD;
                }
            }
        }

        startLoadingCollection();
    }

    @Override
    protected void onSaveInstanceState(Bundle savedInstanceState) {
        Timber.i("Saving instance");
        savedInstanceState.putInt("caller", mCaller);
        savedInstanceState.putBoolean("addFact", mAddNote);
        savedInstanceState.putLong("did", mCurrentDid);
        savedInstanceState.putStringArray("tags", mSelectedTags.toArray(new String[mSelectedTags.size()]));
        Bundle fields = new Bundle();
        // Save the content of all the note fields. We use the field's ord as the key to
        // easily map the fields correctly later.
        for (FieldEditText e : mEditFields) {
            fields.putString(Integer.toString(e.getOrd()), e.getText().toString());
        }
        savedInstanceState.putBundle("editFields", fields);
        super.onSaveInstanceState(savedInstanceState);
    }

    // Finish initializing the activity after the collection has been correctly loaded
    @Override
    protected void onCollectionLoaded(Collection col) {
        super.onCollectionLoaded(col);
        this.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);

        Intent intent = getIntent();
        Timber.d("onCollectionLoaded: caller: %d", mCaller);

        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());

        registerExternalStorageListener();

        View mainView = findViewById(android.R.id.content);

        Toolbar toolbar = (Toolbar) mainView.findViewById(R.id.toolbar);
        if (toolbar != null) {
            setSupportActionBar(toolbar);
        }

        mFieldsLayoutContainer = (LinearLayout) findViewById(R.id.CardEditorEditFieldsLayout);

        mTagsButton = (TextView) findViewById(R.id.CardEditorTagText);
        mCardsButton = (TextView) findViewById(R.id.CardEditorCardsText);
        mCardsButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Timber.i("NoteEditor:: Cards button pressed. Opening template editor");
                showCardTemplateEditor();
            }
        });


        mAedictIntent = false;

        switch (mCaller) {
            case CALLER_NOCALLER:
                Timber.e("no caller could be identified, closing");
                finishWithoutAnimation();
                return;

            case CALLER_REVIEWER:
                mCurrentEditedCard = AbstractFlashcardViewer.getEditorCard();
                if (mCurrentEditedCard == null) {
                    finishWithoutAnimation();
                    return;
                }
                mEditorNote = mCurrentEditedCard.note();
                mAddNote = false;
                break;

            case CALLER_STUDYOPTIONS:
            case CALLER_DECKPICKER:
            case CALLER_REVIEWER_ADD:
                mAddNote = true;
                break;

            case CALLER_CARDBROWSER_EDIT:
                mCurrentEditedCard = CardBrowser.sCardBrowserCard;
                if (mCurrentEditedCard == null) {
                    finishWithoutAnimation();
                    return;
                }
                mEditorNote = mCurrentEditedCard.note();
                mAddNote = false;
                break;

            case CALLER_CARDBROWSER_ADD:
                mAddNote = true;
                break;

            case CALLER_CARDEDITOR:
                mAddNote = true;
                break;

            case CALLER_CARDEDITOR_INTENT_ADD:
                fetchIntentInformation(intent);
                if (mSourceText == null) {
                    finishWithoutAnimation();
                    return;
                }
                if (mSourceText[0].equals("Aedict Notepad") && addFromAedict(mSourceText[1])) {
                    finishWithoutAnimation();
                    return;
                }
                mAddNote = true;
                break;
        }

        // Note type Selector
        mNoteTypeSpinner = (Spinner) findViewById(R.id.note_type_spinner);
        mAllModelIds = new ArrayList<>();
        final ArrayList<String> modelNames = new ArrayList<>();
        ArrayList<JSONObject> models = getCol().getModels().all();
        Collections.sort(models, new JSONNameComparator());
        for (JSONObject m : models) {
            try {
                modelNames.add(m.getString("name"));
                mAllModelIds.add(m.getLong("id"));
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }

        ArrayAdapter<String> noteTypeAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, modelNames);
        mNoteTypeSpinner.setAdapter(noteTypeAdapter);
        noteTypeAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);


        // Deck Selector
        TextView deckTextView = (TextView) findViewById(R.id.CardEditorDeckText);
        // If edit mode and more than one card template distinguish between "Deck" and "Card deck"
        try {
            if (!mAddNote && mEditorNote.model().getJSONArray("tmpls").length()>1) {
                deckTextView.setText(R.string.CardEditorCardDeck);
            }
        } catch (JSONException e1) {
            throw new RuntimeException();
        }
        mNoteDeckSpinner = (Spinner) findViewById(R.id.note_deck_spinner);
        mAllDeckIds = new ArrayList<>();
        final ArrayList<String> deckNames = new ArrayList<>();

        ArrayList<JSONObject> decks = getCol().getDecks().all();
        Collections.sort(decks, new JSONNameComparator());
        for (JSONObject d : decks) {
            try {
                // add current deck and all other non-filtered decks to deck list
                long thisDid = d.getLong("id");
                long currentDid = getCol().getDecks().current().getLong("id");
                if (d.getInt("dyn") == 0 || (!mAddNote && thisDid == currentDid)) {
                    deckNames.add(d.getString("name"));
                    mAllDeckIds.add(thisDid);
                }
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }

        ArrayAdapter<String> noteDeckAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, deckNames);
        mNoteDeckSpinner.setAdapter(noteDeckAdapter);
        noteDeckAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mNoteDeckSpinner.setOnItemSelectedListener(new OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {
                // Timber.i("NoteEditor:: onItemSelected() fired on mNoteDeckSpinner with pos = "+Integer.toString(pos));
                mCurrentDid = mAllDeckIds.get(pos);
            }

            @Override
            public void onNothingSelected(AdapterView<?> parent) {
                // Do Nothing
            }
        });

        setDid(mEditorNote);

        setNote(mEditorNote);

        // Set current note type and deck positions in spinners
        int position;
        try {
            position = mAllModelIds.indexOf(mEditorNote.model().getLong("id"));
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        // set selection without firing selectionChanged event
        // nb: setOnItemSelectedListener needs to occur after this
        mNoteTypeSpinner.setSelection(position, false);

        if (mAddNote) {
            mNoteTypeSpinner.setOnItemSelectedListener(new SetNoteTypeListener());
            setTitle(R.string.cardeditor_title_add_note);
            // set information transferred by intent
            String contents = null;
            if (mSourceText != null) {
                if (mAedictIntent && (mEditFields.size() == 3) && mSourceText[1].contains("[")) {
                    contents = mSourceText[1].replaceFirst("\\[", "\u001f" + mSourceText[0] + "\u001f");
                    contents = contents.substring(0, contents.length() - 1);
                } else if (mEditFields.size() > 0) {
                    mEditFields.get(0).setText(mSourceText[0]);
                    if (mEditFields.size() > 1) {
                        mEditFields.get(1).setText(mSourceText[1]);
                    }
                }
            } else {
                contents = intent.getStringExtra(EXTRA_CONTENTS);
            }
            if (contents != null) {
                setEditFieldTexts(contents);
            }
        } else {
            mNoteTypeSpinner.setOnItemSelectedListener(new EditNoteTypeListener());
            setTitle(R.string.cardeditor_title_edit_card);
        }


        findViewById(R.id.CardEditorTagButton).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Timber.i("NoteEditor:: Tags button pressed... opening tags editor");
                showTagsDialog();
            }
        });

        if (!mAddNote && mCurrentEditedCard != null) {
            Timber.i("NoteEditor:: Edit note activity successfully started with card id %d", mCurrentEditedCard.getId());
        }
    }


    @Override
    protected void onStop() {
        super.onStop();
        if (!isFinishing()) {
            WidgetStatus.update(this);
            UIUtils.saveCollectionInBackground(this);
        }
    }


    private void fetchIntentInformation(Intent intent) {
        Bundle extras = intent.getExtras();
        if (ACTION_CREATE_FLASHCARD.equals(intent.getAction())) {
            // mSourceLanguage = extras.getString(SOURCE_LANGUAGE);
            // mTargetLanguage = extras.getString(TARGET_LANGUAGE);
            mSourceText = new String[2];
            mSourceText[0] = extras.getString(SOURCE_TEXT);
            mSourceText[1] = extras.getString(TARGET_TEXT);
        } else {
            String first;
            String second;
            if (extras.getString(Intent.EXTRA_SUBJECT) != null) {
                first = extras.getString(Intent.EXTRA_SUBJECT);
            } else {
                first = "";
            }
            if (extras.getString(Intent.EXTRA_TEXT) != null) {
                second = extras.getString(Intent.EXTRA_TEXT);
            } else {
                second = "";
            }
            // Some users add cards via SEND intent from clipboard. In this case SUBJECT is empty
            if (first.equals("")) {
                // Assume that if only one field was sent then it should be the front
                first = second;
                second = "";
            }
            Pair<String, String> messages = new Pair<>(first, second);

            mSourceText = new String[2];
            mSourceText[0] = messages.first;
            mSourceText[1] = messages.second;
        }
    }


    private boolean addFromAedict(String extra_text) {
        String category = "";
        String[] notepad_lines = extra_text.split("\n");
        for (int i = 0; i < notepad_lines.length; i++) {
            if (notepad_lines[i].startsWith("[") && notepad_lines[i].endsWith("]")) {
                category = notepad_lines[i].substring(1, notepad_lines[i].length() - 1);
                if (category.equals("default")) {
                    if (notepad_lines.length > i + 1) {
                        String[] entry_lines = notepad_lines[i + 1].split(":");
                        if (entry_lines.length > 1) {
                            mSourceText[0] = entry_lines[1];
                            mSourceText[1] = entry_lines[0];
                            mAedictIntent = true;
                        } else {
                            UIUtils.showThemedToast(NoteEditor.this,
                                    getResources().getString(R.string.intent_aedict_empty), false);
                            return true;
                        }
                    } else {
                        UIUtils.showThemedToast(NoteEditor.this, getResources().getString(R.string.intent_aedict_empty),
                                false);
                        return true;
                    }
                    return false;
                }
            }
        }
        UIUtils.showThemedToast(NoteEditor.this, getResources().getString(R.string.intent_aedict_category), false);
        return true;
    }


    private void resetEditFields(String[] content) {
        for (int i = 0; i < Math.min(content.length, mEditFields.size()); i++) {
            mEditFields.get(i).setText(content[i]);
        }
    }


    private boolean hasUnsavedChanges() {
        // changed note type?
        if (!mAddNote) {
            final JSONObject newModel = getCurrentlySelectedModel();
            final JSONObject oldModel = mCurrentEditedCard.model();
            if (!newModel.equals(oldModel)) {
                return true;
            }
        }
        // changed deck?
        if (!mAddNote && mCurrentEditedCard!= null && mCurrentEditedCard.getDid() != mCurrentDid) {
            return true;
        }
        // changed fields?
        if (mFieldEdited) {
            return true;
        }
        // changed tags?
        if (mTagsEdited) {
            return true;
        }
        return false;
    }


    private void saveNote() {
        final Resources res = getResources();
        if (mSelectedTags == null) {
            mSelectedTags = new ArrayList<>();
        }
        // treat add new note and edit existing note independently
        if (mAddNote) {
            // load all of the fields into the note
            for (FieldEditText f : mEditFields) {
                updateField(f);
            }
            try {
                // Save deck to model
                mEditorNote.model().put("did", mCurrentDid);
                // Save tags to model
                mEditorNote.setTagsFromStr(tagsAsString(mSelectedTags));
                JSONArray ja = new JSONArray();
                for (String t : mSelectedTags) {
                    ja.put(t);
                }
                getCol().getModels().current().put("tags", ja);
                getCol().getModels().setChanged();
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ADD_FACT, mSaveFactHandler, new DeckTask.TaskData(mEditorNote));
        } else {
            // Check whether note type has been changed
            final JSONObject newModel = getCurrentlySelectedModel();
            final JSONObject oldModel = mCurrentEditedCard.model();
            if (!newModel.equals(oldModel)) {
                mReloadRequired = true;
                if (mModelChangeCardMap.size() < mEditorNote.cards().size() || mModelChangeCardMap.containsKey(null)) {
                    // If cards will be lost via the new mapping then show a confirmation dialog before proceeding with the change
                    ConfirmationDialog dialog = new ConfirmationDialog ();
                    dialog.setArgs(res.getString(R.string.confirm_map_cards_to_nothing));
                    Runnable confirm = new Runnable() {
                        @Override
                        public void run() {
                            // Bypass the check once the user confirms
                            changeNoteTypeWithErrorHandling(oldModel, newModel);
                        }
                    };
                    dialog.setConfirm(confirm);
                    showDialogFragment(dialog);
                } else {
                    // Otherwise go straight to changing note type
                    changeNoteTypeWithErrorHandling(oldModel, newModel);
                }
                return;
            }
            // Regular changes in note content
            boolean modified = false;
            // changed did? this has to be done first as remFromDyn() involves a direct write to the database
            if (mCurrentEditedCard.getDid() != mCurrentDid) {
                mReloadRequired = true;
                // remove card from filtered deck first (if relevant)
                getCol().getSched().remFromDyn(new long[] { mCurrentEditedCard.getId() });
                // refresh the card object to reflect the database changes in remFromDyn()
                mCurrentEditedCard.load();
                // also reload the note object
                mEditorNote = mCurrentEditedCard.note();
                // then set the card ID to the new deck
                mCurrentEditedCard.setDid(mCurrentDid);
                modified = true;
            }
            // now load any changes to the fields from the form
            for (FieldEditText f : mEditFields) {
                modified = modified | updateField(f);
            }
            // added tag?
            for (String t : mSelectedTags) {
                modified = modified || !mEditorNote.hasTag(t);
            }
            // removed tag?
            modified = modified || mEditorNote.getTags().size() > mSelectedTags.size();
            if (modified) {
                mEditorNote.setTagsFromStr(tagsAsString(mSelectedTags));
                // set a flag so that changes to card object will be written to DB later via onActivityResult() in
                // CardBrowser
                mChanged = true;
            }
            closeNoteEditor();
        }
    }

    /**
     * Change the note type from oldModel to newModel, handling the case where a full sync will be required
     * @param oldModel
     * @param newModel
     */
    private void changeNoteTypeWithErrorHandling(final JSONObject oldModel, final JSONObject newModel) {
        Resources res = getResources();
        try {
            changeNoteType(oldModel, newModel);
        } catch (ConfirmModSchemaException e) {
            // Libanki has determined we should ask the user to confirm first
            ConfirmationDialog dialog = new ConfirmationDialog();
            dialog.setArgs(res.getString(R.string.full_sync_confirmation));
            Runnable confirm = new Runnable() {
                @Override
                public void run() {
                    // Bypass the check once the user confirms
                    getCol().modSchemaNoCheck();
                    try {
                        changeNoteType(oldModel, newModel);
                    } catch (ConfirmModSchemaException e2) {
                        // This should never be reached as we explicitly called modSchemaNoCheck()
                        throw new RuntimeException(e2);
                    }
                }
            };
            dialog.setConfirm(confirm);
            showDialogFragment(dialog);
        }
    }

    /**
     * Change the note type from oldModel to newModel, throwing ConfirmModSchemaException if a full sync will be required
     * @param oldModel
     * @param newModel
     * @throws ConfirmModSchemaException
     */
    private void changeNoteType(JSONObject oldModel, JSONObject newModel) throws ConfirmModSchemaException {
        final long [] nids = {mEditorNote.getId()};
        getCol().getModels().change(oldModel, nids, newModel, mModelChangeFieldMap, mModelChangeCardMap);
        // refresh the note object to reflect the database changes
        mEditorNote.load();
        // close note editor
        closeNoteEditor();
    }


    @Override
    public void onBackPressed() {
        Timber.i("NoteEditor:: onBackPressed()");
        closeCardEditorWithCheck();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mUnmountReceiver != null) {
            unregisterReceiver(mUnmountReceiver);
        }
    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.note_editor, menu);
        if (mAddNote) {
            menu.findItem(R.id.action_copy_card).setVisible(false);
        } else {
            menu.findItem(R.id.action_add_card_from_card_editor).setVisible(true);
            menu.findItem(R.id.action_reset_card_progress).setVisible(true);
            menu.findItem(R.id.action_reschedule_card).setVisible(true);
            menu.findItem(R.id.action_reset_card_progress).setVisible(true);
        }
        if (mEditFields != null) {
            for (int i = 0; i < mEditFields.size(); i++) {
                if (mEditFields.get(i).getText().length() > 0) {
                    menu.findItem(R.id.action_copy_card).setEnabled(true);
                    break;
                } else if (i == mEditFields.size() - 1) {
                    menu.findItem(R.id.action_copy_card).setEnabled(false);
                }
            }
        }
        return super.onCreateOptionsMenu(menu);
    }


    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        Resources res = getResources();
        switch (item.getItemId()) {
            case android.R.id.home:
                Timber.i("NoteEditor:: Home button pressed");
                closeCardEditorWithCheck();
                return true;

            case R.id.action_save:
                Timber.i("NoteEditor:: Save note button pressed");
                saveNote();
                return true;

            case R.id.action_add_card_from_card_editor:
            case R.id.action_copy_card:
                Timber.i("NoteEditor:: Copy or add card button pressed");
                Intent intent = new Intent(NoteEditor.this, NoteEditor.class);
                intent.putExtra(EXTRA_CALLER, CALLER_CARDEDITOR);
                // intent.putExtra(EXTRA_DECKPATH, mDeckPath);
                if (item.getItemId() == R.id.action_copy_card) {
                    intent.putExtra(EXTRA_CONTENTS, getFieldsText());
                }
                startActivityForResultWithAnimation(intent, REQUEST_ADD, ActivityTransitionAnimation.LEFT);
                return true;

            case R.id.action_reset_card_progress: {
                Timber.i("NoteEditor:: Reset progress button pressed");
                // Show confirmation dialog before resetting card progress
                ConfirmationDialog dialog = new ConfirmationDialog();
                String title = res.getString(R.string.reset_card_dialog_title);
                String message = res.getString(R.string.reset_card_dialog_message);
                dialog.setArgs(title, message);
                Runnable confirm = new Runnable() {
                    @Override
                    public void run() {
                        Timber.i("NoteEditor:: OK button pressed");
                        getCol().getSched().forgetCards(new long[]{mCurrentEditedCard.getId()});
                        getCol().reset();
                        mReloadRequired = true;
                        UIUtils.showThemedToast(NoteEditor.this,
                                getResources().getString(R.string.reset_card_dialog_acknowledge), true);
                    }
                };
                dialog.setConfirm(confirm);
                showDialogFragment(dialog);
                return true;
            }
            case R.id.action_reschedule_card:
                Timber.i("NoteEditor:: Reschedule button pressed");
                showDialogFragment(NoteEditorRescheduleCard.newInstance());
                return true;

            default:
                return super.onOptionsItemSelected(item);

        }
    }


    // ----------------------------------------------------------------------------
    // CUSTOM METHODS
    // ----------------------------------------------------------------------------

    /**
     * finish when sd card is ejected
     */
    private void registerExternalStorageListener() {
        if (mUnmountReceiver == null) {
            mUnmountReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    if (intent.getAction().equals(SdCardReceiver.MEDIA_EJECT)) {
                        finishWithoutAnimation();
                    }
                }
            };
            IntentFilter iFilter = new IntentFilter();
            iFilter.addAction(SdCardReceiver.MEDIA_EJECT);
            registerReceiver(mUnmountReceiver, iFilter);
        }
    }


    private void closeCardEditorWithCheck() {
        if (hasUnsavedChanges()) {
           showDiscardChangesDialog();
        } else {
            closeNoteEditor();
        }
    }


    private void showDiscardChangesDialog() {
        new MaterialDialog.Builder(this)
                .content(R.string.discard_unsaved_changes)
                .positiveText(R.string.dialog_ok)
                .negativeText(R.string.dialog_cancel)
                .callback(new MaterialDialog.ButtonCallback() {
                    @Override
                    public void onPositive(MaterialDialog dialog) {
                        Timber.i("NoteEditor:: OK button pressed to confirm discard changes");
                        closeNoteEditor();
                    }
                })
                .build().show();
    }


    private void closeNoteEditor() {
        closeNoteEditor(null);
    }


    private void closeNoteEditor(Intent intent) {
        int result;
        if (mChanged) {
            result = RESULT_OK;
        } else {
            result = RESULT_CANCELED;
        }
        if (mReloadRequired) {
            if (intent == null) {
                intent = new Intent();
            }
            intent.putExtra("reloadRequired", true);
        }

        closeNoteEditor(result, intent);
    }


    private void closeNoteEditor(int result) {
        closeNoteEditor(result, null);
    }


    private void closeNoteEditor(int result, Intent intent) {
        if (intent != null) {
            setResult(result, intent);
        } else {
            setResult(result);
        }
        if (mCaller == CALLER_CARDEDITOR_INTENT_ADD) {
            finishWithAnimation(ActivityTransitionAnimation.NONE);
        } else {
            finishWithAnimation(ActivityTransitionAnimation.RIGHT);
        }
    }

    public void onRescheduleCard(int days) {
        Timber.i("Reschedule card");
        getCol().getSched().reschedCards(new long[] { mCurrentEditedCard.getId() }, days, days);
        getCol().reset();
        mReloadRequired = true;
        UIUtils.showThemedToast(NoteEditor.this,
                getResources().getString(R.string.reschedule_card_dialog_acknowledge), true);
    }


    private void showTagsDialog() {
        if (mSelectedTags == null) {
            mSelectedTags = new ArrayList<>();
        }
        ArrayList<String> tags = new ArrayList<>(getCol().getTags().all());
        ArrayList<String> selTags = new ArrayList<>(mSelectedTags);
        TagsDialog dialog = com.ichi2.anki.dialogs.TagsDialog.newInstance(TagsDialog.TYPE_ADD_TAG, selTags,
                tags);
        dialog.setTagsDialogListener(new TagsDialogListener() {
            @Override
            public void onPositive(List<String> selectedTags, int option) {
                if (!mSelectedTags.equals(selectedTags)) {
                    mTagsEdited = true;
                }
                mSelectedTags = selectedTags;
                updateTags();
            }
        });
        showDialogFragment(dialog);
    }

    private void showCardTemplateEditor() {
        Intent intent = new Intent(this, CardTemplateEditor.class);
        // Pass the model ID
        try {
            intent.putExtra("modelId", getCurrentlySelectedModel().getLong("id"));
        } catch (JSONException e) {
           throw new RuntimeException(e);
        }
        // Also pass the card ID if not adding new note
        if (!mAddNote) {
            intent.putExtra("noteId", mCurrentEditedCard.note().getId());
        }
        startActivityForResultWithAnimation(intent, REQUEST_TEMPLATE_EDIT, ActivityTransitionAnimation.LEFT);
    }


    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);

        if (resultCode == DeckPicker.RESULT_DB_ERROR) {
            closeNoteEditor(DeckPicker.RESULT_DB_ERROR);
        }

        switch (requestCode) {
            case REQUEST_ADD:
                if (resultCode != RESULT_CANCELED) {
                    mChanged = true;
                }
                break;
            case REQUEST_MULTIMEDIA_EDIT:
                if (resultCode != RESULT_CANCELED) {
                    Collection col = getCol();
                    Bundle extras = data.getExtras();
                    int index = extras.getInt(MultimediaEditFieldActivity.EXTRA_RESULT_FIELD_INDEX);
                    IField field = (IField) extras.get(MultimediaEditFieldActivity.EXTRA_RESULT_FIELD);
                    IMultimediaEditableNote mNote = NoteService.createEmptyNote(mEditorNote.model());
                    NoteService.updateMultimediaNoteFromJsonNote(col, mEditorNote, mNote);
                    mNote.setField(index, field);
                    FieldEditText fieldEditText = mEditFields.get(index);
                    // Completely replace text for text fields (because current text was passed in)
                    if (field.getType() == EFieldType.TEXT) {
                        fieldEditText.setText(field.getFormattedValue());
                    }
                    // Insert text at cursor position if the field has focus
                    else if (fieldEditText.hasFocus()) {
                        fieldEditText.getText().replace(fieldEditText.getSelectionStart(),
                                fieldEditText.getSelectionEnd(),
                                field.getFormattedValue());
                    }
                    // Append text if the field doesn't have focus
                    else {
                        fieldEditText.getText().append(field.getFormattedValue());
                    }
                    NoteService.saveMedia(col, (MultimediaEditableNote) mNote);
                    mChanged = true;
                }
                break;
            case REQUEST_TEMPLATE_EDIT:
                if (resultCode == RESULT_OK) {
                    mReloadRequired = true;
                }
                updateCards(mEditorNote.model());
        }
    }

    private void populateEditFields() {
        String[][] fields;
        // If we have a bundle of pre-populated field values, we overwrite the existing values
        // with those ones since we are resuming the activity after it was terminated early.
        if (mSavedFields != null) {
            fields = mEditorNote.items();
            for (String key : mSavedFields.keySet()) {
                int ord = Integer.parseInt(key);
                String text = mSavedFields.getString(key);
                fields[ord][1] = text;
            }
            // Clear the saved values since we've consumed them.
            mSavedFields = null;
        } else {
            fields = mEditorNote.items();
        }
        populateEditFields(fields, false);
    }

    private void populateEditFields(String[][] fields, boolean editModelMode) {
        mFieldsLayoutContainer.removeAllViews();
        mEditFields = new LinkedList<>();

        // Use custom font if selected from preferences
        Typeface mCustomTypeface = null;
        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());
        String customFont = preferences.getString("browserEditorFont", "");
        if (!customFont.equals("")) {
            mCustomTypeface = AnkiFont.getTypeface(this, customFont);
        }

        for (int i = 0; i < fields.length; i++) {
            View editline_view = getLayoutInflater().inflate(R.layout.card_multimedia_editline, null);
            FieldEditText newTextbox = (FieldEditText) editline_view.findViewById(R.id.id_note_editText);

            initFieldEditText(newTextbox, i, fields[i], mCustomTypeface, !editModelMode);

            TextView label = newTextbox.getLabel();
            label.setPadding((int) UIUtils.getDensityAdjustedValue(this, 3.4f), 0, 0, 0);
            mEditFields.add(newTextbox);

            ImageButton mediaButton = (ImageButton) editline_view.findViewById(R.id.id_media_button);
            // Load icons from attributes
            int[] icons = Themes.getResFromAttr(this, new int[] { R.attr.attachFileImage, R.attr.upDownImage});
            // Make the icon change between media icon and switch field icon depending on whether editing note type
            if (editModelMode && allowFieldRemapping()) {
                // Allow remapping if originally more than two fields
                mediaButton.setBackgroundResource(icons[1]);
                setRemapButtonListener(mediaButton, i);
            } else if (editModelMode && !allowFieldRemapping()) {
                mediaButton.setBackgroundResource(0);
            } else {
                // Use media editor button if not changing note type
                mediaButton.setBackgroundResource(icons[0]);
                setMMButtonListener(mediaButton, i);
            }
            mediaButton.setContentDescription(getString(R.string.multimedia_editor_attach_mm_content, fields[i][0]));
            mFieldsLayoutContainer.addView(label);
            mFieldsLayoutContainer.addView(editline_view);
        }
    }


    private void setMMButtonListener(ImageButton mediaButton, final int index) {
        mediaButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Timber.i("NoteEditor:: Multimedia button pressed for field %d", index);
                final Collection col = CollectionHelper.getInstance().getCol(NoteEditor.this);
                if (mEditorNote.items()[index][1].length() > 0) {
                    // If the field already exists then we start the field editor, which figures out the type
                    // automatically
                    IMultimediaEditableNote mNote = NoteService.createEmptyNote(mEditorNote.model());
                    NoteService.updateMultimediaNoteFromJsonNote(col, mEditorNote, mNote);
                    IField field = mNote.getField(index);
                    startMultimediaFieldEditor(index, mNote, field);
                } else {
                    // Otherwise we make a popup menu allowing the user to choose between audio/image/text field
                    // TODO: Update the icons for dark material theme, then can set 3rd argument to true
                    PopupMenuWithIcons popup = new PopupMenuWithIcons(NoteEditor.this, v, false);
                    MenuInflater inflater = popup.getMenuInflater();
                    inflater.inflate(R.menu.popupmenu_multimedia_options, popup.getMenu());
                    popup.setOnMenuItemClickListener(new OnMenuItemClickListener() {
                        @Override
                        public boolean onMenuItemClick(MenuItem item) {
                            IMultimediaEditableNote mNote = NoteService.createEmptyNote(mEditorNote.model());
                            NoteService.updateMultimediaNoteFromJsonNote(col, mEditorNote, mNote);
                            IField field;
                            switch (item.getItemId()) {
                                case R.id.menu_multimedia_audio:
                                    Timber.i("NoteEditor:: Record audio button pressed");
                                    field = new AudioField();
                                    mNote.setField(index, field);
                                    startMultimediaFieldEditor(index, mNote, field);
                                    return true;
                                case R.id.menu_multimedia_photo:
                                    Timber.i("NoteEditor:: Add image button pressed");
                                    field = new ImageField();
                                    mNote.setField(index, field);
                                    startMultimediaFieldEditor(index, mNote, field);
                                    return true;
                                case R.id.menu_multimedia_text:
                                    Timber.i("NoteEditor:: Advanced editor button pressed");
                                    field = new TextField();
                                    field.setText(mEditFields.get(index).getText().toString());
                                    mNote.setField(index, field);
                                    startMultimediaFieldEditor(index, mNote, field);
                                    return true;
                                case R.id.menu_multimedia_cloze:
                                    FieldEditText fieldEditText = mEditFields.get(index);
                                    String text = fieldEditText.getText().toString();
                                    int selectionStart = fieldEditText.getSelectionStart();
                                    int selectionEnd = fieldEditText.getSelectionEnd();
                                    fieldEditText.setText(insertClozeAround(text, selectionStart, selectionEnd));
                                    return true;
                                default:
                                    return false;
                            }
                        }
                    });
                    popup.show();
                }
            }
        });
    }

    private String insertClozeAround(String text, int selectionStart, int selectionEnd) {
        int selectionMin = Math.min(selectionStart, selectionEnd);
        int selectionMax = Math.max(selectionStart, selectionEnd);
        return text.substring(0, selectionMin) + "{{c1::" + text.substring(selectionMin, selectionMax) + "}}" + text.substring(selectionMax);
    }


    private void setRemapButtonListener(ImageButton remapButton, final int newFieldIndex) {
        remapButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Timber.i("NoteEditor:: Remap button pressed for new field %d", newFieldIndex);
                // Show list of fields from the original note which we can map to
                PopupMenu popup = new PopupMenu(NoteEditor.this, v);
                final String[][] items = mEditorNote.items();
                for (int i = 0; i < items.length; i++) {
                    popup.getMenu().add(Menu.NONE, i, Menu.NONE, items[i][0]);
                }
                // Add "nothing" at the end of the list
                popup.getMenu().add(Menu.NONE, items.length, Menu.NONE, R.string.nothing);
                popup.setOnMenuItemClickListener(new OnMenuItemClickListener() {
                    @Override
                    public boolean onMenuItemClick(MenuItem item) {
                        // Get menu item id
                        Integer idx = item.getItemId();
                        Timber.i("NoteEditor:: User chose to remap to old field %d", idx);
                        // Retrieve any existing mappings between newFieldIndex and idx
                        Integer previousMapping = getKeyByValue(mModelChangeFieldMap, newFieldIndex);
                        Integer mappingConflict = mModelChangeFieldMap.get(idx);
                        // Update the mapping depending on any conflicts
                        if (idx == items.length && previousMapping != null) {
                            // Remove the previous mapping if None selected
                            mModelChangeFieldMap.remove(previousMapping);
                        } else if (idx < items.length && mappingConflict != null && previousMapping != null && newFieldIndex != mappingConflict) {
                            // Swap the two mappings if there was a conflict and previous mapping
                            mModelChangeFieldMap.put(previousMapping, mappingConflict);
                            mModelChangeFieldMap.put(idx, newFieldIndex);
                        } else if (idx < items.length && mappingConflict != null) {
                            // Set the conflicting field to None if no previous mapping to swap into it
                            mModelChangeFieldMap.remove(previousMapping);
                            mModelChangeFieldMap.put(idx, newFieldIndex);
                        } else if (idx < items.length) {
                            // Can simply set the new mapping if no conflicts
                            mModelChangeFieldMap.put(idx, newFieldIndex);
                        }
                        // Reload the fields                     
                        updateFieldsFromMap(getCurrentlySelectedModel());
                        return true;
                    }
                });
                popup.show();
            }
        });
    }


    private void startMultimediaFieldEditor(final int index, IMultimediaEditableNote mNote, IField field) {
        Intent editCard = new Intent(NoteEditor.this, MultimediaEditFieldActivity.class);
        editCard.putExtra(MultimediaEditFieldActivity.EXTRA_FIELD_INDEX, index);
        editCard.putExtra(MultimediaEditFieldActivity.EXTRA_FIELD, field);
        editCard.putExtra(MultimediaEditFieldActivity.EXTRA_WHOLE_NOTE, mNote);
        startActivityForResultWithoutAnimation(editCard, REQUEST_MULTIMEDIA_EDIT);
    }


    private void initFieldEditText(FieldEditText editText, final int index, String[] values, Typeface customTypeface, boolean enabled) {
        String name = values[0];
        String content = values[1];
        editText.init(index, name, content);
        if (customTypeface != null) {
            editText.setTypeface(customTypeface);
        }

        // Listen for changes in the first field so we can re-check duplicate status.
        editText.addTextChangedListener(new TextWatcher() {
            @Override
            public void afterTextChanged(Editable arg0) {
                mFieldEdited = true;
                if (index == 0) {
                    duplicateCheck();
                }
            }


            @Override
            public void beforeTextChanged(CharSequence arg0, int arg1, int arg2, int arg3) {
            }


            @Override
            public void onTextChanged(CharSequence arg0, int arg1, int arg2, int arg3) {
            }
        });
        editText.setEnabled(enabled);
    }


    private void setEditFieldTexts(String contents) {
        String[] fields = null;
        int len;
        if (contents == null) {
            len = 0;
        } else {
            fields = Utils.splitFields(contents);
            len = fields.length;
        }
        for (int i = 0; i < mEditFields.size(); i++) {
            if (i < len) {
                mEditFields.get(i).setText(fields[i]);
            } else {
                mEditFields.get(i).setText("");
            }
        }
    }


    private boolean duplicateCheck() {
        boolean isDupe;
        FieldEditText field = mEditFields.get(0);
        // Keep copy of current internal value for this field.
        String oldValue = mEditorNote.getFields()[0];
        // Update the field in the Note so we can run a dupe check on it.
        updateField(field);
        // 1 is empty, 2 is dupe, null is neither.
        Integer dupeCode = mEditorNote.dupeOrEmpty();
        // Change bottom line color of text field
        if (dupeCode != null && dupeCode == 2) {
            field.setDupeStyle();
            isDupe = true;
        } else {
            field.setDefaultStyle();
            isDupe = false;
        }
        // Put back the old value so we don't interfere with modification detection
        mEditorNote.values()[0] = oldValue;
        return isDupe;
    }


    private String getFieldsText() {
        String[] fields = new String[mEditFields.size()];
        for (int i = 0; i < mEditFields.size(); i++) {
            fields[i] = mEditFields.get(i).getText().toString();
        }
        return Utils.joinFields(fields);
    }


    private void setDid(Note note) {
        // If the target deck ID has already been set, we use that value and avoid trying to
        // determine what it should be again. An existing value means we are resuming the activity
        // where the target deck was already decided by the user.
        if (mCurrentDid != 0) {
            return;
        }
        if (note == null || mAddNote) {
            try {
                JSONObject conf = getCol().getConf();
                JSONObject model = getCol().getModels().current();
                if (conf.optBoolean("addToCur", true)) {
                    mCurrentDid = conf.getLong("curDeck");
                    if (getCol().getDecks().isDyn(mCurrentDid)) {
                        /*
                         * If the deck in mCurrentDid is a filtered (dynamic) deck, then we can't create cards in it,
                         * and we set mCurrentDid to the Default deck. Otherwise, we keep the number that had been
                         * selected previously in the activity.
                         */
                        mCurrentDid = 1;
                    }
                } else {
                    mCurrentDid = model.getLong("did");
                }
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        } else {
            mCurrentDid = mCurrentEditedCard.getDid();
        }
    }


    /** Make NOTE the current note. */
    private void setNote() {
        setNote(null);
    }


    private void setNote(Note note) {
        if (note == null || mAddNote) {
            JSONObject model = getCol().getModels().current();
            mEditorNote = new Note(getCol(), model);
        } else {
            mEditorNote = note;
        }
        if (mSelectedTags == null) {
            mSelectedTags = mEditorNote.getTags();
        }
        updateDeckPosition();
        updateTags();
        updateCards(mEditorNote.model());
        populateEditFields();
    }


    private void updateDeckPosition() {
        int position = mAllDeckIds.indexOf(mCurrentDid);
        if (position != -1) {
            mNoteDeckSpinner.setSelection(position, false);
        } else {
            Timber.e("updateDeckPosition() error :: mCurrentDid=%d, position=%d", mCurrentDid, position);
        }
    }


    private void updateTags() {
        if (mSelectedTags == null) {
            mSelectedTags = new ArrayList<>();
        }
        mTagsButton.setText(getResources().getString(R.string.CardEditorTags,
                getCol().getTags().join(getCol().getTags().canonify(mSelectedTags)).trim().replace(" ", ", ")));
    }


    /** Update the list of card templates for current note type */
    private void updateCards(JSONObject model) {
        try {
            JSONArray tmpls = model.getJSONArray("tmpls");
            String cardsList = "";
            // Build comma separated list of card names
            for (int i = 0; i < tmpls.length(); i++) {
                String name = tmpls.getJSONObject(i).optString("name");
                // If more than one card then make currently selected card underlined
                if (!mAddNote && tmpls.length() > 1 && model == mEditorNote.model() &&
                        mCurrentEditedCard.template().optString("name").equals(name)) {
                    name = "<u>" + name + "</u>";
                }
                cardsList += name;
                if (i < tmpls.length()-1) {
                    cardsList += ", ";
                }
            }
            // Make cards list red if the number of cards is being reduced
            if (!mAddNote && tmpls.length() < mEditorNote.model().getJSONArray("tmpls").length()) {
                cardsList = "<font color='red'>" + cardsList + "</font>";
            }
            mCardsButton.setText(Html.fromHtml(getResources().getString(R.string.CardEditorCards, cardsList)));
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    private boolean updateField(FieldEditText field) {
        String newValue = field.getText().toString().replace(FieldEditText.NEW_LINE, "<br>");
        if (!mEditorNote.values()[field.getOrd()].equals(newValue)) {
            mEditorNote.values()[field.getOrd()] = newValue;
            return true;
        }
        return false;
    }


    private String tagsAsString(List<String> tags) {
        return TextUtils.join(" ", tags);
    }

    private JSONObject getCurrentlySelectedModel() {
        return getCol().getModels().get(mAllModelIds.get(mNoteTypeSpinner.getSelectedItemPosition()));
    }

    /**
     * Convenience method for getting the corresponding key given the value in a 1-to-1 map
     * @param map
     * @param value
     * @return
     */
    private <T, E> T getKeyByValue(Map<T, E> map, E value) {
        for (Entry<T, E> entry : map.entrySet()) {
            if (value.equals(entry.getValue())) {
                return entry.getKey();
            }
        }
        return null;
    }

    /**
     * Update all the field EditText views based on the currently selected note type and the mModelChangeFieldMap
     */
    private void updateFieldsFromMap(JSONObject newModel) {
        // Get the field map for new model and old fields list
        String [][] oldFields = mEditorNote.items();
        Map<String, Pair<Integer, JSONObject>> fMapNew = getCol().getModels().fieldMap(newModel);
        // Build array of label/values to provide to field EditText views
        String[][] fields = new String[fMapNew.size()][2];
        for (String fname : fMapNew.keySet()) {
            // Field index of new note type
            Integer i = fMapNew.get(fname).first;
            // Add values from old note type if they exist in map, otherwise make the new field empty
            if (mModelChangeFieldMap.containsValue(i)) {
                // Get index of field from old note type given the field index of new note type
                Integer j = getKeyByValue(mModelChangeFieldMap, i);
                // Set the new field label text
                if (allowFieldRemapping()) {
                    // Show the content of old field if remapping is enabled
                    fields[i][0] = String.format(getResources().getString(R.string.field_remapping), fname, oldFields[j][0]);
                } else {
                    fields[i][0] = fname;
                }

                // Set the new field label value
                fields[i][1] = oldFields[j][1];
            } else {
                // No values from old note type exist in the mapping
                fields[i][0] = fname;
                fields[i][1] = "";
            }
        }
        populateEditFields(fields, true);
        updateCards(newModel);
    }

    /**
     *
     * @return whether or not to allow remapping of fields for current model
     */
    private boolean allowFieldRemapping() {
        // Map<String, Pair<Integer, JSONObject>> fMapNew = getCol().getModels().fieldMap(getCurrentlySelectedModel())
        return mEditorNote.items().length > 2;
    }

    // ----------------------------------------------------------------------------
    // INNER CLASSES
    // ----------------------------------------------------------------------------

    public class JSONNameComparator implements Comparator<JSONObject> {
        @Override
        public int compare(JSONObject lhs, JSONObject rhs) {
            String[] o1;
            String[] o2;
            try {
                o1 = lhs.getString("name").split("::");
                o2 = rhs.getString("name").split("::");
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            for (int i = 0; i < Math.min(o1.length, o2.length); i++) {
                int result = o1[i].compareToIgnoreCase(o2[i]);
                if (result != 0) {
                    return result;
                }
            }
            if (o1.length < o2.length) {
                return -1;
            } else if (o1.length > o2.length) {
                return 1;
            } else {
                return 0;
            }
        }
    }


    private class SetNoteTypeListener implements OnItemSelectedListener {
        @Override
        public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {
            // If a new column was selected then change the key used to map from mCards to the column TextView
            //Timber.i("NoteEditor:: onItemSelected() fired on mNoteTypeSpinner");
            long oldModelId;
            try {
                oldModelId = getCol().getModels().current().getLong("id");
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            long newId = mAllModelIds.get(pos);
            if (oldModelId != newId) {
                JSONObject model = getCol().getModels().get(newId);
                getCol().getModels().setCurrent(model);
                JSONObject cdeck = getCol().getDecks().current();
                try {
                    cdeck.put("mid", newId);
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
                getCol().getDecks().save(cdeck);
                // Update deck
                if (!getCol().getConf().optBoolean("addToCur", true)) {
                    try {
                        mCurrentDid = model.getLong("did");
                        updateDeckPosition();
                    } catch (JSONException e) {
                        throw new RuntimeException(e);
                    }
                }
                // Reset edit fields
                int size = mEditFields.size();
                String[] oldValues = new String[size];
                for (int i = 0; i < size; i++) {
                    oldValues[i] = mEditFields.get(i).getText().toString();
                }
                setNote();
                resetEditFields(oldValues);
                duplicateCheck();
            }
        }

        @Override
        public void onNothingSelected(AdapterView<?> parent) {
            // Do Nothing
        }
    }


    private class EditNoteTypeListener implements OnItemSelectedListener {
        @Override
        public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {
            // Get the current model
            long noteModelId;
            try {
                noteModelId = mCurrentEditedCard.model().getLong("id");
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            // Get new model
            JSONObject newModel = getCol().getModels().get(mAllModelIds.get(pos));            
            // Configure the interface according to whether note type is getting changed or not
            if (mAllModelIds.get(pos) != noteModelId) {
                // Initialize mapping between fields of old model -> new model
                mModelChangeFieldMap = new HashMap<>();
                for (int i=0; i < mEditorNote.items().length; i++) {
                    mModelChangeFieldMap.put(i, i);
                }
                // Initialize mapping between cards new model -> old model
                mModelChangeCardMap = new HashMap<>();
                try {
                    for (int i=0; i < newModel.getJSONArray("tmpls").length() ; i++) {
                        if (i < mEditorNote.cards().size()) {
                            mModelChangeCardMap.put(i, i);
                        } else {
                            mModelChangeCardMap.put(i, null);
                        }
                    }
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
                // Update the field text edits based on the default mapping just assigned
                updateFieldsFromMap(newModel);
                // Don't let the user change any other values at the same time as changing note type
                mSelectedTags = mEditorNote.getTags();
                updateTags();
                findViewById(R.id.CardEditorTagButton).setEnabled(false);
                //((LinearLayout) findViewById(R.id.CardEditorCardsButton)).setEnabled(false);
                mNoteDeckSpinner.setEnabled(false);
                int position = mAllDeckIds.indexOf(mCurrentEditedCard.getDid());
                if (position != -1) {
                    mNoteDeckSpinner.setSelection(position, false);
                }
            } else {
                populateEditFields();
                updateCards(mCurrentEditedCard.model());
                findViewById(R.id.CardEditorTagButton).setEnabled(true);
                //((LinearLayout) findViewById(R.id.CardEditorCardsButton)).setEnabled(false);
                mNoteDeckSpinner.setEnabled(true);
            }
        }

        @Override
        public void onNothingSelected(AdapterView<?> parent) {
            // Do Nothing
        }
    }
}
/***************************************************************************************
 * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 * Copyright (c) 2010 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 * Copyright (c) 2015 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.annotation.TargetApi;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.ComponentName;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.EditTextPreference;
import android.preference.ListPreference;
import android.preference.Preference;
import android.preference.Preference.OnPreferenceChangeListener;
import android.preference.Preference.OnPreferenceClickListener;
import android.preference.PreferenceCategory;
import android.preference.PreferenceFragment;
import android.preference.PreferenceGroup;
import android.support.annotation.NonNull;
import android.preference.PreferenceScreen;
import android.text.TextUtils;
import android.view.KeyEvent;
import android.view.MenuItem;
import android.view.WindowManager.BadTokenException;
import android.widget.Toast;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.receiver.NotificationReceiver;
import com.ichi2.anki.services.BootService;
import com.ichi2.libanki.hooks.AdvancedStatistics;
import com.ichi2.themes.Themes;
import com.ichi2.ui.AppCompatPreferenceActivity;
import com.ichi2.ui.SeekBarPreference;
import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.exception.StorageAccessException;
import com.ichi2.compat.CompatHelper;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Utils;
import com.ichi2.libanki.hooks.ChessFilter;
import com.ichi2.libanki.hooks.HebrewFixFilter;
import com.ichi2.libanki.hooks.Hooks;
import com.ichi2.preferences.NumberRangePreference;
import com.ichi2.utils.LanguageUtil;
import com.ichi2.utils.VersionUtils;

import org.json.JSONException;
import org.json.JSONObject;

import java.sql.Timestamp;
import java.util.Arrays;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TreeMap;

import timber.log.Timber;

interface PreferenceContext {
    void addPreferencesFromResource(int preferencesResId);
    PreferenceScreen getPreferenceScreen();
}

/**
 * Preferences dialog.
 */
public class Preferences extends AppCompatPreferenceActivity implements PreferenceContext, OnSharedPreferenceChangeListener {

    private static final int DIALOG_HEBREW_FONT = 3;

    /** Key of the language preference */
    public static final String LANGUAGE = "language";

    // Other variables
    private final HashMap<String, String> mOriginalSumarries = new HashMap<>();
    private static final String [] sCollectionPreferences = {"showEstimates", "showProgress",
            "learnCutoff", "timeLimit", "useCurrent", "newSpread", "dayOffset"};


    // ----------------------------------------------------------------------------
    // Overridden methods
    // ----------------------------------------------------------------------------

    @SuppressWarnings("deprecation")
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Themes.setThemeLegacy(this);

        super.onCreate(savedInstanceState);

        // Legacy code using intents instead of PreferenceFragments
        String action = getIntent().getAction();
        if (!CompatHelper.isHoneycomb()) {
            if (action == null) {
                // Headers screen
                addPreferencesFromResource(R.xml.preference_headers_legacy);
            } else {
                initSubscreen(action, this);
            }
            // Set the text for the summary of each of the preferences
            initAllPreferences(getPreferenceScreen());
        }

        // Add a home button to the actionbar
        getSupportActionBar().setHomeButtonEnabled(true);
        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
    }

    private Collection getCol() {
        return CollectionHelper.getInstance().getCol(this);
    }


    // Called only on Honeycomb and later
    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    @Override
    public void onBuildHeaders(List<Header> target) {
        loadHeadersFromResource(R.xml.preference_headers, target);
    }


    @Override
    protected boolean isValidFragment(String fragmentName) {
        return SettingsFragment.class.getName().equals(fragmentName);
    }


    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                finish();
                return true;
        }
        return false;
    }


    @SuppressWarnings("deprecation")
    @Override
    protected void onPause() {
        super.onPause();
        // Legacy code to register listener when not using PreferenceFragment
        if (!CompatHelper.isHoneycomb() && getPreferenceScreen() != null) {
            getPreferenceScreen().getSharedPreferences().unregisterOnSharedPreferenceChangeListener(this);
        }
    }


    @SuppressWarnings("deprecation")
    @Override
    protected void onResume() {
        super.onResume();
        // Legacy code to register listener when not using PreferenceFragment
        if (!CompatHelper.isHoneycomb() && getPreferenceScreen() != null) {
            SharedPreferences prefs = getPreferenceScreen().getSharedPreferences();
            prefs.registerOnSharedPreferenceChangeListener(this);
            // syncAccount's summary can change while preferences are still open (user logs
            // in from preferences screen), so we need to update it here.
            updatePreference(prefs, "syncAccount", this);
            updatePreference(prefs, "custom_sync_server_link", this);
            updatePreference(prefs, "advanced_statistics_link", this);
        }
    }


    @Override
    public boolean onKeyDown(int keyCode, @NonNull KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
            Timber.i("Preferences:: onBackPressed()");
            closePreferences();
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    protected MaterialDialog onCreateDialog(int id) {
        Resources res = getResources();
        MaterialDialog.Builder builder = new MaterialDialog.Builder(this);
        switch (id) {
            case DIALOG_HEBREW_FONT:
                builder.title(res.getString(R.string.fix_hebrew_text));
                builder.content(res.getString(R.string.fix_hebrew_instructions,
                        CollectionHelper.getCurrentAnkiDroidDirectory(this)));
                builder.callback(new MaterialDialog.ButtonCallback() {
                    @Override
                    public void onPositive(MaterialDialog dialog) {
                        Intent intent = new Intent("android.intent.action.VIEW", Uri.parse(getResources().getString(
                                R.string.link_hebrew_font)));
                        startActivity(intent);
                    }
                });
                builder.positiveText(res.getString(R.string.fix_hebrew_download_font));
                builder.negativeText(R.string.dialog_cancel);
        }
        return builder.show();
    }

    @Override
    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
        updatePreference(sharedPreferences, key, this);
    }


    // ----------------------------------------------------------------------------
    // Class methods
    // ----------------------------------------------------------------------------

    private void initSubscreen(String action, PreferenceContext listener) {
        PreferenceScreen screen;
        switch (action) {
            case "com.ichi2.anki.prefs.general":
                listener.addPreferencesFromResource(R.xml.preferences_general);
                screen = listener.getPreferenceScreen();
                // Build languages
                initializeLanguageDialog(screen);
                break;
            case "com.ichi2.anki.prefs.reviewing":
                listener.addPreferencesFromResource(R.xml.preferences_reviewing);
                screen = listener.getPreferenceScreen();
                // Show error toast if the user tries to disable answer button without gestures on
                ListPreference fullscreenPreference = (ListPreference)
                        screen.findPreference("fullscreenMode");
                fullscreenPreference.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {
                    public boolean onPreferenceChange(Preference preference, final Object newValue) {
                        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(Preferences.this);
                        if (prefs.getBoolean("gestures", false) || !newValue.equals("2")) {
                            return true;
                        } else {
                            Toast.makeText(getApplicationContext(),
                                    R.string.full_screen_error_gestures, Toast.LENGTH_LONG).show();
                            return false;
                        }
                    }
                });
                // Custom buttons options
                Preference customButtonsPreference = screen.findPreference("custom_buttons_link");
                customButtonsPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {
                    public boolean onPreferenceClick(Preference preference) {
                        Intent i = CompatHelper.getCompat().getPreferenceSubscreenIntent(Preferences.this,
                                "com.ichi2.anki.prefs.custom_buttons");
                        startActivity(i);
                        return true;
                    }
                });
                break;
            case "com.ichi2.anki.prefs.appearance":
                listener.addPreferencesFromResource(R.xml.preferences_appearance);
                screen = listener.getPreferenceScreen();
                initializeCustomFontsDialog(screen);
                break;
            case "com.ichi2.anki.prefs.gestures":
                listener.addPreferencesFromResource(R.xml.preferences_gestures);
                break;
            case "com.ichi2.anki.prefs.custom_buttons":
                getSupportActionBar().setTitle(R.string.custom_buttons);
                listener.addPreferencesFromResource(R.xml.preferences_custom_buttons);
                screen = listener.getPreferenceScreen();
                // Reset toolbar button customizations
                Preference reset_custom_buttons = screen.findPreference("reset_custom_buttons");
                reset_custom_buttons.setOnPreferenceClickListener(new OnPreferenceClickListener() {
                    public boolean onPreferenceClick(Preference preference) {
                        SharedPreferences.Editor edit = AnkiDroidApp.getSharedPrefs(getBaseContext()).edit();
                        edit.remove("customButtonUndo");
                        edit.remove("customButtonMarkCard");
                        edit.remove("customButtonEditCard");
                        edit.remove("customButtonAddCard");
                        edit.remove("customButtonReplay");
                        edit.remove("customButtonSelectTts");
                        edit.remove("customButtonDeckOptions");
                        edit.remove("customButtonBury");
                        edit.remove("customButtonSuspend");
                        edit.remove("customButtonDelete");
                        edit.remove("customButtonClearWhiteboard");
                        edit.remove("customButtonShowHideWhiteboard");
                        edit.apply();
                        //finish();
                        //TODO: Should reload the preferences screen on completion
                        return true;
                    }
                });
                break;
            case "com.ichi2.anki.prefs.advanced":
                listener.addPreferencesFromResource(R.xml.preferences_advanced);
                screen = listener.getPreferenceScreen();
                // Check that input is valid before committing change in the collection path
                EditTextPreference collectionPathPreference = (EditTextPreference) screen.findPreference("deckPath");
                collectionPathPreference.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {
                    public boolean onPreferenceChange(Preference preference, final Object newValue) {
                        final String newPath = (String) newValue;
                        try {
                            CollectionHelper.initializeAnkiDroidDirectory(newPath);
                            return true;
                        } catch (StorageAccessException e) {
                            Timber.e(e, "Could not initialize directory: %s", newPath);
                            Toast.makeText(getApplicationContext(), R.string.dialog_collection_path_not_dir, Toast.LENGTH_LONG).show();
                            return false;
                        }
                    }
                });
                // Custom sync server option
                Preference customSyncServerPreference = screen.findPreference("custom_sync_server_link");
                customSyncServerPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {
                    public boolean onPreferenceClick(Preference preference) {
                        Intent i = CompatHelper.getCompat().getPreferenceSubscreenIntent(Preferences.this,
                                "com.ichi2.anki.prefs.custom_sync_server");
                        startActivity(i);
                        return true;
                    }
                });
                // Advanced statistics option
                Preference advancedStatisticsPreference = screen.findPreference("advanced_statistics_link");
                advancedStatisticsPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {
                    public boolean onPreferenceClick(Preference preference) {
                        Intent i = CompatHelper.getCompat().getPreferenceSubscreenIntent(Preferences.this,
                                "com.ichi2.anki.prefs.advanced_statistics");
                        startActivity(i);
                        return true;
                    }
                });
                // Force full sync option
                Preference fullSyncPreference = screen.findPreference("force_full_sync");
                fullSyncPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {
                    public boolean onPreferenceClick(Preference preference) {
                        // TODO: Could be useful to show the full confirmation dialog
                        getCol().modSchemaNoCheck();
                        getCol().setMod();
                        Toast.makeText(getApplicationContext(), android.R.string.ok, Toast.LENGTH_SHORT).show();
                        return true;
                    }
                });
                // Workaround preferences
                removeUnnecessaryAdvancedPrefs(screen);
                break;
            case "com.ichi2.anki.prefs.custom_sync_server":
                getSupportActionBar().setTitle(R.string.custom_sync_server_title);
                listener.addPreferencesFromResource(R.xml.preferences_custom_sync_server);
                break;
            case "com.ichi2.anki.prefs.advanced_statistics":
                getSupportActionBar().setTitle(R.string.advanced_statistics_title);
                listener.addPreferencesFromResource(R.xml.preferences_advanced_statistics);
                break;
        }
    }


    /**
     * Loop over every preference in the list and set the summary text
     */
    private void initAllPreferences(PreferenceScreen screen) {
        for (int i = 0; i < screen.getPreferenceCount(); ++i) {
            Preference preference = screen.getPreference(i);
            if (preference instanceof PreferenceGroup) {
                PreferenceGroup preferenceGroup = (PreferenceGroup) preference;
                for (int j = 0; j < preferenceGroup.getPreferenceCount(); ++j) {
                    Preference nestedPreference = preferenceGroup.getPreference(j);
                    if (nestedPreference instanceof PreferenceGroup) {
                        PreferenceGroup nestedPreferenceGroup = (PreferenceGroup) nestedPreference;
                        for (int k = 0; k < nestedPreferenceGroup.getPreferenceCount(); ++k) {
                            initPreference(nestedPreferenceGroup.getPreference(k));
                        }
                    } else {
                        initPreference(preferenceGroup.getPreference(j));
                    }
                }
            } else {
                initPreference(preference);
            }
        }
    }



    private void initPreference(Preference pref) {
        // Load stored values from Preferences which are stored in the Collection
        if (Arrays.asList(sCollectionPreferences).contains(pref.getKey())) {
            Collection col = getCol();
            if (col != null) {
                try {
                    JSONObject conf = col.getConf();
                    switch (pref.getKey()) {
                        case "showEstimates":
                            ((CheckBoxPreference)pref).setChecked(conf.getBoolean("estTimes"));
                            break;
                        case "showProgress":
                            ((CheckBoxPreference)pref).setChecked(conf.getBoolean("dueCounts"));
                            break;
                        case "learnCutoff":
                            ((NumberRangePreference)pref).setValue(conf.getInt("collapseTime") / 60);
                            break;
                        case "timeLimit":
                            ((NumberRangePreference)pref).setValue(conf.getInt("timeLim") / 60);
                            break;
                        case "useCurrent":
                            ((ListPreference)pref).setValueIndex(conf.optBoolean("addToCur", true) ? 0 : 1);
                            break;
                        case "newSpread":
                            ((ListPreference)pref).setValueIndex(conf.getInt("newSpread"));
                            break;
                        case "dayOffset":
                            Calendar calendar = new GregorianCalendar();
                            Timestamp timestamp = new Timestamp(col.getCrt() * 1000);
                            calendar.setTimeInMillis(timestamp.getTime());
                            ((SeekBarPreference)pref).setValue(calendar.get(Calendar.HOUR_OF_DAY));
                            break;
                    }
                } catch (JSONException | NumberFormatException e) {
                    throw new RuntimeException();
                }
            } else {
                // Disable Col preferences if Collection closed
                pref.setEnabled(false);
            }
        } else if ("minimumCardsDueForNotification".equals(pref.getKey())) {
            updateNotificationPreference((ListPreference) pref);
        }
        // Set the value from the summary cache
        CharSequence s = pref.getSummary();
        mOriginalSumarries.put(pref.getKey(), (s != null) ? s.toString() : "");
        // Update summary
        updateSummary(pref);
    }


    /**
     * Code which is run when a SharedPreference change has been detected
     * @param prefs instance of SharedPreferences
     * @param key key in prefs which is being updated
     * @param listener PreferenceActivity of PreferenceFragment which is hosting the preference
     */
    private void updatePreference(SharedPreferences prefs, String key, PreferenceContext listener) {
        try {
            PreferenceScreen screen = listener.getPreferenceScreen();
            Preference pref = screen.findPreference(key);
            if (pref == null) {
                Timber.e("Preferences: no preference found for the key: %s", key);
                return;
            }
            // Handle special cases
            switch (key) {
                case "timeoutAnswer": {
                    CheckBoxPreference keepScreenOn = (CheckBoxPreference) screen.findPreference("keepScreenOn");
                    keepScreenOn.setChecked(((CheckBoxPreference) pref).isChecked());
                    break;
                }
                case LANGUAGE:
                    closePreferences();
                    break;
                case "convertFenText":
                    if (((CheckBoxPreference) pref).isChecked()) {
                        ChessFilter.install(Hooks.getInstance(getApplicationContext()));
                    } else {
                        ChessFilter.uninstall(Hooks.getInstance(getApplicationContext()));
                    }
                    break;
                case "fixHebrewText":
                    if (((CheckBoxPreference) pref).isChecked()) {
                        HebrewFixFilter.install(Hooks.getInstance(getApplicationContext()));
                        showDialog(DIALOG_HEBREW_FONT);
                    } else {
                        HebrewFixFilter.uninstall(Hooks.getInstance(getApplicationContext()));
                    }
                    break;
                case "advanced_statistics_enabled":
                    if (((CheckBoxPreference) pref).isChecked()) {
                        AdvancedStatistics.install(Hooks.getInstance(getApplicationContext()));
                    } else {
                        AdvancedStatistics.uninstall(Hooks.getInstance(getApplicationContext()));
                    }
                    break;
                case "showProgress":
                    getCol().getConf().put("dueCounts", ((CheckBoxPreference) pref).isChecked());
                    getCol().setMod();
                    break;
                case "showEstimates":
                    getCol().getConf().put("estTimes", ((CheckBoxPreference) pref).isChecked());
                    getCol().setMod();
                    break;
                case "newSpread":
                    getCol().getConf().put("newSpread", Integer.parseInt(((ListPreference) pref).getValue()));
                    getCol().setMod();
                    break;
                case "timeLimit":
                    getCol().getConf().put("timeLim", ((NumberRangePreference) pref).getValue() * 60);
                    getCol().setMod();
                    break;
                case "learnCutoff":
                    getCol().getConf().put("collapseTime", ((NumberRangePreference) pref).getValue() * 60);
                    getCol().setMod();
                    break;
                case "useCurrent":
                    getCol().getConf().put("addToCur", ((ListPreference) pref).getValue().equals("0"));
                    getCol().setMod();
                    break;
                case "dayOffset": {
                    int hours = ((SeekBarPreference) pref).getValue();
                    Timestamp crtTime = new Timestamp(getCol().getCrt() * 1000);
                    Calendar date = GregorianCalendar.getInstance();
                    date.setTimeInMillis(crtTime.getTime());
                    date.set(Calendar.HOUR_OF_DAY, hours);
                    getCol().setCrt(date.getTimeInMillis() / 1000);
                    getCol().setMod();
                    BootService.scheduleNotification(this);
                    break;
                }
                case "minimumCardsDueForNotification": {
                    ListPreference listpref = (ListPreference) screen.findPreference("minimumCardsDueForNotification");
                    if (listpref != null) {
                        updateNotificationPreference(listpref);
                        if (Integer.valueOf(listpref.getValue()) < 1000000) {
                            BootService.scheduleNotification(this);
                        } else {
                            PendingIntent intent = PendingIntent.getBroadcast(this, 0,
                                    new Intent(this, NotificationReceiver.class), 0);
                            final AlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE);
                            alarmManager.cancel(intent);
                        }
                    }
                    break;
                }
                case "reportErrorMode": {
                    String value = prefs.getString("reportErrorMode", "");
                    AnkiDroidApp.getInstance().setAcraReportingMode(value);
                    AnkiDroidApp.getSharedPrefs(this).edit().remove("sentExceptionReports").apply();    // clear cache
                    break;
                }
                case "syncAccount": {
                    SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());
                    String username = preferences.getString("username", "");
                    Preference syncAccount = screen.findPreference("syncAccount");
                    if (syncAccount != null) {
                        if (TextUtils.isEmpty(username)) {
                            syncAccount.setSummary(R.string.sync_account_summ_logged_out);
                        } else {
                            syncAccount.setSummary(getString(R.string.sync_account_summ_logged_in, username));
                        }
                    }
                    break;
                }
                case "providerEnabled": {
                    ComponentName providerName = new ComponentName(this, "com.ichi2.anki.provider.CardContentProvider");
                    PackageManager pm = getPackageManager();
                    int state;
                    if (((CheckBoxPreference) pref).isChecked()) {
                         state = PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
                        Timber.i("AnkiDroid ContentProvider enabled by user");
                    } else {
                        state = PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
                        Timber.i("AnkiDroid ContentProvider disabled by user");
                    }
                    pm.setComponentEnabledSetting(providerName, state, PackageManager.DONT_KILL_APP);
                    break;
                }
            }
            // Update the summary text to reflect new value
            updateSummary(pref);
        } catch (BadTokenException e) {
            Timber.e(e, "Preferences: BadTokenException on showDialog");
        } catch (NumberFormatException | JSONException e) {
            throw new RuntimeException();
        }
    }

    public void updateNotificationPreference(ListPreference listpref) {
        CharSequence[] entries = listpref.getEntries();
        CharSequence[] values = listpref.getEntryValues();
        for (int i = 0; i < entries.length; i++) {
            int value = Integer.parseInt(values[i].toString());
            if (entries[i].toString().contains("%d")) {
                entries[i] = String.format(entries[i].toString(), value);
            }
        }
        listpref.setEntries(entries);
        listpref.setSummary(listpref.getEntry().toString());
    }

    private void updateSummary(Preference pref) {
        if (pref == null || pref.getKey() == null) {
            return;
        }
        // Handle special cases
        if (pref.getKey().equals("about_dialog_preference")) {
            pref.setSummary(getResources().getString(R.string.about_version) + " " + VersionUtils.getPkgVersionName());
        } else if (pref.getKey().equals("custom_sync_server_link")) {
            if (!AnkiDroidApp.getSharedPrefs(this).getBoolean("useCustomSyncServer", false)) {
                pref.setSummary(R.string.disabled);
            } else {
                pref.setSummary(AnkiDroidApp.getSharedPrefs(this).getString("syncBaseUrl", ""));
            }
        }
          else if (pref.getKey().equals("advanced_statistics_link")) {
            if (!AnkiDroidApp.getSharedPrefs(this).getBoolean("advanced_statistics_enabled", false)) {
                pref.setSummary(R.string.disabled);
            } else {
                pref.setSummary(R.string.enabled);
            }
        }
        // Get value text
        String value;
        try {
            if (pref instanceof  NumberRangePreference) {
                value = Integer.toString(((NumberRangePreference) pref).getValue());
            } else if (pref instanceof SeekBarPreference) {
                value = Integer.toString(((SeekBarPreference) pref).getValue());
            } else if (pref instanceof ListPreference) {
                value = ((ListPreference) pref).getEntry().toString();
            } else if (pref instanceof EditTextPreference) {
                value = ((EditTextPreference) pref).getText();
            } else {
                return;
            }
        } catch (NullPointerException e) {
            value = "";
        }
        // Get summary text
        String oldSummary = mOriginalSumarries.get(pref.getKey());
        // Replace summary text with value according to some rules
        if (oldSummary.equals("")) {
            pref.setSummary(value);
        } else if (value.equals("")) {
            pref.setSummary(oldSummary);
        } else if (pref.getKey().equals("minimumCardsDueForNotification")) {
            pref.setSummary(replaceStringIfNumeric(oldSummary, value));
        } else {
            pref.setSummary(replaceString(oldSummary, value));
        }
    }


    private String replaceString(String str, String value) {
        if (str.contains("XXX")) {
            return str.replace("XXX", value);
        } else {
            return str;
        }
    }

    @SuppressWarnings("ResultOfMethodCallIgnored")
    private String replaceStringIfNumeric(String str, String value) {
        try {
            Double.parseDouble(value);
            return replaceString(str, value);
        } catch (NumberFormatException e){
            return value;
        }
    }

    private void initializeLanguageDialog(PreferenceScreen screen) {
        ListPreference languageSelection = (ListPreference) screen.findPreference(LANGUAGE);
        if (languageSelection != null) {
            Map<String, String> items = new TreeMap<>();
            for (String localeCode : LanguageUtil.APP_LANGUAGES) {
                Locale loc = LanguageUtil.getLocale(localeCode);
                items.put(loc.getDisplayName(), loc.toString());
            }
            CharSequence[] languageDialogLabels = new CharSequence[items.size() + 1];
            CharSequence[] languageDialogValues = new CharSequence[items.size() + 1];
            languageDialogLabels[0] = getResources().getString(R.string.language_system);
            languageDialogValues[0] = "";
            int i = 1;
            for (Map.Entry<String, String> e : items.entrySet()) {
                languageDialogLabels[i] = e.getKey();
                languageDialogValues[i] = e.getValue();
                i++;
            }

            languageSelection.setEntries(languageDialogLabels);
            languageSelection.setEntryValues(languageDialogValues);
        }
    }

    private void removeUnnecessaryAdvancedPrefs(PreferenceScreen screen) {
        PreferenceCategory plugins = (PreferenceCategory) screen.findPreference("category_plugins");
        // Disable the emoji/kana buttons to scroll preference if those keys don't exist
        if (!CompatHelper.hasKanaAndEmojiKeys()) {
            CheckBoxPreference emojiScrolling = (CheckBoxPreference) screen.findPreference("scrolling_buttons");
            if (emojiScrolling != null && plugins != null) {
                plugins.removePreference(emojiScrolling);
            }
        }
        // Disable the double scroll preference if no scrolling keys
        if (!CompatHelper.hasScrollKeys() && !CompatHelper.hasKanaAndEmojiKeys()) {
            CheckBoxPreference doubleScrolling = (CheckBoxPreference) screen.findPreference("double_scrolling");
            if (doubleScrolling != null && plugins != null) {
                plugins.removePreference(doubleScrolling);
            }
        }

        PreferenceCategory workarounds = (PreferenceCategory) screen.findPreference("category_workarounds");
        if (workarounds != null) {
            CheckBoxPreference writeAnswersDisable = (CheckBoxPreference) screen.findPreference("writeAnswersDisable");
            CheckBoxPreference useInputTag = (CheckBoxPreference) screen.findPreference("useInputTag");
            CheckBoxPreference inputWorkaround = (CheckBoxPreference) screen.findPreference("inputWorkaround");
            CheckBoxPreference longclickWorkaround =
                (CheckBoxPreference) screen.findPreference("textSelectionLongclickWorkaround");
            CheckBoxPreference fixHebrewText = (CheckBoxPreference) screen.findPreference("fixHebrewText");
            CheckBoxPreference safeDisplayMode = (CheckBoxPreference) screen.findPreference("safeDisplay");
            CompatHelper.removeHiddenPreferences(this.getApplicationContext());
            if (CompatHelper.isHoneycomb()) {
                workarounds.removePreference(longclickWorkaround);
            }
            if (CompatHelper.getSdkVersion() >= 13) {
                workarounds.removePreference(safeDisplayMode);
            }
            if (CompatHelper.getSdkVersion() >= 15) {
                workarounds.removePreference(writeAnswersDisable);
                workarounds.removePreference(inputWorkaround);
            } else {
                // For older Androids we never use the input tag anyway.
                workarounds.removePreference(useInputTag);
            }
            if (CompatHelper.getSdkVersion() >= 16) {
                workarounds.removePreference(fixHebrewText);
            }
        }
    }


    /** Initializes the list of custom fonts shown in the preferences. */
    private void initializeCustomFontsDialog(PreferenceScreen screen) {
        ListPreference defaultFontPreference = (ListPreference) screen.findPreference("defaultFont");
        if (defaultFontPreference != null) {
            defaultFontPreference.setEntries(getCustomFonts("System default"));
            defaultFontPreference.setEntryValues(getCustomFonts(""));
        }
        ListPreference browserEditorCustomFontsPreference = (ListPreference) screen.findPreference("browserEditorFont");
        browserEditorCustomFontsPreference.setEntries(getCustomFonts("System default"));
        browserEditorCustomFontsPreference.setEntryValues(getCustomFonts("", true));
    }


    /** Returns a list of the names of the installed custom fonts. */
    private String[] getCustomFonts(String defaultValue) {
        return getCustomFonts(defaultValue, false);
    }


    private String[] getCustomFonts(String defaultValue, boolean useFullPath) {
        List<AnkiFont> mFonts = Utils.getCustomFonts(this);
        int count = mFonts.size();
        Timber.d("There are %d custom fonts", count);
        String[] names = new String[count + 1];
        names[0] = defaultValue;
        if (useFullPath) {
            for (int index = 1; index < count + 1; ++index) {
                names[index] = mFonts.get(index - 1).getPath();
                Timber.d("Adding custom font: %s", names[index]);
            }
        } else {
            for (int index = 1; index < count + 1; ++index) {
                names[index] = mFonts.get(index - 1).getName();
                Timber.d("Adding custom font: %s", names[index]);
            }
        }
        return names;
    }


    private void closePreferences() {
        finish();
        ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.FADE);
        if (getCol() != null && getCol().getDb()!= null) {
            getCol().save();
        }
    }

    // ----------------------------------------------------------------------------
    // Inner classes
    // ----------------------------------------------------------------------------

    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    public static class SettingsFragment extends PreferenceFragment implements PreferenceContext, OnSharedPreferenceChangeListener {
        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            String subscreen = getArguments().getString("subscreen");
            ((Preferences) getActivity()).initSubscreen(subscreen, this);
            ((Preferences) getActivity()).initAllPreferences(getPreferenceScreen());
        }

        @Override
        public void onResume() {
            super.onResume();
            SharedPreferences prefs = getPreferenceManager().getSharedPreferences();
            prefs.registerOnSharedPreferenceChangeListener(this);
            // syncAccount's summary can change while preferences are still open (user logs
            // in from preferences screen), so we need to update it here.
            ((Preferences) getActivity()).updatePreference(prefs, "syncAccount", this);
            ((Preferences) getActivity()).updatePreference(prefs, "custom_sync_server_link", this);
            ((Preferences) getActivity()).updatePreference(prefs, "advanced_statistics_link", this);
        }

        @Override
        public void onPause() {
            getPreferenceManager().getSharedPreferences().unregisterOnSharedPreferenceChangeListener(this);
            super.onPause();
        }

        @Override
        public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
            ((Preferences) getActivity()).updatePreference(sharedPreferences, key, this);
        }
    }
}
/***************************************************************************************
 * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 * Copyright (c) 2013 Jolta Technologies                                                *
 * Copyright (c) 2014 Bruno Romero de Azevedo <brunodea@inf.ufsm.br>                    *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.os.Bundle;
import android.view.View;

import com.ichi2.libanki.Collection;
import com.ichi2.themes.Themes;

import timber.log.Timber;

/**
 * The previewer intent must supply an array of cards to show and the index in the list from where
 * to begin showing them. Special rules are applied if the list size is 1 (i.e., no scrolling
 * buttons will be shown).
 */
public class Previewer extends AbstractFlashcardViewer {
    private long[] mCardList;
    private int mIndex;
    private boolean mShowingAnswer;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Timber.d("onCreate()");
        mCardList = getIntent().getLongArrayExtra("cardList");
        mIndex = getIntent().getIntExtra("index", -1);
        if (mCardList.length == 0 || mIndex < 0 || mIndex > mCardList.length - 1) {
            Timber.e("Previewer started with empty card list or invalid index");
            finishWithoutAnimation();
        }
        super.onCreate(savedInstanceState);
        showBackIcon();
        // Ensure navigation drawer can't be opened. Various actions in the drawer cause crashes.
        disableDrawerSwipe();
    }

    @Override
    protected void onCollectionLoaded(Collection col) {
        super.onCollectionLoaded(col);
        mCurrentCard = col.getCard(mCardList[mIndex]);
        displayCardQuestion();
        showBackIcon();
    }


    @Override
    protected void setTitle() {
        getSupportActionBar().setTitle(R.string.preview_title);
    }


    @Override
    protected void initLayout() {
        super.initLayout();
        mTopBarLayout.setVisibility(View.GONE);
    }


    @Override
    protected void displayCardQuestion() {
        super.displayCardQuestion();
        mShowingAnswer = false;
        updateButtonState();
    }


    // Called via mFlipCardListener in parent class when answer button pressed
    @Override
    protected void displayCardAnswer() {
        super.displayCardAnswer();
        mShowingAnswer = true;
        updateButtonState();
    }


    // we don't want the Activity title to be changed.
    @Override
    protected void updateScreenCounts() {
    }


    // No Gestures!
    @Override
    protected void executeCommand(int which) {
    }

    private View.OnClickListener mSelectScrollHandler = new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            if (!mShowingAnswer) {
                displayCardAnswer();
            } else {
                if (view.getId() == R.id.flashcard_layout_ease1) {
                    mIndex--;
                } else if (view.getId() == R.id.flashcard_layout_ease2) {
                    mIndex++;
                }
                mCurrentCard = getCol().getCard(mCardList[mIndex]);
                displayCardQuestion();
            }
        }
    };

    private void updateButtonState() {
        // If we are in single-card mode, we show the "Show Answer" button on the question side
        // and hide all the button s on the answer side.
        if (mCardList.length == 1) {
            if (!mShowingAnswer) {
                mFlipCardLayout.setVisibility(View.VISIBLE);
            } else {
                findViewById(R.id.answer_options_layout).setVisibility(View.GONE);
                mFlipCardLayout.setVisibility(View.GONE);
                hideEaseButtons();
            }
            return;
        }

        mFlipCardLayout.setVisibility(View.GONE);
        mEase1Layout.setVisibility(View.VISIBLE);
        mEase2Layout.setVisibility(View.VISIBLE);
        mEase3Layout.setVisibility(View.GONE);
        mEase4Layout.setVisibility(View.GONE);

        final int[] background = Themes.getResFromAttr(this, new int[]{R.attr.hardButtonRef});
        final int[] textColor = Themes.getColorFromAttr(this, new int[]{R.attr.hardButtonTextColor});

        mNext1.setTextSize(30);
        mEase1.setVisibility(View.GONE);
        mNext1.setTextColor(textColor[0]);
        mEase1Layout.setOnClickListener(mSelectScrollHandler);
        mEase1Layout.setBackgroundResource(background[0]);

        mNext2.setTextSize(30);
        mEase2.setVisibility(View.GONE);
        mNext2.setTextColor(textColor[0]);
        mEase2Layout.setOnClickListener(mSelectScrollHandler);
        mEase2Layout.setBackgroundResource(background[0]);


        if (mIndex == 0 && mShowingAnswer) {
            mEase1Layout.setEnabled(false);
            mNext1.setText("-");
        } else {
            mEase1Layout.setEnabled(true);
            mNext1.setText("<");
        }

        if (mIndex == mCardList.length - 1 && mShowingAnswer) {
            mEase2Layout.setEnabled(false);
            mNext2.setText("-");
        } else {
            mEase2Layout.setEnabled(true);
            mNext2.setText(">");
        }
    }
}
/****************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.Context;
import android.content.res.Resources;
import android.os.Handler;
import android.speech.tts.TextToSpeech;
import android.view.View;

import android.widget.Toast;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.compat.CompatHelper;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Locale;

import timber.log.Timber;

public class ReadText {
    private static TextToSpeech mTts;
    private static ArrayList<Locale> availableTtsLocales = new ArrayList<>();
    private static String mTextToSpeak;
    private static WeakReference<Context> mReviewer;
    private static long mDid;
    private static int mOrd;
    private static int mQuestionAnswer;
    public static final String NO_TTS = "0";
    public static ArrayList<String[]> sTextQueue = new ArrayList<>();
    public static HashMap<String, String> mTtsParams;


    // private boolean mTtsReady = false;

    public static void speak(String text, String loc) {
        int result = mTts.setLanguage(new Locale(loc));
        if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
            Toast.makeText(mReviewer.get(), mReviewer.get().getString(R.string.no_tts_available_message)
                    +" ("+loc+")", Toast.LENGTH_LONG).show();
            Timber.e("Error loading locale " + loc);
        } else {
            if (mTts.isSpeaking()) {
                Timber.d("tts engine appears to be busy... clearing queue");
                stopTts();
                //sTextQueue.add(new String[] { text, loc });
            }
            Timber.d("tts text '%s' to be played for locale (%s)",text, loc);
            mTts.speak(mTextToSpeak, TextToSpeech.QUEUE_FLUSH, mTtsParams);
        }
    }


    public static String getLanguage(long did, int ord, int qa) {
        return MetaDB.getLanguage(mReviewer.get(), did, ord, qa);
    }


    /**
     * Ask the user what language they want.
     *
     * @param text The text to be read
     * @param did The deck id
     * @param ord The card template ordinal
     * @param qa The card question or card answer
     */
    public static void selectTts(String text, long did, int ord, int qa) {
        mTextToSpeak = text;
        mQuestionAnswer = qa;
        mDid = did;
        mOrd = ord;
        Resources res = mReviewer.get().getResources();
        final MaterialDialog.Builder builder = new MaterialDialog.Builder(mReviewer.get());
        // Build the language list if it's empty
        if (availableTtsLocales.isEmpty()) {
            buildAvailableLanguages();
        }
        if (availableTtsLocales.size() == 0) {
            Timber.w("ReadText.textToSpeech() no TTS languages available");
            builder.content(res.getString(R.string.no_tts_available_message))
                    .iconAttr(R.attr.dialogErrorIcon)
                    .positiveText(res.getString(R.string.dialog_ok));
        } else {
            ArrayList<CharSequence> dialogItems = new ArrayList<>();
            final ArrayList<String> dialogIds = new ArrayList<>();
            // Add option: "no tts"
            dialogItems.add(res.getString(R.string.tts_no_tts));
            dialogIds.add(NO_TTS);
            for (int i = 0; i < availableTtsLocales.size(); i++) {
                dialogItems.add(availableTtsLocales.get(i).getDisplayName());
                dialogIds.add(availableTtsLocales.get(i).getISO3Language());
            }
            String[] items = new String[dialogItems.size()];
            dialogItems.toArray(items);

            builder.title(res.getString(R.string.select_locale_title))
                    .items(items)
                    .itemsCallback(new MaterialDialog.ListCallback() {
                        @Override
                        public void onSelection(MaterialDialog materialDialog, View view, int which,
                                                CharSequence charSequence) {
                            String locale = dialogIds.get(which);
                            Timber.d("ReadText.selectTts() user chose locale '%s'", locale);
                            if (!locale.equals(NO_TTS)) {
                                speak(mTextToSpeak, locale);
                            }
                            String language = getLanguage(mDid, mOrd, mQuestionAnswer);
                            if (language.equals("")) { // No language stored
                                MetaDB.storeLanguage(mReviewer.get(), mDid, mOrd, mQuestionAnswer, locale);
                            } else {
                                MetaDB.updateLanguage(mReviewer.get(), mDid, mOrd, mQuestionAnswer, locale);
                            }

                        }
                    });
        }
        // Show the dialog after short delay so that user gets a chance to preview the card
        final Handler handler = new Handler();
        final int delay = 500;
        handler.postDelayed(new Runnable() {
            @Override
            public void run() {
                builder.build().show();
            }
        }, delay);
    }


    public static void textToSpeech(String text, long did, int ord, int qa) {
        mTextToSpeak = text;
        mQuestionAnswer = qa;
        mDid = did;
        mOrd = ord;
        Timber.d("ReadText.textToSpeech() method started for string '%s'", text);
        // get the user's existing language preference
        String language = getLanguage(mDid, mOrd, mQuestionAnswer);
        Timber.d("ReadText.textToSpeech() method found language choice '%s'", language);
        // rebuild the language list if it's empty
        if (availableTtsLocales.isEmpty()) {
            buildAvailableLanguages();
        }
        // Check, if stored language is available
        for (int i = 0; i < availableTtsLocales.size(); i++) {
            if (language.equals(NO_TTS)) {
                // user has chosen not to read the text
                return;
            } else if (language.equals(availableTtsLocales.get(i).getISO3Language())) {
                speak(mTextToSpeak, language);
                return;
            }
        }

        // Otherwise ask the user what language they want to use
        selectTts(mTextToSpeak, mDid, mOrd, mQuestionAnswer);
    }


    public static void initializeTts(Context context) {
        // Store weak reference to Activity to prevent memory leak
        mReviewer = new WeakReference<>(context);
        // Create new TTS object and setup its onInit Listener
        mTts = new TextToSpeech(context, new TextToSpeech.OnInitListener() {
            @Override
            public void onInit(int status) {
                if (status == TextToSpeech.SUCCESS) {
                    // build list of available languages
                    buildAvailableLanguages();
                    if (availableTtsLocales.size() > 0) {
                        // notify the reviewer that TTS has been initialized
                        Timber.d("TTS initialized and available languages found");
                        ((AbstractFlashcardViewer) mReviewer.get()).ttsInitialized();
                    } else {
                        Toast.makeText(mReviewer.get(), mReviewer.get().getString(R.string.no_tts_available_message), Toast.LENGTH_LONG).show();
                        Timber.w("TTS initialized but no available languages found");
                    }
                } else {
                    Toast.makeText(mReviewer.get(), mReviewer.get().getString(R.string.no_tts_available_message), Toast.LENGTH_LONG).show();
                }
                CompatHelper.getCompat().setTtsOnUtteranceProgressListener(mTts);
            }
        });
        mTtsParams = new HashMap<>();
        mTtsParams.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, "stringId");
        // Show toast that it's getting initialized, as it can take a while before the sound plays the first time
        Toast.makeText(context, context.getString(R.string.initializing_tts), Toast.LENGTH_LONG).show();
    }

    public static void buildAvailableLanguages() {
        availableTtsLocales.clear();
        Locale[] systemLocales = Locale.getAvailableLocales();
        for (Locale loc : systemLocales) {
            try {
                int retCode = mTts.isLanguageAvailable(loc);
                if (retCode >= TextToSpeech.LANG_COUNTRY_AVAILABLE) {
                    availableTtsLocales.add(loc);
                } else {
                    Timber.v("ReadText.buildAvailableLanguages() :: %s  not available (error code %d)", loc.getDisplayName(), retCode);
                }
            } catch (IllegalArgumentException e) {
                Timber.e("Error checking if language " + loc.getDisplayName() + " available");
            }
        }
    }


    public static void releaseTts() {
        if (mTts != null) {
            mTts.stop();
            mTts.shutdown();
        }
    }


    public static void stopTts() {
        if (mTts != null) {
            if (sTextQueue != null) {
                sTextQueue.clear();
            }
            mTts.stop();
        }
    }
}
/****************************************************************************************
 * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 * Copyright (c) 2014 Bruno Romero de Azevedo <brunodea@inf.ufsm.br>                    *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/
// TODO: implement own menu? http://www.codeproject.com/Articles/173121/Android-Menus-My-Way

package com.ichi2.anki;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.os.Bundle;
import android.support.v4.content.ContextCompat;
import android.support.v4.view.ActionProvider;
import android.support.v4.view.MenuItemCompat;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.SubMenu;
import android.view.View;
import android.widget.FrameLayout;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.async.DeckTask;
import com.ichi2.compat.CompatHelper;
import com.ichi2.libanki.Card;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Collection.DismissType;
import com.ichi2.libanki.Sched;
import com.ichi2.themes.Themes;
import com.ichi2.widget.WidgetStatus;

import org.json.JSONException;

import java.lang.ref.WeakReference;
import java.text.MessageFormat;
import java.util.List;

import timber.log.Timber;

public class Reviewer extends AbstractFlashcardViewer {
    private boolean mHasDrawerSwipeConflicts = false;
    private boolean mShowWhiteboard = true;
    private boolean mBlackWhiteboard = true;
    private boolean mPrefFullscreenReview = false;
    private static final int ADD_NOTE = 12;
    private Long mLastSelectedBrowserDid = null;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Timber.d("onCreate()");

        if (Intent.ACTION_VIEW.equals(getIntent().getAction())) {
            Timber.d("onCreate() :: received Intent with action = %s", getIntent().getAction());
            selectDeckFromExtra();
        }

        super.onCreate(savedInstanceState);
    }

    private void selectDeckFromExtra() {
        Bundle extras = getIntent().getExtras();
        long did = extras.getLong("deckId", Long.MIN_VALUE);

        if(did == Long.MIN_VALUE) {
            // deckId is not set, load default
            return;
        }

        Timber.d("selectDeckFromExtra() with deckId = %d", did);

        // Clear the undo history when selecting a new deck
        if (getCol().getDecks().selected() != did) {
            getCol().clearUndo();
        }
        // Select the deck
        getCol().getDecks().select(did);
        // Reset the schedule so that we get the counts for the currently selected deck
        getCol().getSched().reset();
    }

    @Override
    protected void setTitle() {
        try {
            String[] title = {""};
            if (colIsOpen()) {
                title = getCol().getDecks().current().getString("name").split("::");
            } else {
                Timber.e("Could not set title in reviewer because collection closed");
            }
            getSupportActionBar().setTitle(title[title.length - 1]);
            super.setTitle(title[title.length - 1]);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        getSupportActionBar().setSubtitle("");
    }

    @Override
    protected int getContentViewAttr(int fullscreenMode) {
        if (CompatHelper.getSdkVersion() < Build.VERSION_CODES.KITKAT) {
            fullscreenMode = 0;     // The specific fullscreen layouts are only applicable for immersive mode
        }
        switch (fullscreenMode) {
            case 1:
                return R.layout.reviewer_fullscreen_1;
            case 2:
                return R.layout.reviewer_fullscreen_2;
            default:
                return R.layout.reviewer;
        }
    }

    @Override
    protected void onCollectionLoaded(Collection col) {
        super.onCollectionLoaded(col);
        // Load the first card and start reviewing. Uses the answer card
        // task to load a card, but since we send null
        // as the card to answer, no card will be answered.

        mPrefWhiteboard = MetaDB.getWhiteboardState(this, getParentDid());
        if (mPrefWhiteboard) {
            setWhiteboardEnabledState(true);
            setWhiteboardVisibility(true);
        }

        col.getSched().reset();     // Reset schedule incase card had previous been loaded
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler,
                new DeckTask.TaskData(null, 0));

        disableDrawerSwipeOnConflicts();
        // Add a weak reference to current activity so that scheduler can talk to to Activity
        mSched.setContext(new WeakReference<Activity>(this));

        // Set full screen/immersive mode if needed
        if (mPrefFullscreenReview) {
            CompatHelper.getCompat().setFullScreen(this);
        }
    }


    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (getDrawerToggle().onOptionsItemSelected(item)) {
            return true;
        }
        switch (item.getItemId()) {

            case android.R.id.home:
                Timber.i("Reviewer:: Home button pressed");
                closeReviewer(RESULT_OK, true);
                break;

            case R.id.action_undo:
                Timber.i("Reviewer:: Undo button pressed");
                if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.undoSize() > 0) {
                    mWhiteboard.undo();
                } else {
                    undo();
                }
                break;

            case R.id.action_mark_card:
                Timber.i("Reviewer:: Mark button pressed");
                onMark(mCurrentCard);
                break;

            case R.id.action_replay:
                Timber.i("Reviewer:: Replay audio button pressed (from menu)");
                playSounds(true);
                break;

            case R.id.action_edit:
                Timber.i("Reviewer:: Edit note button pressed");
                return editCard();

            case R.id.action_bury:
                Timber.i("Reviewer:: Bury button pressed");
                if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {
                    Timber.d("Bury card due to no submenu");
                    dismiss(DismissType.BURY_CARD);
                }
                break;

            case R.id.action_suspend:
                Timber.i("Reviewer:: Suspend button pressed");
                if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {
                    Timber.d("Suspend card due to no submenu");
                    dismiss(DismissType.SUSPEND_CARD);
                }
                break;

            case R.id.action_delete:
                Timber.i("Reviewer:: Delete note button pressed");
                showDeleteNoteDialog();
                break;

            case R.id.action_clear_whiteboard:
                Timber.i("Reviewer:: Clear whiteboard button pressed");
                if (mWhiteboard != null) {
                    mWhiteboard.clear();
                }
                break;

            case R.id.action_hide_whiteboard:
                // toggle whiteboard visibility
                Timber.i("Reviewer:: Whiteboard visibility set to %b", !mShowWhiteboard);
                setWhiteboardVisibility(!mShowWhiteboard);
                refreshActionBar();
                break;

            case R.id.action_enable_whiteboard:
                // toggle whiteboard enabled state (and show/hide whiteboard item in action bar)
                mPrefWhiteboard = ! mPrefWhiteboard;
                Timber.i("Reviewer:: Whiteboard enabled state set to %b", mPrefWhiteboard);
                setWhiteboardEnabledState(mPrefWhiteboard);
                setWhiteboardVisibility(mPrefWhiteboard);
                refreshActionBar();
                break;

            case R.id.action_search_dictionary:
                Timber.i("Reviewer:: Search dictionary button pressed");
                lookUpOrSelectText();
                break;

            case R.id.action_open_deck_options:
                Intent i = new Intent(this, DeckOptions.class);
                startActivityForResultWithAnimation(i, DECK_OPTIONS, ActivityTransitionAnimation.FADE);
                break;

            case R.id.action_select_tts:
                Timber.i("Reviewer:: Select TTS button pressed");
                showSelectTtsDialogue();
                break;

            case R.id.action_add_note_reviewer:
                Timber.i("Reviewer:: Add note button pressed");
                addNote();
                break;

            default:
                return super.onOptionsItemSelected(item);
        }
        return true;
    }


    private void addNote() {
        Intent intent = new Intent(this, NoteEditor.class);
        intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_REVIEWER_ADD);
        startActivityForResultWithAnimation(intent, ADD_NOTE, ActivityTransitionAnimation.LEFT);
    }


    private void setCustomButtons(Menu menu) {
        for(int itemId : mCustomButtons.keySet()) {
            if(mCustomButtons.get(itemId) != MENU_DISABLED) {
                MenuItemCompat.setShowAsAction(menu.findItem(itemId), mCustomButtons.get(itemId));
            }
            else {
                menu.findItem(itemId).setVisible(false);
            }
        }
    }


    @SuppressLint("NewApi")
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // NOTE: This is called every time a new question is shown via invalidate options menu
        getMenuInflater().inflate(R.menu.reviewer, menu);
        Resources res = getResources();
        setCustomButtons(menu);
        if (mCurrentCard != null && mCurrentCard.note().hasTag("marked")) {
            menu.findItem(R.id.action_mark_card).setTitle(R.string.menu_unmark_note).setIcon(R.drawable.ic_star_white_24dp);
        } else {
            menu.findItem(R.id.action_mark_card).setTitle(R.string.menu_mark_note).setIcon(R.drawable.ic_star_outline_white_24dp);
        }

        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.undoSize() > 0) {
            // Whiteboard undo queue non-empty. Switch the undo icon to a whiteboard specific one.
            menu.findItem(R.id.action_undo).setIcon(R.drawable.ic_eraser_variant_white_24dp);
            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);
        } else if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {
            // Whiteboard undo queue empty, but user has added strokes to it for current card. Disable undo button.
            menu.findItem(R.id.action_undo).setIcon(R.drawable.ic_eraser_variant_white_24dp);
            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);
        } else if (colIsOpen() && getCol().undoAvailable()) {
            menu.findItem(R.id.action_undo).setIcon(R.drawable.ic_undo_white_24dp);
            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);
        } else {
            menu.findItem(R.id.action_undo).setIcon(R.drawable.ic_undo_white_24dp);
            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);
        }
        if (mPrefWhiteboard) {
            // Configure the whiteboard related items in the action bar
            menu.findItem(R.id.action_enable_whiteboard).setTitle(R.string.disable_whiteboard);
            if(mCustomButtons.get(R.id.action_hide_whiteboard) != MENU_DISABLED)
                menu.findItem(R.id.action_hide_whiteboard).setVisible(true);
            if(mCustomButtons.get(R.id.action_clear_whiteboard) != MENU_DISABLED)
                menu.findItem(R.id.action_clear_whiteboard).setVisible(true);

            Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white_24dp);
            if (mShowWhiteboard) {
                whiteboardIcon.setAlpha(255);
                menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);
                menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.hide_whiteboard);
            } else {
                whiteboardIcon.setAlpha(77);
                menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);
                menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.show_whiteboard);
            }
        } else {
            menu.findItem(R.id.action_enable_whiteboard).setTitle(R.string.enable_whiteboard);
        }
        if (!CompatHelper.isHoneycomb() && !mDisableClipboard) {
            menu.findItem(R.id.action_search_dictionary).setVisible(true).setEnabled(!(mPrefWhiteboard && mShowWhiteboard))
                    .setTitle(clipboardHasText() ? Lookup.getSearchStringTitle() : res.getString(R.string.menu_select));
        }
        if (getCol().getDecks().isDyn(getParentDid())) {
            menu.findItem(R.id.action_open_deck_options).setVisible(false);
        }
        if(mSpeakText){
            if(mCustomButtons.get(R.id.action_select_tts) != MENU_DISABLED)
                menu.findItem(R.id.action_select_tts).setVisible(true);
        }
        // Setup bury / suspend providers
        MenuItemCompat.setActionProvider(menu.findItem(R.id.action_suspend), new SuspendProvider(this));
        MenuItemCompat.setActionProvider(menu.findItem(R.id.action_bury), new BuryProvider(this));
        if (dismissNoteAvailable(DismissType.SUSPEND_NOTE)) {
            menu.findItem(R.id.action_suspend).setIcon(R.drawable.ic_lock_outline_white_24px_dropdown);
            menu.findItem(R.id.action_suspend).setTitle(R.string.menu_suspend);
        } else {
            menu.findItem(R.id.action_suspend).setIcon(R.drawable.ic_lock_outline_white_24dp);
            menu.findItem(R.id.action_suspend).setTitle(R.string.menu_suspend_card);
        }
        if (dismissNoteAvailable(DismissType.BURY_NOTE)) {
            menu.findItem(R.id.action_bury).setIcon(R.drawable.ic_flip_to_back_white_24px_dropdown);
            menu.findItem(R.id.action_bury).setTitle(R.string.menu_bury);
        } else {
            menu.findItem(R.id.action_bury).setIcon(R.drawable.ic_flip_to_back_white_24dp);
            menu.findItem(R.id.action_bury).setTitle(R.string.menu_bury_card);
        }
        return super.onCreateOptionsMenu(menu);
    }


    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        char keyPressed = (char) event.getUnicodeChar();
        if (mAnswerField != null && !mAnswerField.isFocused()) {
	        if (sDisplayAnswer) {
	            if (keyPressed == '1') {
	                answerCard(EASE_1);
	                return true;
	            }
	            if (keyPressed == '2') {
	                answerCard(EASE_2);
	                return true;
	            }
	            if (keyPressed == '3') {
	                answerCard(EASE_3);
	                return true;
	            }
	            if (keyPressed == '4') {
	                answerCard(EASE_4);
	                return true;
	            }
	            if (keyCode == KeyEvent.KEYCODE_SPACE || keyCode == KeyEvent.KEYCODE_ENTER || keyCode == KeyEvent.KEYCODE_NUMPAD_ENTER) {
	                answerCard(getDefaultEase());
	                return true;
	            }
	        }
	        if (keyPressed == 'e') {
	            editCard();
	            return true;
	        }
	        if (keyPressed == '*') {
                onMark(mCurrentCard);
	            return true;
	        }
	        if (keyPressed == '-') {
                dismiss(DismissType.BURY_CARD);
	            return true;
	        }
	        if (keyPressed == '=') {
                dismiss(DismissType.BURY_NOTE);
	            return true;
	        }
	        if (keyPressed == '@') {
                dismiss(DismissType.SUSPEND_CARD);
	            return true;
	        }
	        if (keyPressed == '!') {
                dismiss(DismissType.SUSPEND_NOTE);
	            return true;
	        }
	        if (keyPressed == 'r' || keyCode == KeyEvent.KEYCODE_F5) {
	            playSounds(true);
	            return true;
	        }

            // different from Anki Desktop
            if (keyPressed == 'z') {
                undo();
                return true;
            }
        }
        return super.onKeyUp(keyCode, event);
    }


    @Override
    protected SharedPreferences restorePreferences() {
        super.restorePreferences();
        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());
        mBlackWhiteboard = preferences.getBoolean("blackWhiteboard", true);
        mPrefFullscreenReview = Integer.parseInt(preferences.getString("fullscreenMode", "0")) > 0;
        return preferences;
    }

    @Override
    public void fillFlashcard() {
        super.fillFlashcard();
        if (!sDisplayAnswer) {
            if (mShowWhiteboard && mWhiteboard != null) {
                mWhiteboard.clear();
            }
        }
    }


    @Override
    public void displayCardQuestion() {
        // show timer, if activated in the deck's preferences
        initTimer();
        super.displayCardQuestion();
    }

    @Override
    protected void onStop() {
        super.onStop();

        if (!isFinishing()) {
            if (colIsOpen() && mSched != null) {
                WidgetStatus.update(this);
            }
        }
        UIUtils.saveCollectionInBackground(this);
    }


    @Override
    protected void initControls() {
        super.initControls();
        if (mPrefWhiteboard) {
            setWhiteboardVisibility(mShowWhiteboard);
        }
    }


    private void setWhiteboardEnabledState(boolean state) {
        mPrefWhiteboard = state;
        MetaDB.storeWhiteboardState(this, getParentDid(), state);
        if (state && mWhiteboard == null) {
            createWhiteboard();
        }
    }

    // Create the whiteboard
    private void createWhiteboard() {
        mWhiteboard = new Whiteboard(this, mNightMode, mBlackWhiteboard);
        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(
                android.view.ViewGroup.LayoutParams.FILL_PARENT, android.view.ViewGroup.LayoutParams.FILL_PARENT);
        mWhiteboard.setLayoutParams(lp2);
        FrameLayout fl = (FrameLayout) findViewById(R.id.whiteboard);
        fl.addView(mWhiteboard);

        mWhiteboard.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                if (!mShowWhiteboard || (mPrefFullscreenReview
                        && CompatHelper.getCompat().isImmersiveSystemUiVisible(Reviewer.this))) {
                    // Bypass whiteboard listener when it's hidden or fullscreen immersive mode is temporarily suspended
                    return getGestureDetector().onTouchEvent(event);
                }
                return mWhiteboard.handleTouchEvent(event);
            }
        });
        mWhiteboard.setEnabled(true);
    }

    // Show or hide the whiteboard
    private void setWhiteboardVisibility(boolean state) {
        mShowWhiteboard = state;
        if (state) {
            mWhiteboard.setVisibility(View.VISIBLE);
            disableDrawerSwipe();
        } else {
            mWhiteboard.setVisibility(View.GONE);
            if (!mHasDrawerSwipeConflicts) {
                enableDrawerSwipe();
            }
        }
    }


    private void disableDrawerSwipeOnConflicts() {
        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());
        boolean gesturesEnabled = AnkiDroidApp.initiateGestures(preferences);
        if (gesturesEnabled) {
            int gestureSwipeUp = Integer.parseInt(preferences.getString("gestureSwipeUp", "9"));
            int gestureSwipeDown = Integer.parseInt(preferences.getString("gestureSwipeDown", "0"));
            int gestureSwipeRight = Integer.parseInt(preferences.getString("gestureSwipeRight", "17"));
            if (gestureSwipeUp != GESTURE_NOTHING ||
                    gestureSwipeDown != GESTURE_NOTHING ||
                    gestureSwipeRight != GESTURE_NOTHING) {
                mHasDrawerSwipeConflicts = true;
                super.disableDrawerSwipe();
            }
        }
    }


    @Override
    protected void openCardBrowser() {
        Intent cardBrowser = new Intent(this, CardBrowser.class);
        cardBrowser.putExtra("selectedDeck", getCol().getDecks().selected());
        if (mLastSelectedBrowserDid != null) {
            cardBrowser.putExtra("defaultDeckId", mLastSelectedBrowserDid);
        } else {
            cardBrowser.putExtra("defaultDeckId", getCol().getDecks().selected());
        }
        cardBrowser.putExtra("currentCard", mCurrentCard.getId());
        startActivityForResultWithAnimation(cardBrowser, REQUEST_BROWSE_CARDS, ActivityTransitionAnimation.LEFT);
    }


    @Override
    public void onWindowFocusChanged(boolean hasFocus) {
        super.onWindowFocusChanged(hasFocus);
        // Restore full screen once we regain focus
        if (hasFocus) {
            delayedHide(INITIAL_HIDE_DELAY);
        } else {
            mFullScreenHandler.removeMessages(0);
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == REQUEST_STATISTICS || requestCode == REQUEST_BROWSE_CARDS) {
            // Store the selected deck
            if (data != null && data.getBooleanExtra("allDecksSelected", false)) {
                mLastSelectedBrowserDid = -1L;
            } else {
                mLastSelectedBrowserDid = getCol().getDecks().selected();
            }
            // select original deck if the statistics or card browser were opened, which can change the selected deck
            if (data != null && data.hasExtra("originalDeck")) {
                getCol().getDecks().select(data.getLongExtra("originalDeck", 0L));
            }
        }
        super.onActivityResult(requestCode, resultCode, data);
    }


    /**
     * Whether or not dismiss note is available for current card and specified DismissType
     * @param type Currently only SUSPEND_NOTE and BURY_NOTE supported
     * @return true if there is another card of same note that could be dismissed
     */
    private boolean dismissNoteAvailable(DismissType type) {
        if (mCurrentCard == null || mCurrentCard.note() == null || mCurrentCard.note().cards().size() < 2) {
            return false;
        }
        List<Card> cards = mCurrentCard.note().cards();
        for(Card card : cards) {
            if (card.getId() == mCurrentCard.getId()) continue;
            int queue = card.getQueue();
            if(type == DismissType.SUSPEND_NOTE && queue != Card.QUEUE_SUSP) {
                return true;
            } else if (type == DismissType.BURY_NOTE &&
                    queue != Card.QUEUE_SUSP && queue != Card.QUEUE_USER_BRD && queue != Card.QUEUE_SCHED_BRD) {
                return true;
            }
        }
        return false;
    }

    /**
     * Inner class which implements the submenu for the Suspend button
     */
    class SuspendProvider extends ActionProvider implements MenuItem.OnMenuItemClickListener {
        public SuspendProvider(Context context) {
            super(context);
        }

        @Override
        public View onCreateActionView() {
            return null;  // Just return null for a simple dropdown menu
        }

        @Override
        public boolean hasSubMenu() {
            return dismissNoteAvailable(DismissType.SUSPEND_NOTE);
        }

        @Override
        public void onPrepareSubMenu(SubMenu subMenu) {
            subMenu.clear();
            getMenuInflater().inflate(R.menu.reviewer_suspend, subMenu);
            for (int i = 0; i < subMenu.size(); i++) {
                subMenu.getItem(i).setOnMenuItemClickListener(this);
            }
        }

        @Override
        public boolean onMenuItemClick(MenuItem item) {
            switch (item.getItemId()) {
                case R.id.action_suspend_card:
                    dismiss(DismissType.SUSPEND_CARD);
                    return true;
                case R.id.action_suspend_note:
                    dismiss(DismissType.SUSPEND_NOTE);
                    return true;
                default:
                    return false;
            }
        }
    }

    /**
     * Inner class which implements the submenu for the Suspend button
     */
    class BuryProvider extends ActionProvider implements MenuItem.OnMenuItemClickListener {
        public BuryProvider(Context context) {
            super(context);
        }

        @Override
        public View onCreateActionView() {
            return null;    // Just return null for a simple dropdown menu
        }

        @Override
        public boolean hasSubMenu() {
            return dismissNoteAvailable(DismissType.BURY_NOTE);
        }

        @Override
        public void onPrepareSubMenu(SubMenu subMenu) {
            subMenu.clear();
            getMenuInflater().inflate(R.menu.reviewer_bury, subMenu);
            for (int i = 0; i < subMenu.size(); i++) {
                subMenu.getItem(i).setOnMenuItemClickListener(this);
            }
        }

        @Override
        public boolean onMenuItemClick(MenuItem item) {
            switch (item.getItemId()) {
                case R.id.action_bury_card:
                    dismiss(DismissType.BURY_CARD);
                    return true;
                case R.id.action_bury_note:
                    dismiss(DismissType.BURY_NOTE);
                    return true;
                default:
                    return false;
            }
        }
    }
}
/****************************************************************************************
 * Copyright (c) 2014 Michael Goldbach <michael@m-goldbach.net>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/
package com.ichi2.anki;

import android.content.Intent;
import android.graphics.Color;
import android.os.AsyncTask;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.view.ViewPager;
import android.support.v7.app.ActionBar;
import android.support.v7.app.AppCompatActivity;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.webkit.WebView;
import android.widget.AdapterView;
import android.widget.ProgressBar;
import android.widget.Spinner;
import android.widget.TextView;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.stats.AnkiStatsTaskHandler;
import com.ichi2.anki.stats.ChartView;
import com.ichi2.anki.widgets.DeckDropDownAdapter;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Stats;
import com.ichi2.ui.SlidingTabLayout;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

import timber.log.Timber;


public class Statistics extends NavigationDrawerActivity implements DeckDropDownAdapter.SubtitleListener {

    public static final int TODAYS_STATS_TAB_POSITION = 0;
    public static final int FORECAST_TAB_POSITION = 1;
    public static final int REVIEW_COUNT_TAB_POSITION = 2;
    public static final int REVIEW_TIME_TAB_POSITION = 3;
    public static final int INTERVALS_TAB_POSITION = 4;
    public static final int HOURLY_BREAKDOWN_TAB_POSITION = 5;
    public static final int WEEKLY_BREAKDOWN_TAB_POSITION = 6;
    public static final int ANSWER_BUTTONS_TAB_POSITION = 7;
    public static final int CARDS_TYPES_TAB_POSITION = 8;

    private SectionsPagerAdapter mSectionsPagerAdapter;
    private ViewPager mViewPager;
    private AnkiStatsTaskHandler mTaskHandler = null;
    private ArrayList<JSONObject> mDropDownDecks;
    private Spinner mActionBarSpinner;
    private boolean mIsWholeCollection = false;
    private static boolean sIsSubtitle;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Timber.d("onCreate()");
        sIsSubtitle = true;
        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_anki_stats);
        initNavigationDrawer(findViewById(android.R.id.content));
        startLoadingCollection();
    }

    @Override
    protected void onCollectionLoaded(Collection col) {
        Timber.d("onCollectionLoaded()");
        SlidingTabLayout slidingTabLayout;
        // Add drop-down menu to select deck to action bar.
        mDropDownDecks = getCol().getDecks().allSorted();
        ActionBar actionBar = getSupportActionBar();
        actionBar.setDisplayShowTitleEnabled(false);
        mActionBarSpinner = (Spinner) findViewById(R.id.toolbar_spinner);
        mActionBarSpinner.setAdapter(new DeckDropDownAdapter(this, mDropDownDecks));
        mActionBarSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                selectDropDownItem(position);
            }

            @Override
            public void onNothingSelected(AdapterView<?> parent) {
                // do nothing
            }
        });
        mActionBarSpinner.setVisibility(View.VISIBLE);

        // Setup Task Handler
        mTaskHandler = new AnkiStatsTaskHandler(col);

        // Create the adapter that will return a fragment for each of the three
        // primary sections of the activity.
        mSectionsPagerAdapter = new SectionsPagerAdapter(getSupportFragmentManager());

        // Set up the ViewPager with the sections adapter.
        mViewPager = (ViewPager) findViewById(R.id.pager);
        mViewPager.setAdapter(mSectionsPagerAdapter);
        mViewPager.setOffscreenPageLimit(8);
        slidingTabLayout = (SlidingTabLayout) findViewById(R.id.sliding_tabs);
        slidingTabLayout.setViewPager(mViewPager);

        // Dirty way to get text size from a TextView with current style, change if possible
        float size = new TextView(this).getTextSize();
        mTaskHandler.setmStandardTextSize(size);
        // Prepare options menu only after loading everything
        supportInvalidateOptionsMenu();
        mSectionsPagerAdapter.notifyDataSetChanged();

        // set the currently selected deck
        String currentDeckName;
        try {
            currentDeckName = getCol().getDecks().current().getString("name");
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        if (mIsWholeCollection) {
            selectDropDownItem(0);
        } else {
            for (int dropDownDeckIdx = 0; dropDownDeckIdx < mDropDownDecks.size(); dropDownDeckIdx++) {
                JSONObject deck = mDropDownDecks.get(dropDownDeckIdx);
                String deckName;
                try {
                    deckName = deck.getString("name");
                } catch (JSONException e) {
                    throw new RuntimeException();
                }
                if (deckName.equals(currentDeckName)) {
                    selectDropDownItem(dropDownDeckIdx + 1);
                    break;
                }
            }
        }
    }


    @Override
    protected void onResume() {
        Timber.d("onResume()");
        selectNavigationItem(R.id.nav_stats);
        super.onResume();
    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        //System.err.println("in onCreateOptionsMenu");
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.anki_stats, menu);
        return true;
    }


    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        // exit if mTaskHandler not initialized yet
        if (mTaskHandler == null) {
            return true;
        }
        switch (mTaskHandler.getStatType()) {
            case TYPE_MONTH:
                MenuItem monthItem = menu.findItem(R.id.item_time_month);
                monthItem.setChecked(true);
                break;
            case TYPE_YEAR:
                MenuItem yearItem = menu.findItem(R.id.item_time_year);
                yearItem.setChecked(true);
                break;
            case TYPE_LIFE:
                MenuItem lifeItem = menu.findItem(R.id.item_time_all);
                lifeItem.setChecked(true);
                break;
        }
        return super.onPrepareOptionsMenu(menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (getDrawerToggle().onOptionsItemSelected(item)) {
            return true;
        }
        int itemId = item.getItemId();
        switch (itemId) {
            case R.id.item_time_month:
                if (item.isChecked()) item.setChecked(false);
                else item.setChecked(true);
                if (mTaskHandler.getStatType() != Stats.AxisType.TYPE_MONTH) {
                    mTaskHandler.setStatType(Stats.AxisType.TYPE_MONTH);
                    mSectionsPagerAdapter.notifyDataSetChanged();
                }
                return true;
            case R.id.item_time_year:
                if (item.isChecked()) item.setChecked(false);
                else item.setChecked(true);
                if (mTaskHandler.getStatType() != Stats.AxisType.TYPE_YEAR) {
                    mTaskHandler.setStatType(Stats.AxisType.TYPE_YEAR);
                    mSectionsPagerAdapter.notifyDataSetChanged();
                }
                return true;
            case R.id.item_time_all:
                if (item.isChecked()) item.setChecked(false);
                else item.setChecked(true);
                if (mTaskHandler.getStatType() != Stats.AxisType.TYPE_LIFE) {
                    mTaskHandler.setStatType(Stats.AxisType.TYPE_LIFE);
                    mSectionsPagerAdapter.notifyDataSetChanged();
                }
                return true;
            case R.id.action_time_chooser:
                //showTimeDialog();
                return true;
        }
        return super.onOptionsItemSelected(item);
    }


    public void selectDropDownItem(int position) {
        mActionBarSpinner.setSelection(position);
        if (position == 0) {
            mIsWholeCollection = true;
        } else {
            mIsWholeCollection = false;
            JSONObject deck = mDropDownDecks.get(position - 1);
            try {
                getCol().getDecks().select(deck.getLong("id"));
            } catch (JSONException e) {
                Timber.e(e, "Could not get ID from deck");
            }
        }
        mTaskHandler.setIsWholeCollection(mIsWholeCollection);
        mSectionsPagerAdapter.notifyDataSetChanged();
    }


    /**
     * @return text to be used in the subtitle of the drop-down deck selector
     */
    public String getSubtitleText() {
        return getResources().getString(R.string.statistics);
    }


    public AnkiStatsTaskHandler getTaskHandler(){
        return mTaskHandler;
    }


    public ViewPager getViewPager(){
        return mViewPager;
    }


    public SectionsPagerAdapter getSectionsPagerAdapter() {
        return mSectionsPagerAdapter;
    }


    /**
     * A {@link FragmentPagerAdapter} that returns a fragment corresponding to
     * one of the sections/tabs/pages.
     */
    public class SectionsPagerAdapter extends FragmentPagerAdapter {

        public SectionsPagerAdapter(FragmentManager fm) {
            super(fm);
        }

        //this is called when mSectionsPagerAdapter.notifyDataSetChanged() is called, so checkAndUpdate() here
        //works best for updating all tabs
        @Override
        public int getItemPosition(Object object) {
            if (object instanceof StatisticFragment) {
                ((StatisticFragment) object).checkAndUpdate();
            }
            //don't return POSITION_NONE, avoid fragment recreation.
            return super.getItemPosition(object);
        }

        @Override
        public Fragment getItem(int position) {
            Fragment item = StatisticFragment.newInstance(position);
            ((StatisticFragment) item).checkAndUpdate();
            return item;
        }

        @Override
        public int getCount() {
            return 9;
        }

        @Override
        public CharSequence getPageTitle(int position) {
            Locale l = Locale.getDefault();

            switch (position) {
                case TODAYS_STATS_TAB_POSITION:
                    return getString(R.string.stats_overview).toUpperCase(l);
                case FORECAST_TAB_POSITION:
                    return getString(R.string.stats_forecast).toUpperCase(l);
                case REVIEW_COUNT_TAB_POSITION:
                    return getString(R.string.stats_review_count).toUpperCase(l);
                case REVIEW_TIME_TAB_POSITION:
                    return getString(R.string.stats_review_time).toUpperCase(l);
                case INTERVALS_TAB_POSITION:
                    return getString(R.string.stats_review_intervals).toUpperCase(l);
                case HOURLY_BREAKDOWN_TAB_POSITION:
                    return getString(R.string.stats_breakdown).toUpperCase(l);
                case WEEKLY_BREAKDOWN_TAB_POSITION:
                    return getString(R.string.stats_weekly_breakdown).toUpperCase(l);
                case ANSWER_BUTTONS_TAB_POSITION:
                    return getString(R.string.stats_answer_buttons).toUpperCase(l);
                case CARDS_TYPES_TAB_POSITION:
                    return getString(R.string.stats_cards_types).toUpperCase(l);
            }
            return null;
        }
    }

    public static abstract class StatisticFragment extends Fragment {

        //track current settings for each individual fragment
        protected long mDeckId;
        protected ViewPager mActivityPager;
        protected SectionsPagerAdapter mActivitySectionPagerAdapter;

        /**
         * The fragment argument representing the section number for this
         * fragment.
         */
        protected static final String ARG_SECTION_NUMBER = "section_number";


        /**
         * Returns a new instance of this fragment for the given section
         * number.
         */
        public static StatisticFragment newInstance(int sectionNumber) {
            Fragment fragment;
            Bundle args;
            switch (sectionNumber) {
                case FORECAST_TAB_POSITION:
                case REVIEW_COUNT_TAB_POSITION:
                case REVIEW_TIME_TAB_POSITION:
                case INTERVALS_TAB_POSITION:
                case HOURLY_BREAKDOWN_TAB_POSITION:
                case WEEKLY_BREAKDOWN_TAB_POSITION:
                case ANSWER_BUTTONS_TAB_POSITION:
                case CARDS_TYPES_TAB_POSITION:
                    fragment = new ChartFragment();
                    args = new Bundle();
                    args.putInt(ARG_SECTION_NUMBER, sectionNumber);
                    fragment.setArguments(args);
                    return (ChartFragment) fragment;
                case TODAYS_STATS_TAB_POSITION:
                    fragment = new OverviewStatisticsFragment();
                    args = new Bundle();
                    args.putInt(ARG_SECTION_NUMBER, sectionNumber);
                    fragment.setArguments(args);
                    return (OverviewStatisticsFragment) fragment;
                default:
                    return null;
            }
        }

        @Override
        public void onResume() {
            super.onResume();
            checkAndUpdate();

        }

        public abstract void invalidateView();
        public abstract void checkAndUpdate();
    }


    /**
     * A chart fragment containing a ChartView.
     */
    public static class ChartFragment extends StatisticFragment {

        private ChartView mChart;
        private ProgressBar mProgressBar;
        private int mHeight = 0;
        private int mWidth = 0;
        private int mSectionNumber;
        private Stats.AxisType mType  = Stats.AxisType.TYPE_MONTH;
        private boolean mIsCreated = false;
        private AsyncTask mCreateChartTask;

        public ChartFragment() {
            super();
        }

        @Override
        public View onCreateView(LayoutInflater inflater, ViewGroup container,
                                 Bundle savedInstanceState) {
            setHasOptionsMenu(true);
            Bundle bundle = getArguments();
            mSectionNumber = bundle.getInt(ARG_SECTION_NUMBER);
            //int sectionNumber = 0;
            //System.err.println("sectionNumber: " + mSectionNumber);
            View rootView = inflater.inflate(R.layout.fragment_anki_stats, container, false);
            mChart = (ChartView) rootView.findViewById(R.id.image_view_chart);
            if (mChart == null) {
                Timber.d("mChart null!");
            } else {
                Timber.d("mChart is not null!");
            }

            //mChart.setLayerType(View.LAYER_TYPE_SOFTWARE, null);

            mProgressBar = (ProgressBar) rootView.findViewById(R.id.progress_bar_stats);

            mProgressBar.setVisibility(View.VISIBLE);
            //mChart.setVisibility(View.GONE);

            // TODO: Implementing loader for Collection in Fragment itself would be a better solution.
            if ((((Statistics) getActivity()).getTaskHandler()) == null) {
                // Close statistics if the TaskHandler hasn't been loaded yet
                Timber.e("Statistics.ChartFragment.onCreateView() TaskHandler not found");
                getActivity().finish();
                return rootView;
            }

            createChart();
            mHeight = mChart.getMeasuredHeight();
            mWidth = mChart.getMeasuredWidth();
            mChart.addFragment(this);

            mType = (((Statistics) getActivity()).getTaskHandler()).getStatType();
            mIsCreated = true;
            mActivityPager = ((Statistics) getActivity()).getViewPager();
            mActivitySectionPagerAdapter = ((Statistics) getActivity()).getSectionsPagerAdapter();
            mDeckId = CollectionHelper.getInstance().getCol(getActivity()).getDecks().selected();
            if (!isWholeCollection()) {
                try {
                    Collection col = CollectionHelper.getInstance().getCol(getActivity());
                    List<String> parts = Arrays.asList(col.getDecks().current().getString("name").split("::", -1));
                    if (sIsSubtitle) {
                        ((AppCompatActivity) getActivity()).getSupportActionBar().setSubtitle(parts.get(parts.size() - 1));
                    } else {
                        getActivity().setTitle(parts.get(parts.size() - 1));
                    }
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
            } else {
                if (sIsSubtitle) {
                    ((AppCompatActivity) getActivity()).getSupportActionBar().setSubtitle(R.string.stats_deck_collection);
                } else {
                    getActivity().setTitle(getResources().getString(R.string.stats_deck_collection));
                }
            }
            return rootView;
        }

        private void createChart() {
            switch (mSectionNumber) {
                case FORECAST_TAB_POSITION:
                    mCreateChartTask = (((Statistics) getActivity()).getTaskHandler()).createChart(
                            Stats.ChartType.FORECAST, mChart, mProgressBar);
                    break;
                case REVIEW_COUNT_TAB_POSITION:
                    mCreateChartTask = (((Statistics) getActivity()).getTaskHandler()).createChart(
                            Stats.ChartType.REVIEW_COUNT, mChart, mProgressBar);
                    break;
                case REVIEW_TIME_TAB_POSITION:
                    mCreateChartTask = (((Statistics) getActivity()).getTaskHandler()).createChart(
                            Stats.ChartType.REVIEW_TIME, mChart, mProgressBar);
                    break;
                case INTERVALS_TAB_POSITION:
                    mCreateChartTask = (((Statistics) getActivity()).getTaskHandler()).createChart(
                            Stats.ChartType.INTERVALS, mChart, mProgressBar);
                    break;
                case HOURLY_BREAKDOWN_TAB_POSITION:
                    mCreateChartTask = (((Statistics) getActivity()).getTaskHandler()).createChart(
                            Stats.ChartType.HOURLY_BREAKDOWN, mChart, mProgressBar);
                    break;
                case WEEKLY_BREAKDOWN_TAB_POSITION:
                    mCreateChartTask = (((Statistics) getActivity()).getTaskHandler()).createChart(
                            Stats.ChartType.WEEKLY_BREAKDOWN, mChart, mProgressBar);
                    break;
                case ANSWER_BUTTONS_TAB_POSITION:
                    mCreateChartTask = (((Statistics) getActivity()).getTaskHandler()).createChart(
                            Stats.ChartType.ANSWER_BUTTONS, mChart, mProgressBar);
                    break;
                case CARDS_TYPES_TAB_POSITION:
                    mCreateChartTask = (((Statistics) getActivity()).getTaskHandler()).createChart(
                            Stats.ChartType.CARDS_TYPES, mChart, mProgressBar);
                    break;
            }
        }


        @Override
        public void checkAndUpdate() {
            //System.err.println("<<<<<<<checkAndUpdate" + mSectionNumber);
            if (!mIsCreated) {
                return;
            }
            int height = mChart.getMeasuredHeight();
            int width = mChart.getMeasuredWidth();

            //are height and width checks still necessary without bitmaps?
            if (height != 0 && width != 0) {
                Collection col = CollectionHelper.getInstance().getCol(getActivity());
                if (mHeight != height || mWidth != width ||
                        mType != (((Statistics) getActivity()).getTaskHandler()).getStatType() ||
                        mDeckId != col.getDecks().selected() || isWholeCollection()) {
                    mHeight = height;
                    mWidth = width;
                    mType = (((Statistics) getActivity()).getTaskHandler()).getStatType();
                    mProgressBar.setVisibility(View.VISIBLE);
                    mChart.setVisibility(View.GONE);
                    if (!isWholeCollection())
                        mDeckId = col.getDecks().selected();
                    else
                        mDeckId = -1;
                    if (mCreateChartTask != null && !mCreateChartTask.isCancelled()) {
                        mCreateChartTask.cancel(true);
                    }
                    createChart();
                }
            }
        }


        private boolean isWholeCollection() {
            return ((Statistics) getActivity()).mIsWholeCollection;
        }


        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
        }


        @Override
        public void invalidateView() {
            if (mChart != null) {
                mChart.invalidate();
            }
        }


        @Override
        public void onDestroy() {
            super.onDestroy();
            if (mCreateChartTask != null && !mCreateChartTask.isCancelled()) {
                mCreateChartTask.cancel(true);
            }
        }
    }

    public static class OverviewStatisticsFragment extends StatisticFragment {

        private WebView mWebView;
        private ProgressBar mProgressBar;
        private Stats.AxisType mType  = Stats.AxisType.TYPE_MONTH;
        private boolean mIsCreated = false;
        private AsyncTask mCreateStatisticsOverviewTask;

        public OverviewStatisticsFragment() {
            super();
        }


        @Override
        public View onCreateView(LayoutInflater inflater, ViewGroup container,
                                 Bundle savedInstanceState) {
            setHasOptionsMenu(true);
            View rootView = inflater.inflate(R.layout.fragment_anki_stats_overview, container, false);
            AnkiStatsTaskHandler handler = (((Statistics) getActivity()).getTaskHandler());
            // Workaround for issue 2406 -- crash when resuming after app is purged from RAM
            // TODO: Implementing loader for Collection in Fragment itself would be a better solution.
            if (handler == null) {
                Timber.e("Statistics.OverviewStatisticsFragment.onCreateView() TaskHandler not found");
                getActivity().finish();
                return rootView;
            }
            mWebView = (WebView) rootView.findViewById(R.id.web_view_stats);
            if (mWebView == null) {
                Timber.d("mChart null!");
            } else {
                Timber.d("mChart is not null!");
                // Set transparent color to prevent flashing white when night mode enabled
                mWebView.setBackgroundColor(Color.argb(1, 0, 0, 0));
            }

            //mChart.setLayerType(View.LAYER_TYPE_SOFTWARE, null);

            mProgressBar = (ProgressBar) rootView.findViewById(R.id.progress_bar_stats_overview);

            mProgressBar.setVisibility(View.VISIBLE);
            //mChart.setVisibility(View.GONE);
            createStatisticOverview();
            mType = handler.getStatType();
            mIsCreated = true;
            mActivityPager = ((Statistics) getActivity()).getViewPager();
            mActivitySectionPagerAdapter = ((Statistics) getActivity()).getSectionsPagerAdapter();
            Collection col = CollectionHelper.getInstance().getCol(getActivity());
            if (!isWholeCollection()) {
                mDeckId = col.getDecks().selected();
                try {
                    List<String> parts = Arrays.asList(col.getDecks().current().getString("name").split("::"));
                    if (sIsSubtitle) {
                        ((AppCompatActivity) getActivity()).getSupportActionBar().setSubtitle(parts.get(parts.size() - 1));
                    } else {
                        getActivity().setTitle(parts.get(parts.size() - 1));
                    }
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
            } else {
                if (sIsSubtitle) {
                    ((AppCompatActivity) getActivity()).getSupportActionBar().setSubtitle(R.string.stats_deck_collection);
                } else {
                    getActivity().setTitle(R.string.stats_deck_collection);
                }
            }
            return rootView;
        }


        private boolean isWholeCollection() {
            return ((Statistics) getActivity()).mIsWholeCollection;
        }


        private void createStatisticOverview(){
            AnkiStatsTaskHandler handler = (((Statistics)getActivity()).getTaskHandler());
            mCreateStatisticsOverviewTask = handler.createStatisticsOverview(mWebView, mProgressBar);
        }


        @Override
        public void invalidateView() {
            if (mWebView != null) {
                mWebView.invalidate();
            }
        }


        @Override
        public void checkAndUpdate() {
            if (!mIsCreated) {
                return;
            }
            Collection col = CollectionHelper.getInstance().getCol(getActivity());
            if (mType != (((Statistics) getActivity()).getTaskHandler()).getStatType() ||
                    mDeckId != col.getDecks().selected() || isWholeCollection()) {
                mType = (((Statistics) getActivity()).getTaskHandler()).getStatType();
                mProgressBar.setVisibility(View.VISIBLE);
                mWebView.setVisibility(View.GONE);
                if (!isWholeCollection())
                    mDeckId = col.getDecks().selected();
                else
                    mDeckId = -1;
                if (mCreateStatisticsOverviewTask != null && !mCreateStatisticsOverviewTask.isCancelled()) {
                    mCreateStatisticsOverviewTask.cancel(true);
                }
                createStatisticOverview();
            }
        }


        @Override
        public void onDestroy() {
            super.onDestroy();
            if (mCreateStatisticsOverviewTask != null && !mCreateStatisticsOverviewTask.isCancelled()) {
                mCreateStatisticsOverviewTask.cancel(true);
            }
        }
    }


    @Override
    public void onBackPressed() {
        if (isDrawerOpen()) {
            super.onBackPressed();
        } else {
            Timber.i("Back key pressed");
            Intent data = new Intent();
            if (getIntent().hasExtra("selectedDeck")) {
                data.putExtra("originalDeck", getIntent().getLongExtra("selectedDeck", 0L));
            }
            setResult(RESULT_CANCELED, data);
            finishWithAnimation(ActivityTransitionAnimation.RIGHT);
        }
    }
}
/***************************************************************************************
 * Copyright (c) 2012 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.Intent;
import android.os.Bundle;
import android.view.MenuItem;
import android.view.View;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.StudyOptionsFragment.StudyOptionsListener;
import com.ichi2.anki.dialogs.CustomStudyDialog;
import com.ichi2.widget.WidgetStatus;

import timber.log.Timber;

public class StudyOptionsActivity extends NavigationDrawerActivity implements StudyOptionsListener,
        CustomStudyDialog.CustomStudyListener {


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // The empty frame layout is a workaround for fragments not showing when they are added
        // to android.R.id.content when an action bar is used in Android 2.1 (and potentially
        // higher) with the appcompat package.
        View mainView = getLayoutInflater().inflate(R.layout.studyoptions, null);
        setContentView(mainView);
        // create inherited navigation drawer layout here so that it can be used by parent class
        initNavigationDrawer(mainView);
        if (savedInstanceState == null) {
            loadStudyOptionsFragment();
        }
    }

    private void loadStudyOptionsFragment() {
        boolean withDeckOptions = false;
        if (getIntent().getExtras() != null) {
            withDeckOptions = getIntent().getExtras().getBoolean("withDeckOptions");
        }
        StudyOptionsFragment currentFragment = StudyOptionsFragment.newInstance(withDeckOptions);
        getSupportFragmentManager().beginTransaction().replace(R.id.studyoptions_frame, currentFragment).commit();
    }


    private StudyOptionsFragment getCurrentFragment() {
        return (StudyOptionsFragment) getSupportFragmentManager().findFragmentById(R.id.studyoptions_frame);
    }


    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (getDrawerToggle().onOptionsItemSelected(item)) {
            return true;
        }
        switch (item.getItemId()) {

            case android.R.id.home:
                closeStudyOptions();
                return true;

            default:
                return super.onOptionsItemSelected(item);
        }
    }


    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent intent) {
        super.onActivityResult(requestCode, resultCode, intent);
        Timber.d("onActivityResult (requestCode = %d, resultCode = %d)", requestCode, resultCode);
        getCurrentFragment().restorePreferences();
    }


    private void closeStudyOptions() {
        closeStudyOptions(RESULT_OK);
    }


    private void closeStudyOptions(int result) {
        // mCompat.invalidateOptionsMenu(this);
        setResult(result);
        finishWithAnimation(ActivityTransitionAnimation.RIGHT);
    }


    @Override
    public void onBackPressed() {
        if (isDrawerOpen()) {
            super.onBackPressed();
        } else {
            Timber.i("Back key pressed");
            closeStudyOptions();
        }
    }


    @Override
    public void onStop() {
        super.onStop();
        if (colIsOpen()) {
            WidgetStatus.update(this);
            UIUtils.saveCollectionInBackground(this);
        }
    }


    @Override
    public void onResume() {
        super.onResume();
        selectNavigationItem(-1);
    }


    @Override
    public void onRequireDeckListUpdate() {
        getCurrentFragment().refreshInterface();
    }

    /**
     * Callback methods from CustomStudyDialog
     */
    @Override
    public void onCreateCustomStudySession() {
        // Sched already reset by DeckTask in CustomStudyDialog
        getCurrentFragment().refreshInterface();
    }

    @Override
    public void onExtendStudyLimits() {
        // Sched needs to be reset so provide true argument
        getCurrentFragment().refreshInterface(true);
    }
}
/****************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program. If not, see <http://www.gnu.org/licenses/>.                            *
 ****************************************************************************************/

package com.ichi2.anki;

import android.app.Activity;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.res.Resources;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v7.widget.Toolbar;
import android.text.Html;
import android.text.method.LinkMovementMethod;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.TextView;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.dialogs.CustomStudyDialog;
import com.ichi2.async.DeckTask;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Utils;
import com.ichi2.themes.StyledProgressDialog;

import org.json.JSONException;
import org.json.JSONObject;

import timber.log.Timber;

public class StudyOptionsFragment extends Fragment implements Toolbar.OnMenuItemClickListener {


    /**
     * Available options performed by other activities
     */
    private static final int BROWSE_CARDS = 3;
    private static final int STATISTICS = 4;
    private static final int DECK_OPTIONS = 5;

    /**
     * Constants for selecting which content view to display
     */
    public static final int CONTENT_STUDY_OPTIONS = 0;
    public static final int CONTENT_CONGRATS = 1;
    public static final int CONTENT_EMPTY = 2;

    // Threshold at which the total number of new cards is truncated by libanki
    private static final int NEW_CARD_COUNT_TRUNCATE_THRESHOLD = 1000;

    /**
     * Preferences
     */
    private int mCurrentContentView = CONTENT_STUDY_OPTIONS;

    /** Alerts to inform the user about different situations */
    private MaterialDialog mProgressDialog;

    /**
     * UI elements for "Study Options" view
     */
    private View mStudyOptionsView;
    private View mDeckInfoLayout;
    private Button mButtonStart;
    private TextView mTextDeckName;
    private TextView mTextDeckDescription;
    private TextView mTextTodayNew;
    private TextView mTextTodayLrn;
    private TextView mTextTodayRev;
    private TextView mTextNewTotal;
    private TextView mTextTotal;
    private TextView mTextETA;
    private TextView mTextCongratsMessage;
    private Toolbar mToolbar;

    // Flag to indicate if the fragment should load the deck options immediately after it loads
    private boolean mLoadWithDeckOptions;

    private boolean mFragmented;

    private Thread mFullNewCountThread = null;

    StudyOptionsListener mListener;


    public interface StudyOptionsListener {
        void onRequireDeckListUpdate();
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        try {
            mListener = (StudyOptionsListener) activity;
        } catch (ClassCastException e) {
            throw new ClassCastException(activity.toString() + " must implement StudyOptionsListener");
        }
    }


    /**
     * Callbacks for UI events
     */
    private View.OnClickListener mButtonClickListener = new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            // long timeLimit = 0;
            switch (v.getId()) {
                case R.id.studyoptions_start:
                    Timber.i("StudyOptionsFragment:: start study button pressed");
                    if (mCurrentContentView != CONTENT_CONGRATS) {
                        openReviewer();
                    } else {
                        showCustomStudyContextMenu();
                    }
                    return;
                default:
            }
        }
    };

    private void openFilteredDeckOptions() {
        openFilteredDeckOptions(false);
    }

    /**
     * Open the FilteredDeckOptions activity to allow the user to modify the parameters of the
     * filtered deck.
     * @param defaultConfig If true, signals to the FilteredDeckOptions activity that the filtered
     *                      deck has no options associated with it yet and should use a default
     *                      set of values.
     */
    private void openFilteredDeckOptions(boolean defaultConfig) {
        Intent i = new Intent(getActivity(), FilteredDeckOptions.class);
        i.putExtra("defaultConfig", defaultConfig);
        getActivity().startActivityForResult(i, DECK_OPTIONS);
        ActivityTransitionAnimation.slide(getActivity(), ActivityTransitionAnimation.FADE);
    }


    /**
     * Get a new instance of the fragment.
     * @param withDeckOptions If true, the fragment will load a new activity on top of itself
     *                        which shows the current deck's options. Set to true when programmatically
     *                        opening a new filtered deck for the first time.
     */
    public static StudyOptionsFragment newInstance(boolean withDeckOptions) {
        StudyOptionsFragment f = new StudyOptionsFragment();
        Bundle args = new Bundle();
        args.putBoolean("withDeckOptions", withDeckOptions);
        f.setArguments(args);
        return f;
    }


    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        if (container == null) {
            // Currently in a layout without a container, so no reason to create our view.
            return null;
        }
        restorePreferences();
        mStudyOptionsView = inflater.inflate(R.layout.studyoptions_fragment, container, false);
        mFragmented = getActivity().getClass() != StudyOptionsActivity.class;
        initAllContentViews();
        if (getArguments() != null) {
            mLoadWithDeckOptions = getArguments().getBoolean("withDeckOptions");
        }
        mToolbar = (Toolbar) mStudyOptionsView.findViewById(R.id.studyOptionsToolbar);
        mToolbar.inflateMenu(R.menu.study_options_fragment);
        if (mToolbar != null) {
            configureToolbar();
        }
        refreshInterface(true);
        return mStudyOptionsView;
    }


    @Override
    public void onDestroy() {
        super.onDestroy();
        if (mFullNewCountThread != null) {
            mFullNewCountThread.interrupt();
        }
        Timber.d("onDestroy()");
    }


    @Override
    public void onResume() {
        super.onResume();
        Timber.d("onResume()");
        refreshInterface(true);
    }


    private void closeStudyOptions(int result) {
        Activity a = getActivity();
        if (!mFragmented && a != null) {
            a.setResult(result);
            a.finish();
            ActivityTransitionAnimation.slide(a, ActivityTransitionAnimation.RIGHT);
        } else if (a == null) {
            // getActivity() can return null if reference to fragment lingers after parent activity has been closed,
            // which is particularly relevant when using AsyncTasks.
            Timber.e("closeStudyOptions() failed due to getActivity() returning null");
        }
    }


    private void openReviewer() {
        Intent reviewer = new Intent(getActivity(), Reviewer.class);
        if (mFragmented) {
            getActivity().startActivityForResult(reviewer, AnkiActivity.REQUEST_REVIEW);
        } else {
            // Go to DeckPicker after studying when not tablet
            reviewer.setFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);
            startActivity(reviewer);
            getActivity().finish();
        }
        animateLeft();
        getCol().startTimebox();
    }


    private void animateLeft() {
        ActivityTransitionAnimation.slide(getActivity(), ActivityTransitionAnimation.LEFT);
    }


    private void initAllContentViews() {
        if (mFragmented) {
            mStudyOptionsView.findViewById(R.id.studyoptions_gradient).setVisibility(View.VISIBLE);
        }
        mDeckInfoLayout = mStudyOptionsView.findViewById(R.id.studyoptions_deckinformation);
        mTextDeckName = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_deck_name);
        mTextDeckDescription = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_deck_description);
        // make links clickable
        mTextDeckDescription.setMovementMethod(LinkMovementMethod.getInstance());
        mButtonStart = (Button) mStudyOptionsView.findViewById(R.id.studyoptions_start);
        mTextCongratsMessage = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_congrats_message);
        // Code common to both fragmented and non-fragmented view
        mTextTodayNew = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_new);
        mTextTodayLrn = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_lrn);
        mTextTodayRev = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_rev);
        mTextNewTotal = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_total_new);
        mTextTotal = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_total);
        mTextETA = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_eta);
        mButtonStart.setOnClickListener(mButtonClickListener);
    }


    /**
     * Show the context menu for the custom study options
     */
    private void showCustomStudyContextMenu() {
        CustomStudyDialog d = CustomStudyDialog.newInstance(CustomStudyDialog.CONTEXT_MENU_STANDARD,
                getCol().getDecks().selected());
        ((AnkiActivity)getActivity()).showDialogFragment(d);
    }


    void setFragmentContentView(View newView) {
        ViewGroup parent = (ViewGroup) this.getView();
        parent.removeAllViews();
        parent.addView(newView);
    }


    @Override
    public boolean onMenuItemClick(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.action_undo:
                Timber.i("StudyOptionsFragment:: Undo button pressed");
                getCol().undo();
                openReviewer();
                return true;
            case R.id.action_deck_options:
                Timber.i("StudyOptionsFragment:: Deck options button pressed");
                if (getCol().getDecks().isDyn(getCol().getDecks().selected())) {
                    openFilteredDeckOptions();
                } else {
                    Intent i = new Intent(getActivity(), DeckOptions.class);
                    getActivity().startActivityForResult(i, DECK_OPTIONS);
                    ActivityTransitionAnimation.slide(getActivity(), ActivityTransitionAnimation.FADE);
                }
                return true;
            case R.id.action_custom_study:
                Timber.i("StudyOptionsFragment:: custom study button pressed");
                showCustomStudyContextMenu();
                return true;
            case R.id.action_unbury:
                Timber.i("StudyOptionsFragment:: unbury button pressed");
                getCol().getSched().unburyCardsForDeck();
                refreshInterfaceAndDecklist(true);
                item.setVisible(false);
                return true;
            case R.id.action_rebuild:
                Timber.i("StudyOptionsFragment:: rebuild cram deck button pressed");
                mProgressDialog = StyledProgressDialog.show(getActivity(), "",
                        getResources().getString(R.string.rebuild_cram_deck), true);
                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REBUILD_CRAM, getDeckTaskListener(true),
                        new DeckTask.TaskData(mFragmented));
                return true;
            case R.id.action_empty:
                Timber.i("StudyOptionsFragment:: empty cram deck button pressed");
                mProgressDialog = StyledProgressDialog.show(getActivity(), "",
                        getResources().getString(R.string.empty_cram_deck), false);
                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_EMPTY_CRAM, getDeckTaskListener(true),
                        new DeckTask.TaskData(mFragmented));
                return true;
            case R.id.action_rename:
                ((DeckPicker) getActivity()).renameDeckDialog(getCol().getDecks().selected());
                return true;
            case R.id.action_delete:
                ((DeckPicker) getActivity()).confirmDeckDeletion(getCol().getDecks().selected());
                return true;
            case R.id.action_export:
                ((DeckPicker) getActivity()).exportDeck(getCol().getDecks().selected());
                return true;
            default:
                return false;
        }
    }

    public void configureToolbar() {
        mToolbar.setOnMenuItemClickListener(this);
        Menu menu = mToolbar.getMenu();
        // Switch on or off rebuild/empty/custom study depending on whether or not filtered deck
        if (getCol().getDecks().isDyn(getCol().getDecks().selected())) {
            menu.findItem(R.id.action_rebuild).setVisible(true);
            menu.findItem(R.id.action_empty).setVisible(true);
            menu.findItem(R.id.action_custom_study).setVisible(false);
        } else {
            menu.findItem(R.id.action_rebuild).setVisible(false);
            menu.findItem(R.id.action_empty).setVisible(false);
            menu.findItem(R.id.action_custom_study).setVisible(true);
        }
        // Don't show custom study icon if congrats shown
        if (mCurrentContentView == CONTENT_CONGRATS) {
            menu.findItem(R.id.action_custom_study).setVisible(false);
        }
        // Switch on rename / delete / export if tablet layout
        if (mFragmented) {
            menu.findItem(R.id.action_rename).setVisible(true);
            menu.findItem(R.id.action_delete).setVisible(true);
            menu.findItem(R.id.action_export).setVisible(true);
        } else {
            menu.findItem(R.id.action_rename).setVisible(false);
            menu.findItem(R.id.action_delete).setVisible(false);
            menu.findItem(R.id.action_export).setVisible(false);
        }
        // Switch on or off unbury depending on if there are cards to unbury
        menu.findItem(R.id.action_unbury).setVisible(getCol().getSched().haveBuried());
        // Switch on or off undo depending on whether undo is available
        if (!getCol().undoAvailable()) {
            menu.findItem(R.id.action_undo).setVisible(false);
        } else {
            menu.findItem(R.id.action_undo).setVisible(true);
            Resources res = AnkiDroidApp.getAppResources();
            menu.findItem(R.id.action_undo).setTitle(res.getString(R.string.studyoptions_congrats_undo, getCol().undoName(res)));
        }
        // Set the back button listener
        if (!mFragmented) {
            mToolbar.setNavigationIcon(R.drawable.ic_arrow_back_white_24dp);
            mToolbar.setNavigationOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    ((AnkiActivity) getActivity()).finishWithAnimation(ActivityTransitionAnimation.RIGHT);
                }
            });
        }
    }


    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent intent) {
        super.onActivityResult(requestCode, resultCode, intent);
        Timber.d("onActivityResult (requestCode = %d, resultCode = %d)", requestCode, resultCode);

        // rebuild action bar
        configureToolbar();

        // boot back to deck picker if there was an error
        if (resultCode == DeckPicker.RESULT_DB_ERROR || resultCode == DeckPicker.RESULT_MEDIA_EJECTED) {
            closeStudyOptions(resultCode);
            return;
        }

        // perform some special actions depending on which activity we're returning from
        if (requestCode == STATISTICS || requestCode == BROWSE_CARDS) {
            // select original deck if the statistics or card browser were opened,
            // which can change the selected deck
            if (intent.hasExtra("originalDeck")) {
                getCol().getDecks().select(intent.getLongExtra("originalDeck", 0L));
            }
        }
        if (requestCode == DECK_OPTIONS) {
            if (mLoadWithDeckOptions) {
                mLoadWithDeckOptions = false;
                try {
                    JSONObject deck = getCol().getDecks().current();
                    if (deck.getInt("dyn") != 0 && deck.has("empty")) {
                        deck.remove("empty");
                    }
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
                    mProgressDialog = StyledProgressDialog.show(getActivity(), "",
                            getResources().getString(R.string.rebuild_cram_deck), true);
                    DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REBUILD_CRAM, getDeckTaskListener(true),
                            new DeckTask.TaskData(mFragmented));
            } else {
                DeckTask.waitToFinish();
                refreshInterface(true);
            }
        } else if (requestCode == AnkiActivity.REQUEST_REVIEW) {
            if (resultCode == Reviewer.RESULT_NO_MORE_CARDS) {
                // If no more cards getting returned while counts > 0 (due to learn ahead limit) then show a snackbar
                int[] counts = getCol().getSched().counts();
                if ((counts[0]+counts[1]+counts[2])>0 && mStudyOptionsView != null) {
                    View rootLayout = mStudyOptionsView.findViewById(R.id.studyoptions_main);
                    UIUtils.showSnackbar(getActivity(), R.string.studyoptions_no_cards_due, false, 0, null, rootLayout);
                }
            }
        } else if (requestCode == STATISTICS && mCurrentContentView == CONTENT_CONGRATS) {
            mCurrentContentView = CONTENT_STUDY_OPTIONS;
            setFragmentContentView(mStudyOptionsView);
        }
    }

    private void dismissProgressDialog() {
        if (mStudyOptionsView != null && mStudyOptionsView.findViewById(R.id.progress_bar) != null) {
            mStudyOptionsView.findViewById(R.id.progress_bar).setVisibility(View.GONE);
        }
        // for rebuilding cram decks
        if (mProgressDialog != null && mProgressDialog.isShowing()) {
            try {
                mProgressDialog.dismiss();
            } catch (Exception e) {
                Timber.e("onPostExecute - Dialog dismiss Exception = " + e.getMessage());
            }
        }
    }


    public SharedPreferences restorePreferences() {
        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getActivity().getBaseContext());
        return preferences;
    }


    private void refreshInterfaceAndDecklist(boolean resetSched) {
        refreshInterface(resetSched, true);
    }

    protected void refreshInterface() {
        refreshInterface(false, false);
    }

    protected void refreshInterface(boolean resetSched) {
        refreshInterface(resetSched, false);
    }

    /**
     * Rebuild the fragment's interface to reflect the status of the currently selected deck.
     *
     * @param resetSched    Indicates whether to rebuild the queues as well. Set to true for any
     *                      task that modifies queues (e.g., unbury or empty filtered deck).
     * @param resetDecklist Indicates whether to call back to the parent activity in order to
     *                      also refresh the deck list.
     */
    protected void refreshInterface(boolean resetSched, boolean resetDecklist) {
        Timber.d("Refreshing StudyOptionsFragment");
        // Load the deck counts for the deck from Collection asynchronously
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UPDATE_VALUES_FROM_DECK, getDeckTaskListener(resetDecklist),
                new DeckTask.TaskData(new Object[]{resetSched}));
    }


    /**
     * Returns a listener that rebuilds the interface after execute.
     *
     * @param refreshDecklist If true, the listener notifies the parent activity to update its deck list
     *                        to reflect the latest values.
     */
    private DeckTask.TaskListener getDeckTaskListener(final boolean refreshDecklist) {
        return new DeckTask.TaskListener() {
            @Override
            public void onPreExecute() {

            }

            @Override
            public void onPostExecute(DeckTask.TaskData result) {
                dismissProgressDialog();
                if (result != null) {
                    // Get the return values back from the AsyncTask
                    Object[] obj = result.getObjArray();
                    int newCards = (Integer) obj[0];
                    int lrnCards = (Integer) obj[1];
                    int revCards = (Integer) obj[2];
                    int totalNew = (Integer) obj[3];
                    int totalCards = (Integer) obj[4];
                    int eta = (Integer) obj[5];

                    // Don't do anything if the fragment is no longer attached to it's Activity or col has been closed
                    if (getActivity() == null) {
                        Timber.e("StudyOptionsFragment.mRefreshFragmentListener :: can't refresh");
                        return;
                    }
                    // Reinitialize controls incase changed to filtered deck
                    initAllContentViews();
                    // Set the deck name
                    String fullName;
                    JSONObject deck = getCol().getDecks().current();
                    try {
                        // Main deck name
                        fullName = deck.getString("name");
                        String[] name = fullName.split("::");
                        StringBuilder nameBuilder = new StringBuilder();
                        if (name.length > 0) {
                            nameBuilder.append(name[0]);
                        }
                        if (name.length > 1) {
                            nameBuilder.append("\n").append(name[1]);
                        }
                        if (name.length > 3) {
                            nameBuilder.append("...");
                        }
                        if (name.length > 2) {
                            nameBuilder.append("\n").append(name[name.length - 1]);
                        }
                        mTextDeckName.setText(nameBuilder.toString());

                    } catch (JSONException e) {
                        throw new RuntimeException(e);
                    }

                    // open cram deck option if deck is opened for the first time
                    if (mLoadWithDeckOptions) {
                        openFilteredDeckOptions(mLoadWithDeckOptions);
                        mLoadWithDeckOptions = false;
                        return;
                    }
                    // Switch between the empty view, the ordinary view, and the "congratulations" view
                    boolean isDynamic = deck.optInt("dyn", 0) != 0;
                    if (totalCards == 0 && !isDynamic) {
                        mCurrentContentView = CONTENT_EMPTY;
                        mDeckInfoLayout.setVisibility(View.VISIBLE);
                        mTextCongratsMessage.setVisibility(View.VISIBLE);
                        mTextCongratsMessage.setText(R.string.studyoptions_empty);
                        mButtonStart.setVisibility(View.GONE);
                    } else if (newCards + lrnCards + revCards == 0) {
                        mCurrentContentView = CONTENT_CONGRATS;
                        if (!isDynamic) {
                            mDeckInfoLayout.setVisibility(View.GONE);
                            mButtonStart.setVisibility(View.VISIBLE);
                            mButtonStart.setText(R.string.custom_study);
                        } else {
                            mButtonStart.setVisibility(View.GONE);
                        }
                        mTextCongratsMessage.setVisibility(View.VISIBLE);
                        mTextCongratsMessage.setText(getCol().getSched().finishedMsg(getActivity()));
                    } else {
                        mCurrentContentView = CONTENT_STUDY_OPTIONS;
                        mDeckInfoLayout.setVisibility(View.VISIBLE);
                        mTextCongratsMessage.setVisibility(View.GONE);
                        mButtonStart.setVisibility(View.VISIBLE);
                        mButtonStart.setText(R.string.studyoptions_start);
                    }

                    // Set deck description
                    String desc;
                    if (isDynamic) {
                        desc = getResources().getString(R.string.dyn_deck_desc);
                    } else {
                        desc = getCol().getDecks().getActualDescription();
                    }
                    if (desc.length() > 0) {
                        mTextDeckDescription.setText(Html.fromHtml(desc));
                        mTextDeckDescription.setVisibility(View.VISIBLE);
                    } else {
                        mTextDeckDescription.setVisibility(View.GONE);
                    }

                    // Set new/learn/review card counts
                    mTextTodayNew.setText(String.valueOf(newCards));
                    mTextTodayLrn.setText(String.valueOf(lrnCards));
                    mTextTodayRev.setText(String.valueOf(revCards));

                    // Set the total number of new cards in deck
                    if (totalNew < NEW_CARD_COUNT_TRUNCATE_THRESHOLD) {
                        // if it hasn't been truncated by libanki then just set it usually
                        mTextNewTotal.setText(String.valueOf(totalNew));
                    } else {
                        // if truncated then make a thread to allow full count to load
                        mTextNewTotal.setText(">1000");
                        if (mFullNewCountThread != null) {
                            // a thread was previously made -- interrupt it
                            mFullNewCountThread.interrupt();
                        }
                        mFullNewCountThread = new Thread(new Runnable() {
                            @Override
                            public void run() {
                                Collection collection = getCol();
                                // TODO: refactor code to not rewrite this query, add to Sched.totalNewForCurrentDeck()
                                StringBuilder sbQuery = new StringBuilder();
                                sbQuery.append("SELECT count(*) FROM cards WHERE did IN ");
                                sbQuery.append(Utils.ids2str(collection.getDecks().active()));
                                sbQuery.append(" AND queue = 0");
                                final int fullNewCount = collection.getDb().queryScalar(sbQuery.toString());
                                if (fullNewCount > 0) {
                                    Runnable setNewTotalText = new Runnable() {
                                        @Override
                                        public void run() {
                                            mTextNewTotal.setText(String.valueOf(fullNewCount));
                                        }
                                    };
                                    if (!Thread.currentThread().isInterrupted()) {
                                        mTextNewTotal.post(setNewTotalText);
                                    }
                                }
                            }
                        });
                        mFullNewCountThread.start();
                    }

                    // Set total number of cards
                    mTextTotal.setText(String.valueOf(totalCards));
                    // Set estimated time remaining
                    if (eta != -1) {
                        mTextETA.setText(Integer.toString(eta));
                    } else {
                        mTextETA.setText("-");
                    }
                    // Rebuild the options menu
                    configureToolbar();
                }

                // If in fragmented mode, refresh the deck list
                if (mFragmented && refreshDecklist) {
                    mListener.onRequireDeckListUpdate();
                }
            }

            @Override
            public void onProgressUpdate(DeckTask.TaskData... values) {

            }

            @Override
            public void onCancelled() {

            }
        };
    }

    private Collection getCol() {
        return CollectionHelper.getInstance().getCol(getContext());
    }
}

package com.ichi2.anki;

import android.app.Activity;
import android.content.Context;
import android.graphics.Color;
import android.support.design.widget.Snackbar;
import android.support.v4.content.ContextCompat;
import android.view.View;
import android.widget.TextView;
import android.widget.Toast;

import com.ichi2.async.DeckTask;
import com.ichi2.async.DeckTask.TaskData;

import java.util.Calendar;

import timber.log.Timber;

public class UIUtils {

    public static void showThemedToast(Context context, String text, boolean shortLength) {
        Toast.makeText(context, text, shortLength ? Toast.LENGTH_SHORT : Toast.LENGTH_LONG).show();
    }


    /**
     * Show a simple Toast-like Snackbar with no actions.
     * To enable swipe-to-dismiss, the Activity layout should include a CoordinatorLayout with id "root_layout"
     * @param mainTextResource
     * @param shortLength
     */
    public static void showSimpleSnackbar(Activity activity, int mainTextResource, boolean shortLength) {
        View root = activity.findViewById(R.id.root_layout);
        showSnackbar(activity, mainTextResource, shortLength, -1, null, root);
    }
    public static void showSimpleSnackbar(Activity activity, String mainText, boolean shortLength) {
        View root = activity.findViewById(R.id.root_layout);
        showSnackbar(activity, mainText, shortLength, -1, null, root, null);
    }

    /**
     * Show a snackbar with an action
     * @param mainTextResource resource for the main text string
     * @param shortLength whether or not to use long length
     * @param actionTextResource resource for the text string shown as the action
     * @param listener listener for the action (if null no action shown)
     * @oaram root View Snackbar will attach to. Should be CoordinatorLayout for swipe-to-dismiss to work.
     */
    public static void showSnackbar(Activity activity, int mainTextResource, boolean shortLength,
                                int actionTextResource, View.OnClickListener listener, View root) {
        showSnackbar(activity, mainTextResource,shortLength,actionTextResource,listener,root, null);
    }


    public static void showSnackbar(Activity activity, int mainTextResource, boolean shortLength,
                                int actionTextResource, View.OnClickListener listener, View root,
                                Snackbar.Callback callback) {
        String mainText = activity.getResources().getString(mainTextResource);
        showSnackbar(activity, mainText, shortLength, actionTextResource, listener, root, callback);
    }


    public static void showSnackbar(Activity activity, String mainText, boolean shortLength,
                                int actionTextResource, View.OnClickListener listener, View root,
                                Snackbar.Callback callback) {
        if (root == null) {
            root = activity.findViewById(android.R.id.content);
            if (root == null) {
                Timber.e("Could not show Snackbar due to null View");
                return;
            }
        }
        int length = shortLength ? Snackbar.LENGTH_SHORT : Snackbar.LENGTH_LONG;
        Snackbar sb = Snackbar.make(root, mainText, length);
        if (listener != null) {
            sb.setAction(actionTextResource, listener);
        }
        if (callback != null) {
            sb.setCallback(callback);
        }
        // Make the text white to avoid interference from our theme colors.
        View view = sb.getView();
        TextView tv = (TextView) view.findViewById(android.support.design.R.id.snackbar_text);
        TextView action = (TextView) view.findViewById(android.support.design.R.id.snackbar_action);
        if (tv != null && action != null) {
            tv.setTextColor(Color.WHITE);
            action.setTextColor(ContextCompat.getColor(activity, R.color.material_light_blue_500));
            tv.setMaxLines(2);  // prevent tablets from truncating to 1 line
        }
        sb.show();
    }


    public static float getDensityAdjustedValue(Context context, float value) {
        return context.getResources().getDisplayMetrics().density * value;
    }


    public static long getDayStart() {
        Calendar cal = Calendar.getInstance();
        if (cal.get(Calendar.HOUR_OF_DAY) < 4) {
            cal.roll(Calendar.DAY_OF_YEAR, -1);
        }
        cal.set(Calendar.HOUR_OF_DAY, 4);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        return cal.getTimeInMillis();
    }


    public static void saveCollectionInBackground(Context context) {
        if (CollectionHelper.getInstance().colIsOpen()) {
            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SAVE_COLLECTION, new DeckTask.TaskListener() {
                @Override
                public void onPreExecute() {
                    Timber.d("saveCollectionInBackground: start");
                }


                @Override
                public void onPostExecute(TaskData result) {
                    Timber.d("saveCollectionInBackground: finished");
                }


                @Override
                public void onProgressUpdate(TaskData... values) {
                }


                @Override
                public void onCancelled() {
                }
            });
        }
    }
}
package com.ichi2.anki;
import com.ichi2.libanki.Sound;

import android.app.Activity;
import android.content.res.Configuration;
import android.media.MediaPlayer;
import android.os.Bundle;
import android.view.SurfaceHolder;
import android.view.WindowManager;
import android.widget.VideoView;



/****************************************************************************************
 * Copyright (c) 2014 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

public class VideoPlayer extends Activity implements android.view.SurfaceHolder.Callback {
    VideoView mVideoView;
    String mPath;
    Sound mSoundPlayer;

    /** Called when the activity is first created. */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.video_player);
        mPath = getIntent().getStringExtra("path");
        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
                WindowManager.LayoutParams.FLAG_FULLSCREEN);        
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
        mVideoView = (VideoView) findViewById(R.id.video_surface);
        mVideoView.getHolder().addCallback(this);
        mSoundPlayer = new Sound();
    }
    @Override
    public void surfaceCreated(SurfaceHolder holder) {
        mSoundPlayer.playSound(mPath, new MediaPlayer.OnCompletionListener() {
            @Override
            public void onCompletion(MediaPlayer mp) {
                finish();
                MediaPlayer.OnCompletionListener originalListener = mSoundPlayer.getMediaCompletionListener();
                if (originalListener != null) {
                    originalListener.onCompletion(mp);
                }
            }
        }, mVideoView);
    }
    @Override
    public void surfaceChanged(SurfaceHolder holder, int format, int width,
            int height) {
        // TODO Auto-generated method stub
        
    }
    @Override
    public void surfaceDestroyed(SurfaceHolder holder) {
        mSoundPlayer.stopSounds();
        finish();
    }
    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        mSoundPlayer.notifyConfigurationChanged(mVideoView);
    }
    @Override
    public void onStop() {
        super.onStop();
    }
}/****************************************************************************************
 * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>                                    *
 * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.PathMeasure;
import android.graphics.PointF;
import android.support.v4.content.ContextCompat;
import android.view.Display;
import android.view.MotionEvent;
import android.view.View;
import android.view.WindowManager;

import java.lang.ref.WeakReference;
import java.util.Stack;

/**
 * Whiteboard allowing the user to draw the card's answer on the touchscreen.
 */
public class Whiteboard extends View {

    private static final float TOUCH_TOLERANCE = 4;

    private Paint mPaint;
    private UndoStack mUndo = new UndoStack();
    private Bitmap mBitmap;
    private Canvas mCanvas;
    private Path mPath;
    private Paint mBitmapPaint;
    private WeakReference<AnkiActivity> mActivity;

    private float mX;
    private float mY;

    private boolean mInvertedColors = false;
    private boolean mMonochrome = true;
    private boolean mUndoModeActive = false;


    public Whiteboard(AnkiActivity context, boolean inverted, boolean monochrome) {
        super(context, null);
        mActivity = new WeakReference<>(context);
        mInvertedColors = inverted;
        mMonochrome = monochrome;

        int foregroundColor;
        if (!mInvertedColors) {
            if (mMonochrome) {
                foregroundColor = Color.BLACK;
            } else {
                foregroundColor = ContextCompat.getColor(context, R.color.wb_fg_color);
            }
        } else {
            if (mMonochrome) {
                foregroundColor = Color.WHITE;
            } else {
                foregroundColor = ContextCompat.getColor(context, R.color.wb_fg_color_inv);
            }
        }

        mPaint = new Paint();
        mPaint.setAntiAlias(true);
        mPaint.setDither(true);
        mPaint.setColor(foregroundColor);
        mPaint.setStyle(Paint.Style.STROKE);
        mPaint.setStrokeJoin(Paint.Join.ROUND);
        mPaint.setStrokeCap(Paint.Cap.ROUND);
        int wbStrokeWidth = AnkiDroidApp.getSharedPrefs(context).getInt("whiteBoardStrokeWidth", 6);
        mPaint.setStrokeWidth((float) wbStrokeWidth);
        createBitmap();
        mPath = new Path();
        mBitmapPaint = new Paint(Paint.DITHER_FLAG);
    }


    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        canvas.drawColor(0);
        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);
        canvas.drawPath(mPath, mPaint);
    }


    /**
     * Handle touch screen motion events.
     * 
     * @param event The motion event.
     * @return True if the event was handled, false otherwise.
     */
    public boolean handleTouchEvent(MotionEvent event) {
        float x = event.getX();
        float y = event.getY();

        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                touchStart(x, y);
                invalidate();
                return true;
            case MotionEvent.ACTION_MOVE:
                for (int i = 0; i < event.getHistorySize(); i++) {
                    touchMove(event.getHistoricalX(i), event.getHistoricalY(i));
                }
                touchMove(x, y);
                invalidate();
                return true;
            case MotionEvent.ACTION_UP:
                touchUp();
                invalidate();
                return true;
            default:
                return false;
        }
    }


    /**
     * Clear the whiteboard.
     */
    public void clear() {
        mUndoModeActive = false;
        mBitmap.eraseColor(0);
        mUndo.clear();
        invalidate();
        if (mActivity.get() != null) {
            mActivity.get().supportInvalidateOptionsMenu();
        }
    }


    /**
     * Undo the last stroke
     */
    public void undo() {
        mUndo.pop();
        mUndo.apply();
        if (undoSize() == 0 && mActivity.get() != null) {
            mActivity.get().supportInvalidateOptionsMenu();
        }
    }

    /**
     * @return the number of strokes currently on the undo queue
     */
    public int undoSize() {
        return mUndo.size();
    }

    /**
     * @return true if the undo queue has had any strokes added to it since the last clear
     */
    public boolean isUndoModeActive() {
        return mUndoModeActive;
    }

    private void createBitmap(int w, int h, Bitmap.Config conf) {
        mBitmap = Bitmap.createBitmap(w, h, conf);
        mCanvas = new Canvas(mBitmap);
        clear();
    }


    private void createBitmap() {
        // To fix issue #1336, just make the whiteboard big and square.
        int bitmapSize = Math.max(getDisplayWidth(), getDisplayHeight());
        if (mMonochrome && !mInvertedColors) {
            createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ALPHA_8);
        } else {
            createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_4444);
        }
    }


    private void touchStart(float x, float y) {
        mPath.reset();
        mPath.moveTo(x, y);
        mX = x;
        mY = y;
    }


    private void touchMove(float x, float y) {
        float dx = Math.abs(x - mX);
        float dy = Math.abs(y - mY);
        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);
            mX = x;
            mY = y;
        }
    }


    private void touchUp() {
        PathMeasure pm = new PathMeasure(mPath, false);
        mPath.lineTo(mX, mY);
        if(pm.getLength() > 0){
            mCanvas.drawPath(mPath, mPaint);
            mUndo.add(mPath);
        } else {
            mCanvas.drawPoint(mX, mY, mPaint);
            mUndo.add(mX, mY);
        }
        mUndoModeActive = true;
        // kill the path so we don't double draw
        mPath.reset();
        if (mUndo.size() == 1 && mActivity.get() != null) {
            mActivity.get().supportInvalidateOptionsMenu();
        }
    }


    private static int getDisplayHeight() {
        Display display = ((WindowManager) AnkiDroidApp.getInstance().getApplicationContext().
                getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
        return display.getHeight();
    }


    private static int getDisplayWidth() {
        Display display = ((WindowManager) AnkiDroidApp.getInstance().getApplicationContext().
                getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
        return display.getWidth();
    }

    /**
     * Keep a stack of all points and paths so that the last stroke can be undone
     * pop() removes the last stroke from the stack, and apply() redraws it to whiteboard.
     */
    private class UndoStack {
        private final Stack<Path> mPathStack = new Stack<>();
        private final Stack<PointF> mPointStack = new Stack<>();
        private final Stack<Integer> mWhichStack = new Stack<>();

        public void add(Path path) {
            mPathStack.add(new Path(path));
            mWhichStack.add(0);
        }
        public void add(float x, float y) {
            mPointStack.add(new PointF(x, y));
            mWhichStack.add(1);
        }

        public void clear() {
            mPathStack.clear();
            mPointStack.clear();
            mWhichStack.clear();
        }

        public int size() {
            return mWhichStack.size();
        }

        public void pop() {
            if (mWhichStack.size() == 0) return;
            switch (mWhichStack.peek()) {
                case 0:
                    mPathStack.pop();
                    break;
                case 1:
                    mPointStack.pop();
                    break;
            }
            mWhichStack.pop();
        }

        public void apply() {
            mBitmap.eraseColor(0);
            for (Path path : mPathStack) {
                mCanvas.drawPath(path, mPaint);
            }
            for (PointF point : mPointStack) {
                mCanvas.drawPoint(point.x, point.y, mPaint);
            }
            invalidate();
        }
    }
}
/***************************************************************************************
 * Copyright (c) 2015 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.dialogs;

import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.CheckBox;
import android.widget.EditText;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.R;

import org.acra.ACRA;
import org.acra.BaseCrashReportDialog;

public class AnkiDroidCrashReportDialog extends BaseCrashReportDialog implements DialogInterface.OnClickListener, DialogInterface.OnDismissListener {
    private static final String STATE_COMMENT = "comment";
    CheckBox mAlwaysReportCheckBox;
    EditText mUserComment;

    AlertDialog mDialog;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(this);
        int resourceId = ACRA.getConfig().resDialogTitle();
        if(resourceId != 0) {
            dialogBuilder.setTitle(resourceId);
        }
        resourceId = ACRA.getConfig().resDialogIcon();
        if(resourceId != 0) {
            dialogBuilder.setIcon(resourceId);
        }
        dialogBuilder.setView(buildCustomView(savedInstanceState));
        dialogBuilder.setPositiveButton(getText(ACRA.getConfig().resDialogPositiveButtonText()), AnkiDroidCrashReportDialog.this);
        dialogBuilder.setNegativeButton(getText(ACRA.getConfig().resDialogNegativeButtonText()), AnkiDroidCrashReportDialog.this);

        mDialog = dialogBuilder.create();
        mDialog.setCanceledOnTouchOutside(false);
        mDialog.setOnDismissListener(this);
        mDialog.show();
    }

    /**
     * Build the custom view used by the dialog
     * @param savedInstanceState
     * @return
     */
    private View buildCustomView(Bundle savedInstanceState) {
        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(this);
        LayoutInflater inflater = getLayoutInflater();
        View rootView = inflater.inflate(R.layout.feedback, null);
        mAlwaysReportCheckBox = (CheckBox) rootView.findViewById(R.id.alwaysReportCheckbox);
        mAlwaysReportCheckBox.setChecked(preferences.getBoolean("autoreportCheckboxValue", true));
        mUserComment = (EditText) rootView.findViewById(R.id.etFeedbackText);
        // Set user comment if reloading after the activity has been stopped
        if (savedInstanceState != null) {
            String savedValue = savedInstanceState.getString(STATE_COMMENT);
            if (savedValue != null) {
                mUserComment.setText(savedValue);
            }
        }
        return rootView;
    }

    @Override
    public void onClick(DialogInterface dialog, int which) {
        if (which == DialogInterface.BUTTON_POSITIVE) {
            // Next time don't tick the auto-report checkbox by default
            boolean autoReport = mAlwaysReportCheckBox.isChecked();
            SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(this);
            preferences.edit().putBoolean("autoreportCheckboxValue", autoReport).commit();
            // Set the autoreport value to true if ticked
            if (autoReport) {
                preferences.edit().putString("reportErrorMode", AnkiDroidApp.FEEDBACK_REPORT_ALWAYS).commit();
                AnkiDroidApp.getInstance().setAcraReportingMode(AnkiDroidApp.FEEDBACK_REPORT_ALWAYS);
            }
            // Send the crash report
            sendCrash(mUserComment.getText().toString(), "");
        } else {
            cancelReports();
        }

        finish();
    }

    @Override
    public void onDismiss(DialogInterface dialog) {
        finish();
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        if (mUserComment != null && mUserComment.getText() != null) {
            outState.putString(STATE_COMMENT, mUserComment.getText().toString());
        }
    }
}
package com.ichi2.anki.dialogs;
import android.content.res.Resources;
import android.os.Message;
import android.support.v4.app.DialogFragment;

import com.ichi2.anki.AnkiDroidApp;

public abstract class AsyncDialogFragment extends DialogFragment {
    /* provide methods for text to show in notification bar when the DialogFragment
       can't be shown due to the host activity being in stopped state.
       This can happen when the DialogFragment is shown from 
       the onPostExecute() method of an AsyncTask */
    
    public abstract String getNotificationMessage();
    public abstract String getNotificationTitle();

    public Message getDialogHandlerMessage() {
        return null;
    }

    protected Resources res() {
        return AnkiDroidApp.getAppResources();
    }
} 
package com.ichi2.anki.dialogs;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.R;

import android.app.Dialog;
import android.content.res.Resources;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;

public class CardBrowserContextMenu extends DialogFragment {
    /**
     * Context Menu items
     */
    public static final int CONTEXT_MENU_MARK = 0;
    public static final int CONTEXT_MENU_SUSPEND = 1;
    public static final int CONTEXT_MENU_DELETE = 2;
    public static final int CONTEXT_MENU_DETAILS = 3;
    public static final int CONTEXT_MENU_MOVE_FIRST = 4;
    private static final int MAX_TITLE_LENGTH = 75;

    private static MaterialDialog.ListCallback mContextMenuListener;


    public static CardBrowserContextMenu newInstance(String dialogTitle, boolean isMarked,
            boolean isSuspended, MaterialDialog.ListCallback contextMenuListener) {
        CardBrowserContextMenu f = new CardBrowserContextMenu();
        Bundle args = new Bundle();
        args.putString("dialogTitle", dialogTitle);
        args.putBoolean("isMarked", isMarked);
        args.putBoolean("isSuspended", isSuspended);
        mContextMenuListener = contextMenuListener;
        f.setArguments(args);
        return f;
    }


    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Resources res = getResources();
        String[] entries = new String[5];
        entries[CONTEXT_MENU_MOVE_FIRST] = res.getString(R.string.card_browser_move_first);
        entries[CONTEXT_MENU_DELETE] = res.getString(R.string.card_browser_delete_card);
        entries[CONTEXT_MENU_DETAILS] = res.getString(R.string.card_editor_preview_card);
        entries[CONTEXT_MENU_MARK] = res.getString(
                getArguments().getBoolean("isMarked") ?
                        R.string.card_browser_unmark_card :
                        R.string.card_browser_mark_card);
        entries[CONTEXT_MENU_SUSPEND] = res.getString(
                getArguments().getBoolean("isSuspended") ?
                        R.string.card_browser_unsuspend_card :
                        R.string.card_browser_suspend_card);
        // Ellipsize the title if it's obscenely long
        String title = getArguments().getString("dialogTitle");
        if (title != null && title.length() > MAX_TITLE_LENGTH) {
            title = title.substring(0, MAX_TITLE_LENGTH) + "鈥package com.ichi2.anki.dialogs;

import android.app.Activity;
import android.app.Dialog;
import android.content.Context;
import android.content.res.Resources;
import android.graphics.drawable.ColorDrawable;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.support.v4.content.ContextCompat;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ImageButton;
import android.widget.TextView;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.R;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;

public class CardBrowserMySearchesDialog extends DialogFragment {

    public static int CARD_BROWSER_MY_SEARCHES_TYPE_LIST = 0; //list searches dialog
    public static int CARD_BROWSER_MY_SEARCHES_TYPE_SAVE = 1; //save searches dialog

    public interface MySearchesDialogListener {
        public void OnSelection(String searchName);
        public void OnRemoveSearch(String searchName);
        public void OnSaveSearch(String searchName, String searchTerms);
    }

    private static MySearchesDialogListener mMySearchesDialogListener;

    private MySearchesArrayAdapter mSearchesAdapter;
    private HashMap<String, String> mSavedFilters;
    private String mCurrentSearchTerms;

    public static CardBrowserMySearchesDialog newInstance(HashMap<String, String> savedFilters,
                                                          MySearchesDialogListener mySearchesDialogListener,
                                                          String currentSearchTerms, int type) {
        mMySearchesDialogListener = mySearchesDialogListener;
        CardBrowserMySearchesDialog m = new CardBrowserMySearchesDialog();
        Bundle args = new Bundle();
        args.putSerializable("savedFilters", savedFilters);
        args.putInt("type", type);
        args.putString("currentSearchTerms", currentSearchTerms);
        m.setArguments(args);
        return m;
    }

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        final Resources res = getResources();

        Activity activity = getActivity();
        final MaterialDialog.Builder builder = new MaterialDialog.Builder(activity);

        int type = getArguments().getInt("type");
        if (type == CARD_BROWSER_MY_SEARCHES_TYPE_LIST) {
            mSavedFilters = (HashMap<String, String>) getArguments().getSerializable("savedFilters");
            mSearchesAdapter = new MySearchesArrayAdapter(activity, new ArrayList<>(mSavedFilters.keySet()));
            mSearchesAdapter.notifyDataSetChanged(); //so the values are sorted.
            builder.title(res.getString(R.string.card_browser_list_my_searches_title))
                    .adapter(mSearchesAdapter, new MaterialDialog.ListCallback() {
                        @Override
                        public void onSelection(MaterialDialog dialog, View itemView, int which, CharSequence text) {
                            mMySearchesDialogListener.OnSelection(mSearchesAdapter.getItem(which));
                            dialog.dismiss();
                        }
                    });
        } else if (type == CARD_BROWSER_MY_SEARCHES_TYPE_SAVE) {
            mCurrentSearchTerms = getArguments().getString("currentSearchTerms");
            builder.title(getString(R.string.card_browser_list_my_searches_save))
                   .positiveText(getString(android.R.string.ok))
                   .negativeText(getString(R.string.cancel))
                   .input(R.string.card_browser_list_my_searches_new_name, R.string.empty_string, new MaterialDialog.InputCallback() {
                       @Override
                       public void onInput(MaterialDialog dialog, CharSequence text) {
                           mMySearchesDialogListener.OnSaveSearch(text.toString(), mCurrentSearchTerms);
                       }
                   });
        }
        MaterialDialog dialog = builder.build();
        if (dialog.getListView() != null) {
            dialog.getListView().setDivider(new ColorDrawable(ContextCompat.getColor(activity, R.color.material_grey_600)));
            dialog.getListView().setDividerHeight(1);
            //adjust padding to use dp as seen here: http://stackoverflow.com/a/9685690/1332026
            float scale = res.getDisplayMetrics().density;
            int dpAsPixels = (int) (5*scale + 0.5f);
            dialog.getView().setPadding(dpAsPixels, 0, dpAsPixels, dpAsPixels);
        }

        return dialog;
    }

    private void removeSearch(final String searchName) {
        if (mSearchesAdapter.getPosition(searchName) >= 0) {
            Resources res = getResources();
            new MaterialDialog.Builder(getActivity())
                    .content(res.getString(R.string.card_browser_list_my_searches_remove_content, searchName))
                    .positiveText(res.getString(android.R.string.ok))
                    .negativeText(res.getString(R.string.cancel))
                    .callback(new MaterialDialog.ButtonCallback() {
                        @Override
                        public void onPositive(MaterialDialog dialog) {
                            mMySearchesDialogListener.OnRemoveSearch(searchName);
                            mSavedFilters.remove(searchName);
                            mSearchesAdapter.remove(searchName);
                            mSearchesAdapter.notifyDataSetChanged();
                            dialog.dismiss();
                            if (mSavedFilters.size() == 0) {
                                getDialog().dismiss();
                            }
                        }
                    }).show();
        }
    }

    //using View Holder pattern for faster ListView scrolling.
    static class ViewHolder {
        private TextView mSearchName;
        private TextView mSearchTerms;
        private ImageButton mRemoveButton;
    }

    public class MySearchesArrayAdapter extends ArrayAdapter<String> {
        private Context mContext;
        private ArrayList<String> mSavedFiltersNames;

        public MySearchesArrayAdapter(Context context, ArrayList<String> savedFiltersNames) {
            super(context, R.layout.card_browser_item_my_searches_dialog, savedFiltersNames);
            mContext = context;
            mSavedFiltersNames = savedFiltersNames;
        }

        @Override
        public View getView(final int position, View convertView, ViewGroup parent) {
            ViewHolder viewHolder = null;
            if (convertView == null) {
                viewHolder = new ViewHolder();
                LayoutInflater inflater = (LayoutInflater) mContext
                        .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
                convertView = inflater.inflate(R.layout.card_browser_item_my_searches_dialog, parent, false);
                viewHolder.mSearchName = (TextView) convertView.findViewById(R.id.card_browser_my_search_name_textview);
                viewHolder.mSearchTerms = (TextView) convertView.findViewById(R.id.card_browser_my_search_terms_textview);
                viewHolder.mRemoveButton = (ImageButton) convertView.findViewById(R.id.card_browser_my_search_remove_button);

                convertView.setTag(viewHolder);
            } else {
                viewHolder = (ViewHolder) convertView.getTag();
            }

            viewHolder.mSearchName.setText(getItem(position));
            viewHolder.mSearchTerms.setText(mSavedFilters.get(getItem(position)));
            viewHolder.mRemoveButton.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    CardBrowserMySearchesDialog.this.removeSearch(getItem(position));
                }
            });
            return convertView;
        }

        @Override
        public void notifyDataSetChanged() {
            Collections.sort(mSavedFiltersNames, new Comparator<String>() {
                @Override
                public int compare(String lhs, String rhs) {
                    return lhs.compareToIgnoreCase(rhs);
                }
            });
            super.notifyDataSetChanged();
        }

        @Override
        public boolean areAllItemsEnabled() {
            return true;
        }
    }
}

package com.ichi2.anki.dialogs;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.CardBrowser;
import com.ichi2.anki.R;

import android.app.Dialog;
import android.content.res.Resources;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;

public class CardBrowserOrderDialog extends DialogFragment {

    private static MaterialDialog.ListCallbackSingleChoice mOrderDialogListener;


    public static CardBrowserOrderDialog newInstance(int order, boolean isOrderAsc,
            MaterialDialog.ListCallbackSingleChoice orderDialogListener) {
        CardBrowserOrderDialog f = new CardBrowserOrderDialog();
        Bundle args = new Bundle();
        args.putInt("order", order);
        args.putBoolean("isOrderAsc", isOrderAsc);
        mOrderDialogListener = orderDialogListener;
        f.setArguments(args);
        return f;
    }


    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Resources res = getResources();
        String[] items = res.getStringArray(R.array.card_browser_order_labels);
        // Set sort order arrow
        for (int i = 0; i < items.length; ++i) {
            if (i != CardBrowser.CARD_ORDER_NONE && i == getArguments().getInt("order")) {
                if (getArguments().getBoolean("isOrderAsc")) {
                    items[i] = items[i] + " (\u25b2)";
                } else {
                    items[i] = items[i] + " (\u25bc)";

                }
            }
        }
        return new MaterialDialog.Builder(getActivity())
                .title(res.getString(R.string.card_browser_change_display_order_title))
                .content(res.getString(R.string.card_browser_change_display_order_reverse))
                .items(items)
                .itemsCallbackSingleChoice(getArguments().getInt("order"), mOrderDialogListener)
                .build();
    }

}

package com.ichi2.anki.dialogs;

import android.content.res.Resources;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.R;

    /**
     * This is a reusable convenience class which makes it easy to show a confirmation dialog as a DialogFragment.
     * Create a new instance, call setArgs(...), setConfirm(), and setCancel() then show it via the fragment manager as usual.
     */
    public class ConfirmationDialog extends DialogFragment {
        // TODO: Replace these with lambdas
        private Runnable mConfirm = new Runnable() {
            @Override
            public void run() { // Do nothing by default
            }
        };
        private Runnable mCancel = new Runnable() {
            @Override
            public void run() { // Do nothing by default
            }
        };

        public void setArgs(String message) {
            setArgs("" , message);
        }

        public void setArgs(String title, String message) {
            Bundle args = new Bundle();
            args.putString("message", message);
            args.putString("title", title);
            setArguments(args);
        }

        public void setConfirm(Runnable confirm) {
            mConfirm = confirm;
        }

        public void setCancel(Runnable cancel) {
            mCancel = cancel;
        }

        @Override
        public MaterialDialog onCreateDialog(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            Resources res = getActivity().getResources();
            String title = getArguments().getString("title");
            return new MaterialDialog.Builder(getActivity())
                    .title(title.equals("") ? res.getString(R.string.app_name) : title)
                    .content(getArguments().getString("message"))
                    .positiveText(res.getString(R.string.dialog_ok))
                    .negativeText(res.getString(R.string.dialog_cancel))
                    .callback(new MaterialDialog.ButtonCallback() {
                        @Override
                        public void onPositive(MaterialDialog dialog) {
                            mConfirm.run();
                        }

                        @Override
                        public void onNegative(MaterialDialog dialog) {
                            mCancel.run();
                        }
                    })
                    .show();
        }
    }
/****************************************************************************************
 * Copyright (c) 2015 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/
package com.ichi2.anki.dialogs;

import java.util.ArrayList;
import java.util.HashMap;

public class ContextMenuHelper {
    public static String[] getValuesFromKeys(HashMap<Integer, String> map, int[] keys) {
        String[] values = new String[keys.length];
        for (int i = 0; i < keys.length; i++) {
            values[i] = map.get(keys[i]);
        }
        return values;
    }

    public static int[] integerListToArray(ArrayList<Integer> itemIds) {
        int[] intItemIds = new int[itemIds.size()];
        for (int i = 0; i < itemIds.size(); i++) {
            intItemIds[i] = itemIds.get(i);
        }
        return intItemIds;
    }
}
/****************************************************************************************
 * Copyright (c) 2015 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/
package com.ichi2.anki.dialogs;

import android.app.Dialog;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.res.Resources;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.v4.app.DialogFragment;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.view.KeyEvent;
import android.view.View;
import android.view.WindowManager;
import android.widget.EditText;
import android.widget.TextView;

import com.afollestad.materialdialogs.DialogAction;
import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.AnkiActivity;
import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.DeckOptions;
import com.ichi2.anki.R;
import com.ichi2.anki.Reviewer;
import com.ichi2.async.DeckTask;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Consts;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;

public class CustomStudyDialog extends DialogFragment {
    // Different configurations for the context menu
    public static final int CONTEXT_MENU_STANDARD = 0;
    public static final int CONTEXT_MENU_LIMITS = 1;
    public static final int CONTEXT_MENU_EMPTY_SCHEDULE = 2;
    // Standard custom study options to show in the context menu
    private static final int CUSTOM_STUDY_NEW = 100;
    private static final int CUSTOM_STUDY_REV = 101;
    private static final int CUSTOM_STUDY_FORGOT = 102;
    private static final int CUSTOM_STUDY_AHEAD = 103;
    private static final int CUSTOM_STUDY_RANDOM = 104;
    private static final int CUSTOM_STUDY_PREVIEW = 105;
    private static final int CUSTOM_STUDY_TAGS = 106;
    // Special items to put in the context menu
    private static final int DECK_OPTIONS = 107;
    private static final int MORE_OPTIONS = 108;

    public interface CustomStudyListener {
        void onCreateCustomStudySession();
        void onExtendStudyLimits();
    }

    /**
     * Instance factories
     */
    public static CustomStudyDialog newInstance(int id, long did) {
        return newInstance(id, did, false);
    }

    public static CustomStudyDialog newInstance(int id, long did, boolean jumpToReviewer) {
        CustomStudyDialog f = new CustomStudyDialog();
        Bundle args = new Bundle();
        args.putInt("id", id);
        args.putLong("did", did);
        args.putBoolean("jumpToReviewer", jumpToReviewer);
        f.setArguments(args);
        return f;
    }

    @NonNull
    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        final int dialogId = getArguments().getInt("id");
        if (dialogId < 100) {
            // Select the specified deck
            CollectionHelper.getInstance().getCol(getActivity()).getDecks().select(getArguments().getLong("did"));
            return buildContextMenu(dialogId);
        } else {
            return buildInputDialog(dialogId);
        }
    }

    /**
     * Build a context menu for custom study
     * @param id
     * @return
     */
    private MaterialDialog buildContextMenu(int id) {
        int[] listIds = getListIds(id);
        final boolean jumpToReviewer = getArguments ().getBoolean("jumpToReviewer");
        return new MaterialDialog.Builder(this.getActivity())
                .title(R.string.custom_study)
                .cancelable(true)
                .itemsIds(listIds)
                .items(ContextMenuHelper.getValuesFromKeys(getKeyValueMap(), listIds))
                .itemsCallback(new MaterialDialog.ListCallback() {
                    @Override
                    public void onSelection(MaterialDialog materialDialog, View view, int which,
                                            CharSequence charSequence) {
                        AnkiActivity activity = (AnkiActivity) getActivity();
                        switch (view.getId()) {
                            case DECK_OPTIONS: {
                                // User asked to permanently change the deck options
                                Intent i = new Intent(activity, DeckOptions.class);
                                i.putExtra("did", getArguments().getLong("did"));
                                getActivity().startActivity(i);
                                break;
                            }
                            case MORE_OPTIONS: {
                                // User asked to see all custom study options
                                CustomStudyDialog d = CustomStudyDialog.newInstance(CONTEXT_MENU_STANDARD,
                                        getArguments().getLong("did"), jumpToReviewer);
                                activity.showDialogFragment(d);
                                break;
                            }
                            case CUSTOM_STUDY_TAGS: {
                                /*
                                 * This is a special Dialog for CUSTOM STUDY, where instead of only collecting a
                                 * number, it is necessary to collect a list of tags. This case handles the creation
                                 * of that Dialog.
                                 */
                                long currentDeck = getArguments().getLong("did");
                                TagsDialog dialogFragment = TagsDialog.newInstance(
                                        TagsDialog.TYPE_CUSTOM_STUDY_TAGS, new ArrayList<String>(),
                                        new ArrayList<>(activity.getCol().getTags().byDeck(currentDeck, true)));
                                dialogFragment.setTagsDialogListener(new TagsDialog.TagsDialogListener() {
                                    @Override
                                    public void onPositive(List<String> selectedTags, int option) {
                                        /*
                                         * Here's the method that gathers the final selection of tags, type of cards and
                                         * generates the search screen for the custom study deck.
                                         */
                                        StringBuilder sb = new StringBuilder();
                                        switch (option) {
                                            case 1:
                                                sb.append("is:new ");
                                                break;
                                            case 2:
                                                sb.append("is:due ");
                                                break;
                                            default:
                                                // Logging here might be appropriate : )
                                                break;
                                        }
                                        List<String> arr = new ArrayList<>();
                                        if (selectedTags.size() > 0) {
                                            for (String tag : selectedTags) {
                                                arr.add(String.format("tag:'%s'", tag));
                                            }
                                            sb.append("(").append(TextUtils.join(" or ", arr)).append(")");
                                        }
                                        createCustomStudySession(new JSONArray(), new Object[]{sb.toString(),
                                                Consts.DYN_MAX_SIZE, Consts.DYN_RANDOM}, true);
                                    }
                                });
                                activity.showDialogFragment(dialogFragment);
                                break;
                            }
                            default: {
                                // User asked for a standard custom study option
                                CustomStudyDialog d = CustomStudyDialog.newInstance(view.getId(),
                                        getArguments().getLong("did"), jumpToReviewer);
                                ((AnkiActivity) getActivity()).showDialogFragment(d);
                            }
                        }
                    }
                }).build();
    }

    /**
     * Build an input dialog that is used to get a parameter related to custom study from the user
     * @param dialogId
     * @return
     */
    private MaterialDialog buildInputDialog(final int dialogId) {
        /*
            TODO: Try to change to a standard input dialog (currently the thing holding us back is having the extra
            TODO: hint line for the number of cards available, and having the pre-filled text selected by default)
        */
        // Input dialogs
        Resources res = getActivity().getResources();
        // Show input dialog for an individual custom study dialog
        View v = getActivity().getLayoutInflater().inflate(R.layout.styled_custom_study_details_dialog, null);
        TextView textView1 = (TextView) v.findViewById(R.id.custom_study_details_text1);
        TextView textView2 = (TextView) v.findViewById(R.id.custom_study_details_text2);
        final EditText mEditText = (EditText) v.findViewById(R.id.custom_study_details_edittext2);
        // Set the text
        textView1.setText(getText1());
        textView2.setText(getText2());
        mEditText.setText(getDefaultValue());
        // Give EditText focus and show keyboard
        mEditText.setSelectAllOnFocus(true);
        mEditText.requestFocus();
        // deck id
        final long did = getArguments().getLong("did");
        // Whether or not to jump straight to the reviewer
        final boolean jumpToReviewer = getArguments ().getBoolean("jumpToReviewer");
        // Set builder parameters
        MaterialDialog.Builder builder = new MaterialDialog.Builder(getActivity())
                .customView(v, true)
                .positiveText(res.getString(R.string.dialog_ok))
                .negativeText(res.getString(R.string.dialog_cancel))
                .callback(new MaterialDialog.ButtonCallback() {
                    @Override
                    public void onPositive(MaterialDialog dialog) {
                        Collection col = CollectionHelper.getInstance().getCol(getActivity());
                        // Get the value selected by user
                        int n;
                        try {
                            n = Integer.parseInt(mEditText.getText().toString());
                        } catch (Exception ignored) {
                            n = Integer.MAX_VALUE;
                        }

                        // Set behavior when clicking OK button
                        switch (dialogId) {
                            case CUSTOM_STUDY_NEW:
                                try {
                                    AnkiDroidApp.getSharedPrefs(getActivity()).edit().putInt("extendNew", n).commit();
                                    JSONObject deck = col.getDecks().get(did);
                                    deck.put("extendNew", n);
                                    col.getDecks().save(deck);
                                    col.getSched().extendLimits(n, 0);
                                    onLimitsExtended(jumpToReviewer);
                                } catch (JSONException e) {
                                    throw new RuntimeException(e);
                                }
                                break;
                            case CUSTOM_STUDY_REV:
                                try {
                                    AnkiDroidApp.getSharedPrefs(getActivity()).edit().putInt("extendRev", n).commit();
                                    JSONObject deck = col.getDecks().get(did);
                                    deck.put("extendRev", n);
                                    col.getDecks().save(deck);
                                    col.getSched().extendLimits(0, n);
                                    onLimitsExtended(jumpToReviewer);
                                } catch (JSONException e) {
                                    throw new RuntimeException(e);
                                }
                                break;
                            case CUSTOM_STUDY_FORGOT:
                                JSONArray ar = new JSONArray();
                                try {
                                    ar.put(0, 1);
                                    createCustomStudySession(ar, new Object[]{String.format(Locale.US,
                                            "rated:%d:1", n), Consts.DYN_MAX_SIZE, Consts.DYN_RANDOM}, false);
                                } catch (JSONException e) {
                                    throw new RuntimeException(e);
                                }
                                break;
                            case CUSTOM_STUDY_AHEAD:
                                createCustomStudySession(new JSONArray(), new Object[]{String.format(Locale.US,
                                        "prop:due<=%d", n), Consts.DYN_MAX_SIZE, Consts.DYN_DUE}, true);
                                break;
                            case CUSTOM_STUDY_RANDOM:
                                createCustomStudySession(new JSONArray(),
                                        new Object[]{"", n, Consts.DYN_RANDOM}, true);
                                break;
                            case CUSTOM_STUDY_PREVIEW:
                                createCustomStudySession(new JSONArray(), new Object[]{"is:new added:" +
                                        Integer.toString(n), Consts.DYN_MAX_SIZE, Consts.DYN_OLDEST}, false);
                                break;
                            default:
                                break;
                        }
                    }

                    @Override
                    public void onNegative(MaterialDialog dialog) {
                        ((AnkiActivity) getActivity()).dismissAllDialogFragments();
                    }
                });
        final MaterialDialog dialog = builder.build();
        mEditText.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {

            }

            @Override
            public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {

            }

            @Override
            public void afterTextChanged(Editable editable) {
                if (editable.length() == 0) {
                    dialog.getActionButton(DialogAction.POSITIVE).setEnabled(false);
                } else {
                    dialog.getActionButton(DialogAction.POSITIVE).setEnabled(true);
                }
            }
        });

        // Show soft keyboard
        dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
        return dialog;
    }

    private HashMap<Integer, String> getKeyValueMap() {
        Resources res = getResources();
        HashMap<Integer, String> keyValueMap = new HashMap<>();
        keyValueMap.put(CONTEXT_MENU_STANDARD, res.getString(R.string.custom_study));
        keyValueMap.put(CUSTOM_STUDY_NEW, res.getString(R.string.custom_study_increase_new_limit));
        keyValueMap.put(CUSTOM_STUDY_REV, res.getString(R.string.custom_study_increase_review_limit));
        keyValueMap.put(CUSTOM_STUDY_FORGOT, res.getString(R.string.custom_study_review_forgotten));
        keyValueMap.put(CUSTOM_STUDY_AHEAD, res.getString(R.string.custom_study_review_ahead));
        keyValueMap.put(CUSTOM_STUDY_RANDOM, res.getString(R.string.custom_study_random_selection));
        keyValueMap.put(CUSTOM_STUDY_PREVIEW, res.getString(R.string.custom_study_preview_new));
        keyValueMap.put(CUSTOM_STUDY_TAGS, res.getString(R.string.custom_study_limit_tags));
        keyValueMap.put(DECK_OPTIONS, res.getString(R.string.study_options));
        keyValueMap.put(MORE_OPTIONS, res.getString(R.string.more_options));
        return keyValueMap;
    }


    /**
     * Retrieve the list of ids to put in the context menu list
     * @param dialogId option to specify which tasks are shown in the list
     * @return the ids of which values to show
     */
    private int[] getListIds(int dialogId) {
        Collection col = ((AnkiActivity) getActivity()).getCol();
        switch (dialogId) {
            case CONTEXT_MENU_STANDARD:
                // Standard context menu
                return new int[] {CUSTOM_STUDY_NEW, CUSTOM_STUDY_REV, CUSTOM_STUDY_FORGOT, CUSTOM_STUDY_AHEAD,
                        CUSTOM_STUDY_RANDOM, CUSTOM_STUDY_PREVIEW, CUSTOM_STUDY_TAGS};
            case CONTEXT_MENU_LIMITS:
                // Special custom study options to show when the daily study limit has been reached
                if (col.getSched().newDue() && col.getSched().revDue()) {
                    return new int[] {CUSTOM_STUDY_NEW, CUSTOM_STUDY_REV, DECK_OPTIONS, MORE_OPTIONS};
                } else {
                    if (col.getSched().newDue()) {
                        return new int[]{CUSTOM_STUDY_NEW, DECK_OPTIONS, MORE_OPTIONS};
                    } else {
                        return new int[]{CUSTOM_STUDY_REV, DECK_OPTIONS, MORE_OPTIONS};
                    }
                }
            case CONTEXT_MENU_EMPTY_SCHEDULE:
                // Special custom study options to show when extending the daily study limits is not applicable
                return new int[] {CUSTOM_STUDY_FORGOT, CUSTOM_STUDY_AHEAD, CUSTOM_STUDY_RANDOM,
                        CUSTOM_STUDY_PREVIEW, CUSTOM_STUDY_TAGS, DECK_OPTIONS};
        }
        return null;
    }


    private String getText1() {
        Resources res = AnkiDroidApp.getAppResources();
        Collection col = CollectionHelper.getInstance().getCol(getActivity());
        switch (getArguments().getInt("id")) {
            case CUSTOM_STUDY_NEW:
                return res.getString(R.string.custom_study_new_total_new, col.getSched().totalNewForCurrentDeck());
            case CUSTOM_STUDY_REV:
                return res.getString(R.string.custom_study_rev_total_rev, col.getSched().totalRevForCurrentDeck());
            default:
                return "";
        }
    }

    private String getText2() {
        Resources res = AnkiDroidApp.getAppResources();
        switch (getArguments().getInt("id")) {
            case CUSTOM_STUDY_NEW:
                return res.getString(R.string.custom_study_new_extend);
            case CUSTOM_STUDY_REV:
                return res.getString(R.string.custom_study_rev_extend);
            case CUSTOM_STUDY_FORGOT:
                return res.getString(R.string.custom_study_forgotten);
            case CUSTOM_STUDY_AHEAD:
                return res.getString(R.string.custom_study_ahead);
            case CUSTOM_STUDY_RANDOM:
                return res.getString(R.string.custom_study_random);
            case CUSTOM_STUDY_PREVIEW:
                return res.getString(R.string.custom_study_preview);
            default:
                return "";
        }
    }

    private String getDefaultValue() {
        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(getActivity());
        switch (getArguments().getInt("id")) {
            case CUSTOM_STUDY_NEW:
                return Integer.toString(prefs.getInt("extendNew", 10));
            case CUSTOM_STUDY_REV:
                return Integer.toString(prefs.getInt("extendRev", 50));
            case CUSTOM_STUDY_FORGOT:
                return Integer.toString(prefs.getInt("forgottenDays", 1));
            case CUSTOM_STUDY_AHEAD:
                return Integer.toString(prefs.getInt("aheadDays", 1));
            case CUSTOM_STUDY_RANDOM:
                return Integer.toString(prefs.getInt("randomCards", 100));
            case CUSTOM_STUDY_PREVIEW:
                return Integer.toString(prefs.getInt("previewDays", 1));
            default:
                return "";
        }
    }

    /**
     * Create a custom study session
     * @param delays delay options for scheduling algorithm
     * @param terms search terms
     * @param resched whether to reschedule the cards based on the answers given (or ignore them if false)
     */
    private void createCustomStudySession(JSONArray delays, Object[] terms, Boolean resched) {
        JSONObject dyn;
        final AnkiActivity activity = (AnkiActivity) getActivity();
        Collection col = CollectionHelper.getInstance().getCol(activity);
        try {
            long did = getArguments().getLong("did");
            String deckName = col.getDecks().get(did).getString("name");
            String customStudyDeck = getResources().getString(R.string.custom_study_deck_name);
            JSONObject cur = col.getDecks().byName(customStudyDeck);
            if (cur != null) {
                if (cur.getInt("dyn") != 1) {
                    new MaterialDialog.Builder(getActivity())
                            .content(R.string.custom_study_deck_exists)
                            .negativeText(R.string.dialog_cancel)
                            .build().show();
                    return;
                } else {
                    // safe to empty
                    col.getSched().emptyDyn(cur.getLong("id"));
                    // reuse; don't delete as it may have children
                    dyn = cur;
                    col.getDecks().select(cur.getLong("id"));
                }
            } else {
                long customStudyDid = col.getDecks().newDyn(customStudyDeck);
                dyn = col.getDecks().get(customStudyDid);
            }
            // and then set various options
            if (delays.length() > 0) {
                dyn.put("delays", delays);
            } else {
                dyn.put("delays", JSONObject.NULL);
            }
            JSONArray ar = dyn.getJSONArray("terms");
            ar.getJSONArray(0).put(0, "deck:\"" + deckName + "\" " + terms[0]);
            ar.getJSONArray(0).put(1, terms[1]);
            ar.getJSONArray(0).put(2, terms[2]);
            dyn.put("resched", resched);
            // Rebuild the filtered deck
            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REBUILD_CRAM, new DeckTask.TaskListener() {
                @Override
                public void onCancelled() {
                }

                @Override
                public void onPreExecute() {
                    activity.showProgressBar();
                }

                @Override
                public void onPostExecute(DeckTask.TaskData result) {
                    activity.hideProgressBar();
                    ((CustomStudyListener) activity).onCreateCustomStudySession();
                }

                @Override
                public void onProgressUpdate(DeckTask.TaskData... values) {
                }
            });

        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        // Hide the dialogs
        activity.dismissAllDialogFragments();
    }

    private void onLimitsExtended(boolean jumpToReviewer) {
        AnkiActivity activity = (AnkiActivity) getActivity();
        if (jumpToReviewer) {
            activity.startActivityForResult(new Intent(activity, Reviewer.class), AnkiActivity.REQUEST_REVIEW);
            CollectionHelper.getInstance().getCol(activity).startTimebox();
        } else {
            ((CustomStudyListener) activity).onExtendStudyLimits();
        }
        activity.dismissAllDialogFragments();
    }
}

package com.ichi2.anki.dialogs;

import android.content.res.Resources;
import android.os.Bundle;
import android.os.Message;
import android.view.View;

import com.afollestad.materialdialogs.MaterialDialog;

import com.ichi2.anki.AnkiActivity;
import com.ichi2.anki.BackupManager;
import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.DeckPicker;
import com.ichi2.anki.R;
import com.ichi2.compat.CompatHelper;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;

public class DatabaseErrorDialog extends AsyncDialogFragment {
    private int mType = 0;
    private int[] mRepairValues;
    private File[] mBackups;

    public static final int DIALOG_LOAD_FAILED = 0;
    public static final int DIALOG_DB_ERROR = 1;
    public static final int DIALOG_ERROR_HANDLING = 2;
    public static final int DIALOG_REPAIR_COLLECTION = 3;
    public static final int DIALOG_RESTORE_BACKUP = 4;
    public static final int DIALOG_NEW_COLLECTION = 5;
    public static final int DIALOG_CONFIRM_DATABASE_CHECK = 6;
    public static final int DIALOG_CONFIRM_RESTORE_BACKUP = 7;
    public static final int DIALOG_FULL_SYNC_FROM_SERVER = 8;
    public static final int DIALOG_CURSOR_SIZE_LIMIT_EXCEEDED = 9;

    // public flag which lets us distinguish between inaccessible and corrupt database
    public static boolean databaseCorruptFlag = false;


    /**
     * A set of dialogs which deal with problems with the database when it can't load
     * 
     * @param dialogType An integer which specifies which of the sub-dialogs to show
     */
    public static DatabaseErrorDialog newInstance(int dialogType) {
        DatabaseErrorDialog f = new DatabaseErrorDialog();
        Bundle args = new Bundle();
        args.putInt("dialogType", dialogType);
        f.setArguments(args);
        return f;
    }


    @Override
    public MaterialDialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mType = getArguments().getInt("dialogType");
        Resources res = getResources();
        MaterialDialog.Builder builder = new MaterialDialog.Builder(getActivity());
        builder.cancelable(true)
                .title(getTitle());

        boolean sqliteInstalled = false;
        try {
            sqliteInstalled = Runtime.getRuntime().exec("sqlite3 --version").waitFor() == 0;
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }

        switch (mType) {
            case DIALOG_CURSOR_SIZE_LIMIT_EXCEEDED:
            case DIALOG_LOAD_FAILED:
                // Collection failed to load; give user the option of either choosing from repair options, or closing
                // the activity
                return builder.cancelable(false)
                        .content(getMessage())
                        .iconAttr(R.attr.dialogErrorIcon)
                        .positiveText(res.getString(R.string.error_handling_options))
                        .negativeText(res.getString(R.string.close))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((DeckPicker) getActivity())
                                        .showDatabaseErrorDialog(DIALOG_ERROR_HANDLING);
                            }

                            @Override
                            public void onNegative(MaterialDialog dialog) {
                                ((DeckPicker) getActivity()).exit();
                            }
                        })
                        .show();

            case DIALOG_DB_ERROR:
                // Database Check failed to execute successfully; give user the option of either choosing from repair
                // options, submitting an error report, or closing the activity
                MaterialDialog dialog = builder
                        .cancelable(false)
                        .content(getMessage())
                        .iconAttr(R.attr.dialogErrorIcon)
                        .positiveText(res.getString(R.string.error_handling_options))
                        .negativeText(res.getString(R.string.answering_error_report))
                        .neutralText(res.getString(R.string.close))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((DeckPicker) getActivity())
                                        .showDatabaseErrorDialog(DIALOG_ERROR_HANDLING);
                            }

                            @Override
                            public void onNegative(MaterialDialog dialog) {
                                ((DeckPicker) getActivity()).sendErrorReport();
                                dismissAllDialogFragments();
                            }

                            @Override
                            public void onNeutral(MaterialDialog dialog) {
                                ((DeckPicker) getActivity()).exit();
                            }
                        })
                        .show();
                dialog.getCustomView().findViewById(R.id.buttonDefaultNegative).setEnabled(
                        ((DeckPicker) getActivity()).hasErrorFiles());
                return dialog;

            case DIALOG_ERROR_HANDLING:
                // The user has asked to see repair options; allow them to choose one of the repair options or go back
                // to the previous dialog
                ArrayList<String> options = new ArrayList<>();
                ArrayList<Integer> values = new ArrayList<>();
                if (!((AnkiActivity)getActivity()).colIsOpen()) {
                    // retry
                    options.add(res.getString(R.string.backup_retry_opening));
                    values.add(0);
                } else {
                    // fix integrity
                    options.add(res.getString(R.string.check_db));
                    values.add(1);
                }
                // repair db with sqlite
                if (sqliteInstalled) {
                    options.add(res.getString(R.string.backup_error_menu_repair));
                    values.add(2);
                }
                // // restore from backup
                options.add(res.getString(R.string.backup_restore));
                values.add(3);
                // delete old collection and build new one
                options.add(res.getString(R.string.backup_full_sync_from_server));
                values.add(4);
                // delete old collection and build new one
                options.add(res.getString(R.string.backup_del_collection));
                values.add(5);

                String[] titles = new String[options.size()];
                mRepairValues = new int[options.size()];
                for (int i = 0; i < options.size(); i++) {
                    titles[i] = options.get(i);
                    mRepairValues[i] = values.get(i);
                }

                dialog = builder.iconAttr(R.attr.dialogErrorIcon)
                        .negativeText(res.getString(R.string.dialog_cancel))
                        .items(titles)
                        .itemsCallback(new MaterialDialog.ListCallback() {
                            @Override
                            public void onSelection(MaterialDialog materialDialog, View view, int which,
                                    CharSequence charSequence) {
                                switch (mRepairValues[which]) {
                                    case 0:
                                        ((DeckPicker) getActivity()).restartActivity();
                                        return;
                                    case 1:
                                        ((DeckPicker) getActivity())
                                                .showDatabaseErrorDialog(DIALOG_CONFIRM_DATABASE_CHECK);
                                        return;
                                    case 2:
                                        ((DeckPicker) getActivity())
                                                .showDatabaseErrorDialog(DIALOG_REPAIR_COLLECTION);
                                        return;
                                    case 3:
                                        ((DeckPicker) getActivity())
                                                .showDatabaseErrorDialog(DIALOG_RESTORE_BACKUP);
                                        return;
                                    case 4:
                                        ((DeckPicker) getActivity())
                                                .showDatabaseErrorDialog(DIALOG_FULL_SYNC_FROM_SERVER);
                                        return;
                                    case 5:
                                        ((DeckPicker) getActivity())
                                                .showDatabaseErrorDialog(DIALOG_NEW_COLLECTION);
                                }
                            }
                        })
                        .show();
                return dialog;

            case DIALOG_REPAIR_COLLECTION:
                // Allow user to run BackupManager.repairCollection()
                return builder.content(getMessage())
                        .iconAttr(R.attr.dialogErrorIcon)
                        .positiveText(res.getString(R.string.dialog_positive_repair))
                        .negativeText(res.getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((DeckPicker) getActivity()).repairDeck();
                                dismissAllDialogFragments();
                            }
                        })
                        .show();

            case DIALOG_RESTORE_BACKUP:
                // Allow user to restore one of the backups
                String path = CollectionHelper.getInstance().getCollectionPath(getActivity());
                File[] files = BackupManager.getBackups(new File(path));
                mBackups = new File[files.length];
                for (int i = 0; i < files.length; i++) {
                    mBackups[i] = files[files.length - 1 - i];
                }
                if (mBackups.length == 0) {
                    builder.title(res.getString(R.string.backup_restore))
                            .content(getMessage())
                            .positiveText(res.getString(R.string.dialog_ok))
                            .callback(new MaterialDialog.ButtonCallback() {
                                @Override
                                public void onPositive(MaterialDialog dialog) {
                                    ((DeckPicker) getActivity())
                                            .showDatabaseErrorDialog(DIALOG_ERROR_HANDLING);
                                }
                            });
                } else {
                    String[] dates = new String[mBackups.length];
                    for (int i = 0; i < mBackups.length; i++) {
                        dates[i] = mBackups[i].getName().replaceAll(
                                ".*-(\\d{4}-\\d{2}-\\d{2})-(\\d{2})-(\\d{2}).apkg", "$1 ($2:$3 h)");
                    }
                    builder.title(res.getString(R.string.backup_restore_select_title))
                            .negativeText(res.getString(R.string.dialog_cancel))
                            .callback(new MaterialDialog.ButtonCallback() {
                                @Override
                                public void onNegative(MaterialDialog dialog) {
                                    dismissAllDialogFragments();
                                }
                            })
                            .items(dates)
                            .itemsCallbackSingleChoice(dates.length,
                                    new MaterialDialog.ListCallbackSingleChoice() {
                                @Override
                                public boolean onSelection(MaterialDialog materialDialog, View view,
                                        int which, CharSequence charSequence) {
                                    if (mBackups[which].length() > 0) {
                                        // restore the backup if it's valid
                                        ((DeckPicker) getActivity())
                                                .restoreFromBackup(mBackups[which]
                                                        .getPath());
                                        dismissAllDialogFragments();
                                    } else {
                                        // otherwise show an error dialog
                                        new MaterialDialog.Builder(getActivity())
                                                .title(R.string.backup_error)
                                                .content(R.string.backup_invalid_file_error)
                                                .positiveText(R.string.dialog_ok)
                                                .build().show();
                                    }
                                    return true;
                                }
                            });
                }
                return builder.show();

            case DIALOG_NEW_COLLECTION:
                // Allow user to create a new empty collection
                return builder.content(getMessage())
                        .positiveText(res.getString(R.string.dialog_positive_create))
                        .negativeText(res.getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                CollectionHelper.getInstance().closeCollection(false);
                                String path = CollectionHelper.getCollectionPath(getActivity());
                                if (BackupManager.moveDatabaseToBrokenFolder(path, false)) {
                                    ((DeckPicker) getActivity()).restartActivity();
                                } else {
                                    ((DeckPicker) getActivity()).showDatabaseErrorDialog(DIALOG_LOAD_FAILED);
                                }
                            }
                        })
                        .show();

            case DIALOG_CONFIRM_DATABASE_CHECK:
                // Confirmation dialog for database check
                return builder.content(getMessage())
                        .positiveText(res.getString(R.string.dialog_ok))
                        .negativeText(res.getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((DeckPicker) getActivity()).integrityCheck();
                                dismissAllDialogFragments();
                            }
                        })
                        .show();

            case DIALOG_CONFIRM_RESTORE_BACKUP:
                // Confirmation dialog for backup restore
                return builder.content(getMessage())
                        .positiveText(res.getString(R.string.dialog_continue))
                        .negativeText(res.getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((DeckPicker) getActivity())
                                        .showDatabaseErrorDialog(DIALOG_RESTORE_BACKUP);
                            }
                        })
                        .show();

            case DIALOG_FULL_SYNC_FROM_SERVER:
                // Allow user to do a full-sync from the server
                return builder.content(getMessage())
                        .positiveText(res.getString(R.string.dialog_positive_overwrite))
                        .negativeText(res.getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((DeckPicker) getActivity()).sync("download");
                                dismissAllDialogFragments();
                            }
                        })
                        .show();

            default:
                return null;
        }
    }


    private String getMessage() {
        switch (getArguments().getInt("dialogType")) {
            case DIALOG_LOAD_FAILED:
                if (!CompatHelper.isHoneycomb()) {
                    // Before honeycomb there's no way to know if the db has actually been corrupted
                    // so we show a non-specific message.
                    return res().getString(R.string.open_collection_failed_message, res().getString(R.string.repair_deck));
                } else if (databaseCorruptFlag) {
                    // The sqlite database has been corrupted (DatabaseErrorHandler.onCorrupt() was called)
                    // Show a specific message appropriate for the situation
                    return res().getString(R.string.corrupt_db_message, res().getString(R.string.repair_deck));

                } else {
                    // Generic message shown when a libanki task failed
                    return res().getString(R.string.access_collection_failed_message, res().getString(R.string.link_help));
                }
            case DIALOG_DB_ERROR:
                return res().getString(R.string.answering_error_message);
            case DIALOG_REPAIR_COLLECTION:
                return res().getString(R.string.repair_deck_dialog, BackupManager.BROKEN_DECKS_SUFFIX);
            case DIALOG_RESTORE_BACKUP:
                return res().getString(R.string.backup_restore_no_backups);
            case DIALOG_NEW_COLLECTION:
                return res().getString(R.string.backup_del_collection_question);
            case DIALOG_CONFIRM_DATABASE_CHECK:
                return res().getString(R.string.check_db_warning);
            case DIALOG_CONFIRM_RESTORE_BACKUP:
                return res().getString(R.string.restore_backup);
            case DIALOG_FULL_SYNC_FROM_SERVER:
                return res().getString(R.string.backup_full_sync_from_server_question);
            case DIALOG_CURSOR_SIZE_LIMIT_EXCEEDED:
                return res().getString(R.string.cursor_size_limit_exceeded);
            default:
                return getArguments().getString("dialogMessage");
        }
    }

    private String getTitle() {
        switch (getArguments().getInt("dialogType")) {
            case DIALOG_LOAD_FAILED:
                return res().getString(R.string.open_collection_failed_title);
            case DIALOG_DB_ERROR:
                return res().getString(R.string.answering_error_title);
            case DIALOG_ERROR_HANDLING:
                return res().getString(R.string.error_handling_title);
            case DIALOG_REPAIR_COLLECTION:
                return res().getString(R.string.backup_repair_deck);
            case DIALOG_RESTORE_BACKUP:
                return res().getString(R.string.backup_restore);
            case DIALOG_NEW_COLLECTION:
                return res().getString(R.string.backup_new_collection);
            case DIALOG_CONFIRM_DATABASE_CHECK:
                return res().getString(R.string.check_db_title);
            case DIALOG_CONFIRM_RESTORE_BACKUP:
                return res().getString(R.string.restore_backup_title);
            case DIALOG_FULL_SYNC_FROM_SERVER:
                return res().getString(R.string.backup_full_sync_from_server);
            case DIALOG_CURSOR_SIZE_LIMIT_EXCEEDED:
                return res().getString(R.string.open_collection_failed_title);
            default:
                return res().getString(R.string.answering_error_title);
        }        
    }


    @Override
    public String getNotificationMessage() {
        switch (getArguments().getInt("dialogType")) {
            default:
                return getMessage();
        }
    }


    @Override
    public String getNotificationTitle() {
        switch (getArguments().getInt("dialogType")) {
            default:
                return res().getString(R.string.answering_error_title);
        }
    }


    @Override
    public Message getDialogHandlerMessage() {
        Message msg = Message.obtain();
        msg.what = DialogHandler.MSG_SHOW_DATABASE_ERROR_DIALOG;
        Bundle b = new Bundle();
        b.putInt("dialogType", getArguments().getInt("dialogType"));
        msg.setData(b);
        return msg;
    }
    
    
    public void dismissAllDialogFragments() {
        ((DeckPicker) getActivity()).dismissAllDialogFragments();
    }
}
package com.ichi2.anki.dialogs;

import android.content.DialogInterface;
import android.content.DialogInterface.OnCancelListener;
import android.content.res.Resources;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.BackupManager;
import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.DeckPicker;
import com.ichi2.anki.R;

public class DeckPickerBackupNoSpaceLeftDialog extends DialogFragment {
    public static DeckPickerBackupNoSpaceLeftDialog newInstance() {
        DeckPickerBackupNoSpaceLeftDialog f = new DeckPickerBackupNoSpaceLeftDialog();
        return f;        
    }
    
    @Override
    public MaterialDialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Resources res = getResources();
        long space = BackupManager.getFreeDiscSpace(CollectionHelper.getCollectionPath(getActivity()));
        return new MaterialDialog.Builder(getActivity())
                .title(res.getString(R.string.sd_card_almost_full_title))
                .content(res.getString(R.string.sd_space_warning, space/1024/1024))
                .positiveText(res.getString(R.string.dialog_ok))
                .callback(new MaterialDialog.ButtonCallback() {
                    @Override
                    public void onPositive(MaterialDialog dialog) {
                        ((DeckPicker) getActivity()).finishWithoutAnimation();
                    }
                })
                .cancelable(true)
                .cancelListener(new OnCancelListener() {
                    @Override
                    public void onCancel(DialogInterface dialog) {
                        ((DeckPicker) getActivity()).finishWithoutAnimation();
                    }
                })
                .show();
    }
}
package com.ichi2.anki.dialogs;

import android.app.Dialog;
import android.content.res.Resources;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.DeckPicker;
import com.ichi2.anki.R;

public class DeckPickerConfirmDeleteDeckDialog extends DialogFragment {
    public static DeckPickerConfirmDeleteDeckDialog newInstance(String dialogMessage) {
        DeckPickerConfirmDeleteDeckDialog f = new DeckPickerConfirmDeleteDeckDialog();
        Bundle args = new Bundle();
        args.putString("dialogMessage", dialogMessage);
        f.setArguments(args);
        return f;
    }


    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Resources res = getResources();
        return new MaterialDialog.Builder(getActivity())
                .title(res.getString(R.string.delete_deck_title))
                .content(getArguments().getString("dialogMessage"))
                .iconAttr(R.attr.dialogErrorIcon)
                .positiveText(res.getString(R.string.dialog_positive_delete))
                .negativeText(res.getString(R.string.dialog_cancel))
                .cancelable(true)
                .callback(new MaterialDialog.ButtonCallback() {
                    @Override
                    public void onPositive(MaterialDialog dialog) {
                        ((DeckPicker) getActivity()).deleteContextMenuDeck();
                        ((DeckPicker) getActivity()).dismissAllDialogFragments();
                    }

                    @Override
                    public void onNegative(MaterialDialog dialog) {
                        ((DeckPicker) getActivity()).dismissAllDialogFragments();
                    }
                })
                .build();

    }
}
/****************************************************************************************
 * Copyright (c) 2015 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/
package com.ichi2.anki.dialogs;

import android.app.Dialog;
import android.content.res.Resources;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.view.View;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.AnkiActivity;
import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.DeckPicker;
import com.ichi2.anki.R;
import com.ichi2.anki.StudyOptionsFragment;
import com.ichi2.libanki.Collection;

import java.util.ArrayList;
import java.util.HashMap;

import timber.log.Timber;

public class DeckPickerContextMenu extends DialogFragment {
    /**
     * Context Menus
     */
    private static final int CONTEXT_MENU_RENAME_DECK = 0;
    private static final int CONTEXT_MENU_DECK_OPTIONS = 1;
    private static final int CONTEXT_MENU_CUSTOM_STUDY = 2;
    private static final int CONTEXT_MENU_DELETE_DECK = 3;
    private static final int CONTEXT_MENU_EXPORT_DECK = 4;
    private static final int CONTEXT_MENU_UNBURY = 5;
    private static final int CONTEXT_MENU_CUSTOM_STUDY_REBUILD = 6;
    private static final int CONTEXT_MENU_CUSTOM_STUDY_EMPTY = 7;


    public static DeckPickerContextMenu newInstance(long did) {
        DeckPickerContextMenu f = new DeckPickerContextMenu();
        Bundle args = new Bundle();
        args.putLong("did", did);
        f.setArguments(args);
        return f;
    }


    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        long did = getArguments().getLong("did");
        String title = CollectionHelper.getInstance().getCol(getContext()).getDecks().name(did);
        int[] itemIds = getListIds();
        return new MaterialDialog.Builder(getActivity())
                .title(title)
                .cancelable(true)
                .autoDismiss(false)
                .itemsIds(itemIds)
                .items(ContextMenuHelper.getValuesFromKeys(getKeyValueMap(), itemIds))
                .itemsCallback(mContextMenuListener)
                .build();
    }


    private HashMap<Integer, String> getKeyValueMap() {
        Resources res = getResources();
        HashMap<Integer, String> keyValueMap = new HashMap<>();
        keyValueMap.put(CONTEXT_MENU_RENAME_DECK, res.getString(R.string.rename_deck));
        keyValueMap.put(CONTEXT_MENU_DECK_OPTIONS, res.getString(R.string.study_options));
        keyValueMap.put(CONTEXT_MENU_CUSTOM_STUDY, res.getString(R.string.custom_study));
        keyValueMap.put(CONTEXT_MENU_DELETE_DECK, res.getString(R.string.contextmenu_deckpicker_delete_deck));
        keyValueMap.put(CONTEXT_MENU_EXPORT_DECK, res.getString(R.string.export_deck));
        keyValueMap.put(CONTEXT_MENU_UNBURY, res.getString(R.string.unbury));
        keyValueMap.put(CONTEXT_MENU_CUSTOM_STUDY_REBUILD, res.getString(R.string.rebuild_cram_label));
        keyValueMap.put(CONTEXT_MENU_CUSTOM_STUDY_EMPTY, res.getString(R.string.empty_cram_label));
        return keyValueMap;
    }

    /**
     * Retrieve the list of ids to put in the context menu list
     * @return the ids of which values to show
     */
    private int[] getListIds() {
        Collection col = CollectionHelper.getInstance().getCol(getContext());
        long did = getArguments().getLong("did");
        ArrayList<Integer> itemIds = new ArrayList<>();
        if (col.getDecks().isDyn(did)) {
            itemIds.add(CONTEXT_MENU_CUSTOM_STUDY_REBUILD);
            itemIds.add(CONTEXT_MENU_CUSTOM_STUDY_EMPTY);
        }
        itemIds.add(CONTEXT_MENU_RENAME_DECK);
        itemIds.add(CONTEXT_MENU_DECK_OPTIONS);
        if (!col.getDecks().isDyn(did)) {
            itemIds.add(CONTEXT_MENU_CUSTOM_STUDY);
        }
        itemIds.add(CONTEXT_MENU_DELETE_DECK);
        itemIds.add(CONTEXT_MENU_EXPORT_DECK);
        if (col.getSched().haveBuried(did)) {
            itemIds.add(CONTEXT_MENU_UNBURY);
        }
        return ContextMenuHelper.integerListToArray(itemIds);
    }

    // Handle item selection on context menu which is shown when the user long-clicks on a deck
    private MaterialDialog.ListCallback mContextMenuListener = new MaterialDialog.ListCallback() {
        @Override
        public void onSelection(MaterialDialog materialDialog, View view, int item,
                CharSequence charSequence) {
            switch (view.getId()) {
                case CONTEXT_MENU_DELETE_DECK:
                    Timber.i("Delete deck selected");
                    ((DeckPicker) getActivity()).confirmDeckDeletion();
                    break;

                case CONTEXT_MENU_DECK_OPTIONS:
                    Timber.i("Open deck options selected");
                    ((DeckPicker) getActivity()).showContextMenuDeckOptions();
                    ((AnkiActivity) getActivity()).dismissAllDialogFragments();
                    break;
                case CONTEXT_MENU_CUSTOM_STUDY: {
                    Timber.i("Custom study option selected");
                    long did = getArguments().getLong("did");
                    CustomStudyDialog d = CustomStudyDialog.newInstance(
                            CustomStudyDialog.CONTEXT_MENU_STANDARD, did);
                    ((AnkiActivity) getActivity()).showDialogFragment(d);
                    break;
                }
                case CONTEXT_MENU_RENAME_DECK:
                    Timber.i("Rename deck selected");
                    ((DeckPicker) getActivity()).renameDeckDialog();
                    break;

                case CONTEXT_MENU_EXPORT_DECK:
                    Timber.i("Export deck selected");
                    ((DeckPicker) getActivity()).showContextMenuExportDialog();
                    break;

                case CONTEXT_MENU_UNBURY: {
                    Timber.i("Unbury deck selected");
                    Collection col = CollectionHelper.getInstance().getCol(getContext());
                    col.getSched().unburyCardsForDeck(getArguments().getLong("did"));
                    ((StudyOptionsFragment.StudyOptionsListener) getActivity()).onRequireDeckListUpdate();
                    ((AnkiActivity) getActivity()).dismissAllDialogFragments();
                    break;
                }
                case CONTEXT_MENU_CUSTOM_STUDY_REBUILD: {
                    Timber.i("Empty deck selected");
                    ((DeckPicker) getActivity()).rebuildFiltered();
                    ((AnkiActivity) getActivity()).dismissAllDialogFragments();
                    break;
                }
                case CONTEXT_MENU_CUSTOM_STUDY_EMPTY: {
                    Timber.i("Empty deck selected");
                    ((DeckPicker) getActivity()).emptyFiltered();
                    ((AnkiActivity) getActivity()).dismissAllDialogFragments();
                    break;
                }
            }
        }
    };
}

package com.ichi2.anki.dialogs;

import android.os.Bundle;
import android.os.Message;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.DeckPicker;
import com.ichi2.anki.R;

import java.io.File;

public class DeckPickerExportCompleteDialog extends AsyncDialogFragment {
    
    public static DeckPickerExportCompleteDialog newInstance(String exportPath) {
        DeckPickerExportCompleteDialog f = new DeckPickerExportCompleteDialog();
        Bundle args = new Bundle();
        args.putString("exportPath", exportPath);
        f.setArguments(args);
        return f;
    }


    @Override
    public MaterialDialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        final String exportPath = getArguments().getString("exportPath");
        return new MaterialDialog.Builder(getActivity())
                .title(getNotificationTitle())
                .content(getNotificationMessage())
                .iconAttr(R.attr.dialogSendIcon)
                .positiveText(R.string.dialog_ok)
                .negativeText(R.string.dialog_cancel)
                .callback(new MaterialDialog.ButtonCallback() {
                    @Override
                    public void onPositive(MaterialDialog dialog) {
                        ((DeckPicker) getActivity()).dismissAllDialogFragments();
                        ((DeckPicker) getActivity()).emailFile(exportPath);
                    }

                    @Override
                    public void onNegative(MaterialDialog dialog) {
                        ((DeckPicker) getActivity()).dismissAllDialogFragments();
                    }
                })
                .show();
    }
    
    public String getNotificationTitle() {
        return res().getString(R.string.export_successful_title);
    }


    public String getNotificationMessage() {
        if (CollectionHelper.getCurrentAnkiDroidDirectory(getContext()).equals(CollectionHelper.getDefaultAnkiDroidDirectory())) {
            // Show a relative path if the collection is stored in the default location
            File exportFile = new File("AnkiDroid/export/", new File(getArguments().getString("exportPath")).getName());
            return res().getString(R.string.export_successful, exportFile.getPath());
        } else {
            // Show the absolute path if the user has messed with the AnkiDroid directory
            return res().getString(R.string.export_successful, getArguments().getString("exportPath"));
        }
    }


    @Override
    public Message getDialogHandlerMessage() {
        Message msg = Message.obtain();
        msg.what = DialogHandler.MSG_SHOW_EXPORT_COMPLETE_DIALOG;
        Bundle b = new Bundle();
        b.putString("exportPath", getArguments().getString("exportPath"));
        msg.setData(b);
        return msg;
    } 
}
package com.ichi2.anki.dialogs;

import android.content.DialogInterface;
import android.content.DialogInterface.OnCancelListener;
import android.content.res.Resources;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.DeckPicker;
import com.ichi2.anki.R;

public class DeckPickerNoSpaceLeftDialog extends DialogFragment {
    public static DeckPickerNoSpaceLeftDialog newInstance() {
        DeckPickerNoSpaceLeftDialog f = new DeckPickerNoSpaceLeftDialog();
        return f;
    }
    
    @Override
    public MaterialDialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Resources res = getResources();
        return new MaterialDialog.Builder(getActivity())
                .title(res.getString(R.string.sd_card_full_title))
                .content(res.getString(R.string.backup_deck_no_space_left))
                .cancelable(true)
                .positiveText(res.getString(R.string.dialog_ok))
                .callback(new MaterialDialog.ButtonCallback() {
                    @Override
                    public void onPositive(MaterialDialog dialog) {
                        ((DeckPicker) getActivity()).startLoadingCollection();
                    }
                })
                .cancelListener(new OnCancelListener() {
                    @Override
                    public void onCancel(DialogInterface dialog) {
                        ((DeckPicker) getActivity()).startLoadingCollection();
                    }
                })
                .show();
    }
}package com.ichi2.anki.dialogs;

import android.content.SharedPreferences;
import android.content.res.Resources;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;

import com.ichi2.anki.AnkiActivity;
import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.DeckPicker;
import com.ichi2.anki.R;
import com.ichi2.async.Connection;
import com.ichi2.libanki.Utils;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;

import timber.log.Timber;


/**
 * We're not allowed to commit fragment transactions from Loader.onLoadCompleted(),
 * and it's unsafe to commit them from an AsyncTask onComplete event, so we work 
 * around this by using a message handler.
 */
public class DialogHandler extends Handler {

    public static final long INTENT_SYNC_MIN_INTERVAL = 2*60000;    // 2min minimum sync interval

    /**
     * Handler messages
     */
    public static final int MSG_SHOW_COLLECTION_LOADING_ERROR_DIALOG = 0;
    public static final int MSG_SHOW_COLLECTION_IMPORT_REPLACE_DIALOG = 1;
    public static final int MSG_SHOW_COLLECTION_IMPORT_ADD_DIALOG = 2;
    public static final int MSG_SHOW_SYNC_ERROR_DIALOG = 3;
    public static final int MSG_SHOW_EXPORT_COMPLETE_DIALOG = 4;
    public static final int MSG_SHOW_MEDIA_CHECK_COMPLETE_DIALOG = 5;
    public static final int MSG_SHOW_DATABASE_ERROR_DIALOG = 6;
    public static final int MSG_SHOW_FORCE_FULL_SYNC_DIALOG = 7;
    public static final int MSG_DO_SYNC = 8;


    WeakReference<AnkiActivity> mActivity;
    private static Message sStoredMessage;
    
    public DialogHandler(AnkiActivity activity) {
        // Use weak reference to main activity to prevent leaking the activity when it's closed
        mActivity = new WeakReference<>(activity);
    }


    @Override
    public void handleMessage(Message msg) {
        Bundle msgData = msg.getData();
        if (msg.what == MSG_SHOW_COLLECTION_LOADING_ERROR_DIALOG) {
            // Collection could not be opened
            ((DeckPicker) mActivity.get()).showDatabaseErrorDialog(DatabaseErrorDialog.DIALOG_LOAD_FAILED);
        } else if (msg.what == MSG_SHOW_COLLECTION_IMPORT_REPLACE_DIALOG) {
            // Handle import of collection package APKG
            ((DeckPicker) mActivity.get()).showImportDialog(ImportDialog.DIALOG_IMPORT_REPLACE_CONFIRM, msgData.getString("importPath"));
        } else if (msg.what == MSG_SHOW_COLLECTION_IMPORT_ADD_DIALOG) {
            // Handle import of deck package APKG
            ((DeckPicker) mActivity.get()).showImportDialog(ImportDialog.DIALOG_IMPORT_ADD_CONFIRM, msgData.getString("importPath"));
        } else if (msg.what == MSG_SHOW_SYNC_ERROR_DIALOG) {
            int id = msgData.getInt("dialogType");
            String message = msgData.getString("dialogMessage");
            ((DeckPicker) mActivity.get()).showSyncErrorDialog(id, message);
        } else if (msg.what == MSG_SHOW_EXPORT_COMPLETE_DIALOG) {
            // Export complete
            AsyncDialogFragment f = DeckPickerExportCompleteDialog.newInstance(msgData.getString("exportPath"));
            mActivity.get().showAsyncDialogFragment(f);
        } else if (msg.what == MSG_SHOW_MEDIA_CHECK_COMPLETE_DIALOG) {            
            // Media check results
            int id = msgData.getInt("dialogType");
            if (id!=MediaCheckDialog.DIALOG_CONFIRM_MEDIA_CHECK) {
                List<List<String>> checkList = new ArrayList<>();
                checkList.add(msgData.getStringArrayList("nohave"));
                checkList.add(msgData.getStringArrayList("unused"));
                checkList.add(msgData.getStringArrayList("invalid"));
                ((DeckPicker) mActivity.get()).showMediaCheckDialog(id, checkList);
            }
        } else if (msg.what == MSG_SHOW_DATABASE_ERROR_DIALOG) {
            // Database error dialog
            ((DeckPicker) mActivity.get()).showDatabaseErrorDialog(msgData.getInt("dialogType"));
        } else if (msg.what == MSG_SHOW_FORCE_FULL_SYNC_DIALOG) {
            // Confirmation dialog for forcing full sync
            ConfirmationDialog dialog = new ConfirmationDialog ();
            Runnable confirm = new Runnable() {
                @Override
                public void run() {
                    // Bypass the check once the user confirms
                    CollectionHelper.getInstance().getCol(AnkiDroidApp.getInstance()).modSchemaNoCheck();
                }
            };
            dialog.setConfirm(confirm);
            dialog.setArgs(msgData.getString("message"));
            (mActivity.get()).showDialogFragment(dialog);
        } else if (msg.what == MSG_DO_SYNC) {
            SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(mActivity.get());
            Resources res = mActivity.get().getResources();
            String hkey = preferences.getString("hkey", "");
            boolean limited = Utils.intNow(1000) - preferences.getLong("lastSyncTime", 0) < INTENT_SYNC_MIN_INTERVAL;
            if (!limited && hkey.length() > 0 && Connection.isOnline()) {
                ((DeckPicker) mActivity.get()).sync();
            } else {
                String err = res.getString(R.string.sync_error);
                if (limited) {
                    mActivity.get().showSimpleNotification(err, res.getString(R.string.sync_too_busy));
                } else {
                    mActivity.get().showSimpleNotification(err, res.getString(R.string.youre_offline));
                }
            }
            mActivity.get().finishWithoutAnimation();
        }
    }

    /**
     * Store a persistent message to static variable
     * @param message Message to store
     */
    public static void storeMessage(Message message) {
        Timber.d("Storing persistent message");
        sStoredMessage = message;
    }

    /**
     * Read and handle Message which was stored via storeMessage()
     */
    public void readMessage() {
        Timber.d("Reading persistent message");
        if (sStoredMessage != null) {
            sendMessage(sStoredMessage);
        }
        sStoredMessage = null;
    }
}

package com.ichi2.anki.dialogs;

import android.content.res.Resources;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.v4.app.DialogFragment;

import com.afollestad.materialdialogs.DialogAction;
import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.R;

public class ExportDialog extends DialogFragment {

    public interface ExportDialogListener {

        void exportApkg(String path, Long did, boolean includeSched, boolean includeMedia);
        void dismissAllDialogFragments();
    }

    private final int INCLUDE_SCHED = 0;
    private final int INCLUDE_MEDIA = 1;
    private boolean mIncludeSched = false;
    private boolean mIncludeMedia = false;


    /**
     * A set of dialogs which deal with importing a file
     * 
     * @param did An integer which specifies which of the sub-dialogs to show
     * @param dialogMessage An optional string which can be used to show a custom message or specify import path
     */
    public static ExportDialog newInstance(@NonNull String dialogMessage, Long did) {
        ExportDialog f = new ExportDialog();
        Bundle args = new Bundle();
        args.putLong("did", did);
        args.putString("dialogMessage", dialogMessage);
        f.setArguments(args);
        return f;
    }


    public static ExportDialog newInstance(@NonNull String dialogMessage) {
        ExportDialog f = new ExportDialog();
        Bundle args = new Bundle();
        args.putString("dialogMessage", dialogMessage);
        f.setArguments(args);
        return f;
    }


    @Override
    public MaterialDialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Resources res = getResources();
        final Long did = getArguments().getLong("did", -1L);
        Integer[] checked;
        if (did != -1L) {
            mIncludeSched = false;
            checked = new Integer[]{};
        } else {
            mIncludeSched = true;
            checked = new Integer[]{ INCLUDE_SCHED };
        }
        final String[] items = { res.getString(R.string.export_include_schedule),
                res.getString(R.string.export_include_media) };

        MaterialDialog.Builder builder = new MaterialDialog.Builder(getActivity())
                .title(R.string.export)
                .content(getArguments().getString("dialogMessage"))
                .positiveText(android.R.string.ok)
                .negativeText(android.R.string.cancel)
                .cancelable(true)
                .items(items)
                .alwaysCallMultiChoiceCallback()
                .itemsCallbackMultiChoice(checked,
                        new MaterialDialog.ListCallbackMultiChoice() {
                            @Override
                            public boolean onSelection(MaterialDialog materialDialog,
                                                       Integer[] integers, CharSequence[] charSequences) {
                                mIncludeMedia = false;
                                mIncludeSched = false;
                                for (Integer integer : integers) {
                                    switch (integer) {
                                        case INCLUDE_SCHED:
                                            mIncludeSched = true;
                                            break;
                                        case INCLUDE_MEDIA:
                                            mIncludeMedia = true;
                                            break;
                                    }
                                }
                                return true;
                            }
                        })
                .onPositive(new MaterialDialog.SingleButtonCallback() {
                    @Override
                    public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
                        ((ExportDialogListener) getActivity())
                                .exportApkg(null, did != -1L ? did : null, mIncludeSched, mIncludeMedia);
                        dismissAllDialogFragments();
                    }
                })
                .onNegative(new MaterialDialog.SingleButtonCallback() {
                    @Override
                    public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
                        dismissAllDialogFragments();
                    }
                });
        return builder.show();
    }


    public void dismissAllDialogFragments() {
        ((ExportDialogListener) getActivity()).dismissAllDialogFragments();
    }

}

package com.ichi2.anki.dialogs;

import android.content.DialogInterface;
import android.content.res.Resources;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.view.View;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.R;
import com.ichi2.anki.UIUtils;
import com.ichi2.libanki.Utils;
import com.ichi2.themes.Themes;

import java.io.File;
import java.util.List;

public class ImportDialog extends DialogFragment {
    private int mType = 0;
    
    public static final int DIALOG_IMPORT_HINT = 0;
    public static final int DIALOG_IMPORT_SELECT = 1;
    public static final int DIALOG_IMPORT_ADD_CONFIRM = 2;
    public static final int DIALOG_IMPORT_REPLACE_CONFIRM = 3;

    public interface ImportDialogListener {
        public void showImportDialog(int id, String message);
        
        public void showImportDialog(int id);

        public void importAdd(String importPath);

        public void importReplace(String importPath);
        
        public void dismissAllDialogFragments();
    }


    /**
     * A set of dialogs which deal with importing a file
     * 
     * @param dialogType An integer which specifies which of the sub-dialogs to show
     * @param dialogMessage An optional string which can be used to show a custom message
     * or specify import path
     */
    public static ImportDialog newInstance(int dialogType, String dialogMessage) {
        ImportDialog f = new ImportDialog();
        Bundle args = new Bundle();
        args.putInt("dialogType", dialogType);
        args.putString("dialogMessage", dialogMessage);
        f.setArguments(args);
        return f;
    }


    @Override
    public MaterialDialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mType = getArguments().getInt("dialogType");
        Resources res = getResources();
        MaterialDialog.Builder builder = new MaterialDialog.Builder(getActivity());
        builder.cancelable(true);

        switch (mType) {
            case DIALOG_IMPORT_HINT:
                // Instruct the user that they need to put their APKG files into the AnkiDroid directory
                return builder.title(res.getString(R.string.import_title))
                        .content(res.getString(R.string.import_hint, CollectionHelper.getCurrentAnkiDroidDirectory(getActivity())))
                        .positiveText(res.getString(R.string.dialog_ok))
                        .negativeText(res.getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((ImportDialogListener) getActivity()).showImportDialog(DIALOG_IMPORT_SELECT);
                            }

                            @Override
                            public void onNegative(MaterialDialog dialog) {
                                dismissAllDialogFragments();
                            }
                        })
                        .show();

            case DIALOG_IMPORT_SELECT:
                // Allow user to choose from the list of available APKG files
                List<File> fileList = Utils.getImportableDecks(getActivity());
                if (fileList.size() == 0) {
                    UIUtils.showThemedToast(getActivity(),
                            getResources().getString(R.string.upgrade_import_no_file_found, "'.apkg'"), false);
                    return builder.showListener(new DialogInterface.OnShowListener() {
                        @Override
                        public void onShow(DialogInterface dialog) {
                            dialog.cancel();
                        }
                    }).show();
                }
                else {
                    String[] tts = new String[fileList.size()];
                    final String[] importValues = new String[fileList.size()];
                    for (int i = 0; i < tts.length; i++) {
                        tts[i] = fileList.get(i).getName().replace(".apkg", "");
                        importValues[i] = fileList.get(i).getAbsolutePath();
                    }
                    return builder.title(res.getString(R.string.import_select_title))
                            .items(tts)
                            .itemsCallback(new MaterialDialog.ListCallback() {
                                @Override
                                public void onSelection(MaterialDialog materialDialog, View view,
                                        int i,
                                        CharSequence charSequence) {
                                    String importPath = importValues[i];
                                    // If the apkg file is called "collection.apkg", we assume the collection will be replaced
                                    if (filenameFromPath(importPath).equals("collection.apkg")) {
                                        ((ImportDialogListener) getActivity()).showImportDialog(DIALOG_IMPORT_REPLACE_CONFIRM, importPath);
                                        // Otherwise we add the file since exported decks / shared decks can't be imported via replace anyway
                                    } else {
                                        ((ImportDialogListener) getActivity()).showImportDialog(DIALOG_IMPORT_ADD_CONFIRM, importPath);
                                    }
                                }
                            })
                            .show();
                }
                
            case DIALOG_IMPORT_ADD_CONFIRM:
                return builder.title(res.getString(R.string.import_title))
                        .content(res.getString(R.string.import_message_add_confirm, filenameFromPath(getArguments().getString("dialogMessage"))))
                        .positiveText(res.getString(R.string.import_message_add))
                        .negativeText(res.getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((ImportDialogListener) getActivity()).importAdd(getArguments().getString("dialogMessage"));
                                dismissAllDialogFragments();
                            }
                        })
                        .show();

            case DIALOG_IMPORT_REPLACE_CONFIRM:
                return builder.title(res.getString(R.string.import_title))
                        .content(res.getString(R.string.import_message_replace_confirm, getArguments().getString("dialogMessage")))
                        .positiveText(res.getString(R.string.dialog_positive_replace))
                        .negativeText(res.getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((ImportDialogListener) getActivity()).importReplace(getArguments().getString("dialogMessage"));
                                dismissAllDialogFragments();
                            }
                        })
                        .show();

            default:
                return null;
        }
    }
    
    public void dismissAllDialogFragments() {
        ((ImportDialogListener) getActivity()).dismissAllDialogFragments();        
    }

    private static String filenameFromPath (String path) {
        return path.split("/")[path.split("/").length - 1];
    }
}

package com.ichi2.anki.dialogs;

import android.os.Bundle;
import android.os.Message;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.R;

import java.util.ArrayList;
import java.util.List;

public class MediaCheckDialog extends AsyncDialogFragment {
    public static final int DIALOG_CONFIRM_MEDIA_CHECK = 0;
    public static final int DIALOG_MEDIA_CHECK_RESULTS = 1;

    public interface MediaCheckDialogListener {
        public void showMediaCheckDialog(int dialogType);


        public void showMediaCheckDialog(int dialogType, List<List<String>> checkList);


        public void mediaCheck();


        public void deleteUnused(List<String> unused);


        public void dismissAllDialogFragments();
    }


    public static MediaCheckDialog newInstance(int dialogType) {
        MediaCheckDialog f = new MediaCheckDialog();
        Bundle args = new Bundle();
        args.putInt("dialogType", dialogType);
        f.setArguments(args);
        return f;
    }


    public static MediaCheckDialog newInstance(int dialogType, List<List<String>> checkList) {
        MediaCheckDialog f = new MediaCheckDialog();
        Bundle args = new Bundle();
        args.putStringArrayList("nohave", new ArrayList<>(checkList.get(0)));
        args.putStringArrayList("unused", new ArrayList<>(checkList.get(1)));
        args.putStringArrayList("invalid", new ArrayList<>(checkList.get(2)));
        args.putInt("dialogType", dialogType);
        f.setArguments(args);
        return f;
    }


    @Override
    public MaterialDialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        MaterialDialog.Builder builder = new MaterialDialog.Builder(getActivity());
        builder.title(getNotificationTitle());

        switch (getArguments().getInt("dialogType")) {
            case DIALOG_CONFIRM_MEDIA_CHECK:
                return builder.content(getNotificationMessage())
                        .positiveText(res().getString(R.string.dialog_ok))
                        .negativeText(res().getString(R.string.dialog_cancel))
                        .cancelable(true)
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((MediaCheckDialogListener) getActivity()).mediaCheck();
                                ((MediaCheckDialogListener) getActivity())
                                        .dismissAllDialogFragments();
                            }

                            @Override
                            public void onNegative(MaterialDialog dialog) {
                                ((MediaCheckDialogListener) getActivity())
                                        .dismissAllDialogFragments();
                            }
                        })
                        .show();
            case DIALOG_MEDIA_CHECK_RESULTS:
                final ArrayList<String> nohave = getArguments().getStringArrayList("nohave");
                final ArrayList<String> unused = getArguments().getStringArrayList("unused");
                final ArrayList<String> invalid = getArguments().getStringArrayList("invalid");
                // Generate report
                String report = "";
                if (invalid.size() > 0) {
                    report += String.format(res().getString(R.string.check_media_invalid), invalid.size());
                }
                if (unused.size() > 0) {
                    if (report.length() > 0) {
                        report += "\n";
                    }
                    report += String.format(res().getString(R.string.check_media_unused), unused.size());
                }
                if (nohave.size() > 0) {
                    if (report.length() > 0) {
                        report += "\n";
                    }
                    report += String.format(res().getString(R.string.check_media_nohave), nohave.size());
                }

                if (report.length() == 0) {
                    report = res().getString(R.string.check_media_no_unused_missing);
                }

                // We also prefix the report with a message about the media db being rebuilt, since
                // we do a full media scan and update the db on each media check on AnkiDroid.
                report = res().getString(R.string.check_media_db_updated) + "\n\n" + report;
                builder.content(report)
                        .cancelable(true);

                // If we have unused files, show a dialog with a "delete" button. Otherwise, the user only
                // needs to acknowledge the results, so show only an OK dialog.
                if (unused.size() > 0) {
                    builder.positiveText(res().getString(R.string.dialog_ok))
                            .negativeText(res().getString(R.string.check_media_delete_unused))
                            .callback(new MaterialDialog.ButtonCallback() {
                                @Override
                                public void onPositive(MaterialDialog dialog) {
                                    ((MediaCheckDialogListener) getActivity())
                                            .dismissAllDialogFragments();
                                }

                                @Override
                                public void onNegative(MaterialDialog dialog) {
                                    ((MediaCheckDialogListener) getActivity()).deleteUnused(unused);
                                    dismissAllDialogFragments();
                                }
                            });
                } else {
                    builder.positiveText(res().getString(R.string.dialog_ok))
                            .callback(new MaterialDialog.ButtonCallback() {
                                @Override
                                public void onPositive(MaterialDialog dialog) {
                                    ((MediaCheckDialogListener) getActivity()).dismissAllDialogFragments();
                                }
                            });
                }
                return builder.show();
            default:
                return null;
        }
    }


    public void dismissAllDialogFragments() {
        ((MediaCheckDialogListener) getActivity()).dismissAllDialogFragments();
    }


    @Override
    public String getNotificationMessage() {
        switch (getArguments().getInt("dialogType")) {
            case DIALOG_CONFIRM_MEDIA_CHECK:
                return res().getString(R.string.check_media_warning);
            default:
                return res().getString(R.string.app_name);
        }
    }


    @Override
    public String getNotificationTitle() {
        switch (getArguments().getInt("dialogType")) {
            case DIALOG_CONFIRM_MEDIA_CHECK:
                return res().getString(R.string.check_media_title);
            case DIALOG_MEDIA_CHECK_RESULTS:
                return res().getString(R.string.check_media_acknowledge);
            default:
                return res().getString(R.string.app_name);
        }
    }


    @Override
    public Message getDialogHandlerMessage() {
        Message msg = Message.obtain();
        msg.what = DialogHandler.MSG_SHOW_MEDIA_CHECK_COMPLETE_DIALOG;
        Bundle b = new Bundle();
        b.putStringArrayList("nohave", getArguments().getStringArrayList("nohave"));
        b.putStringArrayList("unused", getArguments().getStringArrayList("unused"));
        b.putStringArrayList("invalid", getArguments().getStringArrayList("invalid"));
        b.putInt("dialogType", getArguments().getInt("dialogType"));
        msg.setData(b);
        return msg;
    }
}
package com.ichi2.anki.dialogs;

import android.app.Dialog;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.R;

public class ModelBrowserContextMenu extends DialogFragment {

    public final static int MODEL_TEMPLATE = 0;
    public final static int MODEL_RENAME = 1;
    public final static int MODEL_DELETE = 2;

    private static MaterialDialog.ListCallback mContextMenuListener;

    public static ModelBrowserContextMenu newInstance(String label, MaterialDialog.ListCallback contextMenuListener) {
        mContextMenuListener = contextMenuListener;
        ModelBrowserContextMenu n = new ModelBrowserContextMenu();
        Bundle b = new Bundle();
        b.putString("label", label);
        n.setArguments(b);
        return n;
    }

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        String[] entries = new String[3];
        entries[MODEL_TEMPLATE] = getResources().getString(R.string.model_browser_template);
        entries[MODEL_RENAME] = getResources().getString(R.string.model_browser_rename);
        entries[MODEL_DELETE] = getResources().getString(R.string.model_browser_delete);

        return new MaterialDialog.Builder(getActivity())
                .title(getArguments().getString("label"))
                .items(entries)
                .itemsCallback(mContextMenuListener)
                .build();
    }
}
package com.ichi2.anki.dialogs;

import android.app.Dialog;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.R;

public class ModelEditorContextMenu extends DialogFragment {

    public final static int FIELD_REPOSITION = 0;
    public final static int SORT_FIELD = 1;
    public final static int FIELD_RENAME = 2;
    public final static int FIELD_DELETE = 3;


    private static MaterialDialog.ListCallback mContextMenuListener;

    public static ModelEditorContextMenu newInstance(String label, MaterialDialog.ListCallback contextMenuListener) {
        ModelEditorContextMenu n = new ModelEditorContextMenu();
        mContextMenuListener = contextMenuListener;
        Bundle b = new Bundle();
        b.putString("label", label);
        mContextMenuListener = contextMenuListener;
        n.setArguments(b);
        return n;
    }

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        String[] entries = new String[4];
        entries[FIELD_REPOSITION] = getResources().getString(R.string.model_field_editor_reposition_menu);
        entries[SORT_FIELD] = getResources().getString(R.string.model_field_editor_sort_field);
        entries[FIELD_RENAME] = getResources().getString(R.string.model_field_editor_rename);
        entries[FIELD_DELETE] = getResources().getString(R.string.model_field_editor_delete);

        return new MaterialDialog.Builder(getActivity())
                .title(getArguments().getString("label"))
                .items(entries)
                .itemsCallback(mContextMenuListener)
                .build();
    }
}

package com.ichi2.anki.dialogs;

import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.text.InputType;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.NoteEditor;
import com.ichi2.anki.R;

public class NoteEditorRescheduleCard extends DialogFragment {
    public static NoteEditorRescheduleCard newInstance() {
        return new NoteEditorRescheduleCard();
    }


    @Override
    public MaterialDialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        return new MaterialDialog.Builder(getActivity())
                .title(R.string.reschedule_card_dialog_title)
                .positiveText(getResources().getString(R.string.dialog_ok))
                .negativeText(R.string.cancel)
                .inputType(InputType.TYPE_CLASS_NUMBER)
                .inputRange(1, 4) // max 4 characters (i.e., 9999)
                .input(R.string.reschedule_card_dialog_message, R.string.empty_string, new MaterialDialog.InputCallback() {
                    @Override
                    public void onInput(MaterialDialog dialog, CharSequence text) {
                        int days = Integer.parseInt(text.toString());
                        ((NoteEditor) getActivity()).onRescheduleCard(days);
                    }
                })
                .show();
    }
    }

package com.ichi2.anki.dialogs;

import android.os.Bundle;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.R;

public class SimpleMessageDialog extends AsyncDialogFragment {

    public interface SimpleMessageDialogListener {
        public void dismissSimpleMessageDialog(boolean reload);
    }


    public static SimpleMessageDialog newInstance(String message, boolean reload) {
        return newInstance("" , message, reload);
    }


    public static SimpleMessageDialog newInstance(String title, String message, boolean reload) {
        SimpleMessageDialog f = new SimpleMessageDialog();
        Bundle args = new Bundle();
        args.putString("title", title);
        args.putString("message", message);
        args.putBoolean("reload", reload);
        f.setArguments(args);
        return f;
    }


    @Override
    public MaterialDialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        return new MaterialDialog.Builder(getActivity())
                .title(getNotificationTitle())
                .content(getNotificationMessage())
                .positiveText(res().getString(R.string.dialog_ok))
                .callback(new MaterialDialog.ButtonCallback() {
                    @Override
                    public void onPositive(MaterialDialog dialog) {
                        ((SimpleMessageDialogListener) getActivity())
                                .dismissSimpleMessageDialog(getArguments().getBoolean(
                                        "reload"));
                    }
                })
                .show();
    }


    public String getNotificationTitle() {
        String title = getArguments().getString("title");
        if (!title.equals("")) {
            return title;
        } else {
            return AnkiDroidApp.getAppResources().getString(R.string.app_name);
        }
    }


    public String getNotificationMessage() {
        return getArguments().getString("message");
    }
}

package com.ichi2.anki.dialogs;

import android.os.Bundle;
import android.os.Message;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.R;
import com.ichi2.libanki.Collection;

public class SyncErrorDialog extends AsyncDialogFragment {
    public static final int DIALOG_USER_NOT_LOGGED_IN_SYNC = 0;
    public static final int DIALOG_CONNECTION_ERROR = 1;
    public static final int DIALOG_SYNC_CONFLICT_RESOLUTION = 2;
    public static final int DIALOG_SYNC_CONFLICT_CONFIRM_KEEP_LOCAL = 3;
    public static final int DIALOG_SYNC_CONFLICT_CONFIRM_KEEP_REMOTE = 4;
    public static final int DIALOG_SYNC_SANITY_ERROR = 6;
    public static final int DIALOG_SYNC_SANITY_ERROR_CONFIRM_KEEP_LOCAL = 7;
    public static final int DIALOG_SYNC_SANITY_ERROR_CONFIRM_KEEP_REMOTE = 8;
    public static final int DIALOG_MEDIA_SYNC_ERROR = 9;

    public interface SyncErrorDialogListener {
        public void showSyncErrorDialog(int dialogType);


        public void showSyncErrorDialog(int dialogType, String message);


        public void loginToSyncServer();


        public void sync();


        public void sync(String conflict);


        public Collection getCol();


        public void mediaCheck();


        public void dismissAllDialogFragments();
    }


    /**
     * A set of dialogs belonging to AnkiActivity which deal with sync problems
     * 
     * @param dialogType An integer which specifies which of the sub-dialogs to show
     * @param dialogMessage A string which can be optionally used to set the dialog message
     */
    public static SyncErrorDialog newInstance(int dialogType, String dialogMessage) {
        SyncErrorDialog f = new SyncErrorDialog();
        Bundle args = new Bundle();
        args.putInt("dialogType", dialogType);
        args.putString("dialogMessage", dialogMessage);
        f.setArguments(args);
        return f;
    }


    @Override
    public MaterialDialog onCreateDialog(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        MaterialDialog.Builder builder = new MaterialDialog.Builder(getActivity())
                .title(getTitle())
                .content(getMessage())
                .cancelable(true);

        switch (getArguments().getInt("dialogType")) {
            case DIALOG_USER_NOT_LOGGED_IN_SYNC:
                // User not logged in; take them to login screen
                return builder.iconAttr(R.attr.dialogSyncErrorIcon)
                        .positiveText(res().getString(R.string.log_in))
                        .negativeText(res().getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((SyncErrorDialogListener) getActivity()).loginToSyncServer();
                            }
                        })
                        .show();

            case DIALOG_CONNECTION_ERROR:
                // Connection error; allow user to retry or cancel
                return builder.iconAttr(R.attr.dialogSyncErrorIcon)
                        .positiveText(res().getString(R.string.retry))
                        .negativeText(res().getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((SyncErrorDialogListener) getActivity()).sync();
                                dismissAllDialogFragments();
                            }

                            @Override
                            public void onNegative(MaterialDialog dialog) {
                                dismissAllDialogFragments();
                            }
                        })
                        .show();

            case DIALOG_SYNC_CONFLICT_RESOLUTION:
                // Sync conflict; allow user to cancel, or choose between local and remote versions
                return builder.iconAttr(R.attr.dialogSyncErrorIcon)
                        .positiveText(res().getString(R.string.sync_conflict_local))
                        .negativeText(res().getString(R.string.sync_conflict_remote))
                        .neutralText(res().getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((SyncErrorDialogListener) getActivity())
                                        .showSyncErrorDialog(DIALOG_SYNC_CONFLICT_CONFIRM_KEEP_LOCAL);
                            }

                            @Override
                            public void onNegative(MaterialDialog dialog) {
                                ((SyncErrorDialogListener) getActivity())
                                        .showSyncErrorDialog(DIALOG_SYNC_CONFLICT_CONFIRM_KEEP_REMOTE);
                            }

                            @Override
                            public void onNeutral(MaterialDialog dialog) {
                                dismissAllDialogFragments();
                            }
                        })
                        .show();

            case DIALOG_SYNC_CONFLICT_CONFIRM_KEEP_LOCAL:
                // Confirmation before pushing local collection to server after sync conflict
                return builder.positiveText(res().getString(R.string.dialog_positive_overwrite))
                        .negativeText(res().getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                SyncErrorDialogListener activity = (SyncErrorDialogListener) getActivity();
                                activity.sync("upload");
                                dismissAllDialogFragments();
                            }
                        })
                        .show();

            case DIALOG_SYNC_CONFLICT_CONFIRM_KEEP_REMOTE:
                // Confirmation before overwriting local collection with server collection after sync conflict
                return builder.positiveText(res().getString(R.string.dialog_positive_overwrite))
                        .negativeText(res().getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                SyncErrorDialogListener activity = (SyncErrorDialogListener) getActivity();
                                activity.sync("download");
                                dismissAllDialogFragments();
                            }
                        })
                        .show();

            case DIALOG_SYNC_SANITY_ERROR:
                // Sync sanity check error; allow user to cancel, or choose between local and remote versions
                return builder.positiveText(res().getString(R.string.sync_sanity_local))
                        .neutralText(res().getString(R.string.sync_sanity_remote))
                        .negativeText(res().getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((SyncErrorDialogListener) getActivity())
                                        .showSyncErrorDialog(DIALOG_SYNC_SANITY_ERROR_CONFIRM_KEEP_LOCAL);
                            }

                            @Override
                            public void onNeutral(MaterialDialog dialog) {
                                ((SyncErrorDialogListener) getActivity())
                                        .showSyncErrorDialog(DIALOG_SYNC_SANITY_ERROR_CONFIRM_KEEP_REMOTE);
                            }
                        })
                        .show();

            case DIALOG_SYNC_SANITY_ERROR_CONFIRM_KEEP_LOCAL:
                // Confirmation before pushing local collection to server after sanity check error
                return builder.positiveText(res().getString(R.string.dialog_positive_overwrite))
                        .negativeText(res().getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((SyncErrorDialogListener) getActivity()).sync("upload");
                                dismissAllDialogFragments();
                            }
                        })
                        .show();

            case DIALOG_SYNC_SANITY_ERROR_CONFIRM_KEEP_REMOTE:
                // Confirmation before overwriting local collection with server collection after sanity check error
                return builder.positiveText(res().getString(R.string.dialog_positive_overwrite))
                        .negativeText(res().getString(R.string.dialog_cancel))
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((SyncErrorDialogListener) getActivity()).sync("download");
                                dismissAllDialogFragments();
                            }
                        })
                        .show();
            case DIALOG_MEDIA_SYNC_ERROR:
                return builder.positiveText(R.string.check_media)
                        .negativeText(R.string.cancel)
                        .callback(new MaterialDialog.ButtonCallback() {
                            @Override
                            public void onPositive(MaterialDialog dialog) {
                                ((SyncErrorDialogListener) getActivity()).mediaCheck();
                                dismissAllDialogFragments();
                            }
                        })
                        .show();
            default:
                return null;
        }
    }


    private String getTitle() {
        switch (getArguments().getInt("dialogType")) {
            case DIALOG_USER_NOT_LOGGED_IN_SYNC:
                return res().getString(R.string.not_logged_in_title);
            case DIALOG_SYNC_CONFLICT_CONFIRM_KEEP_LOCAL:
            case DIALOG_SYNC_CONFLICT_CONFIRM_KEEP_REMOTE:
            case DIALOG_SYNC_CONFLICT_RESOLUTION:
                return res().getString(R.string.sync_conflict_title);
            default:
                return res().getString(R.string.sync_error);
        }
    }


    /**
     * Get the title which is shown in notification bar when dialog fragment can't be shown
     * 
     * @return tile to be shown in notification in bar
     */
    @Override
    public String getNotificationTitle() {
        switch (getArguments().getInt("dialogType")) {
            case DIALOG_USER_NOT_LOGGED_IN_SYNC:
                return res().getString(R.string.sync_error);
            default:
                return getTitle();
        }
    }


    private String getMessage() {
        switch (getArguments().getInt("dialogType")) {
            case DIALOG_USER_NOT_LOGGED_IN_SYNC:
                return res().getString(R.string.login_create_account_message);
            case DIALOG_CONNECTION_ERROR:
                return res().getString(R.string.connection_error_message);
            case DIALOG_SYNC_CONFLICT_RESOLUTION:
                return res().getString(R.string.sync_conflict_message);
            case DIALOG_SYNC_CONFLICT_CONFIRM_KEEP_LOCAL:
                return res().getString(R.string.sync_conflict_local_confirm);
            case DIALOG_SYNC_CONFLICT_CONFIRM_KEEP_REMOTE:
                return res().getString(R.string.sync_conflict_remote_confirm);
            case DIALOG_SYNC_SANITY_ERROR_CONFIRM_KEEP_LOCAL:
                return res().getString(R.string.sync_conflict_local_confirm);
            case DIALOG_SYNC_SANITY_ERROR_CONFIRM_KEEP_REMOTE:
                return res().getString(R.string.sync_conflict_remote_confirm);
            default:
                return getArguments().getString("dialogMessage");
        }
    }


    /**
     * Get the message which is shown in notification bar when dialog fragment can't be shown
     * 
     * @return message to be shown in notification in bar
     */
    @Override
    public String getNotificationMessage() {
        switch (getArguments().getInt("dialogType")) {
            case DIALOG_USER_NOT_LOGGED_IN_SYNC:
                return res().getString(R.string.not_logged_in_title);
            default:
                return getMessage();
        }
    }

    @Override
    public Message getDialogHandlerMessage() {
        Message msg = Message.obtain();
        msg.what = DialogHandler.MSG_SHOW_SYNC_ERROR_DIALOG;
        Bundle b = new Bundle();
        b.putInt("dialogType", getArguments().getInt("dialogType"));
        b.putString("dialogMessage", getArguments().getString("dialogMessage"));
        msg.setData(b);
        return msg;
    }

    public void dismissAllDialogFragments() {
        ((SyncErrorDialogListener) getActivity()).dismissAllDialogFragments();
    }
}
package com.ichi2.anki.dialogs;

import android.app.Dialog;
import android.content.res.Resources;
import android.os.Bundle;
import android.support.design.widget.Snackbar;
import android.support.v4.app.DialogFragment;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.support.v7.widget.SearchView;
import android.support.v7.widget.Toolbar;
import android.text.InputFilter;
import android.text.InputType;
import android.text.Spanned;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.CheckedTextView;
import android.widget.EditText;
import android.widget.Filter;
import android.widget.Filterable;
import android.widget.RadioGroup;
import android.widget.TextView;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.R;
import com.ichi2.anki.UIUtils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.TreeSet;

public class TagsDialog extends DialogFragment {
    public interface TagsDialogListener {
        void onPositive(List<String> selectedTags, int option);
    }

    public static final int TYPE_NONE = -1;
    public static final int TYPE_ADD_TAG = 0;
    public static final int TYPE_FILTER_BY_TAG = 1;
    public static final int TYPE_CUSTOM_STUDY_TAGS = 2;

    private static final String DIALOG_TYPE_KEY = "dialog_type";
    private static final String CHECKED_TAGS_KEY = "checked_tags";
    private static final String ALL_TAGS_KEY = "all_tags";

    private int mType = TYPE_NONE;
    private TreeSet<String> mCurrentTags;
    private ArrayList<String> mAllTags;

    private String mPositiveText;
    private String mDialogTitle;
    private TagsDialogListener mTagsDialogListener = null;
    private TagsArrayAdapter mTagsArrayAdapter;
    private int mSelectedOption = -1;

    private Toolbar mToolbar;
    private SearchView mToolbarSearchView;
    private MenuItem mToolbarSearchItem;
    private MenuItem mToolbarAddItem;

    private TextView mNoTagsTextView;
    private RecyclerView mTagsListRecyclerView;
    private RadioGroup mOptionsGroup;

    private MaterialDialog mDialog;

    public static TagsDialog newInstance(int type, ArrayList<String> checked_tags,
                                            ArrayList<String> all_tags) {
        TagsDialog t = new TagsDialog();

        Bundle args = new Bundle();
        args.putInt(DIALOG_TYPE_KEY, type);
        args.putStringArrayList(CHECKED_TAGS_KEY, checked_tags);
        args.putStringArrayList(ALL_TAGS_KEY, all_tags);
        t.setArguments(args);

        return t;
    }


    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        getActivity().getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);

        mType = getArguments().getInt(DIALOG_TYPE_KEY);

        mCurrentTags = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
        mCurrentTags.addAll(getArguments().getStringArrayList(CHECKED_TAGS_KEY));

        mAllTags = new ArrayList<>();
        mAllTags.addAll(getArguments().getStringArrayList(ALL_TAGS_KEY));

        for (String tag : mCurrentTags) {
            if (!mAllTags.contains(tag)) {
                mAllTags.add(tag);
            }
        }

        setCancelable(true);
    }


    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        Resources res = getResources();

        View tagsDialogView = LayoutInflater.from(getActivity())
                .inflate(R.layout.tags_dialog, null, false);
        mTagsListRecyclerView = (RecyclerView) tagsDialogView.findViewById(R.id.tags_dialog_tags_list);
        mTagsListRecyclerView.requestFocus();
        mTagsListRecyclerView.setHasFixedSize(true);

        RecyclerView.LayoutManager tagsListLayout = new LinearLayoutManager(getActivity());
        mTagsListRecyclerView.setLayoutManager(tagsListLayout);

        mTagsArrayAdapter = new TagsArrayAdapter();
        mTagsListRecyclerView.setAdapter(mTagsArrayAdapter);

        mNoTagsTextView = (TextView) tagsDialogView.findViewById(R.id.tags_dialog_no_tags_textview);
        if (mAllTags.isEmpty()) {
            mNoTagsTextView.setVisibility(View.VISIBLE);
        }
        mOptionsGroup = (RadioGroup) tagsDialogView.findViewById(R.id.tags_dialog_options_radiogroup);
        for (int i = 0; i < mOptionsGroup.getChildCount(); i++) {
            mOptionsGroup.getChildAt(i).setId(i);
        }
        mOptionsGroup.check(0);

        mSelectedOption = mOptionsGroup.getCheckedRadioButtonId();
        mOptionsGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {
            @Override
            public void onCheckedChanged(RadioGroup radioGroup, int checkedId) {
                mSelectedOption = checkedId;
            }
        });

        switch (mType) {
            case TYPE_ADD_TAG:
                mDialogTitle = getResources().getString(R.string.card_details_tags);
                mOptionsGroup.setVisibility(View.GONE);
                mPositiveText = getString(R.string.dialog_ok);
                break;
            default:
                mDialogTitle = getResources().getString(R.string.studyoptions_limit_select_tags);
                mPositiveText = getString(R.string.select);
        }

        adjustToolbar(tagsDialogView);

        MaterialDialog.Builder builder = new MaterialDialog.Builder(getActivity())
                .positiveText(mPositiveText)
                .negativeText(res.getString(R.string.dialog_cancel))
                .customView(tagsDialogView, false)
                .callback(new MaterialDialog.ButtonCallback() {
                    @Override
                    public void onPositive(MaterialDialog dialog) {
                        mTagsDialogListener
                                .onPositive(new ArrayList<>(mCurrentTags), mSelectedOption);
                    }
                });
        mDialog = builder.build();

        mDialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
        return mDialog;
    }

    private void adjustToolbar(View tagsDialogView) {
        mToolbar = (Toolbar) tagsDialogView.findViewById(R.id.tags_dialog_toolbar);
        mToolbar.setTitle(mDialogTitle);

        mToolbar.inflateMenu(R.menu.tags_dialog_menu);

        final InputFilter addTagFilter = new InputFilter() {
            @Override
            public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart,
                                       int dend) {
                for (int i = start; i < end; i++) {
                    if (source.charAt(i) == ' ') {
                        return "";
                    }
                }
                return null;
            }
        };
        mToolbarAddItem = mToolbar.getMenu().findItem(R.id.tags_dialog_action_add);
        mToolbarAddItem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
            @Override
            public boolean onMenuItemClick(MenuItem menuItem) {
                String query = mToolbarSearchView.getQuery().toString();
                if (MenuItemCompat.isActionViewExpanded(mToolbarSearchItem) && !TextUtils.isEmpty(query)) {
                    addTag(query);
                    mToolbarSearchView.setQuery("", true);
                } else {
                    MaterialDialog.Builder addTagBuilder = new MaterialDialog.Builder(getActivity())
                            .title(getString(R.string.add_tag))
                            .negativeText(R.string.dialog_cancel)
                            .positiveText(R.string.dialog_ok)
                            .inputType(InputType.TYPE_CLASS_TEXT)
                            .input(R.string.tag_name, R.string.empty_string, new MaterialDialog.InputCallback() {
                                @Override
                                public void onInput(MaterialDialog dialog, CharSequence input) {
                                    addTag(input.toString());
                                }
                            });
                    final MaterialDialog addTagDialog = addTagBuilder.build();
                    EditText inputET = addTagDialog.getInputEditText();
                    inputET.setFilters(new InputFilter[]{addTagFilter});
                    addTagDialog.show();
                }
                return true;
            }
        });

        mToolbarSearchItem = mToolbar.getMenu().findItem(R.id.tags_dialog_action_filter);
        mToolbarSearchView = (SearchView) MenuItemCompat.getActionView(mToolbarSearchItem);

        EditText queryET = (EditText) mToolbarSearchView.findViewById(R.id.search_src_text);
        queryET.setFilters(new InputFilter[]{addTagFilter});

        mToolbarSearchView.setQueryHint(getString(R.string.filter_tags));
        mToolbarSearchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {
            @Override
            public boolean onQueryTextSubmit(String query) {
                mToolbarSearchView.clearFocus();
                return true;
            }

            @Override
            public boolean onQueryTextChange(String newText) {
                TagsArrayAdapter adapter = (TagsArrayAdapter) mTagsListRecyclerView.getAdapter();
                adapter.getFilter().filter(newText);
                return true;
            }
        });

        MenuItem checkAllItem = mToolbar.getMenu().findItem(R.id.tags_dialog_action_select_all);
        checkAllItem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
            @Override
            public boolean onMenuItemClick(MenuItem menuItem) {
                boolean changed = false;
                if (mCurrentTags.containsAll(mTagsArrayAdapter.mTagsList)) {
                    mCurrentTags.removeAll(mTagsArrayAdapter.mTagsList);
                    changed = true;
                } else {
                    for (String tag : mTagsArrayAdapter.mTagsList) {
                        if (!mCurrentTags.contains(tag)) {
                            mCurrentTags.add(tag);
                            changed = true;
                        }
                    }
                }

                if (changed) {
                    mTagsArrayAdapter.notifyDataSetChanged();
                }
                return true;
            }
        });

        switch (mType) {
            case TYPE_ADD_TAG:
                mToolbarSearchView.setQueryHint(getString(R.string.add_new_filter_tags));
                break;
            default:
                mToolbarAddItem.setVisible(false);
        }
    }

    public void addTag(String tag) {
        if (!TextUtils.isEmpty(tag)) {
            String feedbackText = "";
            if (!mAllTags.contains(tag)) {
                mAllTags.add(tag);
                if (mNoTagsTextView.getVisibility() == View.VISIBLE) {
                    mNoTagsTextView.setVisibility(View.GONE);
                }
                mTagsArrayAdapter.mTagsList.add(tag);
                mTagsArrayAdapter.sortData();
                feedbackText = getString(R.string.tag_editor_add_feedback, tag, mPositiveText);
            } else {
                feedbackText = getString(R.string.tag_editor_add_feedback_existing, tag);
            }
            if (!mCurrentTags.contains(tag)) {
                mCurrentTags.add(tag);
            }
            mTagsArrayAdapter.notifyDataSetChanged();
            // Show a snackbar to let the user know the tag was added successfully
            UIUtils.showSnackbar(getActivity(), feedbackText, false, -1, null,
                    mDialog.getView().findViewById(R.id.tags_dialog_snackbar), null);
        }
    }

    public void setTagsDialogListener(TagsDialogListener selectedTagsListener) {
        mTagsDialogListener = selectedTagsListener;
    }

    public class TagsArrayAdapter extends  RecyclerView.Adapter<TagsArrayAdapter.ViewHolder> implements Filterable{
        public class ViewHolder extends RecyclerView.ViewHolder {
            private CheckedTextView mTagItemCheckedTextView;
            public ViewHolder(CheckedTextView ctv) {
                super(ctv);
                mTagItemCheckedTextView = ctv;
            }
        }

        public ArrayList<String> mTagsList;

        public  TagsArrayAdapter() {
            mTagsList = new ArrayList<>();
            mTagsList.addAll(mAllTags);
            sortData();
        }

        public void sortData() {
            Collections.sort(mTagsList, new Comparator<String>() {
                @Override
                public int compare(String lhs, String rhs) {
                    boolean lhs_checked = mCurrentTags.contains(lhs);
                    boolean rhs_checked = mCurrentTags.contains(rhs);
                    //priority for checked items.
                    return lhs_checked == rhs_checked ? lhs.compareToIgnoreCase(rhs) : lhs_checked ? -1 : 1;
                }
            });
        }

        @Override
        public TagsArrayAdapter.ViewHolder onCreateViewHolder(ViewGroup parent,
                                                              int viewType) {
            View v = LayoutInflater.from(parent.getContext())
                    .inflate(R.layout.tags_item_list_dialog, parent, false);

            ViewHolder vh = new ViewHolder((CheckedTextView) v.findViewById(R.id.tags_dialog_tag_item));
            vh.mTagItemCheckedTextView.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    CheckedTextView ctv = (CheckedTextView) view;
                    ctv.toggle();
                    String tag = ctv.getText().toString();
                    if (ctv.isChecked() && !mCurrentTags.contains(tag)) {
                        mCurrentTags.add(tag);
                    } else if (!ctv.isChecked() && mCurrentTags.contains(tag)) {
                        mCurrentTags.remove(tag);
                    }
                }
            });
            return vh;
        }

        @Override
        public void onBindViewHolder(ViewHolder holder, int position) {
            String tag = mTagsList.get(position);
            holder.mTagItemCheckedTextView.setText(tag);
            holder.mTagItemCheckedTextView.setChecked(mCurrentTags.contains(tag));
        }

        @Override
        public int getItemCount() {
            return mTagsList.size();
        }

        @Override
        public Filter getFilter() {
            return new TagsFilter();
        }

        /* Custom Filter class - as seen in http://stackoverflow.com/a/29792313/1332026 */
        private class TagsFilter extends Filter {
            private ArrayList<String> mFilteredTags;
            private TagsFilter() {
                super();
                mFilteredTags = new ArrayList<>();
            }

            @Override
            protected FilterResults performFiltering(CharSequence constraint) {
                mFilteredTags.clear();
                final FilterResults filterResults = new FilterResults();
                if (constraint.length() == 0) {
                    mFilteredTags.addAll(mAllTags);
                } else {
                    final String filterPattern = constraint.toString().toLowerCase().trim();
                    for (String tag : mAllTags) {
                        if (tag.toLowerCase().startsWith(filterPattern)) {
                            mFilteredTags.add(tag);
                        }
                    }
                }

                filterResults.values = mFilteredTags;
                filterResults.count = mFilteredTags.size();
                return filterResults;
            }

            @Override
            protected void publishResults(CharSequence charSequence, FilterResults filterResults) {
                mTagsList.clear();
                mTagsList.addAll(mFilteredTags);
                sortData();
                notifyDataSetChanged();
            }
        }
    }
}

package com.ichi2.anki.exception;

public class ConfirmModSchemaException extends Exception {

    /**
     * 
     */
    private static final long serialVersionUID = -9215098969154590797L;


    public ConfirmModSchemaException() {
    }
}

package com.ichi2.anki.exception;

import android.content.res.Resources;

import com.ichi2.anki.R;

public class DeckRenameException extends Exception {

    public static final int ALREADY_EXISTS = 0;
    public static final int FILTERED_NOSUBDEKCS = 1;

    private int mErrorCode;

    public DeckRenameException(int errorCode) {
        super();
        mErrorCode = errorCode;
    }

    public String getLocalizedMessage(Resources res) {
        switch (mErrorCode) {
            case ALREADY_EXISTS:
                return res.getString(R.string.decks_rename_exists);
            case FILTERED_NOSUBDEKCS:
                return res.getString(R.string.decks_rename_filtered_nosubdecks);
            default:
                return "";
        }
    }
}

package com.ichi2.anki.exception;

public class MediaSyncException extends Exception {

    public MediaSyncException(String msg) {
        super(msg);
    }
}

package com.ichi2.anki.exception;

public class StorageAccessException extends Exception {

    public StorageAccessException() {
    }


    public StorageAccessException(String msg) {
        super(msg);
    }
}
package com.ichi2.anki.exception;

@SuppressWarnings("serial")
public class UnknownHttpResponseException extends Exception {
    private Integer mCode;
    public UnknownHttpResponseException(String message, Integer code) {
        super(message);
        mCode = code;
    }
    public int getResponseCode() {
        return mCode;
    }
}/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard;

import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.content.Context;
import android.media.MediaPlayer;
import android.media.MediaPlayer.OnCompletionListener;
import android.media.MediaRecorder;
import android.os.Build;

import android.view.View;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.Toast;
import com.ichi2.anki.R;

import timber.log.Timber;

// Not designed for visual editing
@SuppressLint("ViewConstructor")
public class AudioView extends LinearLayout {
    protected String mAudioPath;

    protected PlayPauseButton mPlayPause = null;
    protected StopButton mStop = null;
    protected RecordButton mRecord = null;

    private MediaRecorder mRecorder = null;
    private MediaPlayer mPlayer = null;

    OnRecordingFinishEventListener mOnRecordingFinishEventListener = null;

    private Status mStatus = Status.IDLE;

    int mResPlayImage;
    int mResPauseImage;
    int mResStopImage;
    int mResRecordImage;
    int mResRecordStopImage;

    private Context mContext;

    enum Status {
        IDLE, // Default initial state
        INITIALIZED, // When datasource has been set
        PLAYING, PAUSED, STOPPED, // The different possible states once playing
                                  // has started
        RECORDING // The recorder being played status
    }


    /**
     * @param context Resources for images
     * @param resPlay
     * @param resPause
     * @param resStop
     * @param audioPath
     * @return
     */
    public static AudioView createPlayerInstance(Context context, int resPlay, int resPause, int resStop,
            String audioPath) {
        return new AudioView(context, resPlay, resPause, resStop, audioPath);
    }


    public static AudioView createRecorderInstance(Context context, int resPlay, int resPause, int resStop,
            int resRecord, int resRecordStop, String audioPath) {
        return new AudioView(context, resPlay, resPause, resStop, resRecord, resRecordStop, audioPath);
    }


    private AudioView(Context context, int resPlay, int resPause, int resStop, String audioPath) {
        super(context);

        mContext = context;

        mResPlayImage = resPlay;
        mResPauseImage = resPause;
        mResStopImage = resStop;
        mAudioPath = audioPath;

        this.setOrientation(HORIZONTAL);

        mPlayPause = new PlayPauseButton(context);
        addView(mPlayPause, new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));

        mStop = new StopButton(context);
        addView(mStop, new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));
    }


    private void showToast(String msg) {
        int duration = Toast.LENGTH_SHORT;
        Toast toast = Toast.makeText(mContext, msg, duration);
        toast.show();
    }


    private String gtxt(int id) {
        return mContext.getText(id).toString();
    }


    private AudioView(Context context, int resPlay, int resPause, int resStop, int resRecord, int resRecordStop,
            String audioPath) {
        this(context, resPlay, resPause, resStop, audioPath);
        mResRecordImage = resRecord;
        mResRecordStopImage = resRecordStop;

        this.setOrientation(HORIZONTAL);

        mRecord = new RecordButton(context);
        addView(mRecord, new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));
    }


    public String getAudioPath() {
        return mAudioPath;
    }


    public void setRecordButtonVisible(boolean isVisible) {
        if (isVisible) {
            mRecord.setVisibility(VISIBLE);
        } else {
            mRecord.setVisibility(INVISIBLE);
        }
    }


    public void setOnRecordingFinishEventListener(OnRecordingFinishEventListener listener) {
        mOnRecordingFinishEventListener = listener;
    }


    public void notifyPlay() {
        mPlayPause.update();
        mStop.update();
        if (mRecord != null) {
            mRecord.update();
        }
    }


    public void notifyStop() {
        // Send state change signal to all buttons
        mPlayPause.update();
        mStop.update();
        if (mRecord != null) {
            mRecord.update();
        }
    }


    public void notifyPause() {
        mPlayPause.update();
        mStop.update();
        if (mRecord != null) {
            mRecord.update();
        }
    }


    public void notifyRecord() {
        mPlayPause.update();
        mStop.update();
        if (mRecord != null) {
            mRecord.update();
        }
    }


    public void notifyStopRecord() {
        if (mRecorder != null && mStatus == Status.RECORDING) {
            mRecorder.stop();
            mStatus = Status.IDLE;
            if (mOnRecordingFinishEventListener != null) {
                mOnRecordingFinishEventListener.onRecordingFinish(AudioView.this);
            }
        }
        mPlayPause.update();
        mStop.update();
        if (mRecord != null) {
            mRecord.update();
        }
    }

    public void notifyReleaseRecorder() {
        if (mRecorder != null) {
            mRecorder.release();
        }
    }

    protected class PlayPauseButton extends ImageButton {
        OnClickListener onClickListener = new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (mAudioPath == null) {
                    return;
                }

                switch (mStatus) {
                    case IDLE:
                        try {
                            mPlayer = new MediaPlayer();
                            mPlayer.setDataSource(getAudioPath());
                            mPlayer.setOnCompletionListener(new OnCompletionListener() {
                                @Override
                                public void onCompletion(MediaPlayer mp) {
                                    mStatus = Status.STOPPED;
                                    mPlayer.stop();
                                    notifyStop();
                                }
                            });
                            mPlayer.prepare();
                            mPlayer.start();

                            setImageResource(mResPauseImage);
                            mStatus = Status.PLAYING;
                            notifyPlay();
                        } catch (Exception e) {
                            Timber.e(e.getMessage());
                            showToast(gtxt(R.string.multimedia_editor_audio_view_playing_failed));
                            mStatus = Status.IDLE;
                        }
                        break;

                    case PAUSED:
                        // -> Play, continue playing
                        mStatus = Status.PLAYING;
                        setImageResource(mResPauseImage);
                        mPlayer.start();
                        notifyPlay();
                        break;

                    case STOPPED:
                        // -> Play, start from beginning
                        mStatus = Status.PLAYING;
                        setImageResource(mResPauseImage);
                        try {
                            mPlayer.prepare();
                            mPlayer.seekTo(0);
                        } catch (Exception e) {
                            Timber.e(e.getMessage());
                        }
                        mPlayer.start();
                        notifyPlay();
                        break;

                    case PLAYING:
                        setImageResource(mResPlayImage);
                        mPlayer.pause();
                        mStatus = Status.PAUSED;
                        notifyPause();
                        break;

                    case RECORDING:
                        // this button should be disabled
                        break;
                    default:
                        break;
                }
            }
        };


        public PlayPauseButton(Context context) {
            super(context);
            setImageResource(mResPlayImage);

            setOnClickListener(onClickListener);
        }


        public void update() {
            switch (mStatus) {
                case IDLE:
                case STOPPED:
                    setImageResource(mResPlayImage);
                    setEnabled(true);
                    break;

                case RECORDING:
                    setEnabled(false);
                    break;

                default:
                    setEnabled(true);
                    break;
            }
        }
    }

    protected class StopButton extends ImageButton {
        OnClickListener onClickListener = new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                switch (mStatus) {
                    case PAUSED:
                    case PLAYING:
                        mPlayer.stop();
                        mStatus = Status.STOPPED;
                        notifyStop();
                        break;

                    case IDLE:
                    case STOPPED:
                    case RECORDING:
                    case INITIALIZED:
                }
            }
        };


        public StopButton(Context context) {
            super(context);
            setImageResource(mResStopImage);

            setOnClickListener(onClickListener);
        }


        public void update() {
            switch (mStatus) {
                case RECORDING:
                    setEnabled(false);
                    break;

                default:
                    setEnabled(true);
            }
            // It doesn't need to update itself on any other state changes
        }

    }

    protected class RecordButton extends ImageButton {
        OnClickListener onClickListener = new View.OnClickListener() {
            @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
            @Override
            public void onClick(View v) {
                // Since mAudioPath is not compulsory, we check if it exists
                if (mAudioPath == null) {
                    return;
                }

                switch (mStatus) {
                    case IDLE: // If not already recorded or not already played
                    case STOPPED: // if already recorded or played
                        boolean highSampling = false;
                        int currentapiVersion = android.os.Build.VERSION.SDK_INT;
                        if (currentapiVersion >= android.os.Build.VERSION_CODES.GINGERBREAD_MR1) {
                            try {
                                // try high quality AAC @ 44.1kHz / 192kbps first
                                mRecorder = initMediaRecorder();
                                mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);
                                mRecorder.setAudioChannels(2);
                                mRecorder.setAudioSamplingRate(44100);
                                mRecorder.setAudioEncodingBitRate(192000);
                                mRecorder.prepare();
                                mRecorder.start();
                                highSampling = true;
                            } catch (Exception e) {
                            }
                        }

                        if (!highSampling) {
                            // fall back on default
                            try {
                                mRecorder = initMediaRecorder();
                                mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);

                                mRecorder.prepare();
                                mRecorder.start();

                            } catch (Exception e) {
                                Timber.e("RecordButton.onClick() :: error recording to " + mAudioPath + "\n" +e.getMessage());
                                showToast(gtxt(R.string.multimedia_editor_audio_view_recording_failed));
                                mStatus = Status.STOPPED;
                                break;
                            }

                        }

                        mStatus = Status.RECORDING;
                        setImageResource(mResRecordImage);
                        notifyRecord();

                        break;

                    case RECORDING:
                        setImageResource(mResRecordStopImage);
                        notifyStopRecord();
                        break;

                    default:
                        // do nothing
                }
            }

            private MediaRecorder initMediaRecorder() {
                MediaRecorder mr = new MediaRecorder();
                mr.setAudioSource(MediaRecorder.AudioSource.MIC);
                mr.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
                mStatus = Status.INITIALIZED;
                mr.setOutputFile(mAudioPath); // audioPath
                                              // could
                                              // change
                return mr;
            }
        };


        public RecordButton(Context context) {
            super(context);
            setImageResource(mResRecordStopImage);

            setOnClickListener(onClickListener);
        }


        public void update() {
            switch (mStatus) {
                case PLAYING:
                case PAUSED:
                    setEnabled(false);
                    break;

                default:
                    setEnabled(true);
                    break;
            }
        }
    }

    public interface OnRecordingFinishEventListener {
        public void onRecordingFinish(View v);
    }
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard;

import com.ichi2.anki.multimediacard.fields.IField;

import java.io.Serializable;

/**
 * Interface for a note, which multimedia card editor can process.
 */
public interface IMultimediaEditableNote extends Serializable {

    int getNumberOfFields();


    IField getField(int index);


    boolean setField(int index, IField field);


    boolean isModified();


    public void circularSwap();

}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.activity;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnCancelListener;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.Bundle;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.Spinner;
import android.widget.Toast;

import com.ichi2.anki.R;
import com.ichi2.anki.multimediacard.beolingus.parsing.BeolingusParser;
import com.ichi2.anki.multimediacard.language.LanguageListerBeolingus;
import com.ichi2.anki.runtimetools.TaskOperations;
import com.ichi2.anki.web.HttpFetcher;
import com.ichi2.async.Connection;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.Locale;

/**
 * Activity to load pronunciation files from Beolingus.
 * <p>
 * User picks a source language and the source is passed as extra.
 * <p>
 * When activity finished, it passes the filepath as another extra to the caller.
 */
public class LoadPronounciationActivity extends Activity implements OnCancelListener {

    private static final String BUNDLE_KEY_SHUT_OFF = "key.multimedia.shut.off";
    // Must be passed in
    public static String EXTRA_SOURCE = "com.ichi2.anki.LoadPronounciationActivity.extra.source";
    // Passed out as a result
    public static String EXTRA_PRONUNCIATION_FILE_PATH = "com.ichi2.anki.LoadPronounciationActivity.extra.pronun.file.path";

    String mSource;

    private String mTranslationAddress;

    private ProgressDialog progressDialog = null;

    private String mTranslation;

    private String mPronunciationAddress;

    private String mPronunciationPage;

    private String mMp3Address;

    private LoadPronounciationActivity mActivity;
    private LanguageListerBeolingus mLanguageLister;
    private Spinner mSpinnerFrom;
    private Button mSaveButton;

    private BackgroundPost mPostTranslation = null;
    private BackgroundPost mPostPronunciation = null;
    private DownloadFileTask mDownloadMp3Task = null;

    private boolean mStopped;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (savedInstanceState != null) {
            boolean b = savedInstanceState.getBoolean(BUNDLE_KEY_SHUT_OFF, false);
            if (b) {
                finishCancel();
                return;
            }
        }

        setContentView(R.layout.activity_load_pronounciation);
        mSource = getIntent().getExtras().getString(EXTRA_SOURCE);

        LinearLayout linearLayout = (LinearLayout) findViewById(R.id.layoutInLoadPronActivity);

        mLanguageLister = new LanguageListerBeolingus(this);

        mSpinnerFrom = new Spinner(this);
        ArrayAdapter<String> adapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item,
                mLanguageLister.getLanguages());
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mSpinnerFrom.setAdapter(adapter);
        linearLayout.addView(mSpinnerFrom);

        Button buttonLoadPronunciation = new Button(this);
        buttonLoadPronunciation.setText(gtxt(R.string.multimedia_editor_pron_load));
        linearLayout.addView(buttonLoadPronunciation);
        buttonLoadPronunciation.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                onLoadPronunciation(v);

            }
        });

        mSaveButton = new Button(this);
        mSaveButton.setText("Save");
        mSaveButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {

            }
        });
        mActivity = this;

        mStopped = false;

    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.activity_load_pronounciation, menu);
        return true;
    }


    /**
     * @param v Start of the story.
     */
    protected void onLoadPronunciation(View v) {
        if(!Connection.isOnline()) {
            showToast(gtxt(R.string.network_no_connection));
            return;
        }

        String message = gtxt(R.string.multimedia_editor_searching_word);

        showProgressDialog(message);

        mTranslationAddress = computeAddressOfTranslationPage();

        try {
            mPostTranslation = new BackgroundPost();
            mPostTranslation.setAddress(mTranslationAddress);
            // post.setStopper(PRONUNC_STOPPER);
            mPostTranslation.execute();
        } catch (Exception e) {
            progressDialog.dismiss();
            showToast(gtxt(R.string.multimedia_editor_something_wrong));
        }
    }


    private void showProgressDialog(String message) {

        dismissCarefullyProgressDialog();

        progressDialog = ProgressDialog.show(this, gtxt(R.string.multimedia_editor_progress_wait_title), message, true,
                false);
        progressDialog.setCancelable(true);
        progressDialog.setOnCancelListener(this);
    }

    /**
     * @author zaur This class is used two times. First time from Beolingus it requests a page with the word
     *         translation. Second time it loads a page with the link to mp3 pronunciation file.
     */
    private class BackgroundPost extends AsyncTask<Void, Void, String> {

        private String mAddress;


        // private String mStopper;

        @Override
        protected String doInBackground(Void... params) {
            // TMP CODE for quick testing
            // if (mAddress.contentEquals(mTranslationAddress))
            // {
            // return MockTranslationFetcher.get();
            // }
            // else if (mAddress.contentEquals(mPronunciationAddress))
            // {
            // return MockPronounciationPageFetcher.get();
            // }

            // Should be just this
            return HttpFetcher.fetchThroughHttp(getAddress(), "ISO-8859-1");
        }


        /**
         * @param address Used to set the download address
         */
        public void setAddress(String address) {
            mAddress = address;
        }


        /**
         * @return Used to know, which of the posts finished, to differentiate.
         */
        public String getAddress() {
            return mAddress;
        }


        @Override
        protected void onPostExecute(String result) {
            // Result here is the whole HTML of the page
            // this is passed to ask for address and differentiate, which of the
            // post has finished.
            processPostFinished(this, result);
        }

    }

    /**
     * @author zaur This is to load finally the MP3 file with pronunciation.
     */
    private class DownloadFileTask extends AsyncTask<Void, Void, String> {

        private String mAddress;


        @Override
        protected String doInBackground(Void... params) {
            return HttpFetcher.downloadFileToSdCard(mAddress, mActivity, "pronunc");
        }


        public void setAddress(String address) {
            mAddress = address;
        }


        @Override
        protected void onPostExecute(String result) {
            receiveMp3File(result);
        }

    }


    protected void processPostFinished(BackgroundPost post, String result) {

        if (mStopped) {
            return;
        }

        // First call returned
        // Means we get the page with the word translation,
        // And we have to start fetching the page with pronunciation
        if (post.getAddress().contentEquals(mTranslationAddress)) {
            mTranslation = result;

            if (mTranslation.startsWith("FAILED")) {

                failNoPronunciation();

                return;
            }

            mPronunciationAddress = BeolingusParser.getPronunciationAddressFromTranslation(mTranslation, mSource);

            if (mPronunciationAddress.contentEquals("no")) {

                failNoPronunciation();

                if (!mSource.toLowerCase(Locale.getDefault()).contentEquals(mSource)) {
                    showToastLong(gtxt(R.string.multimedia_editor_word_search_try_lower_case));
                }

                return;
            }

            try {
                showProgressDialog(gtxt(R.string.multimedia_editor_pron_looking_up));
                mPostPronunciation = new BackgroundPost();
                mPostPronunciation.setAddress(mPronunciationAddress);
                mPostPronunciation.execute();
            } catch (Exception e) {
                progressDialog.dismiss();
                showToast(gtxt(R.string.multimedia_editor_something_wrong));
            }

            return;
        }

        // Else
        // second call returned
        // This is a call when pronunciation page has been fetched.
        // We chekc if mp3 file could be downloaded and download it.
        if (post.getAddress().contentEquals(mPronunciationAddress)) {
            // else here = pronunciation post returned;

            mPronunciationPage = result;

            mMp3Address = BeolingusParser.getMp3AddressFromPronounciation(mPronunciationPage);

            if (mMp3Address.contentEquals("no")) {
                failNoPronunciation();
                return;
            }

            // Download MP3 file
            try {
                showProgressDialog(gtxt(R.string.multimedia_editor_general_downloading));
                mDownloadMp3Task = new DownloadFileTask();
                mDownloadMp3Task.setAddress(mMp3Address);
                mDownloadMp3Task.execute();
            } catch (Exception e) {
                progressDialog.dismiss();
                showToast(gtxt(R.string.multimedia_editor_something_wrong));
            }

            return;

        }

    }


    // This is called when MP3 Download is finished.
    public void receiveMp3File(String result) {
        if (mStopped) {
            return;
        }

        if (result == null) {
            failNoPronunciation();
            return;
        }

        if (result.startsWith("FAIL")) {
            failNoPronunciation();
            return;
        }

        progressDialog.dismiss();

        showToast(gtxt(R.string.multimedia_editor_general_done));

        Intent resultData = new Intent();

        resultData.putExtra(EXTRA_PRONUNCIATION_FILE_PATH, result);

        setResult(RESULT_OK, resultData);

        finish();

    }


    private void finishCancel() {
        Intent resultData = new Intent();
        setResult(RESULT_CANCELED, resultData);
        finish();
    }


    private void failNoPronunciation() {
        stop(gtxt(R.string.multimedia_editor_error_word_not_found));
        mPronunciationAddress = "no";
        mMp3Address = "no";
    }


    private void stop(String string) {
        progressDialog.dismiss();
        showToast(string);
    }


    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putBoolean(BUNDLE_KEY_SHUT_OFF, true);
    }


    private String computeAddressOfTranslationPage() {
        // Service name has to be replaced from the language lister.
        String address = "http://dict.tu-chemnitz.de/dings.cgi?lang=en&service=SERVICE&opterrors=0&optpro=0&query=Welt";

        String strFrom = mSpinnerFrom.getSelectedItem().toString();
        String langCodeFrom = mLanguageLister.getCodeFor(strFrom);

        String query;

        try {
            query = URLEncoder.encode(mSource, "utf-8");
        } catch (UnsupportedEncodingException e) {
            query = mSource.replace(" ", "%20");
        }

        address = address.replaceAll("SERVICE", langCodeFrom).replaceAll("Welt", query);

        return address;
    }


    private void showToast(CharSequence text) {
        int duration = Toast.LENGTH_SHORT;
        Toast toast = Toast.makeText(this, text, duration);
        toast.show();
    }


    private void showToastLong(CharSequence text) {
        int duration = Toast.LENGTH_LONG;
        Toast toast = Toast.makeText(this, text, duration);
        toast.show();
    }


    // If the loading and dialog are cancelled
    @Override
    public void onCancel(DialogInterface dialog) {
        mStopped = true;

        dismissCarefullyProgressDialog();

        stopAllTasks();

        Intent resultData = new Intent();

        setResult(RESULT_CANCELED, resultData);

        finish();
    }


    private void dismissCarefullyProgressDialog() {
        try {
            if (progressDialog != null) {
                if (progressDialog.isShowing()) {
                    progressDialog.dismiss();
                }
            }
        } catch (Exception e) {
            // nothing is done intentionally
        }
    }


    private void stopAllTasks() {
        AsyncTask<?, ?, ?> t;
        t = mPostTranslation;
        TaskOperations.stopTaskGracefully(t);
        t = mPostPronunciation;
        TaskOperations.stopTaskGracefully(t);
        t = mDownloadMp3Task;
        TaskOperations.stopTaskGracefully(t);
    }


    @Override
    protected void onPause() {
        super.onPause();
        dismissCarefullyProgressDialog();
        stopAllTasks();
    }


    private String gtxt(int id) {
        return getText(id).toString();
    }

}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.activity;

import android.Manifest;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Bundle;

import android.support.v4.app.ActivityCompat;
import android.support.v4.content.ContextCompat;
import android.support.v7.widget.Toolbar;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.LinearLayout.LayoutParams;

import com.ichi2.anki.AnkiActivity;
import com.ichi2.anki.R;
import com.ichi2.anki.multimediacard.IMultimediaEditableNote;
import com.ichi2.anki.multimediacard.fields.AudioField;
import com.ichi2.anki.multimediacard.fields.BasicControllerFactory;
import com.ichi2.anki.multimediacard.fields.EFieldType;
import com.ichi2.anki.multimediacard.fields.IControllerFactory;
import com.ichi2.anki.multimediacard.fields.IField;
import com.ichi2.anki.multimediacard.fields.IFieldController;
import com.ichi2.anki.multimediacard.fields.ImageField;
import com.ichi2.anki.multimediacard.fields.TextField;

import java.io.File;

import timber.log.Timber;

public class MultimediaEditFieldActivity extends AnkiActivity
        implements ActivityCompat.OnRequestPermissionsResultCallback {

    public static final String EXTRA_RESULT_FIELD = "edit.field.result.field";
    public static final String EXTRA_RESULT_FIELD_INDEX = "edit.field.result.field.index";

    public static final String EXTRA_FIELD_INDEX = "multim.card.ed.extra.field.index";
    public static final String EXTRA_FIELD = "multim.card.ed.extra.field";
    public static final String EXTRA_WHOLE_NOTE = "multim.card.ed.extra.whole.note";

    private static final String BUNDLE_KEY_SHUT_OFF = "key.edit.field.shut.off";
    private static final int REQUEST_AUDIO_PERMISSION = 0;

    IField mField;
    IMultimediaEditableNote mNote;
    int mFieldIndex;

    private IFieldController mFieldController;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (savedInstanceState != null) {
            boolean b = savedInstanceState.getBoolean(BUNDLE_KEY_SHUT_OFF, false);
            if (b) {
                finishCancel();
                return;
            }
        }

        setContentView(R.layout.multimedia_edit_field_activity);
        View mainView = findViewById(android.R.id.content);
        Toolbar toolbar = (Toolbar) mainView.findViewById(R.id.toolbar);
        if (toolbar != null) {
            setSupportActionBar(toolbar);
        }

        mField = (IField) this.getIntent().getExtras().getSerializable(EXTRA_FIELD);

        mNote = (IMultimediaEditableNote) this.getIntent().getSerializableExtra(EXTRA_WHOLE_NOTE);

        mFieldIndex = this.getIntent().getIntExtra(EXTRA_FIELD_INDEX, 0);

        recreateEditingUi();

        // Handling absence of the action bar!
        int currentapiVersion = android.os.Build.VERSION.SDK_INT;
        if (currentapiVersion <= android.os.Build.VERSION_CODES.GINGERBREAD_MR1) {
            LinearLayout linearLayout = (LinearLayout) findViewById(R.id.LinearLayoutForSpareMenuFieldEdit);
            createSpareMenu(linearLayout);
        }
    }


    private void finishCancel() {
        Intent resultData = new Intent();
        setResult(RESULT_CANCELED, resultData);
        finish();
    }


    private void recreateEditingUi() {

        IControllerFactory controllerFactory = BasicControllerFactory.getInstance();

        mFieldController = controllerFactory.createControllerForField(mField);

        if (mFieldController == null) {
            Timber.d("Field controller creation failed");
            return;
        }

        // Request permission to record if audio field
        if (mField instanceof AudioField && ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) !=
                PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.RECORD_AUDIO},
                    REQUEST_AUDIO_PERMISSION);
            return;
        }

        mFieldController.setField(mField);
        mFieldController.setFieldIndex(mFieldIndex);
        mFieldController.setNote(mNote);
        mFieldController.setEditingActivity(this);

        LinearLayout linearLayout = (LinearLayout) findViewById(R.id.LinearLayoutInScrollViewFieldEdit);

        linearLayout.removeAllViews();

        mFieldController.createUI(this, linearLayout);

    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.activity_edit_text, menu);
        menu.findItem(R.id.multimedia_edit_field_to_text).setVisible(mField.getType() != EFieldType.TEXT);
        menu.findItem(R.id.multimedia_edit_field_to_audio).setVisible(mField.getType() != EFieldType.AUDIO);
        menu.findItem(R.id.multimedia_edit_field_to_image).setVisible(mField.getType() != EFieldType.IMAGE);
        return true;
    }


    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.multimedia_edit_field_to_text:
                Timber.i("To text field button pressed");
                mFieldController.onFocusLost();
                toTextField();
                supportInvalidateOptionsMenu();
                return true;

            case R.id.multimedia_edit_field_to_image:
                Timber.i("To image button pressed");
                mFieldController.onFocusLost();
                toImageField();
                supportInvalidateOptionsMenu();
                return true;

            case R.id.multimedia_edit_field_to_audio:
                Timber.i("To audio button pressed");
                mFieldController.onFocusLost();
                toAudioField();
                supportInvalidateOptionsMenu();
                return true;

            case R.id.multimedia_edit_field_done:
                Timber.i("Save button pressed");
                done();
                return true;

            default:
                return super.onOptionsItemSelected(item);
        }
    }


    private void createSpareMenu(LinearLayout linearLayout) {

        LayoutParams pars = new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, 1);

        Button toTextButton = new Button(this);
        toTextButton.setText(gtxt(R.string.multimedia_editor_field_editing_text));
        toTextButton.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                toTextField();
            }

        });
        linearLayout.addView(toTextButton, pars);

        Button toImageButton = new Button(this);
        toImageButton.setText(gtxt(R.string.multimedia_editor_field_editing_image));
        toImageButton.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                toImageField();
            }

        });
        linearLayout.addView(toImageButton, pars);

        Button toAudioButton = new Button(this);
        toAudioButton.setText(gtxt(R.string.multimedia_editor_field_editing_audio));
        toAudioButton.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                toAudioField();
            }

        });
        linearLayout.addView(toAudioButton, pars);

        Button doneButton = new Button(this);
        doneButton.setText(gtxt(R.string.multimedia_editor_field_editing_done));
        doneButton.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                done();
            }

        });
        linearLayout.addView(doneButton, pars);

    }


    protected void done() {

        mFieldController.onDone();

        Intent resultData = new Intent();

        boolean bChangeToText = false;

        if (mField.getType() == EFieldType.IMAGE) {
            if (mField.getImagePath() == null) {
                bChangeToText = true;
            }

            if (!bChangeToText) {
                File f = new File(mField.getImagePath());
                if (!f.exists()) {
                    bChangeToText = true;
                }
            }
        } else if (mField.getType() == EFieldType.AUDIO) {
            if (mField.getAudioPath() == null) {
                bChangeToText = true;
            }

            if (!bChangeToText) {
                File f = new File(mField.getAudioPath());
                if (!f.exists()) {
                    bChangeToText = true;
                }
            }
        }

        if (bChangeToText) {
            mField = new TextField();
        }

        resultData.putExtra(EXTRA_RESULT_FIELD, mField);
        resultData.putExtra(EXTRA_RESULT_FIELD_INDEX, mFieldIndex);

        setResult(RESULT_OK, resultData);

        finish();
    }


    protected void toAudioField() {
        if (mField.getType() != EFieldType.AUDIO) {
            mField = new AudioField();
            recreateEditingUi();
        }
    }


    protected void toImageField() {
        if (mField.getType() != EFieldType.IMAGE) {
            mField = new ImageField();
            recreateEditingUi();
        }

    }


    protected void toTextField() {
        if (mField.getType() != EFieldType.TEXT) {
            mField = new TextField();
            recreateEditingUi();
        }
    }


    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (mFieldController != null) {
            mFieldController.onActivityResult(requestCode, resultCode, data);
        }

        super.onActivityResult(requestCode, resultCode, data);
    }


    public void onRequestPermissionsResult (int requestCode, String[] permissions, int[] grantResults) {
        if (requestCode == REQUEST_AUDIO_PERMISSION && permissions.length == 1) {
            // TODO:  Disable the record button / show some feedback to the user
            recreateEditingUi();
        }
    }

    public void handleFieldChanged(IField newField) {
        mField = newField;
        recreateEditingUi();
    }


    @Override
    protected void onDestroy() {
        super.onDestroy();

        if (mFieldController != null) {
            mFieldController.onDestroy();
        }

    }


    private String gtxt(int id) {
        return getText(id).toString();
    }


    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putBoolean(BUNDLE_KEY_SHUT_OFF, true);
    }

}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.activity;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.widget.ArrayAdapter;

import java.util.ArrayList;

/**
 * This dialog fragment support a choice from a list of strings.
 */
public class PickStringDialogFragment extends DialogFragment {
    private ArrayList<String> mPossibleChoices;
    private android.content.DialogInterface.OnClickListener mListener;
    private String mTitle;


    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        // Use the Builder class for convenient dialog construction
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        builder.setTitle(mTitle);

        ArrayAdapter<String> adapter = new ArrayAdapter<>(this.getActivity(),
                android.R.layout.simple_list_item_1, mPossibleChoices);

        builder.setAdapter(adapter, mListener);

        return builder.create();
    }


    public void setTitle(String mTitle) {
        this.mTitle = mTitle;
    }


    public void setChoices(ArrayList<String> possibleClones) {
        mPossibleChoices = possibleClones;
    }


    public void setOnclickListener(DialogInterface.OnClickListener listener) {
        mListener = listener;
    }

}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.activity;

import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnCancelListener;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.AsyncTask;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.Toast;

import com.google.gson.Gson;
import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.R;
import com.ichi2.anki.multimediacard.glosbe.json.Meaning;
import com.ichi2.anki.multimediacard.glosbe.json.Phrase;
import com.ichi2.anki.multimediacard.glosbe.json.Response;
import com.ichi2.anki.multimediacard.glosbe.json.Tuc;
import com.ichi2.anki.multimediacard.language.LanguagesListerGlosbe;
import com.ichi2.anki.runtimetools.TaskOperations;
import com.ichi2.anki.web.HttpFetcher;
import com.ichi2.async.Connection;
import com.ichi2.libanki.Utils;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * Activity used now with Glosbe.com to enable translation of words.
 */
public class TranslationActivity extends FragmentActivity implements DialogInterface.OnClickListener, OnCancelListener {

    private static final String BUNDLE_KEY_SHUT_OFF = "key.multimedia.shut.off";

    // Something to translate
    public static final String EXTRA_SOURCE = "translation.activity.extra.source";
    // Translated result
    public static final String EXTRA_TRANSLATION = "translation.activity.extra.translation";

    String mSource;
    String mTranslation;
    private LanguagesListerGlosbe mLanguageLister;
    private Spinner mSpinnerFrom;
    private Spinner mSpinnerTo;
    private ProgressDialog progressDialog = null;
    private String mWebServiceAddress;
    private ArrayList<String> mPossibleTranslations;
    private String mLangCodeTo;
    private BackgroundPost mTranslationLoadPost = null;


    private void finishCancel() {
        Intent resultData = new Intent();
        setResult(RESULT_CANCELED, resultData);
        finish();
    }


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (savedInstanceState != null) {
            boolean b = savedInstanceState.getBoolean(BUNDLE_KEY_SHUT_OFF, false);
            if (b) {
                finishCancel();
                return;
            }
        }

        setContentView(R.layout.activity_translation);

        try {
            mSource = getIntent().getExtras().getString(EXTRA_SOURCE);
        } catch (Exception e) {
            mSource = "";
        }

        // If translation fails this is a default - source will be returned.
        mTranslation = mSource;

        LinearLayout linearLayout = (LinearLayout) findViewById(R.id.MainLayoutInTranslationActivity);

        TextView tv = new TextView(this);
        tv.setText(getText(R.string.multimedia_editor_trans_poweredglosbe));
        linearLayout.addView(tv);

        TextView tvFrom = new TextView(this);
        tvFrom.setText(getText(R.string.multimedia_editor_trans_from));
        linearLayout.addView(tvFrom);

        mLanguageLister = new LanguagesListerGlosbe(this);

        mSpinnerFrom = new Spinner(this);
        ArrayAdapter<String> adapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item,
                mLanguageLister.getLanguages());
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mSpinnerFrom.setAdapter(adapter);
        linearLayout.addView(mSpinnerFrom);

        TextView tvTo = new TextView(this);
        tvTo.setText(getText(R.string.multimedia_editor_trans_to));
        linearLayout.addView(tvTo);

        mSpinnerTo = new Spinner(this);
        ArrayAdapter<String> adapterTo = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item,
                mLanguageLister.getLanguages());
        adapterTo.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mSpinnerTo.setAdapter(adapterTo);
        linearLayout.addView(mSpinnerTo);

        final SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());

        // Try to set spinner value to last selected position
        String fromLang = preferences.getString("translatorLastLanguageFrom", "");
        String toLang = preferences.getString("translatorLastLanguageTo", "");
        mSpinnerFrom.setSelection(getSpinnerIndex(mSpinnerFrom, fromLang));
        mSpinnerTo.setSelection(getSpinnerIndex(mSpinnerTo, toLang));
        // Setup button
        Button btnDone = new Button(this);
        btnDone.setText(getText(R.string.multimedia_editor_trans_translate));
        btnDone.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                // Remember currently selected language
                String fromLang = mSpinnerFrom.getSelectedItem().toString();
                String toLang = mSpinnerTo.getSelectedItem().toString();
                preferences.edit().putString("translatorLastLanguageFrom", fromLang).commit();
                preferences.edit().putString("translatorLastLanguageTo", toLang).commit();
                // Get translation
                translate();
            }
        });

        linearLayout.addView(btnDone);

    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.activity_translation, menu);
        return true;
    }

    private class BackgroundPost extends AsyncTask<Void, Void, String> {

        @Override
        protected String doInBackground(Void... params) {
            return HttpFetcher.fetchThroughHttp(mWebServiceAddress);
        }


        @Override
        protected void onPostExecute(String result) {
            progressDialog.dismiss();
            mTranslation = result;
            showPickTranslationDialog();
        }

    }


    protected void translate() {
        if(!Connection.isOnline()) {
            showToast(gtxt(R.string.network_no_connection));
            return;
        }

        progressDialog = ProgressDialog.show(this, getText(R.string.multimedia_editor_progress_wait_title),
                getText(R.string.multimedia_editor_trans_translating_online), true, false);

        progressDialog.setCancelable(true);
        progressDialog.setOnCancelListener(this);

        mWebServiceAddress = computeAddress();

        try {
            mTranslationLoadPost = new BackgroundPost();
            mTranslationLoadPost.execute();
        } catch (Exception e) {
            progressDialog.dismiss();
            showToast(getText(R.string.multimedia_editor_something_wrong));
        }
    }


    private String computeAddress() {
        String address = "http://glosbe.com/gapi/translate?from=FROMLANG&dest=TOLANG&format=json&phrase=SOURCE&pretty=true";

        String strFrom = mSpinnerFrom.getSelectedItem().toString();
        // Conversion to iso, lister created before.
        String langCodeFrom = mLanguageLister.getCodeFor(strFrom);

        String strTo = mSpinnerTo.getSelectedItem().toString();
        mLangCodeTo = mLanguageLister.getCodeFor(strTo);

        String query;

        try {
            query = URLEncoder.encode(mSource, "utf-8");
        } catch (UnsupportedEncodingException e) {
            query = mSource.replace(" ", "%20");
        }

        address = address.replaceAll("FROMLANG", langCodeFrom).replaceAll("TOLANG", mLangCodeTo)
                .replaceAll("SOURCE", query);

        return address;
    }


    private String gtxt(int id) {
        return getText(id).toString();
    }


    private void showToastLong(CharSequence text) {
        int duration = Toast.LENGTH_LONG;
        Toast toast = Toast.makeText(this, text, duration);
        toast.show();
    }


    private void showPickTranslationDialog() {
        if (mTranslation.startsWith("FAILED")) {
            returnFailure(getText(R.string.multimedia_editor_trans_getting_failure).toString());
            return;
        }

        Gson gson = new Gson();
        Response resp = gson.fromJson(mTranslation, Response.class);

        if (resp == null) {
            returnFailure(getText(R.string.multimedia_editor_trans_getting_failure).toString());
            return;
        }

        if (!resp.getResult().contentEquals("ok")) {
            if (!mSource.toLowerCase(Locale.getDefault()).contentEquals(mSource)) {
                showToastLong(gtxt(R.string.multimedia_editor_word_search_try_lower_case));
            }

            returnFailure(getText(R.string.multimedia_editor_trans_getting_failure).toString());
            return;
        }

        mPossibleTranslations = parseJson(resp, mLangCodeTo);

        if (mPossibleTranslations.size() == 0) {
            if (!mSource.toLowerCase(Locale.getDefault()).contentEquals(mSource)) {
                showToastLong(gtxt(R.string.multimedia_editor_word_search_try_lower_case));
            }

            returnFailure(getText(R.string.multimedia_editor_error_word_not_found).toString());
            return;
        }

        PickStringDialogFragment fragment = new PickStringDialogFragment();

        fragment.setChoices(mPossibleTranslations);
        fragment.setOnclickListener(this);
        fragment.setTitle(getText(R.string.multimedia_editor_trans_pick_translation).toString());

        fragment.show(this.getSupportFragmentManager(), "pick.translation");

    }


    private static ArrayList<String> parseJson(Response resp, String languageCodeTo) {
        ArrayList<String> res = new ArrayList<>();

        /*
         * The algorithm below includes the parsing of glosbe results. Glosbe.com returns a list of different phrases in
         * source and destination languages. This is done, probably, to improve the reader's understanding. We leave
         * here only the translations to the destination language.
         */

        List<Tuc> tucs = resp.getTuc();

        if (tucs == null) {
            return res;
        }

        String desiredLang = LanguagesListerGlosbe.requestToResponseLangCode(languageCodeTo);

        for (Tuc tuc : tucs) {
            if (tuc == null) {
                continue;
            }
            List<Meaning> meanings = tuc.getMeanings();
            if (meanings != null) {
                for (Meaning meaning : meanings) {
                    if (meaning == null) {
                        continue;
                    }
                    if (meaning.getLanguage() == null) {
                        continue;
                    }
                    if (meaning.getLanguage().contentEquals(desiredLang)) {
                        String unescappedString = Utils.unescape(meaning.getText());
                        res.add(unescappedString);
                    }
                }
            }

            Phrase phrase = tuc.getPhrase();
            if (phrase != null) {
                if (phrase.getLanguage() == null) {
                    continue;
                }
                if (phrase.getLanguage().contentEquals(desiredLang)) {
                    String unescappedString = Utils.unescape(phrase.getText());
                    res.add(unescappedString);
                }
            }

        }

        return res;
    }


    private void returnTheTranslation() {
        Intent resultData = new Intent();

        resultData.putExtra(EXTRA_TRANSLATION, mTranslation);

        setResult(RESULT_OK, resultData);

        finish();
    }


    private void returnFailure(String explanation) {
        showToast(explanation);
        setResult(RESULT_CANCELED);
        dismissCarefullyProgressDialog();
        finish();
    }


    private void showToast(CharSequence text) {
        int duration = Toast.LENGTH_SHORT;
        Toast toast = Toast.makeText(this, text, duration);
        toast.show();
    }


    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        outState.putBoolean(BUNDLE_KEY_SHUT_OFF, true);

    }


    @Override
    public void onClick(DialogInterface dialog, int which) {
        mTranslation = mPossibleTranslations.get(which);
        returnTheTranslation();
    }


    @Override
    public void onCancel(DialogInterface dialog) {
        stopWorking();
    }


    private void stopWorking() {
        TaskOperations.stopTaskGracefully(mTranslationLoadPost);
        dismissCarefullyProgressDialog();
    }


    @Override
    protected void onPause() {
        super.onPause();
        stopWorking();
    }


    private void dismissCarefullyProgressDialog() {
        try {
            if (progressDialog != null) {
                if (progressDialog.isShowing()) {
                    progressDialog.dismiss();
                }
            }
        } catch (Exception e) {
            // nothing is done intentionally
        }
    }

    private int getSpinnerIndex(Spinner spinner, String myString){

        int index = 0;

        for (int i=0;i<spinner.getCount();i++){
            if (spinner.getItemAtPosition(i).equals(myString)){
                index = i;
            }
        }
        return index;
    }
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.beolingus.parsing;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This class parses beolingus pages
 */
public class BeolingusParser {

    private static final Pattern PRONUNC_PATTERN = Pattern.compile("" +
            "<a href=\"([^\"]+)\"[^>]*>" +
            "<img src=\"/pics/s1[.]png\"[^>]*title=\"([^\"]+)\"[^>]*>");
    private static final Pattern MP3_PATTERN = Pattern.compile("href=\"([^\"]+\\.mp3)\">");

    /**
     * @param html HTML page from beolingus, with translation of the word we search
     * @return {@code "no"} or the pronunciation URL
     */
    public static String getPronunciationAddressFromTranslation(String html, String wordToSearchFor) {
        Matcher m = PRONUNC_PATTERN.matcher(html);
        while (m.find()) {
            if (m.group(2).equals(wordToSearchFor)) {
                return "http://dict.tu-chemnitz.de" + m.group(1);
            }
        }
        return "no";
    }


    /**
     * @return {@code "no"}, or the http address of the mp3 file
     */
    public static String getMp3AddressFromPronounciation(String pronunciationPageHtml) {
        Matcher m = MP3_PATTERN.matcher(pronunciationPageHtml);
        if (m.find()) {
            return "http://dict.tu-chemnitz.de" + m.group(1);
        }
        return "no";
    }

}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.fields;

import com.ichi2.libanki.Collection;

import java.io.File;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Implementation of Audio field type
 */
public class AudioField extends FieldBase implements IField {
    private static final long serialVersionUID = 5033819217738174719L;
    private String mAudioPath;
    private String mName;
    private boolean mHasTemporaryMedia = false;

    private static final String PATH_REGEX = "\\[sound:(.*)\\]";


    @Override
    public EFieldType getType() {
        return EFieldType.AUDIO;
    }


    @Override
    public boolean setType(EFieldType type) {
        return false;
    }


    @Override
    public boolean isModified() {
        return getThisModified();
    }


    @Override
    public String getHtml() {
        return null;
    }


    @Override
    public boolean setHtml(String html) {
        return false;
    }


    @Override
    public boolean setImagePath(String pathToImage) {
        return false;
    }


    @Override
    public String getImagePath() {
        return null;
    }


    @Override
    public boolean setAudioPath(String pathToAudio) {
        mAudioPath = pathToAudio;
        setThisModified();
        return true;
    }


    @Override
    public String getAudioPath() {
        return mAudioPath;
    }


    @Override
    public String getText() {
        return null;
    }


    @Override
    public boolean setText(String text) {
        return false;
    }


    @Override
    public void setHasTemporaryMedia(boolean hasTemporaryMedia) {
        mHasTemporaryMedia = hasTemporaryMedia;
    }


    @Override
    public boolean hasTemporaryMedia() {
        return mHasTemporaryMedia;
    }


    @Override
    public String getName() {
        return mName;
    }


    @Override
    public void setName(String name) {
        mName = name;
    }


    @Override
    public String getFormattedValue() {
        File file = new File(getAudioPath());
        if (file.exists()) {
            return String.format("[sound:%s]", file.getName());
        } else {
            return "";
        }
    }


    @Override
    public void setFormattedString(Collection col, String value) {
        Pattern p = Pattern.compile(PATH_REGEX);
        Matcher m = p.matcher(value);
        String res = "";
        if (m.find()) {
            res = m.group(1);
        }
        String mediaDir = col.getMedia().dir() + "/";
        setAudioPath(mediaDir + res);
    }
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.fields;

import android.content.Context;
import android.content.Intent;

import android.view.View;
import android.widget.LinearLayout;

import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.R;
import com.ichi2.anki.multimediacard.AudioView;
import com.ichi2.libanki.Collection;

import java.io.File;
import java.io.IOException;

import timber.log.Timber;

public class BasicAudioFieldController extends FieldControllerBase implements IFieldController {

    protected static final int ACTIVITY_RECORD_AUDIO = 1;

    /**
     * This controller always return a temporary path where it writes the audio
     */
    private String tempAudioPath;
    private String origAudioPath;
    private AudioView mAudioView;


    @Override
    public void createUI(Context context, LinearLayout layout) {
        origAudioPath = mField.getAudioPath();

        boolean bExist = false;

        if (origAudioPath != null) {
            File f = new File(origAudioPath);

            if (f.exists()) {
                tempAudioPath = f.getAbsolutePath();
                bExist = true;
            }
        }

        if (!bExist) {
            File file = null;
            try {
                Collection col = CollectionHelper.getInstance().getCol(context);
                File storingDirectory = new File(col.getMedia().dir());
                file = File.createTempFile("ankidroid_audiorec", ".3gp", storingDirectory);
                tempAudioPath = file.getAbsolutePath();
            } catch (IOException e) {
                Timber.e("Could not create temporary audio file. " + e.getMessage());
                tempAudioPath = null;
            }
        }

        mAudioView = AudioView.createRecorderInstance(mActivity, R.drawable.av_play, R.drawable.av_pause,
                R.drawable.av_stop, R.drawable.av_rec, R.drawable.av_rec_stop, tempAudioPath);
        mAudioView.setOnRecordingFinishEventListener(new AudioView.OnRecordingFinishEventListener() {
            @Override
            public void onRecordingFinish(View v) {
                // currentFilePath.setText("Recording done, you can preview it. Hit save after finish");
                mField.setAudioPath(tempAudioPath);
                mField.setHasTemporaryMedia(true);
            }
        });
        layout.addView(mAudioView, LinearLayout.LayoutParams.FILL_PARENT);
    }


    @Override
    public void onDone() {
        mAudioView.notifyStopRecord();
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
    }

    @Override
    public void onFocusLost() {
        mAudioView.notifyReleaseRecorder();
    }


    @Override
    public void onDestroy() {
        mAudioView.notifyReleaseRecorder();
    }
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.fields;

public class BasicControllerFactory implements IControllerFactory {

    private BasicControllerFactory() {
    }


    public static IControllerFactory getInstance() {
        return new BasicControllerFactory();
    }


    @Override
    public IFieldController createControllerForField(IField field) {
        EFieldType type = field.getType();

        switch (type) {
            case TEXT:
                return new BasicTextFieldController();

            case IMAGE:
                return new BasicImageFieldController();

            case AUDIO:
                return new BasicAudioFieldController();

            default:

                break;
        }

        return null;
    }

}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.fields;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.net.Uri;
import android.provider.MediaStore;
import android.provider.MediaStore.MediaColumns;
import android.support.v4.content.FileProvider;
import android.util.DisplayMetrics;
import android.view.View;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.LinearLayout.LayoutParams;

import com.ichi2.anki.R;
import com.ichi2.compat.CompatHelper;
import com.ichi2.utils.BitmapUtil;
import com.ichi2.utils.ExifUtil;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

import timber.log.Timber;

public class BasicImageFieldController extends FieldControllerBase implements IFieldController {

    protected static final int ACTIVITY_SELECT_IMAGE = 1;
    protected static final int ACTIVITY_TAKE_PICTURE = 2;
    protected static final int IMAGE_PREVIEW_MAX_WIDTH = 100;
    private static final int IMAGE_SAVE_MAX_WIDTH = 1920;

    protected Button mBtnGallery;
    protected Button mBtnCamera;
    protected ImageView mImagePreview;

    protected String mTempCameraImagePath;
    private DisplayMetrics mMetrics = null;


    private int getMaxImageSize() {
        DisplayMetrics metrics = getDisplayMetrics();

        int height = metrics.heightPixels;
        int width = metrics.widthPixels;

        return (int) Math.min(height * 0.4, width * 0.6);
    }


    @Override
    public void createUI(Context context, LinearLayout layout) {
        mImagePreview = new ImageView(mActivity);

        DisplayMetrics metrics = getDisplayMetrics();

        int height = metrics.heightPixels;
        int width = metrics.widthPixels;

        LinearLayout.LayoutParams p = new LayoutParams(android.view.ViewGroup.LayoutParams.FILL_PARENT,
                android.view.ViewGroup.LayoutParams.WRAP_CONTENT);
        setPreviewImage(mField.getImagePath(), getMaxImageSize());
        mImagePreview.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
        mImagePreview.setAdjustViewBounds(true);

        mImagePreview.setMaxHeight((int) Math.round(height * 0.4));
        mImagePreview.setMaxWidth((int) Math.round(width * 0.6));

        mBtnGallery = new Button(mActivity);
        mBtnGallery.setText(gtxt(R.string.multimedia_editor_image_field_editing_galery));
        mBtnGallery.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent i = new Intent(Intent.ACTION_PICK, android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
                mActivity.startActivityForResult(i, ACTIVITY_SELECT_IMAGE);
            }
        });

        mBtnCamera = new Button(mActivity);
        mBtnCamera.setText(gtxt(R.string.multimedia_editor_image_field_editing_photo));
        mBtnCamera.setOnClickListener(new View.OnClickListener() {
            @SuppressLint("NewApi")
            @Override
            public void onClick(View v) {
                Intent cameraIntent = new Intent(android.provider.MediaStore.ACTION_IMAGE_CAPTURE);
                File image;
                File storageDir;
                String timeStamp = new SimpleDateFormat("yyyyMMddHHmmss", Locale.US).format(new Date());
                try {
                    storageDir = mActivity.getCacheDir();
                    image = File.createTempFile("img_" + timeStamp, ".jpg", storageDir);
                    mTempCameraImagePath = image.getPath();
                    Uri uriSavedImage = FileProvider.getUriForFile(mActivity,
                            mActivity.getApplicationContext().getPackageName() + ".apkgfileprovider",
                            image);

                    cameraIntent.putExtra(MediaStore.EXTRA_OUTPUT, uriSavedImage);
                    mActivity.startActivityForResult(cameraIntent, ACTIVITY_TAKE_PICTURE);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });
        // Chromebooks do not support camera capture yet.
        if (CompatHelper.isChromebook()) {
            mBtnCamera.setVisibility(View.INVISIBLE);
        }

        layout.addView(mImagePreview, android.view.ViewGroup.LayoutParams.FILL_PARENT, p);
        layout.addView(mBtnGallery, android.view.ViewGroup.LayoutParams.FILL_PARENT);
        layout.addView(mBtnCamera, android.view.ViewGroup.LayoutParams.FILL_PARENT);
    }


    private String gtxt(int id) {
        return mActivity.getText(id).toString();
    }


    protected DisplayMetrics getDisplayMetrics() {
        if (mMetrics == null) {
            mMetrics = new DisplayMetrics();
            mActivity.getWindowManager().getDefaultDisplay().getMetrics(mMetrics);
        }
        return mMetrics;
    }


    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (resultCode == Activity.RESULT_CANCELED) {
            // Do Nothing.
        } else if (requestCode == ACTIVITY_SELECT_IMAGE) {
            Uri selectedImage = data.getData();
            // Timber.d(selectedImage.toString());
            String[] filePathColumn = { MediaColumns.DATA };

            Cursor cursor = mActivity.getContentResolver().query(selectedImage, filePathColumn, null, null, null);
            cursor.moveToFirst();

            int columnIndex = cursor.getColumnIndex(filePathColumn[0]);
            String filePath = cursor.getString(columnIndex);
            cursor.close();

            mField.setImagePath(filePath);
        } else if (requestCode == ACTIVITY_TAKE_PICTURE) {
            String imagePath = rotateAndCompress(mTempCameraImagePath);
            mField.setImagePath(imagePath);
            mField.setHasTemporaryMedia(true);
        }
        setPreviewImage(mField.getImagePath(), getMaxImageSize());
    }

    @Override
    public void onFocusLost() {

    }


    @Override
    public void onDone() {
        //
    }


    private String rotateAndCompress(String inPath) {
        // Set the rotation of the camera image and save as png
        File f = new File(inPath);
        // use same filename but with png extension for output file
        String outPath = inPath.substring(0, inPath.lastIndexOf(".")) + ".png";
        // Load into a bitmap with max size of 1920 pixels and rotate if necessary
        Bitmap b = BitmapUtil.decodeFile(f, IMAGE_SAVE_MAX_WIDTH);
        FileOutputStream out = null;
        try {
            out = new FileOutputStream(outPath);
            b = ExifUtil.rotateFromCamera(f, b);
            b.compress(Bitmap.CompressFormat.PNG, 90, out);
            f.delete();
            return outPath;
        } catch (FileNotFoundException e) {
            Timber.e("Error in BasicImageFieldController.rotateAndCompress() : " + e.getMessage());
            return inPath;
        } finally {
            try {
                if (out != null) {
                    out.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }


    protected void setPreviewImage(String imagePath, int maxsize) {
        if (imagePath != null && !imagePath.equals("")) {
            // Caused bug on API <= 7
            // mImagePreview.setImageURI(Uri.fromFile(new File(imagePath)));

            // fix but crashes with out of memory
            // mImagePreview.setImageURI(Uri.parse(new File(imagePath).toString()));

            // fix for both
            File f = new File(imagePath);

            Bitmap b = BitmapUtil.decodeFile(f, maxsize);

            int currentapiVersion = android.os.Build.VERSION.SDK_INT;
            if (currentapiVersion >= android.os.Build.VERSION_CODES.ECLAIR) {
                b = ExifUtil.rotateFromCamera(f, b);
            }

            mImagePreview.setImageBitmap(b);
        }
    }


    @Override
    public void onDestroy() {
        ImageView imageView = mImagePreview;
        BitmapUtil.freeImageView(imageView);
    }

}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.fields;

import android.app.Activity;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.view.Gravity;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.LinearLayout.LayoutParams;
import android.widget.TextView;
import android.widget.Toast;

import com.ichi2.anki.R;
import com.ichi2.anki.multimediacard.activity.LoadPronounciationActivity;
import com.ichi2.anki.multimediacard.activity.PickStringDialogFragment;
import com.ichi2.anki.multimediacard.activity.TranslationActivity;
import com.ichi2.compat.CompatHelper;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

/**
 * One of the most powerful controllers - creates UI and works with the field of textual type.
 * <p>
 * Controllers work with the edit field activity and create UI on it to edit a field.
 */
public class BasicTextFieldController extends FieldControllerBase implements IFieldController,
        DialogInterface.OnClickListener {

    // Additional activities are started to perform translation/pronunciation search and
    // so on, here are their request codes, to differentiate, when they return.
    private static final int REQUEST_CODE_TRANSLATE_GLOSBE = 101;
    private static final int REQUEST_CODE_PRONOUNCIATION = 102;
    private static final int REQUEST_CODE_TRANSLATE_COLORDICT = 103;
    private static final int REQUEST_CODE_IMAGE_SEARCH = 104;

    private TextView mSearchLabel;
    private EditText mEditText;

    // This is used to copy from another field value to this field
    private ArrayList<String> mPossibleClones;


    @Override
    public void createUI(Context context, LinearLayout layout) {
        mEditText = new EditText(mActivity);
        mEditText.setMinLines(3);
        mEditText.setText(mField.getText());
        layout.addView(mEditText, LinearLayout.LayoutParams.FILL_PARENT);

        LinearLayout layoutTools = new LinearLayout(mActivity);
        layoutTools.setOrientation(LinearLayout.HORIZONTAL);
        layout.addView(layoutTools);

        LinearLayout.LayoutParams p = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.FILL_PARENT, 1);

        createCloneButton(layoutTools, p);
        createClearButton(layoutTools, p);
        // search label
        mSearchLabel = new TextView(mActivity);
        mSearchLabel.setText(R.string.multimedia_editor_text_field_editing_search_label);
        layout.addView(mSearchLabel);
        // search buttons
        LinearLayout layoutTools2 = new LinearLayout(mActivity);
        layoutTools2.setOrientation(LinearLayout.HORIZONTAL);
        layout.addView(layoutTools2);
        createTranslateButton(layoutTools2, p);
        createPronounceButton(layoutTools2, p);
    }


    private String gtxt(int id) {
        return mActivity.getText(id).toString();
    }



    private void createClearButton(LinearLayout layoutTools, LayoutParams p) {
        Button clearButton = new Button(mActivity);
        clearButton.setText(gtxt(R.string.multimedia_editor_text_field_editing_clear));
        layoutTools.addView(clearButton, p);

        clearButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                mEditText.setText("");

            }
        });
    }


    /**
     * @param layoutTools
     * @param p Button to load pronunciation from Beolingus
     */
    private void createPronounceButton(LinearLayout layoutTools, LayoutParams p) {
        Button btnPronounce = new Button(mActivity);
        btnPronounce.setText(gtxt(R.string.multimedia_editor_text_field_editing_say));
        btnPronounce.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                String source = mEditText.getText().toString();

                if (source.length() == 0) {
                    showToast(gtxt(R.string.multimedia_editor_text_field_editing_no_text));
                    return;
                }

                Intent intent = new Intent(mActivity, LoadPronounciationActivity.class);
                intent.putExtra(LoadPronounciationActivity.EXTRA_SOURCE, source);
                mActivity.startActivityForResult(intent, REQUEST_CODE_PRONOUNCIATION);
            }
        });

        layoutTools.addView(btnPronounce, p);
    }


    // Here is all the functionality to provide translations
    private void createTranslateButton(LinearLayout layoutTool, LayoutParams ps) {
        Button btnTranslate = new Button(mActivity);
        btnTranslate.setText(gtxt(R.string.multimedia_editor_text_field_editing_translate));
        btnTranslate.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                String source = mEditText.getText().toString();

                // Checks and warnings
                if (source.length() == 0) {
                    showToast(gtxt(R.string.multimedia_editor_text_field_editing_no_text));
                    return;
                }

                if (source.contains(" ")) {
                    showToast(gtxt(R.string.multimedia_editor_text_field_editing_many_words));
                }

                // Pick from two translation sources
                PickStringDialogFragment fragment = new PickStringDialogFragment();

                final ArrayList<String> translationSources = new ArrayList<>();
                translationSources.add("Glosbe.com");
                // Chromebooks do not support dependent apps yet.
                if (!CompatHelper.isChromebook()) {
                    translationSources.add("ColorDict");
                }

                fragment.setChoices(translationSources);
                fragment.setOnclickListener(new DialogInterface.OnClickListener() {

                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        String translationSource = translationSources.get(which);
                        if (translationSource.equals("Glosbe.com")) {
                            startTranslationWithGlosbe();
                        } else if (translationSource.equals("ColorDict")) {
                            startTranslationWithColorDict();
                        }
                    }
                });

                fragment.setTitle(gtxt(R.string.multimedia_editor_trans_pick_translation_source));

                fragment.show(mActivity.getSupportFragmentManager(), "pick.translation.source");
            }
        });

        layoutTool.addView(btnTranslate, ps);

        // flow continues in Start Translation with...

    }


    /**
     * @param layoutTools This creates a button, which will call a dialog, allowing to pick from another note's fields
     *            one, and use it's value in the current one.
     * @param p
     */
    private void createCloneButton(LinearLayout layoutTools, LayoutParams p) {
        // Makes sense only for two and more fields
        if (mNote.getNumberOfFields() > 1) {
            // Should be more than one text not empty fields for clone to make
            // sense

            mPossibleClones = new ArrayList<>();

            int numTextFields = 0;
            for (int i = 0; i < mNote.getNumberOfFields(); ++i) {
                // Sort out non text and empty fields
                IField curField = mNote.getField(i);
                if (curField == null) {
                    continue;
                }

                if (curField.getType() != EFieldType.TEXT) {
                    continue;
                }

                if (curField.getText() == null) {
                    continue;
                }

                if (curField.getText().length() == 0) {
                    continue;
                }

                // as well as the same field
                if (curField.getText().contentEquals(mField.getText())) {
                    continue;
                }

                // collect clone sources
                mPossibleClones.add(curField.getText());
                ++numTextFields;
            }

            // Nothing to clone from
            if (numTextFields < 1) {
                return;
            }

            Button btnOtherField = new Button(mActivity);
            btnOtherField.setText(gtxt(R.string.multimedia_editor_text_field_editing_clone));
            layoutTools.addView(btnOtherField, p);

            final BasicTextFieldController controller = this;

            btnOtherField.setOnClickListener(new OnClickListener() {

                @Override
                public void onClick(View v) {
                    PickStringDialogFragment fragment = new PickStringDialogFragment();

                    fragment.setChoices(mPossibleClones);
                    fragment.setOnclickListener(controller);
                    fragment.setTitle(gtxt(R.string.multimedia_editor_text_field_editing_clone_source));

                    fragment.show(mActivity.getSupportFragmentManager(), "pick.clone");

                    // flow continues in the onClick function

                }
            });

        }

    }


    /*
     * (non-Javadoc)
     * @see com.ichi2.anki.IFieldController#onActivityResult(int, int, android.content.Intent) When activity started
     * from here returns, the MultimediaEditFieldActivity passes control here back. And the results from the started before
     * activity are received.
     */
    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == REQUEST_CODE_TRANSLATE_GLOSBE && resultCode == Activity.RESULT_OK) {
            // Translation returned.
            try {
                String translation = data.getExtras().get(TranslationActivity.EXTRA_TRANSLATION).toString();
                mEditText.setText(translation);
            } catch (Exception e) {
                showToast(gtxt(R.string.multimedia_editor_trans_translation_failed));
            }
        } else if (requestCode == REQUEST_CODE_PRONOUNCIATION && resultCode == Activity.RESULT_OK) {
            try {
                String pronuncPath = data.getExtras().get(LoadPronounciationActivity.EXTRA_PRONUNCIATION_FILE_PATH)
                        .toString();
                File f = new File(pronuncPath);
                if (!f.exists()) {
                    showToast(gtxt(R.string.multimedia_editor_pron_pronunciation_failed));
                }

                AudioField af = new AudioField();
                af.setAudioPath(pronuncPath);
                // This is done to delete the file later.
                af.setHasTemporaryMedia(true);
                mActivity.handleFieldChanged(af);
            } catch (Exception e) {
                showToast(gtxt(R.string.multimedia_editor_pron_pronunciation_failed));
            }
        } else if (requestCode == REQUEST_CODE_TRANSLATE_COLORDICT && resultCode == Activity.RESULT_OK) {
            // String subject = data.getStringExtra(Intent.EXTRA_SUBJECT);
            String text = data.getStringExtra(Intent.EXTRA_TEXT);

            mEditText.setText(text);

        }
    }

    @Override
    public void onFocusLost() {

    }


    /**
     * @param context
     * @param intent
     * @return Needed to check, if the Color Dict is installed
     */
    public static boolean isIntentAvailable(Context context, Intent intent) {
        final PackageManager packageManager = context.getPackageManager();
        List<?> list = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);
        return list.size() > 0;
    }


    // When Done button is clicked
    @Override
    public void onDone() {
        mField.setText(mEditText.getText().toString());
    }


    // This is when the dialog for clone ends
    @Override
    public void onClick(DialogInterface dialog, int which) {
        mEditText.setText(mPossibleClones.get(which));
    }


    /**
     * @param text A short cut to show a toast
     */
    private void showToast(CharSequence text) {
        int duration = Toast.LENGTH_SHORT;
        Toast toast = Toast.makeText(mActivity, text, duration);
        toast.show();
    }


    // Only now not all APIs are used, may be later, they will be.
    @SuppressWarnings("unused")
    protected void startTranslationWithColorDict() {
        final String PICK_RESULT_ACTION = "colordict.intent.action.PICK_RESULT";
        final String SEARCH_ACTION = "colordict.intent.action.SEARCH";
        final String EXTRA_QUERY = "EXTRA_QUERY";
        final String EXTRA_FULLSCREEN = "EXTRA_FULLSCREEN";
        final String EXTRA_HEIGHT = "EXTRA_HEIGHT";
        final String EXTRA_WIDTH = "EXTRA_WIDTH";
        final String EXTRA_GRAVITY = "EXTRA_GRAVITY";
        final String EXTRA_MARGIN_LEFT = "EXTRA_MARGIN_LEFT";
        final String EXTRA_MARGIN_TOP = "EXTRA_MARGIN_TOP";
        final String EXTRA_MARGIN_BOTTOM = "EXTRA_MARGIN_BOTTOM";
        final String EXTRA_MARGIN_RIGHT = "EXTRA_MARGIN_RIGHT";

        Intent intent = new Intent(PICK_RESULT_ACTION);
        intent.putExtra(EXTRA_QUERY, mEditText.getText().toString()); // Search
                                                                      // Query
        intent.putExtra(EXTRA_FULLSCREEN, false); //
        // intent.putExtra(EXTRA_HEIGHT, 400); //400pixel, if you don't specify,
        // fill_parent"
        intent.putExtra(EXTRA_GRAVITY, Gravity.BOTTOM);
        // intent.putExtra(EXTRA_MARGIN_LEFT, 100);
        if (!isIntentAvailable(mActivity, intent)) {
            showToast(gtxt(R.string.multimedia_editor_trans_install_color_dict));
            return;
        }
        mActivity.startActivityForResult(intent, REQUEST_CODE_TRANSLATE_COLORDICT);
    }


    protected void startTranslationWithGlosbe() {
        String source = mEditText.getText().toString();

        Intent intent = new Intent(mActivity, TranslationActivity.class);
        intent.putExtra(TranslationActivity.EXTRA_SOURCE, source);
        mActivity.startActivityForResult(intent, REQUEST_CODE_TRANSLATE_GLOSBE);
    }


    @Override
    public void onDestroy() {
        // TODO Auto-generated method stub

    }

}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.fields;

/**
 * Type of the note field.
 */
public enum EFieldType {
    TEXT, // Just text
    IMAGE, // Just image
    AUDIO, // Just audio
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.fields;

/**
 * Base for all field types.
 * <p>
 * Controls modifications. This is done to not to save anything, if the field has not been modified.
 */
public class FieldBase {
    boolean mIsModified = false;


    void setThisModified() {
        mIsModified = true;
    }


    boolean getThisModified() {
        return mIsModified;
    }
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.fields;

import com.ichi2.anki.multimediacard.IMultimediaEditableNote;
import com.ichi2.anki.multimediacard.activity.MultimediaEditFieldActivity;

public abstract class FieldControllerBase implements IFieldController {

    protected MultimediaEditFieldActivity mActivity;
    protected IField mField;
    protected IMultimediaEditableNote mNote;
    protected int mIndex;


    @Override
    public void setField(IField field) {
        mField = field;
    }


    @Override
    public void setNote(IMultimediaEditableNote note) {
        mNote = note;
    }


    @Override
    public void setFieldIndex(int index) {
        mIndex = index;
    }


    @Override
    public void setEditingActivity(MultimediaEditFieldActivity activity) {
        mActivity = activity;
    };

}
/***********************************************import com.ichi2.anki.IFieldController;
import com.ichi2.anki.multimediacard.IField;
shrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.fields;

public interface IControllerFactory {

    IFieldController createControllerForField(IField field);

}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.fields;

import com.ichi2.libanki.Collection;

import java.io.Serializable;

/**
 * General interface for a field of any type.
 */
public interface IField extends Serializable {
    EFieldType getType();


    boolean setType(EFieldType type);


    boolean isModified();


    // For mixed type
    String getHtml();


    boolean setHtml(String html);


    // For image type. Resets type.
    // Makes no sense to call when type is not image.
    // the same for other groups below.
    boolean setImagePath(String pathToImage);


    String getImagePath();


    // For Audio type
    boolean setAudioPath(String pathToAudio);


    String getAudioPath();


    // For Text type
    String getText();


    boolean setText(String text);


    /**
     * Mark if the current media path is temporary and if it should be deleted once the media has been processed.
     * 
     * @param hasTemporaryMedia True if the media is temporary, False if it is existing media.
     * @return
     */
    public void setHasTemporaryMedia(boolean hasTemporaryMedia);


    public boolean hasTemporaryMedia();


    public String getName();


    public void setName(String name);


    /**
     * Returns the formatted value for this field. Each implementation of IField should return in a format which will be
     * used to store in the database
     * 
     * @return
     */
    public String getFormattedValue();


    void setFormattedString(Collection col, String value);
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.fields;

import android.content.Context;
import android.content.Intent;
import android.widget.LinearLayout;

import com.ichi2.anki.multimediacard.IMultimediaEditableNote;
import com.ichi2.anki.multimediacard.activity.MultimediaEditFieldActivity;

/**
 * A not in anki has fields. Each of the fields can be edited.
 * <p>
 * A controller is about to decide, which UI elements have to be on the activity and what has to be done there to edit a
 * field.
 * <p>
 * MultimediaEditFieldActivity calls controller's set methods by protocol before it works on UI creation.
 */
public interface IFieldController {
    // This is guaranteed to be called before create UI, so that the controller
    // is aware of the field, including type an content.
    void setField(IField field);


    // This is guaranteed to be called before create UI, so that the controller
    // is aware of the note.
    void setNote(IMultimediaEditableNote note);


    // This is guaranteed to be called before create UI, so that the controller
    // is aware of the field index in the note.
    void setFieldIndex(int index);


    // Called before other
    void setEditingActivity(MultimediaEditFieldActivity activity);


    // Layout is vertical inside a scroll view already
    void createUI(Context context, LinearLayout layout);


    // If the controller ever starts an activity for result, this is going to be
    // called back on result.
    void onActivityResult(int requestCode, int resultCode, Intent data);

    // Called when the controller has stopped showing the field in favor of another one
    void onFocusLost();

    // Is called to apply in the field new data from UI.
    void onDone();


    // Called to free memory
    void onDestroy();
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.fields;

import com.ichi2.libanki.Collection;

import java.io.File;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Field with an image.
 */
public class ImageField extends FieldBase implements IField {
    private static final long serialVersionUID = 4431611060655809687L;
    String mImagePath;
    private boolean mHasTemporaryMedia = false;
    private String mName;

    private static final String PATH_REGEX = "<img.*src=[\"'](.*)[\"'].*/?>";


    @Override
    public EFieldType getType() {
        return EFieldType.IMAGE;
    }


    @Override
    public boolean setType(EFieldType type) {
        return false;
    }


    @Override
    public boolean isModified() {
        return getThisModified();
    }


    @Override
    public String getHtml() {
        return null;
    }


    @Override
    public boolean setHtml(String html) {
        return false;
    }


    @Override
    public boolean setImagePath(String pathToImage) {
        mImagePath = pathToImage;
        setThisModified();
        return true;
    }


    @Override
    public String getImagePath() {
        return mImagePath;
    }


    @Override
    public boolean setAudioPath(String pathToAudio) {
        return false;
    }


    @Override
    public String getAudioPath() {
        return null;
    }


    @Override
    public String getText() {
        return null;
    }


    @Override
    public boolean setText(String text) {
        return false;
    }


    @Override
    public void setHasTemporaryMedia(boolean hasTemporaryMedia) {
        mHasTemporaryMedia = hasTemporaryMedia;
    }


    @Override
    public boolean hasTemporaryMedia() {
        return mHasTemporaryMedia;
    }


    @Override
    public String getName() {
        return mName;
    }


    @Override
    public void setName(String name) {
        mName = name;
    }


    @Override
    public String getFormattedValue() {
        File file = new File(getImagePath());
        if (file.exists()) {
            return String.format("<img src='%s'/>", file.getName());
        } else {
            return "";
        }
    }


    @Override
    public void setFormattedString(Collection col, String value) {
        Pattern p = Pattern.compile(PATH_REGEX);
        Matcher m = p.matcher(value);
        String res = "";
        if (m.find()) {
            res = m.group(1);
        }
        String mediaDir = col.getMedia().dir() + "/";
        setImagePath(mediaDir + res);
    }
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.fields;

import com.ichi2.libanki.Collection;

/**
 * Text Field implementation.
 */
public class TextField extends FieldBase implements IField {
    private static final long serialVersionUID = -6508967905716947525L;
    String mText = "";
    private String mName;


    @Override
    public EFieldType getType() {
        return EFieldType.TEXT;
    }


    @Override
    public boolean setType(EFieldType type) {
        return false;
    }


    @Override
    public boolean isModified() {
        return getThisModified();
    }


    @Override
    public String getHtml() {
        return null;
    }


    @Override
    public boolean setHtml(String html) {
        return false;
    }


    @Override
    public boolean setImagePath(String pathToImage) {
        return false;
    }


    @Override
    public String getImagePath() {
        return null;
    }


    @Override
    public boolean setAudioPath(String pathToAudio) {
        return false;
    }


    @Override
    public String getAudioPath() {
        return null;
    }


    @Override
    public String getText() {
        return mText;
    }


    @Override
    public boolean setText(String text) {
        mText = text;
        setThisModified();
        return true;
    }


    @Override
    public void setHasTemporaryMedia(boolean hasTemporaryMedia) {
    }


    @Override
    public boolean hasTemporaryMedia() {
        // TODO Auto-generated method stub
        return false;
    }


    @Override
    public String getName() {
        return mName;
    }


    @Override
    public void setName(String name) {
        mName = name;
    }


    @Override
    public String getFormattedValue() {
        return getText();
    }


    @Override
    public void setFormattedString(Collection col, String value) {
        mText = value;
    }
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.glosbe.json;

/**
 * This is one of the classes, automatically generated to transform json replies from glosbe.com
 */
public class Meaning {
    private String language;
    private String text;


    public String getLanguage() {
        return this.language;
    }


    public void setLanguage(String language) {
        this.language = language;
    }


    public String getText() {
        return this.text;
    }


    public void setText(String text) {
        this.text = text;
    }
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.glosbe.json;

/**
 * This is one of the classes, automatically generated to transform json replies from glosbe.com
 */
public class Phrase {
    private String language;
    private String text;


    public String getLanguage() {
        return this.language;
    }


    public void setLanguage(String l) {
        this.language = l;
    }


    public String getText() {
        return this.text;
    }


    public void setText(String text) {
        this.text = text;
    }
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.glosbe.json;

import java.util.List;

/**
 * @author zaur This is one of the classes, automatically generated to transform json replies from glosbe.com This is
 *         the root class, from which response starts.
 */
public class Response {
    private String dest;
    private String from;
    private String phrase;
    private String result;
    private List<Tuc> tuc;


    public String getDest() {
        return this.dest;
    }


    public void setDest(String dest) {
        this.dest = dest;
    }


    public String getFrom() {
        return this.from;
    }


    public void setFrom(String from) {
        this.from = from;
    }


    public String getPhrase() {
        return this.phrase;
    }


    public void setPhrase(String phrase) {
        this.phrase = phrase;
    }


    public String getResult() {
        return this.result;
    }


    public void setResult(String result) {
        this.result = result;
    }


    public List<Tuc> getTuc() {
        return this.tuc;
    }


    public void setTuc(List<Tuc> tuc) {
        this.tuc = tuc;
    }
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.glosbe.json;

import java.util.List;

/**
 * This is one of the classes, automatically generated to transform json replies from glosbe.com
 */
public class Tuc {
    private List<Number> authors;
    private Number meaningId;
    private List<Meaning> meanings;
    private Phrase phrase;


    public List<Number> getAuthors() {
        return this.authors;
    }


    public void setAuthors(List<Number> authors) {
        this.authors = authors;
    }


    public Number getMeaningId() {
        return this.meaningId;
    }


    public void setMeaningId(Number meaningId) {
        this.meaningId = meaningId;
    }


    public List<Meaning> getMeanings() {
        return this.meanings;
    }


    public void setMeanings(List<Meaning> meanings) {
        this.meanings = meanings;
    }


    public Phrase getPhrase() {
        return this.phrase;
    }


    public void setPhrase(Phrase phrase) {
        this.phrase = phrase;
    }
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.impl;

import com.ichi2.anki.multimediacard.IMultimediaEditableNote;
import com.ichi2.anki.multimediacard.fields.IField;

import java.util.ArrayList;

/**
 * Implementation of the editable note.
 * <p>
 * Has to be translate to and from anki db format.
 */

public class MultimediaEditableNote implements IMultimediaEditableNote {
    private static final long serialVersionUID = -6161821367135636659L;
    boolean mIsModified = false;

    ArrayList<IField> mFields;
    private long mModelId;


    public void circularSwap() {
        if (mFields == null) {
            return;
        }

        if (mFields.size() <= 1) {
            return;
        }

        ArrayList<IField> newFields = new ArrayList<>();
        newFields.add(mFields.get(mFields.size() - 1));
        newFields.addAll(mFields);
        newFields.remove(mFields.size());

        mFields = newFields;
    }


    void setThisModified() {
        mIsModified = true;
    }


    @Override
    public boolean isModified() {
        return mIsModified;
    }


    // package
    public void setNumFields(int numberOfFields) {
        getFieldsPrivate().clear();
        for (int i = 0; i < numberOfFields; ++i) {
            getFieldsPrivate().add(null);
        }
    }


    private ArrayList<IField> getFieldsPrivate() {
        if (mFields == null) {
            mFields = new ArrayList<>();
        }

        return mFields;
    }


    @Override
    public int getNumberOfFields() {
        return getFieldsPrivate().size();
    }


    @Override
    public IField getField(int index) {
        if (index >= 0 && index < getNumberOfFields()) {
            return getFieldsPrivate().get(index);
        }
        return null;
    }


    @Override
    public boolean setField(int index, IField field) {
        if (index >= 0 && index < getNumberOfFields()) {
            // If the same unchanged field is set.
            if (getField(index) == field) {
                if (field.isModified()) {
                    setThisModified();
                }
            } else {
                setThisModified();
            }

            getFieldsPrivate().set(index, field);

            return true;
        }
        return false;
    }


    public void setModelId(long modelId) {
        mModelId = modelId;
    }


    public long getModelId() {
        return mModelId;
    }

}
/**
 * @author Zaur
 */

package com.ichi2.anki.multimediacard.impl;

import com.ichi2.anki.multimediacard.IMultimediaEditableNote;
import com.ichi2.anki.multimediacard.fields.ImageField;
import com.ichi2.anki.multimediacard.fields.TextField;

/**
 * Creates IMultimediaEditableNotes according to various parameters.
 */
public class NoteFactory {
    public static IMultimediaEditableNote createNote() {
        MultimediaEditableNote note = new MultimediaEditableNote();
        note.setNumFields(4);

        TextField tf = new TextField();
        tf.setText("world");
        note.setField(0, tf);

        TextField tf2 = new TextField();
        tf2.setText("Welt");
        note.setField(1, tf2);

        TextField tf3 = new TextField();
        tf3.setText("脺bung");
        note.setField(2, tf3);

        ImageField imageField = new ImageField();
        imageField.setImagePath("/mnt/sdcard/img/1.jpg");
        note.setField(3, imageField);

        return note;
    }

}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.language;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;

/**
 * This is some sort of tool, which translates from languages in a user readable form to a code, used to invoke some
 * service. This code depends on service, of course.
 * <p>
 * Specific language listers derive from this one.
 */
public class LanguageListerBase {

    protected HashMap<String, String> mLanguageMap;


    public LanguageListerBase() {
        mLanguageMap = new HashMap<>();
    }


    /**
     * @param name
     * @param code This one has to be used in constructor to fill the hash map.
     */
    protected void addLanguage(String name, String code) {
        mLanguageMap.put(name, code);
    }


    public String getCodeFor(String Language) {
        if (mLanguageMap.containsKey(Language)) {
            return mLanguageMap.get(Language);
        }

        return null;
    }


    public ArrayList<String> getLanguages() {
        ArrayList<String> res = new ArrayList<>();
        res.addAll(mLanguageMap.keySet());
        Collections.sort(res, new Comparator<String>() {
            @Override
            public int compare(String text1, String text2) {
                return text1.compareToIgnoreCase(text2);
            }
        });
        return res;
    }

}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.language;

import android.content.Context;

import java.util.Locale;

/**
 * This one listers services in beolingus.
 * <p>
 * It is used to load pronunciation.
 */
public class LanguageListerBeolingus extends LanguageListerBase {

    public LanguageListerBeolingus(Context context) {
        super();

        addLanguage((new Locale("eng")).getDisplayLanguage() , "en-de");
        addLanguage((new Locale("deu")).getDisplayLanguage(), "deen");
        addLanguage((new Locale("spa")).getDisplayLanguage(), "es-de");
        // Seems to have no pronunciation yet
        // addLanguage(context.getString(R.string.multimedia_editor_languages_portuguese), "pt-de");
    }

}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.language;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;

public class LanguagesLister {
    HashMap<String, String> mLanguageMap;


    LanguagesLister() {
        mLanguageMap = new HashMap<>();

        mLanguageMap.put("Mandarin", "cmn");
        mLanguageMap.put("Spanish", "spa");
        mLanguageMap.put("English", "eng");
        mLanguageMap.put("Nepali", "nep");
        mLanguageMap.put("Russian", "rus");
        mLanguageMap.put("German", "deu");
        mLanguageMap.put("Slovak", "slk");

    }


    public String getCodeFor(String Language) {
        if (mLanguageMap.containsKey(Language)) {
            return mLanguageMap.get(Language);
        }

        return null;
    }


    public ArrayList<String> getLanguages() {
        ArrayList<String> res = new ArrayList<>();
        res.addAll(mLanguageMap.keySet());
        Collections.sort(res, new Comparator<String>() {
            @Override
            public int compare(String text1, String text2) {
                return text1.compareToIgnoreCase(text2);
            }
        });
        return res;
    }

}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 * Copyright (c) 2014 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.language;

import java.util.HashMap;
import java.util.Locale;

import android.content.Context;

/**
 * This language lister is used to call glosbe.com translation services.
 * <p>
 * Glosbe expects the languages to follow the ISO 639-3 codes.
 * <p>
 * It can be extended freely here, to support more languages.
 */
public class LanguagesListerGlosbe extends LanguageListerBase {
    public LanguagesListerGlosbe(Context context) {
        final String [] languages ={"eng", "deu", "jpn", "fra", "spa", "pol", "ita", "rus",
            "ces", "zho", "nld", "por", "swe", "hrv", "hin", "hun", "vie", "ara", "tur"};
        // Java Locale uses ISO 639-2 rather than 639-3 so we currently only support the subset of
        // the languages on Glosbe which are in ISO 639-2. "Chinese Mandarin" ("cmn") for example
        // is not supported, but "Chinese" ("zho") is.
        for (String l : languages) {
            Locale locale = new Locale(l);
            addLanguage(locale.getDisplayLanguage(), locale.getISO3Language());
        }
    }

    private static HashMap<String, Locale> locale_map = null;

    /**
     * Convert from 3 letter ISO 639-2 language code to ISO 639-1
     * @param req 3 letter language code
     * @return 2 letter language code
     */
    public static String requestToResponseLangCode(String req) {
        if (locale_map == null) {
            String[] languages = Locale.getISOLanguages();
            locale_map = new HashMap<>(languages.length);
            for (String language : languages) {
                Locale locale = new Locale(language);
                locale_map.put(locale.getISO3Language(), locale);
            }
        }
        return locale_map.get(req).getLanguage();
    }
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.test;

import com.ichi2.anki.multimediacard.IMultimediaEditableNote;
import com.ichi2.anki.multimediacard.fields.ImageField;
import com.ichi2.anki.multimediacard.fields.TextField;
import com.ichi2.anki.multimediacard.impl.MultimediaEditableNote;

/**
 * Made for tests
 */
public class MockNoteFactory {
    public static IMultimediaEditableNote makeNote() {
        MultimediaEditableNote note = new MultimediaEditableNote();
        note.setNumFields(4);

        TextField tf = new TextField();
        tf.setText("world");
        note.setField(0, tf);

        TextField tf2 = new TextField();
        tf2.setText("Welt");
        note.setField(1, tf2);

        TextField tf3 = new TextField();
        tf3.setText("脺bung");
        note.setField(2, tf3);

        ImageField imageField = new ImageField();
        imageField.setImagePath("/mnt/sdcard/img/1.jpg");
        note.setField(3, imageField);

        return note;
    }
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.test;

/**
 * This is a class used for tests actually
 */
public class MockPronounciationPageFetcher {

    public static String get() {
        return "        <param name=\"BGCOLOR\" value=\"#FFFFFF\" />"
                + "        <embed src=\"wimpy_button.swf?theFile=/speak-de/4/0/yNuwm9F0njM.mp3&autoplay=yes&loopMe=no\""
                + "        width=\"30\" height=\"30\" quality=\"high\" bgcolor=\"#FFFFFF\""
                + "        pluginspage=\"http://www.macromedia.com/go/getflashplayer\""
                + "        type=\"application/x-shockwave-flash\""
                + "        /></object>"
                + "       <strong></strong></td>"
                + "                   <td style=\"vertical-align: middle;\"><strong>Welt</strong></td>"
                + "                 </tr>"
                + "                 <tr class=\"air\"><td>&nbsp;</td><td><div>&nbsp;</div></td>"
                + "                 </tr>"
                + "                 <tr>"
                + "                   <td>&nbsp;</td>"
                + "                   <td><a href=\"/speak-de/4/0/yNuwm9F0njM.mp3\">Listen with your<br />default MP3 player</a></td>"
                + "                 </tr>" + "               </tbody>" + "             </table>" + "             </td>"
                + "           </tr>" + "           <tr>" + "             <td>&nbsp;</td>"
                + "             <td style=\"text-align:center";
    }
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.multimediacard.test;

/**
 * class for tests
 */
public class MockTranslationFetcher {
    public static String get() {
        return

        "<td class=\"r\"><a href=\"/deutsch-englisch/Welt.html\" onclick=\"return m('Welt',this,'l1');\" ondblclick=\"return d(this);\"><b>Welt</b></a> <span title=\"noun, feminine (die)\">{f}</span>   <a href=\"/dings.cgi?speak=de/4/0/yNuwm9F0njM;text=Welt\" onclick=\"return s(this)\" onmouseover=\"return u('Welt')\"><img src=\"/pics/s1.png\" width=\"16\" height=\"16\" alt=\"[listen]\" title=\"Welt\" border=\"0\" align=\"top\" /></a></td>"
                + "                <td class=\"r\"><a href=\"/english-german/world.html\" onclick=\"return m('world',this,'l2');\" ondblclick=\"return d(this);\">world</a>   <a href=\"/dings.cgi?speak=en/8/5/emUMgGzviSg;text=world\" onclick=\"return s(this)\" onmouseover=\"return u('world')\"><img src=\"/pics/s1.png\" width=\"16\" height=\"16\" alt=\"[listen]\" title=\"world\" border=\"0\" align=\"top\" /></a></td><td><a href=\"#\" onclick=\"return vi('Welt {f}','world','Welt','de','en',this);\"><img src=\"/pics/v.png\" /></a></td>"
                + ""
                + "                </tr>"
                + "                </tbody>"
                + "                <tbody id=\"b1\" class=\"n\">"
                + "                <tr class=\"s1 c\">"
                + "                <td align=\"right\"><br /></td>"
                + "                <td class=\"f\"> <a href=\"/deutsch-englisch/Welten.html\" onclick=\"return m('Welten',this,'l1');\" ondblclick=\"return d(this);\"><b>Welt</b>en</a> <span title=\"noun, plural (die)\">{pl}</span> </td>"
                + "                <td class=\"f\"> <a href=\"/english-german/worlds.html\" onclick=\"return m('worlds',this,'l2');\" ondblclick=\"return d(this);\">worlds</a> </td><td><a href=\"#\" onclick=\"return vi('Welten {pl}','worlds','Welt','de','en',this);\"><img src=\"/pics/v.png\" /></a></td>"
                + "" + "                </tr>";

    }
}
/***************************************************************************************
 *                                                                                      *
 * Copyright (c) 2015 Frank Oltmanns <frank.oltmanns@gmail.com>                         *
 * Copyright (c) 2015 Timothy Rae <timothy.rae@gmail.com>                               *
 * Copyright (c) 2016 Mark Carter <mark@marcardar.com>                                  *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.provider;

import android.content.ContentProvider;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.UriMatcher;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.net.Uri;
import android.os.Binder;
import android.os.Build;
import android.support.annotation.Nullable;
import android.text.TextUtils;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.BuildConfig;
import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.FlashCardsContract;
import com.ichi2.anki.FlashCardsContract.CardTemplate;
import com.ichi2.anki.exception.ConfirmModSchemaException;
import com.ichi2.compat.CompatHelper;
import com.ichi2.libanki.Card;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.DB;
import com.ichi2.libanki.Models;
import com.ichi2.libanki.Note;
import com.ichi2.libanki.Sched;
import com.ichi2.libanki.Utils;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import io.requery.android.database.sqlite.SQLiteDatabase;
import timber.log.Timber;

import static com.ichi2.anki.FlashCardsContract.READ_WRITE_PERMISSION;

/**
 * Supported URIs:
 * .../notes (search for notes)
 * .../notes/# (direct access to note)
 * .../notes/#/cards (access cards of note)
 * .../notes/#/cards/# (access specific card of note)
 * .../models (search for models)
 * .../models/# (direct access to model). String id 'current' can be used in place of # for the current model
 * .../models/#/fields (access to field definitions of a model)
 * .../models/#/templates (access to card templates of a model)
 * .../schedule (access the study schedule)
 * .../decks (access the deck list)
 * .../decks/# (access the specified deck)
 * .../selected_deck (access the currently selected deck)
 * <p/>
 * Note that unlike Android's contact providers:
 * <ul>
  * <li>it's not possible to access cards of more than one note at a time</li>
 * <li>it's not possible to access cards of a note without providing the note's ID</li>
 * </ul>
 */
public class CardContentProvider extends ContentProvider {
    private Context mContext;

    /* URI types */
    private static final int NOTES = 1000;
    private static final int NOTES_ID = 1001;
    private static final int NOTES_ID_CARDS = 1003;
    private static final int NOTES_ID_CARDS_ORD = 1004;
    private static final int NOTES_V2 = 1005;
    private static final int MODELS = 2000;
    private static final int MODELS_ID = 2001;
    private static final int MODELS_ID_EMPTY_CARDS = 2002;
    private static final int MODELS_ID_TEMPLATES = 2003;
    private static final int MODELS_ID_TEMPLATES_ID = 2004;
    private static final int MODELS_ID_FIELDS = 2005;
    private static final int SCHEDULE = 3000;
    private static final int DECKS = 4000;
    private static final int DECK_SELECTED = 4001;
    private static final int DECKS_ID = 4002;

    private static final UriMatcher sUriMatcher =
            new UriMatcher(UriMatcher.NO_MATCH);

    static {
        // Here you can see all the URIs at a glance
        sUriMatcher.addURI(FlashCardsContract.AUTHORITY, "notes", NOTES);
        sUriMatcher.addURI(FlashCardsContract.AUTHORITY, "notes_v2", NOTES_V2);
        sUriMatcher.addURI(FlashCardsContract.AUTHORITY, "notes/#", NOTES_ID);
        sUriMatcher.addURI(FlashCardsContract.AUTHORITY, "notes/#/cards", NOTES_ID_CARDS);
        sUriMatcher.addURI(FlashCardsContract.AUTHORITY, "notes/#/cards/#", NOTES_ID_CARDS_ORD);
        sUriMatcher.addURI(FlashCardsContract.AUTHORITY, "models", MODELS);
        sUriMatcher.addURI(FlashCardsContract.AUTHORITY, "models/*", MODELS_ID); // the model ID can also be "current"
        sUriMatcher.addURI(FlashCardsContract.AUTHORITY, "models/*/empty_cards", MODELS_ID_EMPTY_CARDS);
        sUriMatcher.addURI(FlashCardsContract.AUTHORITY, "models/*/templates", MODELS_ID_TEMPLATES);
        sUriMatcher.addURI(FlashCardsContract.AUTHORITY, "models/*/templates/#", MODELS_ID_TEMPLATES_ID);
        sUriMatcher.addURI(FlashCardsContract.AUTHORITY, "models/*/fields", MODELS_ID_FIELDS);
        sUriMatcher.addURI(FlashCardsContract.AUTHORITY, "schedule/", SCHEDULE);
        sUriMatcher.addURI(FlashCardsContract.AUTHORITY, "decks/", DECKS);
        sUriMatcher.addURI(FlashCardsContract.AUTHORITY, "decks/#", DECKS_ID);
        sUriMatcher.addURI(FlashCardsContract.AUTHORITY, "selected_deck/", DECK_SELECTED);
    }

    /**
     * The names of the columns returned by this content provider differ slightly from the names
     * given of the database columns. This list is used to convert the column names used in a
     * projection by the user into DB column names.
     * <p/>
     * This is currently only "_id" (projection) vs. "id" (Anki DB). But should probably be
     * applied to more columns. "MID", "USN", "MOD" are not really user friendly.
     */
    private static final String[] sDefaultNoteProjectionDBAccess = FlashCardsContract.Note.DEFAULT_PROJECTION.clone();
    private static final String COL_NULL_ERROR_MSG = "AnkiDroid database inaccessible. Open AnkiDroid to see what's wrong.";

    static {
        for (int idx = 0; idx < sDefaultNoteProjectionDBAccess.length; idx++) {
            if (sDefaultNoteProjectionDBAccess[idx].equals(FlashCardsContract.Note._ID)) {
                sDefaultNoteProjectionDBAccess[idx] = "id as _id";
            }
        }
    }

    @Override
    public boolean onCreate() {
        // Initialize content provider on startup.
        Timber.d("CardContentProvider: onCreate");
        mContext = getContext();
        return true;
    }

    @Override
    public String getType(Uri uri) {
        // Find out what data the user is requesting
        int match = sUriMatcher.match(uri);

        switch (match) {
            case NOTES_V2:
            case NOTES:
                return FlashCardsContract.Note.CONTENT_TYPE;
            case NOTES_ID:
                return FlashCardsContract.Note.CONTENT_ITEM_TYPE;
            case NOTES_ID_CARDS:
                return FlashCardsContract.Card.CONTENT_TYPE;
            case NOTES_ID_CARDS_ORD:
                return FlashCardsContract.Card.CONTENT_ITEM_TYPE;
            case MODELS:
                return FlashCardsContract.Model.CONTENT_TYPE;
            case MODELS_ID:
                return FlashCardsContract.Model.CONTENT_ITEM_TYPE;
            case MODELS_ID_EMPTY_CARDS:
                return FlashCardsContract.Card.CONTENT_TYPE;
            case MODELS_ID_TEMPLATES:
                return FlashCardsContract.CardTemplate.CONTENT_TYPE;
            case MODELS_ID_TEMPLATES_ID:
                return FlashCardsContract.CardTemplate.CONTENT_ITEM_TYPE;
            case SCHEDULE:
                return FlashCardsContract.ReviewInfo.CONTENT_TYPE;
            case DECKS:
                return FlashCardsContract.Deck.CONTENT_TYPE;
            case DECKS_ID:
                return FlashCardsContract.Deck.CONTENT_TYPE;
            case DECK_SELECTED:
                return FlashCardsContract.Deck.CONTENT_TYPE;
            default:
                // Unknown URI type
                throw new IllegalArgumentException("uri " + uri + " is not supported");
        }
    }

    /** Only enforce permissions for queries and inserts on Android M and above, or if its a 'rogue client' **/
    private boolean shouldEnforceQueryOrInsertSecurity() {
        return CompatHelper.isMarshmallow() || knownRogueClient();
    }
    /** Enforce permissions for all updates on Android M and above. Otherwise block depending on URI and client app **/
    private boolean shouldEnforceUpdateSecurity(Uri uri) {
        final List<Integer> WHITELIST = Arrays.asList(NOTES_ID_CARDS_ORD, MODELS_ID, MODELS_ID_TEMPLATES_ID, SCHEDULE, DECK_SELECTED);
        return CompatHelper.isMarshmallow() || !WHITELIST.contains(sUriMatcher.match(uri)) || knownRogueClient();
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String order) {
        if (!hasReadWritePermission() && shouldEnforceQueryOrInsertSecurity()) {
            throwSecurityException("query", uri);
        }

        Collection col = CollectionHelper.getInstance().getCol(mContext);
        if (col == null) {
            throw new IllegalStateException(COL_NULL_ERROR_MSG);
        }
        Timber.d(getLogMessage("query", uri));

        // Find out what data the user is requesting
        int match = sUriMatcher.match(uri);

        switch (match) {
            case NOTES_V2: {
                /* Search for notes using direct SQL query */
                String[] proj = sanitizeNoteProjection(projection);
                return col.getDb().getDatabase().query("notes", proj, selection, selectionArgs, null, null, order);
            }
            case NOTES: {
                /* Search for notes using the libanki browser syntax */
                String[] proj = sanitizeNoteProjection(projection);
                String query = (selection != null) ? selection : "";
                List<Long> noteIds = col.findNotes(query);
                if ((noteIds != null) && (!noteIds.isEmpty())) {
                    String sel = String.format("id in (%s)", TextUtils.join(",", noteIds));
                    return col.getDb().getDatabase().query("notes", proj, sel, null, null, null, order);
                } else {
                    return null;
                }
            }
            case NOTES_ID: {
                /* Direct access note with specific ID*/
                String noteId = uri.getPathSegments().get(1);
                String[] proj = sanitizeNoteProjection(projection);
                return col.getDb().getDatabase().query("notes", proj, "id=?", new String[]{noteId}, null, null, order);
            }

            case NOTES_ID_CARDS: {
                Note currentNote = getNoteFromUri(uri, col);
                String[] columns = ((projection != null) ? projection : FlashCardsContract.Card.DEFAULT_PROJECTION);
                MatrixCursor rv = new MatrixCursor(columns, 1);
                for (Card currentCard : currentNote.cards()) {
                    addCardToCursor(currentCard, rv, col, columns);
                }
                return rv;
            }
            case NOTES_ID_CARDS_ORD: {
                Card currentCard = getCardFromUri(uri, col);
                String[] columns = ((projection != null) ? projection : FlashCardsContract.Card.DEFAULT_PROJECTION);
                MatrixCursor rv = new MatrixCursor(columns, 1);
                addCardToCursor(currentCard, rv, col, columns);
                return rv;
            }
            case MODELS: {
                Models models = col.getModels();
                String[] columns = ((projection != null) ? projection : FlashCardsContract.Model.DEFAULT_PROJECTION);
                MatrixCursor rv = new MatrixCursor(columns, 1);
                for (Long modelId : models.getModels().keySet()) {
                    addModelToCursor(modelId, models, rv, columns);
                }
                return rv;
            }
            case MODELS_ID: {
                long modelId = getModelIdFromUri(uri, col);
                String[] columns = ((projection != null) ? projection : FlashCardsContract.Model.DEFAULT_PROJECTION);
                MatrixCursor rv = new MatrixCursor(columns, 1);
                addModelToCursor(modelId, col.getModels(), rv, columns);
                return rv;
            }
            case MODELS_ID_TEMPLATES: {
                /* Direct access model templates */
                Models models = col.getModels();
                JSONObject currentModel = models.get(getModelIdFromUri(uri, col));
                String[] columns = ((projection != null) ? projection : CardTemplate.DEFAULT_PROJECTION);
                MatrixCursor rv = new MatrixCursor(columns, 1);
                try {
                    JSONArray templates = currentModel.getJSONArray("tmpls");
                    for (int idx = 0; idx < templates.length(); idx++) {
                        JSONObject template = templates.getJSONObject(idx);
                        addTemplateToCursor(template, currentModel, idx+1, models, rv, columns);
                    }
                } catch (JSONException e) {
                    throw new IllegalArgumentException("Model is malformed", e);
                }
                return rv;
            }
            case MODELS_ID_TEMPLATES_ID: {
                /* Direct access model template with specific ID */
                Models models = col.getModels();
                int ord = Integer.parseInt(uri.getLastPathSegment());
                JSONObject currentModel = models.get(getModelIdFromUri(uri, col));
                String[] columns = ((projection != null) ? projection : CardTemplate.DEFAULT_PROJECTION);
                MatrixCursor rv = new MatrixCursor(columns, 1);
                try {
                    JSONObject template = getTemplateFromUri(uri, col);
                    addTemplateToCursor(template, currentModel, ord+1, models, rv, columns);
                } catch (JSONException e) {
                    throw new IllegalArgumentException("Model is malformed", e);
                }
                return rv;
            }

            case SCHEDULE: {
                String[] columns = ((projection != null) ? projection : FlashCardsContract.ReviewInfo.DEFAULT_PROJECTION);
                MatrixCursor rv = new MatrixCursor(columns, 1);
                long selectedDeckBeforeQuery = col.getDecks().selected();
                long deckIdOfTemporarilySelectedDeck = -1;
                int limit = 1; //the number of scheduled cards to return
                int selectionArgIndex = 0;

                //parsing the selection arguments
                if (selection != null) {
                    String[] args = selection.split(","); //split selection to get arguments like "limit=?"
                    for (String arg : args) {
                        String[] keyAndValue = arg.split("="); //split arguments into key ("limit") and value ("?")
                        try {
                            //check if value is a placeholder ("?"), if so replace with the next value of selectionArgs
                            String value = keyAndValue[1].trim().equals("?") ? selectionArgs[selectionArgIndex++] :
                                    keyAndValue[1];
                            if (keyAndValue[0].trim().equals("limit")) {
                                limit = Integer.valueOf(value);
                            } else if (keyAndValue[0].trim().equals("deckID")) {
                                deckIdOfTemporarilySelectedDeck = Long.valueOf(value);
                                if(!selectDeckWithCheck(col, deckIdOfTemporarilySelectedDeck)){
                                    return rv; //if the provided deckID is wrong, return empty cursor.
                                }
                            }
                        } catch (NumberFormatException nfe) {
                            nfe.printStackTrace();
                        }
                    }
                }

                //retrieve the number of cards provided by the selection parameter "limit"
                col.getSched().reset();
                for (int k = 0; k< limit; k++){
                    Card currentCard = col.getSched().getCard();

                    if (currentCard != null) {
                        int buttonCount = col.getSched().answerButtons(currentCard);
                        JSONArray buttonTexts = new JSONArray();
                        for (int i = 0; i < buttonCount; i++) {
                            buttonTexts.put(col.getSched().nextIvlStr(mContext, currentCard, i + 1));
                        }
                        addReviewInfoToCursor(currentCard, buttonTexts, buttonCount, rv, col, columns);
                    }else{
                        break;
                    }
                }

                if (deckIdOfTemporarilySelectedDeck != -1) {//if the selected deck was changed
                    //change the selected deck back to the one it was before the query
                    col.getDecks().select(selectedDeckBeforeQuery);
                }
                return rv;
            }
            case DECKS: {
                List<Sched.DeckDueTreeNode> allDecks = col.getSched().deckDueList();
                String[] columns = ((projection != null) ? projection : FlashCardsContract.Deck.DEFAULT_PROJECTION);
                MatrixCursor rv = new MatrixCursor(columns, allDecks.size());
                for (Sched.DeckDueTreeNode deck : allDecks) {
                    long id = deck.did;
                    String name = deck.names[0];
                    addDeckToCursor(id, name, getDeckCountsFromDueTreeNode(deck), rv, col, columns);
                }
                return rv;
            }
            case DECKS_ID: {
                /* Direct access deck */
                String[] columns = ((projection != null) ? projection : FlashCardsContract.Deck.DEFAULT_PROJECTION);
                MatrixCursor rv = new MatrixCursor(columns, 1);
                List<Sched.DeckDueTreeNode> allDecks = col.getSched().deckDueList();
                long deckId;
                deckId = Long.parseLong(uri.getPathSegments().get(1));
                for (Sched.DeckDueTreeNode deck : allDecks) {
                    if(deck.did == deckId){
                        addDeckToCursor(deckId, deck.names[0], getDeckCountsFromDueTreeNode(deck), rv, col, columns);
                        return rv;
                    }
                }
                return rv;
            }
            case DECK_SELECTED: {
                long id = col.getDecks().selected();
                String name = col.getDecks().name(id);
                String[] columns = ((projection != null) ? projection : FlashCardsContract.Deck.DEFAULT_PROJECTION);
                MatrixCursor rv = new MatrixCursor(columns, 1);
                JSONArray counts = new JSONArray(col.getSched().countsList());
                addDeckToCursor(id, name, counts,rv, col, columns);
                return rv;
            }
            default:
                // Unknown URI type
                throw new IllegalArgumentException("uri " + uri + " is not supported");
        }
    }

    private JSONArray getDeckCountsFromDueTreeNode(Sched.DeckDueTreeNode deck){
        JSONArray deckCounts = new JSONArray();
        deckCounts.put(deck.lrnCount);
        deckCounts.put(deck.revCount);
        deckCounts.put(deck.newCount);
        return deckCounts;
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
        if (!hasReadWritePermission() && shouldEnforceUpdateSecurity(uri)) {
            throwSecurityException("update", uri);
        }
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        if (col == null) {
            throw new IllegalStateException(COL_NULL_ERROR_MSG);
        }
        col.log(getLogMessage("update", uri));

        // Find out what data the user is requesting
        int match = sUriMatcher.match(uri);
        int updated = 0; // Number of updated entries (return value)
        switch (match) {
            case NOTES_V2:
            case NOTES:
                throw new IllegalArgumentException("Not possible to update notes directly (only through data URI)");
            case NOTES_ID: {
                /* Direct access note details
                 */
                Note currentNote = getNoteFromUri(uri, col);
                // the key of the ContentValues contains the column name
                // the value of the ContentValues contains the row value.
                Set<Map.Entry<String, Object>> valueSet = values.valueSet();
                for (Map.Entry<String, Object> entry : valueSet) {
                    String key = entry.getKey();
                    // when the client does not specify FLDS, then don't update the FLDS
                    if (key.equals(FlashCardsContract.Note.FLDS)) {
                        // Update FLDS
                        Timber.d("CardContentProvider: flds update...");
                        String newFldsEncoded = (String) entry.getValue();
                        String[] flds = Utils.splitFields(newFldsEncoded);
                        // Check that correct number of flds specified
                        if (flds.length != currentNote.getFields().length) {
                            throw new IllegalArgumentException("Incorrect flds argument : " + newFldsEncoded);
                        }
                        // Update the note
                        for (int idx=0; idx < flds.length; idx++) {
                            currentNote.setField(idx, flds[idx]);
                        }
                        updated++;
                    } else if (key.equals(FlashCardsContract.Note.TAGS)) {
                        // Update tags
                        Timber.d("CardContentProvider: tags update...");
                        Object tags = entry.getValue();
                        if (tags != null) {
                            currentNote.setTagsFromStr(String.valueOf(tags));
                        }
                        updated++;
                    } else {
                        // Unsupported column
                        throw new IllegalArgumentException("Unsupported column: " + key);
                    }
                }
                Timber.d("CardContentProvider: Saving note...");
                currentNote.flush();
                break;
            }
            case NOTES_ID_CARDS:
                // TODO: To be implemented
                throw new UnsupportedOperationException("Not yet implemented");
//                break;
            case NOTES_ID_CARDS_ORD: {
                Card currentCard = getCardFromUri(uri, col);
                boolean isDeckUpdate = false;
                long did = -1;
                // the key of the ContentValues contains the column name
                // the value of the ContentValues contains the row value.
                Set<Map.Entry<String, Object>> valueSet = values.valueSet();
                for (Map.Entry<String, Object> entry : valueSet) {
                    // Only updates on deck id is supported
                    String key = entry.getKey();
                    isDeckUpdate = key.equals(FlashCardsContract.Card.DECK_ID);
                    did = values.getAsLong(key);
                }
                if (col.getDecks().isDyn(did)) {
                    throw new IllegalArgumentException("Cards cannot be moved to a filtered deck");
                }
                /* now update the card
                 */
                if ((isDeckUpdate) && (did >= 0)) {
                    Timber.d("CardContentProvider: Moving card to other deck...");
                    col.getDecks().flush();
                    currentCard.setDid(did);
                    currentCard.flush();
                    col.save();
                    updated++;
                } else {
                    // User tries an operation that is not (yet?) supported.
                    throw new IllegalArgumentException("Currently only updates of decks are supported");
                }
                break;
            }
            case MODELS:
                throw new IllegalArgumentException("Cannot update models in bulk");
            case MODELS_ID:
                // Get the input parameters
                String newModelName = values.getAsString(FlashCardsContract.Model.NAME);
                String newCss = values.getAsString(FlashCardsContract.Model.CSS);
                String newDid = values.getAsString(FlashCardsContract.Model.DECK_ID);
                String newFieldList = values.getAsString(FlashCardsContract.Model.FIELD_NAMES);
                if (newFieldList != null) {
                    // Changing the field names would require a full-sync
                    throw new IllegalArgumentException("Field names cannot be changed via provider");
                }
                Integer newSortf = values.getAsInteger(FlashCardsContract.Model.SORT_FIELD_INDEX);
                Integer newType = values.getAsInteger(FlashCardsContract.Model.TYPE);
                String newLatexPost = values.getAsString(FlashCardsContract.Model.LATEX_POST);
                String newLatexPre = values.getAsString(FlashCardsContract.Model.LATEX_PRE);
                // Get the original note JSON
                JSONObject model = col.getModels().get(getModelIdFromUri(uri, col));
                try {
                    // Update model name and/or css
                    if (newModelName != null) {
                        model.put("name", newModelName);
                        updated++;
                    }
                    if (newCss != null) {
                        model.put("css", newCss);
                        updated++;
                    }
                    if (newDid != null) {
                        if (col.getDecks().isDyn(Long.parseLong(newDid))) {
                            throw new IllegalArgumentException("Cannot set a filtered deck as default deck for a model");
                        }
                        model.put("did", newDid);
                        updated++;
                    }
                    if (newSortf != null) {
                        model.put("sortf", newSortf);
                        updated++;
                    }
                    if (newType != null) {
                        model.put("type", newType);
                        updated++;
                    }
                    if (newLatexPost != null) {
                        model.put("latexPost", newLatexPost);
                        updated++;
                    }
                    if (newLatexPre != null) {
                        model.put("latexPre", newLatexPre);
                        updated++;
                    }
                    col.getModels().save(model);
                    col.save();
                } catch (JSONException e) {
                    Timber.e(e, "JSONException updating model");
                }
                break;
            case MODELS_ID_TEMPLATES:
                throw new IllegalArgumentException("Cannot update templates in bulk");
            case MODELS_ID_TEMPLATES_ID:
                Long mid = values.getAsLong(CardTemplate.MODEL_ID);
                Integer ord = values.getAsInteger(CardTemplate.ORD);
                String name = values.getAsString(CardTemplate.NAME);
                String qfmt = values.getAsString(CardTemplate.QUESTION_FORMAT);
                String afmt = values.getAsString(CardTemplate.ANSWER_FORMAT);
                String bqfmt = values.getAsString(CardTemplate.BROWSER_QUESTION_FORMAT);
                String bafmt = values.getAsString(CardTemplate.BROWSER_ANSWER_FORMAT);
                // Throw exception if read-only fields are included
                if (mid != null || ord != null) {
                    throw new IllegalArgumentException("Updates to mid or ord are not allowed");
                }
                // Update the model
                try {
                    Integer templateOrd = Integer.parseInt(uri.getLastPathSegment());
                    JSONObject existingModel = col.getModels().get(getModelIdFromUri(uri, col));
                    JSONArray templates = existingModel.getJSONArray("tmpls");
                    JSONObject template = templates.getJSONObject(templateOrd);
                    if (name != null) {
                        template.put("name", name);
                        updated++;
                    }
                    if (qfmt != null) {
                        template.put("qfmt", qfmt);
                        updated++;
                    }
                    if (afmt != null) {
                        template.put("afmt", afmt);
                        updated++;
                    }
                    if (bqfmt != null) {
                        template.put("bqfmt", bqfmt);
                        updated++;
                    }
                    if (bafmt != null) {
                        template.put("bafmt", bafmt);
                        updated++;
                    }
                    // Save the model
                    templates.put(templateOrd, template);
                    existingModel.put("tmpls", templates);
                    col.getModels().save(existingModel, true);
                    col.save();
                } catch (JSONException e) {
                    throw new IllegalArgumentException("Model is malformed", e);
                }
                break;
            case SCHEDULE: {
                Set<Map.Entry<String, Object>> valueSet = values.valueSet();
                int cardOrd = -1;
                long noteID = -1;
                int ease = -1;
                long timeTaken = -1;
                for (Map.Entry<String, Object> entry : valueSet) {
                    String key = entry.getKey();

                    if (key.equals(FlashCardsContract.ReviewInfo.NOTE_ID)) {
                        noteID = values.getAsLong(key);
                    } else if (key.equals(FlashCardsContract.ReviewInfo.CARD_ORD)) {
                        cardOrd = values.getAsInteger(key);
                    } else if (key.equals(FlashCardsContract.ReviewInfo.EASE)) {
                        ease = values.getAsInteger(key);
                    }else if (key.equals(FlashCardsContract.ReviewInfo.TIME_TAKEN)) {
                        timeTaken = values.getAsLong(key);
                    }
                }
                if (cardOrd != -1 && noteID != -1) {
                    Card cardToAnswer = getCard(noteID, cardOrd, col);
                    if(cardToAnswer != null) {
                        answerCard(col, col.getSched(), cardToAnswer, ease, timeTaken);
                        updated++;
                    }else{
                        Timber.e("Requested card with noteId %d and cardOrd %d was not found. Either the provided " +
                            "noteId/cardOrd were wrong or the card has been deleted in the meantime.", noteID, cardOrd);
                    }
                }
                break;
            }
            case DECKS:
                throw new IllegalArgumentException("Can't update decks in bulk");
            case DECKS_ID:
                // TODO: be sure to throw exception if change to the dyn value of a deck is requested
                throw new UnsupportedOperationException("Not yet implemented");
            case DECK_SELECTED: {
                Set<Map.Entry<String, Object>> valueSet = values.valueSet();
                for (Map.Entry<String, Object> entry : valueSet) {
                    String key = entry.getKey();
                    if(key.equals(FlashCardsContract.Deck.DECK_ID)) {
                        long deckId = values.getAsLong(key);
                        if(selectDeckWithCheck(col, deckId)){
                            updated ++;
                        }
                    }
                }
                col.save();
                break;
            }
            default:
                // Unknown URI type
                throw new IllegalArgumentException("uri " + uri + " is not supported");
        }
        return updated;
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        if (!hasReadWritePermission()) {
            throwSecurityException("delete", uri);
        }
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        if (col == null) {
            throw new IllegalStateException(COL_NULL_ERROR_MSG);
        }
        col.log(getLogMessage("delete", uri));

        switch (sUriMatcher.match(uri)) {
            case NOTES_ID:
                col.remNotes(new long[]{Long.parseLong(uri.getPathSegments().get(1))});
                return 1;
            case MODELS_ID_EMPTY_CARDS:
                JSONObject model = col.getModels().get(getModelIdFromUri(uri, col));
                if (model == null) {
                    return -1;
                }
                List<Long> cids = col.genCards(col.getModels().nids(model));
                col.remCards(Utils.arrayList2array(cids));
                return cids.size();
            default:
                throw new UnsupportedOperationException();
        }
    }

    /**
     * This can be used to insert multiple notes into a single deck. The deck is specified as a query parameter.
     *
     * For example: content://com.ichi2.anki.flashcards/notes?deckId=1234567890123
     *
     * @param uri content Uri
     * @param values for notes uri, it is acceptable for values to contain null items. Such items will be skipped
     * @return number of notes added (does not include existing notes that were updated)
     */
    @Override
    public int bulkInsert(Uri uri, ContentValues[] values) {
        if (!hasReadWritePermission() && shouldEnforceQueryOrInsertSecurity()) {
            throwSecurityException("bulkInsert", uri);
        }

        // by default, #bulkInsert simply calls insert for each item in #values
        // but in some cases, we want to override this behavior
        int match = sUriMatcher.match(uri);
        if (match == NOTES) {
            String deckIdStr = uri.getQueryParameter(FlashCardsContract.Note.DECK_ID_QUERY_PARAM);
            if (deckIdStr != null) {
                try {
                    long deckId = Long.valueOf(deckIdStr);
                    return bulkInsertNotes(values, deckId);
                } catch (NumberFormatException e) {
                    Timber.d("Invalid %s: %s", FlashCardsContract.Note.DECK_ID_QUERY_PARAM, deckIdStr);
                }
            }
            // deckId not specified, so default to #super implementation (as in spec version 1)
        }
        return super.bulkInsert(uri, values);
    }

    /**
     * This implementation optimizes for when the notes are grouped according to model
     */
    private int bulkInsertNotes(ContentValues[] valuesArr, long deckId) {
        if (valuesArr == null || valuesArr.length == 0) {
            return 0;
        }
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        if (col == null) {
            throw new IllegalStateException(COL_NULL_ERROR_MSG);
        }
        if (col.getDecks().isDyn(deckId)) {
            throw new IllegalArgumentException("A filtered deck cannot be specified as the deck in bulkInsertNotes");
        }
        col.log(String.format(Locale.US, "bulkInsertNotes: %d items.\n%s", valuesArr.length, getLogMessage("bulkInsert", null)));

        // for caching model information (so we don't have to query for each note)
        long modelId = -1L;
        JSONObject model = null;

        col.getDecks().flush(); // is it okay to move this outside the for-loop? Is it needed at all?
        SQLiteDatabase sqldb = col.getDb().getDatabase();
        try {
            int result = 0;
            sqldb.beginTransaction();
            for (int i = 0; i < valuesArr.length; i++) {
                ContentValues values = valuesArr[i];
                if (values == null) {
                    continue;
                }
                String flds = values.getAsString(FlashCardsContract.Note.FLDS);
                if (flds == null) {
                    continue;
                }
                Long thisModelId = values.getAsLong(FlashCardsContract.Note.MID);
                if (thisModelId == null || thisModelId < 0) {
                    Timber.d("Unable to get model at index: " + i);
                    continue;
                }
                String[] fldsArray = Utils.splitFields(flds);

                if (model == null || thisModelId != modelId) {
                    // new modelId so need to recalculate model, modelId and invalidate duplicateChecker (which is based on previous model)
                    model = col.getModels().get(thisModelId);
                    modelId = thisModelId;
                }

                // Create empty note
                com.ichi2.libanki.Note newNote = new com.ichi2.libanki.Note(col, model); // for some reason we cannot pass modelId in here
                // Set fields
                // Check that correct number of flds specified
                if (fldsArray.length != newNote.getFields().length) {
                    throw new IllegalArgumentException("Incorrect flds argument : " + flds);
                }
                for (int idx = 0; idx < fldsArray.length; idx++) {
                    newNote.setField(idx, fldsArray[idx]);
                }
                // Set tags
                String tags = values.getAsString(FlashCardsContract.Note.TAGS);
                if (tags != null) {
                    newNote.setTagsFromStr(tags);
                }
                // Add to collection
                col.addNote(newNote);
                for (Card card : newNote.cards()) {
                    card.setDid(deckId);
                    card.flush();
                }
                result++;
            }
            col.save();
            sqldb.setTransactionSuccessful();
            return result;
        } finally {
            sqldb.endTransaction();
        }
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        if (!hasReadWritePermission() && shouldEnforceQueryOrInsertSecurity()) {
            throwSecurityException("insert", uri);
        }
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        if (col == null) {
            throw new IllegalStateException(COL_NULL_ERROR_MSG);
        }
        col.log(getLogMessage("insert", uri));

        // Find out what data the user is requesting
        int match = sUriMatcher.match(uri);

        switch (match) {
            case NOTES: {
                /* Insert new note with specified fields and tags
                 */
                Long modelId = values.getAsLong(FlashCardsContract.Note.MID);
                String flds = values.getAsString(FlashCardsContract.Note.FLDS);
                String tags = values.getAsString(FlashCardsContract.Note.TAGS);
                // Create empty note
                com.ichi2.libanki.Note newNote = new com.ichi2.libanki.Note(col, col.getModels().get(modelId));
                // Set fields
                String[] fldsArray = Utils.splitFields(flds);
                // Check that correct number of flds specified
                if (fldsArray.length != newNote.getFields().length) {
                    throw new IllegalArgumentException("Incorrect flds argument : " + flds);
                }
                for (int idx=0; idx < fldsArray.length; idx++) {
                    newNote.setField(idx, fldsArray[idx]);
                }
                // Set tags
                if (tags != null) {
                    newNote.setTagsFromStr(tags);
                }
                // Add to collection
                col.addNote(newNote);
                col.save();
                return Uri.withAppendedPath(FlashCardsContract.Note.CONTENT_URI, Long.toString(newNote.getId()));
            }
            case NOTES_ID:
                // Note ID is generated automatically by libanki
                throw new IllegalArgumentException("Not possible to insert note with specific ID");
            case NOTES_ID_CARDS:
                // Cards are generated automatically by libanki
                throw new IllegalArgumentException("Not possible to insert cards directly (only through NOTES)");
            case NOTES_ID_CARDS_ORD:
                // Cards are generated automatically by libanki
                throw new IllegalArgumentException("Not possible to insert cards directly (only through NOTES)");
            case MODELS:
                // Get input arguments
                String modelName = values.getAsString(FlashCardsContract.Model.NAME);
                String css = values.getAsString(FlashCardsContract.Model.CSS);
                Long did = values.getAsLong(FlashCardsContract.Model.DECK_ID);
                String fieldNames = values.getAsString(FlashCardsContract.Model.FIELD_NAMES);
                Integer numCards = values.getAsInteger(FlashCardsContract.Model.NUM_CARDS);
                Integer sortf = values.getAsInteger(FlashCardsContract.Model.SORT_FIELD_INDEX);
                Integer type = values.getAsInteger(FlashCardsContract.Model.TYPE);
                String latexPost = values.getAsString(FlashCardsContract.Model.LATEX_POST);
                String latexPre = values.getAsString(FlashCardsContract.Model.LATEX_PRE);
                // Throw exception if required fields empty
                if (modelName == null || fieldNames == null || numCards == null) {
                    throw new IllegalArgumentException("Model name, field_names, and num_cards can't be empty");
                }
                if (did != null && col.getDecks().isDyn(did)) {
                    throw new IllegalArgumentException("Cannot set a filtered deck as default deck for a model");
                }
                // Create a new model
                Models mm = col.getModels();
                JSONObject newModel = mm.newModel(modelName);
                try {
                    // Add the fields
                    String[] allFields = Utils.splitFields(fieldNames);
                    for (String f: allFields) {
                        mm.addField(newModel, mm.newField(f));
                    }
                    // Add some empty card templates
                    for (int idx = 0; idx < numCards; idx++) {
                        JSONObject t = mm.newTemplate("Card " + (idx+1));
                        t.put("qfmt",String.format("{{%s}}", allFields[0]));
                        String answerField = allFields[0];
                        if (allFields.length > 1) {
                            answerField = allFields[1];
                        }
                        t.put("afmt",String.format("{{FrontSide}}\\n\\n<hr id=answer>\\n\\n{{%s}}", answerField));
                        mm.addTemplate(newModel, t);
                    }
                    // Add the CSS if specified
                    if (css != null) {
                        newModel.put("css", css);
                    }
                    // Add the did if specified
                    if (did != null) {
                        newModel.put("did", did);
                    }
                    if (sortf != null && sortf < allFields.length) {
                        newModel.put("sortf", sortf);
                    }
                    if (type != null) {
                        newModel.put("type", type);
                    }
                    if (latexPost != null) {
                        newModel.put("latexPost", latexPost);
                    }
                    if (latexPre != null) {
                        newModel.put("latexPre", latexPre);
                    }
                    // Add the model to collection (from this point on edits will require a full-sync)
                    mm.add(newModel);
                    col.save();
                    // Get the mid and return a URI
                    String mid = Long.toString(newModel.getLong("id"));
                    return Uri.withAppendedPath(FlashCardsContract.Model.CONTENT_URI, mid);
                } catch (ConfirmModSchemaException e) {
                    // This exception should never be thrown when inserting new models
                    Timber.e(e, "Unexpected ConfirmModSchema exception adding new model %s", modelName);
                    throw new IllegalArgumentException("ConfirmModSchema exception adding new model " + modelName);
                } catch (JSONException e) {
                    Timber.e(e, "Could not set a field of new model %s", modelName);
                    return null;
                }
            case MODELS_ID:
                // Model ID is generated automatically by libanki
                throw new IllegalArgumentException("Not possible to insert model with specific ID");
            case MODELS_ID_TEMPLATES: {
                Models models = col.getModels();
                Long mid = getModelIdFromUri(uri, col);
                JSONObject existingModel = models.get(mid);
                if (existingModel == null) {
                    throw new IllegalArgumentException("model missing: " + mid);
                }
                String name = values.getAsString(CardTemplate.NAME);
                String qfmt = values.getAsString(CardTemplate.QUESTION_FORMAT);
                String afmt = values.getAsString(CardTemplate.ANSWER_FORMAT);
                String bqfmt = values.getAsString(CardTemplate.BROWSER_QUESTION_FORMAT);
                String bafmt = values.getAsString(CardTemplate.BROWSER_ANSWER_FORMAT);
                try {
                    JSONObject t = models.newTemplate(name);
                    try {
                        t.put("qfmt", qfmt);
                        t.put("afmt", afmt);
                        t.put("bqfmt", bqfmt);
                        t.put("bafmt", bafmt);
                    } catch (JSONException e) {
                        throw new RuntimeException(e);
                    }
                    models.addTemplate(existingModel, t);
                    models.save(existingModel);
                    col.save();
                    return ContentUris.withAppendedId(uri, t.getInt("ord"));
                } catch (ConfirmModSchemaException e) {
                    throw new IllegalArgumentException("Unable to add template", e);
                } catch (JSONException e) {
                    throw new IllegalArgumentException("Unable to get ord from new template", e);
                }
            }
            case MODELS_ID_TEMPLATES_ID:
                throw new IllegalArgumentException("Not possible to insert template with specific ORD");
            case MODELS_ID_FIELDS: {
                Models models = col.getModels();
                Long mid = getModelIdFromUri(uri, col);
                JSONObject existingModel = models.get(mid);
                if (existingModel == null) {
                    throw new IllegalArgumentException("model missing: " + mid);
                }
                String name = values.getAsString(FlashCardsContract.Model.FIELD_NAME);
                if (name == null) {
                    throw new IllegalArgumentException("field name missing for model: " + mid);
                }
                JSONObject field = models.newField(name);
                try {
                    models.addField(existingModel, field);
                    col.save();
                    JSONArray ja = existingModel.getJSONArray("flds");
                    return ContentUris.withAppendedId(uri, ja.length() - 1);
                } catch (ConfirmModSchemaException e) {
                    throw new IllegalArgumentException("Unable to insert field: " + name, e);
                } catch (JSONException e) {
                    throw new IllegalArgumentException("Unable to get newly created field: " + name, e);
                }
            }
            case SCHEDULE:
                // Doesn't make sense to insert an object into the schedule table
                throw new IllegalArgumentException("Not possible to perform insert operation on schedule");
            case DECKS:
                // Insert new deck with specified name
                String deckName = values.getAsString(FlashCardsContract.Deck.DECK_NAME);
                did = col.getDecks().id(deckName, false);
                if (did != null) {
                    throw new IllegalArgumentException("Deck name already exists: " + deckName);
                }
                did = col.getDecks().id(deckName, true);
                JSONObject deck = col.getDecks().get(did);
                if (deck != null) {
                    try {
                        String deckDesc = values.getAsString(FlashCardsContract.Deck.DECK_DESC);
                        if (deckDesc != null) {
                            deck.put("desc", deckDesc);
                        }
                    } catch (JSONException e) {
                        Timber.e(e, "Could not set a field of new deck %s", deckName);
                        return null;
                    }
                }
                col.getDecks().flush();
                return Uri.withAppendedPath(FlashCardsContract.Deck.CONTENT_ALL_URI, Long.toString(did));
            case DECK_SELECTED:
                // Can't have more than one selected deck
                throw new IllegalArgumentException("Selected deck can only be queried and updated");
            case DECKS_ID:
                // Deck ID is generated automatically by libanki
                throw new IllegalArgumentException("Not possible to insert deck with specific ID");
            default:
                // Unknown URI type
                throw new IllegalArgumentException("uri " + uri + " is not supported");
        }
    }

    private static String[] sanitizeNoteProjection(String[] projection) {
        if (projection == null || projection.length == 0) {
            return sDefaultNoteProjectionDBAccess;
        }
        List<String> sanitized = new ArrayList<>();
        for (String column : projection) {
            int idx = projSearch(FlashCardsContract.Note.DEFAULT_PROJECTION, column);
            if (idx >= 0) {
                sanitized.add(sDefaultNoteProjectionDBAccess[idx]);
            } else {
                throw new IllegalArgumentException("Unknown column " + column);
            }
        }
        return sanitized.toArray(new String[sanitized.size()]);
    }

    private static int projSearch(String[] projection, String column) {
        for (int i = 0; i < projection.length; i++) {
            if (projection[i].equals(column)) {
                return i;
            }
        }
        return -1;
    }

    private void addModelToCursor(Long modelId, Models models, MatrixCursor rv, String[] columns) {
        JSONObject jsonObject = models.get(modelId);
        MatrixCursor.RowBuilder rb = rv.newRow();
        try {
            for (String column : columns) {
                if (column.equals(FlashCardsContract.Model._ID)) {
                    rb.add(modelId);
                } else if (column.equals(FlashCardsContract.Model.NAME)) {
                    rb.add(jsonObject.getString("name"));
                } else if (column.equals(FlashCardsContract.Model.FIELD_NAMES)) {
                    JSONArray flds = jsonObject.getJSONArray("flds");
                    String[] allFlds = new String[flds.length()];
                    for (int idx = 0; idx < flds.length(); idx++) {
                        allFlds[idx] = flds.getJSONObject(idx).optString("name", "");
                    }
                    rb.add(Utils.joinFields(allFlds));
                } else if (column.equals(FlashCardsContract.Model.NUM_CARDS)) {
                    rb.add(jsonObject.getJSONArray("tmpls").length());
                } else if (column.equals(FlashCardsContract.Model.CSS)) {
                    rb.add(jsonObject.getString("css"));
                } else if (column.equals(FlashCardsContract.Model.DECK_ID)) {
                    rb.add(jsonObject.getLong("did"));
                } else if (column.equals(FlashCardsContract.Model.SORT_FIELD_INDEX)) {
                    rb.add(jsonObject.getLong("sortf"));
                } else if (column.equals(FlashCardsContract.Model.TYPE)) {
                    rb.add(jsonObject.getLong("type"));
                } else if (column.equals(FlashCardsContract.Model.LATEX_POST)) {
                    rb.add(jsonObject.getString("latexPost"));
                } else if (column.equals(FlashCardsContract.Model.LATEX_PRE)) {
                    rb.add(jsonObject.getString("latexPre"));
                } else if (column.equals(FlashCardsContract.Model.NOTE_COUNT)) {
                    rb.add(models.useCount(jsonObject));
                } else {
                    throw new UnsupportedOperationException("Column \"" + column + "\" is unknown");
                }
            }
        } catch (JSONException e) {
            Timber.e(e, "Error parsing JSONArray");
            throw new IllegalArgumentException("Model " + modelId + " is malformed", e);
        }
    }

    private void addCardToCursor(Card currentCard, MatrixCursor rv, Collection col, String[] columns) {
        String cardName;
        try {
            cardName = currentCard.template().getString("name");
        } catch (JSONException je) {
            throw new IllegalArgumentException("Card is using an invalid template", je);
        }
        String question = currentCard.q();
        String answer = currentCard.a();

        MatrixCursor.RowBuilder rb = rv.newRow();
        for (String column : columns) {
            if (column.equals(FlashCardsContract.Card.NOTE_ID)) {
                rb.add(currentCard.note().getId());
            } else if (column.equals(FlashCardsContract.Card.CARD_ORD)) {
                rb.add(currentCard.getOrd());
            } else if (column.equals(FlashCardsContract.Card.CARD_NAME)) {
                rb.add(cardName);
            } else if (column.equals(FlashCardsContract.Card.DECK_ID)) {
                rb.add(currentCard.getDid());
            } else if (column.equals(FlashCardsContract.Card.QUESTION)) {
                rb.add(question);
            } else if (column.equals(FlashCardsContract.Card.ANSWER)) {
                rb.add(answer);
            } else if (column.equals(FlashCardsContract.Card.QUESTION_SIMPLE)) {
                rb.add(currentCard.qSimple());
            } else if (column.equals(FlashCardsContract.Card.ANSWER_SIMPLE)) {
                rb.add(currentCard._getQA(false).get("a"));
            }else if (column.equals(FlashCardsContract.Card.ANSWER_PURE)) {
                rb.add(currentCard.getPureAnswer());
            } else {
                throw new UnsupportedOperationException("Column \"" + column + "\" is unknown");
            }
        }
    }

    private void addReviewInfoToCursor(Card currentCard, JSONArray nextReviewTimesJson, int buttonCount,MatrixCursor rv, Collection col, String[] columns) {
        MatrixCursor.RowBuilder rb = rv.newRow();
        for (String column : columns) {
            if (column.equals(FlashCardsContract.Card.NOTE_ID)) {
                rb.add(currentCard.note().getId());
            } else if (column.equals(FlashCardsContract.ReviewInfo.CARD_ORD)) {
                rb.add(currentCard.getOrd());
            } else if (column.equals(FlashCardsContract.ReviewInfo.BUTTON_COUNT)) {
                rb.add(buttonCount);
            } else if (column.equals(FlashCardsContract.ReviewInfo.NEXT_REVIEW_TIMES)) {
                rb.add(nextReviewTimesJson.toString());
            } else if (column.equals(FlashCardsContract.ReviewInfo.MEDIA_FILES)) {
                rb.add(new JSONArray(col.getMedia().filesInStr(currentCard.note().getMid(), currentCard.q()+currentCard.a())));
            } else {
                throw new UnsupportedOperationException("Column \"" + column + "\" is unknown");
            }
        }
    }

    private void answerCard(Collection col, Sched sched, Card cardToAnswer, int ease, long timeTaken) {
        try {
            DB db = col.getDb();
            db.getDatabase().beginTransaction();
            try {
                if (cardToAnswer != null) {
                    if(timeTaken != -1){
                        cardToAnswer.setTimerStarted(Utils.now()-timeTaken/1000);
                    }
                    sched.answerCard(cardToAnswer, ease);
                }
                db.getDatabase().setTransactionSuccessful();
            } finally {
                db.getDatabase().endTransaction();
            }
        } catch (RuntimeException e) {
            Timber.e(e, "answerCard - RuntimeException on answering card");
            AnkiDroidApp.sendExceptionReport(e, "doInBackgroundAnswerCard");
            return;
        }
    }

    private void addTemplateToCursor(JSONObject tmpl, JSONObject model, int id, Models models, MatrixCursor rv, String[] columns) {
        try {
            MatrixCursor.RowBuilder rb = rv.newRow();
            for (String column : columns) {
                if (column.equals(CardTemplate._ID)) {
                    rb.add(id);
                } else if (column.equals(CardTemplate.MODEL_ID)) {
                    rb.add(model.getLong("id"));
                } else if (column.equals(CardTemplate.ORD)) {
                    rb.add(tmpl.getInt("ord"));
                } else if (column.equals(CardTemplate.NAME)) {
                    rb.add(tmpl.getString("name"));
                } else if (column.equals(CardTemplate.QUESTION_FORMAT)) {
                    rb.add(tmpl.getString("qfmt"));
                } else if (column.equals(CardTemplate.ANSWER_FORMAT)) {
                    rb.add(tmpl.getString("afmt"));
                } else if (column.equals(CardTemplate.BROWSER_QUESTION_FORMAT)) {
                    rb.add(tmpl.getString("bqfmt"));
                } else if (column.equals(CardTemplate.BROWSER_ANSWER_FORMAT)) {
                    rb.add(tmpl.getString("bafmt"));
                } else if (column.equals(CardTemplate.CARD_COUNT)) {
                    rb.add(models.tmplUseCount(model, tmpl.getInt("ord")));
                } else {
                    throw new UnsupportedOperationException("Support for column \"" + column +
                            "\" is not implemented");
                }
            }
        } catch (JSONException e) {
            Timber.e(e, "Error adding template to cursor");
            throw new IllegalArgumentException("Template is malformed", e);
        }
    }

    private void addDeckToCursor(long id, String name, JSONArray deckCounts, MatrixCursor rv, Collection col, String[] columns) {
        MatrixCursor.RowBuilder rb = rv.newRow();
        for (String column : columns) {
            if (column.equals(FlashCardsContract.Deck.DECK_NAME)) {
                rb.add(name);
            }else if (column.equals(FlashCardsContract.Deck.DECK_ID)) {
                rb.add(id);
            }else if (column.equals(FlashCardsContract.Deck.DECK_COUNTS)) {
                rb.add(deckCounts);
            }else if (column.equals(FlashCardsContract.Deck.OPTIONS)) {
                String config = col.getDecks().confForDid(id).toString();
                rb.add(config);
            }else if (column.equals(FlashCardsContract.Deck.DECK_DYN)) {
                rb.add(col.getDecks().isDyn(id));
            }else if (column.equals(FlashCardsContract.Deck.DECK_DESC)) {
                String desc = col.getDecks().getActualDescription();
                rb.add(desc);
            }
        }
    }

    private boolean selectDeckWithCheck(Collection col, long did){
        if (col.getDecks().get(did, false) != null) {
            col.getDecks().select(did);
            return true;
        } else {
            Timber.e("Requested deck with id %d was not found in deck list. Either the deckID provided was wrong" +
                    "or the deck has been deleted in the meantime."
                    , did);
            return false;
        }
    }

    private Card getCardFromUri(Uri uri, Collection col) {
        long noteId;
        int ord;
        noteId = Long.parseLong(uri.getPathSegments().get(1));
        ord = Integer.parseInt(uri.getPathSegments().get(3));
        return getCard(noteId, ord, col);
    }

    private Card getCard(long noteId, int ord, Collection col){
        Note currentNote = col.getNote(noteId);
        Card currentCard = null;
        for(Card card : currentNote.cards()){
            if(card.getOrd() == ord){
                currentCard = card;
            }
        }
        if (currentCard == null) {
            throw new IllegalArgumentException("Card with ord " + ord + " does not exist for note " + noteId);
        }
        return currentCard;
    }

    private Note getNoteFromUri(Uri uri, Collection col) {
        long noteId;
        noteId = Long.parseLong(uri.getPathSegments().get(1));
        return col.getNote(noteId);
    }


    private long getModelIdFromUri(Uri uri, Collection col) {
        String modelIdSegment = uri.getPathSegments().get(1);
        long id;
        if (modelIdSegment.equals(FlashCardsContract.Model.CURRENT_MODEL_ID)) {
            id = col.getModels().current().optLong("id", -1);
        } else {
            try {
                id = Long.parseLong(uri.getPathSegments().get(1));
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException("Model ID must be either numeric or the String CURRENT_MODEL_ID");
            }
        }
        return id;
    }

    private JSONObject getTemplateFromUri(Uri uri, Collection col) throws JSONException {
        JSONObject model = col.getModels().get(getModelIdFromUri(uri, col));
        Integer ord = Integer.parseInt(uri.getLastPathSegment());
        return model.getJSONArray("tmpls").getJSONObject(ord);
    }

    private void throwSecurityException(String methodName, Uri uri) {
        String msg = String.format("Permission not granted for: %s", getLogMessage(methodName, uri));
        Timber.e(msg);
        throw new SecurityException(msg);
    }

    private String getLogMessage(String methodName, Uri uri) {
        final String format = "%s.%s %s (%s)";
        String path = uri == null ? null : uri.getPath();
        return String.format(format, getClass().getSimpleName(), methodName, path, getCallingPackageSafe());
    }

    private boolean hasReadWritePermission() {
        if (BuildConfig.DEBUG) {    // Allow self-calling of the provider only in debug builds (e.g. for unit tests)
            return mContext.checkCallingOrSelfPermission(READ_WRITE_PERMISSION) == PackageManager.PERMISSION_GRANTED;
        }
        return mContext.checkCallingPermission(READ_WRITE_PERMISSION) == PackageManager.PERMISSION_GRANTED;
    }


    /** Returns true if the calling package is known to be "rogue" and should be blocked.
     Calling package might be rogue if it has not declared #READ_WRITE_PERMISSION in its manifest, or if blacklisted **/
    private boolean knownRogueClient() {
        final PackageManager pm = mContext.getPackageManager();
        try {
            PackageInfo callingPi = pm.getPackageInfo(getCallingPackageSafe(), PackageManager.GET_PERMISSIONS);
             if (callingPi == null || callingPi.requestedPermissions == null) {
                 return false;
             }
             return !Arrays.asList(callingPi.requestedPermissions).contains(READ_WRITE_PERMISSION);
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        }
    }

    @Nullable
    private String getCallingPackageSafe() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            return getCallingPackage();
        }
        String[] pkgs = mContext.getPackageManager().getPackagesForUid(Binder.getCallingUid());
        if (pkgs.length == 1) {
            return pkgs[0]; // This is usual case, unless multiple packages signed with same key & using "sharedUserId"
        }
        return null;
    }
}
package com.ichi2.anki.receiver;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

import com.ichi2.anki.services.BootService;

public class BootReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        final Intent serviceIntent = new Intent(context, BootService.class);

        context.startService(serviceIntent);
    }
}
package com.ichi2.anki.receiver;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

import com.ichi2.anki.services.NotificationService;

public class NotificationReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        final Intent serviceIntent = new Intent(context, NotificationService.class);
        context.startService(serviceIntent);
    }
}
package com.ichi2.anki.receiver;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

import com.ichi2.anki.services.ReminderService;

public class ReminderReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        final Intent serviceIntent = new Intent(context, ReminderService.class);

        serviceIntent.putExtra(ReminderService.EXTRA_DECK_ID, intent.getLongExtra(ReminderService.EXTRA_DECK_ID, 0));
        context.startService(serviceIntent);
    }
}
/***************************************************************************************
 * Copyright (c) 2012 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.receiver;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;


import com.ichi2.anki.CollectionHelper;
import com.ichi2.libanki.Collection;

import timber.log.Timber;

/**
 * This Broadcast-Receiver listens to media ejects and closes the collection prior to unmount. It then sends a broadcast
 * intent to all activities which might be open in order to show an appropriate screen After media has been remounted,
 * another broadcast intent will be sent to let the activites know about it
 */

public class SdCardReceiver extends BroadcastReceiver {

    public static final String MEDIA_EJECT = "com.ichi2.anki.action.MEDIA_EJECT";
    public static final String MEDIA_MOUNT = "com.ichi2.anki.action.MEDIA_MOUNT";


    @Override
    public void onReceive(Context context, Intent intent) {
        if (intent.getAction().equals(Intent.ACTION_MEDIA_EJECT)) {
            Timber.i("media eject detected - closing collection and sending broadcast");
            Intent i = new Intent();
            i.setAction(MEDIA_EJECT);
            context.sendBroadcast(i);
            Collection col = CollectionHelper.getInstance().getCol(context);
            if (col != null) {
                col.close();
            }
        } else if (intent.getAction().equals(Intent.ACTION_MEDIA_MOUNTED)) {
            Timber.i("media mount detected - sending broadcast");
            Intent i = new Intent();
            i.setAction(MEDIA_MOUNT);
            context.sendBroadcast(i);
        }
    }

}
/****************************************************************************************
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.reviewer;

import android.content.Context;
import android.content.SharedPreferences;
import android.text.TextUtils;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.AnkiFont;
import com.ichi2.libanki.Utils;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CustomFontsReviewerExt implements ReviewerExt {

    private final String mCustomStyle;
    private String mDefaultFontStyle;
    private String mOverrideFontStyle;
    private String mThemeFontStyle;
    private String mDominantFontStyle;

    public CustomFontsReviewerExt(Context context) {
        Map<String, AnkiFont> customFontsMap = getCustomFontsMap(context);
        mCustomStyle = getCustomFontsStyle(customFontsMap) + getDominantFontStyle(context, customFontsMap);
    }


    @Override
    public void updateCssStyle(StringBuilder cssStyle) {
        cssStyle.append(mCustomStyle);
    }


    /**
     * Returns the CSS used to handle custom fonts.
     * <p>
     * Custom fonts live in fonts directory in the directory used to store decks.
     * <p>
     * Each font is mapped to the font family by the same name as the name of the font without the extension.
     */
    private static String getCustomFontsStyle(Map<String, AnkiFont> customFontsMap) {
        StringBuilder builder = new StringBuilder();
        for (AnkiFont font : customFontsMap.values()) {
            builder.append(font.getDeclaration());
            builder.append('\n');
        }
        return builder.toString();
    }


    /**
     * Returns the CSS used to set the theme font.
     * 
     * @return the font style, or the empty string if no font is set
     */
    private String getThemeFontStyle() {
        if (mThemeFontStyle == null) {
            String themeFontName = "OpenSans";
            if (TextUtils.isEmpty(themeFontName)) {
                mThemeFontStyle = "";
            } else {
                mThemeFontStyle = String.format(
                        "BODY {"
                        + "font-family: '%s';"
                        + "font-weight: normal;"
                        + "font-style: normal;"
                        + "font-stretch: normal;"
                        + "}\n", themeFontName);
            }
        }
        return mThemeFontStyle;
    }


    /**
     * Returns the CSS used to set the default font.
     * 
     * @return the default font style, or the empty string if no default font is set
     */
    private String getDefaultFontStyle(Context context, Map<String, AnkiFont> customFontsMap) {
        if (mDefaultFontStyle == null) {
            SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(context);
            AnkiFont defaultFont = customFontsMap.get(preferences.getString("defaultFont", null));
            if (defaultFont != null) {
                mDefaultFontStyle = "BODY { " + defaultFont.getCSS(false) + " }\n";
            } else {
                mDefaultFontStyle = "";
            }
        }
        return mDefaultFontStyle;
    }


    /**
     * Returns the CSS used to set the override font.
     * 
     * @return the override font style, or the empty string if no override font is set
     */
    private String getOverrideFontStyle(Context context, Map<String, AnkiFont> customFontsMap) {
        if (mOverrideFontStyle == null) {
            SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(context);
            AnkiFont defaultFont = customFontsMap.get(preferences.getString("defaultFont", null));
            boolean overrideFont = preferences.getString("overrideFontBehavior", "0").equals("1");
            if (defaultFont != null && overrideFont) {
                mOverrideFontStyle = "BODY, .card, * { " + defaultFont.getCSS(true) + " }\n";
            } else {
                mOverrideFontStyle = "";
            }
        }
        return mOverrideFontStyle;
    }


    /**
     * Returns the CSS that determines font choice in a global fashion.
     * 
     * @return the font style, or the empty string if none applies
     */
    private String getDominantFontStyle(Context context, Map<String, AnkiFont> customFontsMap) {
        if (mDominantFontStyle == null) {
            mDominantFontStyle = getOverrideFontStyle(context, customFontsMap);
            if (TextUtils.isEmpty(mDominantFontStyle)) {
                mDominantFontStyle = getDefaultFontStyle(context, customFontsMap);
                if (TextUtils.isEmpty(mDominantFontStyle)) {
                    mDominantFontStyle = getThemeFontStyle();
                }
            }
        }
        return mDominantFontStyle;
    }


    /**
     * Returns a map from custom fonts names to the corresponding {@link AnkiFont} object.
     * <p>
     * The list of constructed lazily the first time is needed.
     */
    private static Map<String, AnkiFont> getCustomFontsMap(Context context) {
        List<AnkiFont> fonts = Utils.getCustomFonts(context);
        Map<String, AnkiFont> customFontsMap = new HashMap<>();
        for (AnkiFont f : fonts) {
            customFontsMap.put(f.getName(), f);
        }
        return customFontsMap;
    }

}
/****************************************************************************************
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.reviewer;

/**
 * An extension to the reviewer class.
 * <p>
 * This allows splitting parts of the code that offer a specific feature outside the activity itself.
 */
public interface ReviewerExt {

    /**
     * Hook for updating the CSS style used by a card.
     * <p>
     * It should modify the content of the {@link StringBuilder} to reflect the new style.
     * 
     * @param cssStyle containing current style
     */
    void updateCssStyle(StringBuilder cssStyle);

}
/****************************************************************************************
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.reviewer;

import android.content.Context;

/**
 * Keeps track of all the {@link ReviewerExt} implementations and delegates to them.
 */
public class ReviewerExtRegistry implements ReviewerExt {

    /**
     * The registered extensions.
     */
    private final ReviewerExt[] mReviewerExts;


    /**
     * Creates the list of extensions.
     * <p>
     * Must be called at the beginning of onCreate().
     */
    public ReviewerExtRegistry(Context context) {
        mReviewerExts = new ReviewerExt[] { new CustomFontsReviewerExt(context), };
    }


    @Override
    public void updateCssStyle(StringBuilder cssStyle) {
        for (ReviewerExt ext : mReviewerExts) {
            ext.updateCssStyle(cssStyle);
        }
    }

}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.runtimetools;

import android.os.AsyncTask;
import android.os.AsyncTask.Status;

public class TaskOperations {

    /**
     * Gently killing AsyncTask
     */
    public static void stopTaskGracefully(AsyncTask<?, ?, ?> t) {
        if (t != null) {
            if (t.getStatus() == Status.RUNNING) {
                t.cancel(true);
            }
        }
    }

}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.servicelayer;

import com.ichi2.anki.multimediacard.IMultimediaEditableNote;
import com.ichi2.anki.multimediacard.fields.AudioField;
import com.ichi2.anki.multimediacard.fields.IField;
import com.ichi2.anki.multimediacard.fields.ImageField;
import com.ichi2.anki.multimediacard.fields.TextField;
import com.ichi2.anki.multimediacard.impl.MultimediaEditableNote;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Note;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.io.IOException;

public class NoteService {
    /**
     * Creates an empty Note from given Model
     * 
     * @param model the model in JSOBObject format
     * @return a new note instance
     */
    public static MultimediaEditableNote createEmptyNote(JSONObject model) {
        try {
            JSONArray fieldsArray = model.getJSONArray("flds");
            int numOfFields = fieldsArray.length();
            if (numOfFields > 0) {
                MultimediaEditableNote note = new MultimediaEditableNote();
                note.setNumFields(numOfFields);

                for (int i = 0; i < numOfFields; i++) {
                    JSONObject fieldObject = fieldsArray.getJSONObject(i);
                    TextField uiTextField = new TextField();
                    uiTextField.setName(fieldObject.getString("name"));
                    uiTextField.setText(fieldObject.getString("name"));
                    note.setField(i, uiTextField);
                }
                note.setModelId(model.getLong("id"));
                return note;
            }
        } catch (JSONException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return null;
    }


    public static void updateMultimediaNoteFromJsonNote(Collection col, final Note editorNoteSrc, final IMultimediaEditableNote noteDst) {
        if (noteDst instanceof MultimediaEditableNote) {
            MultimediaEditableNote mmNote = (MultimediaEditableNote) noteDst;
            String[] values = editorNoteSrc.getFields();
            for (int i = 0; i < values.length; i++) {
                String value = values[i];
                IField field = null;
                if (value.startsWith("<img")) {
                    field = new ImageField();
                } else if (value.startsWith("[sound:")) {
                    field = new AudioField();
                } else {
                    field = new TextField();
                }
                field.setFormattedString(col, value);
                mmNote.setField(i, field);
            }
            mmNote.setModelId(editorNoteSrc.getMid());
            // TODO: set current id of the note as well
        }
    }


    /**
     * Updates the JsonNote field values from MultimediaEditableNote When both notes are using the same Model, it updaes
     * the destination field values with source values. If models are different it throws an Exception
     * 
     * @param noteSrc
     * @param editorNoteDst
     */
    public static void updateJsonNoteFromMultimediaNote(final IMultimediaEditableNote noteSrc, final Note editorNoteDst) {
        if (noteSrc instanceof MultimediaEditableNote) {
            MultimediaEditableNote mmNote = (MultimediaEditableNote) noteSrc;
            if (mmNote.getModelId() != editorNoteDst.getMid()) {
                throw new RuntimeException("Source and Destination Note ID do not match.");
            }

            int totalFields = mmNote.getNumberOfFields();
            for (int i = 0; i < totalFields; i++) {
                editorNoteDst.values()[i] = mmNote.getField(i).getFormattedValue();
            }
        }
    }


    /**
     * Saves the multimedia associated with this card to proper path inside anki folder. For each field associated with
     * the note it checks for the following condition a. The field content should have changed b. The field content does
     * not already point to a media inside anki media path If both condition satisfies then it copies the file inside
     * the media path and deletes the file referenced by the note
     * 
     * @param noteNew
     */
    public static void saveMedia(Collection col, final MultimediaEditableNote noteNew) {
        // if (noteNew.getModelId() == noteOld.getModelId())
        // {
        // int fieldCount = noteNew.getNumberOfFields();
        // for (int i = 0; i < fieldCount; i++)
        // {
        // IField newField = noteNew.getField(i);
        // IField oldField = noteOld.getField(i);
        // if
        // (newField.getFormattedValue().equals(oldField.getFormattedValue()))
        // {
        // continue;
        // }
        // importMediaToDirectory(newField);
        // }
        // }
        // else
        // {
        int fieldCount = noteNew.getNumberOfFields();
        for (int i = 0; i < fieldCount; i++) {
            IField newField = noteNew.getField(i);
            importMediaToDirectory(col, newField);
        }
        // }
    }


    /**
     * Considering the field is new, if it has media handle it
     * 
     * @param field
     */
    private static void importMediaToDirectory(Collection col, IField field) {
        String tmpMediaPath = null;
        switch (field.getType()) {
            case AUDIO:
                tmpMediaPath = field.getAudioPath();
                break;

            case IMAGE:
                tmpMediaPath = field.getImagePath();
                break;

            case TEXT:
            default:
                break;
        }
        if (tmpMediaPath != null) {
            try {
                File inFile = new File(tmpMediaPath);
                if (inFile.exists()) {
                    String fname = col.getMedia().addFile(inFile);
                    File outFile = new File(col.getMedia().dir(), fname);
                    if (field.hasTemporaryMedia() && !outFile.getAbsolutePath().equals(tmpMediaPath)) {
                        // Delete original
                        inFile.delete();
                    }
                    switch (field.getType()) {
                        case AUDIO:
                            field.setAudioPath(outFile.getAbsolutePath());
                            break;
                        case IMAGE:
                            field.setImagePath(outFile.getAbsolutePath());
                            break;
                        default:
                            break;
                    }
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
package com.ichi2.anki.services;

import android.app.AlarmManager;
import android.app.IntentService;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.preference.PreferenceManager;

import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.receiver.NotificationReceiver;
import com.ichi2.anki.receiver.ReminderReceiver;
import com.ichi2.libanki.Collection;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.Calendar;

public class BootService extends IntentService {

    /**
     * This service is also run when the app is started (from {@link com.ichi2.anki.AnkiDroidApp},
     * so we need to make sure that it isn't run twice.
     */
    private static boolean sWasRun = false;

    public BootService() {
        super("BootService");
    }

    @Override
    protected void onHandleIntent(Intent intent) {
        if (sWasRun) {
            return;
        }

        scheduleDeckReminder();
        scheduleNotification(this);
        sWasRun = true;
    }

    private void scheduleDeckReminder() {
        AlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE);
        try {
            for (JSONObject deck : CollectionHelper.getInstance().getCol(this).getDecks().all()) {
                Collection col = CollectionHelper.getInstance().getCol(this);
                if (col.getDecks().isDyn(deck.getLong("id"))) {
                    continue;
                }
                final long deckConfigurationId = deck.getLong("conf");
                final JSONObject deckConfiguration = col.getDecks().getConf(deckConfigurationId);

                if (deckConfiguration.has("reminder")) {
                    final JSONObject reminder = deckConfiguration.getJSONObject("reminder");

                    if (reminder.getBoolean("enabled")) {
                        final PendingIntent reminderIntent = PendingIntent.getBroadcast(
                                this,
                                (int) deck.getLong("id"),
                                new Intent(this, ReminderReceiver.class).putExtra(ReminderService.EXTRA_DECK_ID,
                                        deck.getLong("id")),
                                0
                        );
                        final Calendar calendar = Calendar.getInstance();

                        calendar.set(Calendar.HOUR_OF_DAY, reminder.getJSONArray("time").getInt(0));
                        calendar.set(Calendar.MINUTE, reminder.getJSONArray("time").getInt(1));
                        calendar.set(Calendar.SECOND, 0);

                        alarmManager.setInexactRepeating(
                                AlarmManager.RTC_WAKEUP,
                                calendar.getTimeInMillis(),
                                AlarmManager.INTERVAL_DAY,
                                reminderIntent
                        );
                    }
                }
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }

    public static void scheduleNotification(Context context) {
        AlarmManager alarmManager = (AlarmManager) context.getSystemService(ALARM_SERVICE);
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(context);
        if (Integer.parseInt(sp.getString("minimumCardsDueForNotification", "1000001")) <= 1000000) {
            return;
        }

        final Calendar calendar = Calendar.getInstance();
        calendar.set(Calendar.HOUR_OF_DAY, sp.getInt("dayOffset", 0));
        calendar.set(Calendar.MINUTE, 0);
        calendar.set(Calendar.SECOND, 0);
        final PendingIntent notificationIntent =
                PendingIntent.getBroadcast(context, 0, new Intent(context, NotificationReceiver.class), 0);
        alarmManager.setInexactRepeating(
                AlarmManager.RTC_WAKEUP,
                calendar.getTimeInMillis(),
                AlarmManager.INTERVAL_DAY,
                notificationIntent
        );
    }
}
/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.services;

import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.os.IBinder;
import android.support.v4.app.NotificationCompat;
import android.support.v4.content.ContextCompat;
import android.support.v4.content.IntentCompat;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.DeckPicker;
import com.ichi2.anki.R;
import com.ichi2.widget.WidgetStatus;

import timber.log.Timber;

public class NotificationService extends Service {

    /** The notification service to show notifications of due cards. */
    private NotificationManager mNotificationManager;

    /** The id of the notification for due cards. */
    private static final int WIDGET_NOTIFY_ID = 1;


    @Override
    public void onCreate() {
        super.onCreate();
        mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
    }


    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Timber.i("NotificationService: OnStartCommand");

        Context context = getApplicationContext();
        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(context);
        int minCardsDue = Integer.parseInt(preferences.getString("minimumCardsDueForNotification", "25"));
        int dueCardsCount = WidgetStatus.fetchDue(context);
        if (dueCardsCount >= minCardsDue) {
            // Build basic notification
            String cardsDueText = getString(R.string.widget_minimum_cards_due_notification_ticker_text, dueCardsCount);
            NotificationCompat.Builder builder = new NotificationCompat.Builder(this)
                    .setSmallIcon(R.drawable.ic_stat_notify)
                    .setColor(ContextCompat.getColor(context, R.color.material_light_blue_700))
                    .setContentTitle(cardsDueText)
                    .setTicker(cardsDueText);
            // Enable vibrate and blink if set in preferences
            if (preferences.getBoolean("widgetVibrate", false)) {
                builder.setVibrate(new long[] { 1000, 1000, 1000});
            }
            if (preferences.getBoolean("widgetBlink", false)) {
                builder.setLights(Color.BLUE, 1000, 1000);
            }
            // Creates an explicit intent for an Activity in your app
            Intent resultIntent = new Intent(context, DeckPicker.class);
            resultIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | IntentCompat.FLAG_ACTIVITY_CLEAR_TASK);
            PendingIntent resultPendingIntent = PendingIntent.getActivity(context, 0, resultIntent,
                    PendingIntent.FLAG_UPDATE_CURRENT);
            builder.setContentIntent(resultPendingIntent);
            // mId allows you to update the notification later on.
            mNotificationManager.notify(WIDGET_NOTIFY_ID, builder.build());
        } else {
            // Cancel the existing notification, if any.
            mNotificationManager.cancel(WIDGET_NOTIFY_ID);
        }
        return START_STICKY;
    }


    @Override
    public IBinder onBind(Intent arg0) {
        return null;
    }
}
package com.ichi2.anki.services;

import android.app.AlarmManager;
import android.app.IntentService;
import android.app.Notification;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.support.v4.app.NotificationCompat;
import android.support.v4.app.NotificationManagerCompat;
import android.support.v4.content.ContextCompat;

import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.IntentHandler;
import com.ichi2.anki.R;
import com.ichi2.anki.receiver.ReminderReceiver;
import com.ichi2.libanki.Sched;

public class ReminderService extends IntentService {
    public static final String EXTRA_DECK_ID = "EXTRA_DECK_ID";

    public ReminderService() {
        super("ReminderService");
    }

    @Override
    protected void onHandleIntent(Intent intent) {
        final long deckId = intent.getLongExtra(ReminderService.EXTRA_DECK_ID, 0);

        if (null == CollectionHelper.getInstance().getCol(this).getDecks().get(deckId, false)) {
            final AlarmManager alarmManager = (AlarmManager) this.getSystemService(Context.ALARM_SERVICE);

            final PendingIntent reminderIntent = PendingIntent.getBroadcast(
                    this,
                    (int) deckId,
                    new Intent(this, ReminderReceiver.class).putExtra(ReminderService.EXTRA_DECK_ID, deckId),
                    0
            );

            alarmManager.cancel(reminderIntent);
        }

        Sched.DeckDueTreeNode deckDue = null;

        for (Sched.DeckDueTreeNode node : CollectionHelper.getInstance().getCol(this).getSched().deckDueTree()) {
            if (node.did == deckId) {
                deckDue = node;
                break;
            }
        }

        if (null == deckDue) {
            return;
        }

        final int total = deckDue.revCount + deckDue.lrnCount + deckDue.newCount;

        if (total <= 0) {
            return;
        }

        final NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);

        if (notificationManager.areNotificationsEnabled()) {
            final Notification notification = new NotificationCompat.Builder(this)
                    .setContentTitle(this.getString(R.string.reminder_title))
                    .setContentText(this.getResources().getQuantityString(
                            R.plurals.reminder_text,
                            deckDue.newCount,
                            CollectionHelper.getInstance().getCol(this).getDecks().name(deckId),
                            total
                    ))
                    .setSmallIcon(R.drawable.ic_stat_notify)
                    .setColor(ContextCompat.getColor(this, R.color.material_light_blue_700))
                    .setContentIntent(PendingIntent.getActivity(
                            this,
                            (int) deckId,
                            new Intent(this, IntentHandler.class).putExtra(EXTRA_DECK_ID, deckId),
                            PendingIntent.FLAG_UPDATE_CURRENT
                    ))
                    .setAutoCancel(true)
                    .build();

            notificationManager.notify((int) deckId, notification);
        }
    }
}
/****************************************************************************************
 * Copyright (c) 2014 Michael Goldbach <michael@m-goldbach.net>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/
package com.ichi2.anki.stats;

import android.content.res.Resources;
import android.database.Cursor;
import android.os.AsyncTask;
import android.support.v4.view.ViewPager;
import android.view.View;
import android.webkit.WebView;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.ichi2.anki.R;
import com.ichi2.anki.Statistics;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Stats;
import com.ichi2.themes.Themes;
import com.wildplot.android.rendering.PlotSheet;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import timber.log.Timber;

public class AnkiStatsTaskHandler {

    private static AnkiStatsTaskHandler sInstance;

    private Collection mCollectionData;
    private float mStandardTextSize = 10f;
    private Stats.AxisType mStatType = Stats.AxisType.TYPE_MONTH;
    private boolean mIsWholeCollection = false;
    private static Lock sLock = new ReentrantLock();


    public AnkiStatsTaskHandler(Collection collection){
        sInstance = this;
        mCollectionData = collection;
    }

    public void setIsWholeCollection(boolean wholeCollection) {
        mIsWholeCollection = wholeCollection;
    }

    public static AnkiStatsTaskHandler getInstance() {
        return sInstance;
    }

    public CreateChartTask createChart(Stats.ChartType chartType, View... views){
        CreateChartTask createChartTask = new CreateChartTask(chartType);
        createChartTask.execute(views);
        return createChartTask;
    }
    public CreateStatisticsOverview createStatisticsOverview(View... views){
        CreateStatisticsOverview createChartTask = new CreateStatisticsOverview();
        createChartTask.execute(views);
        return createChartTask;
    }
    public static DeckPreviewStatistics createReviewSummaryStatistics(Collection col, TextView view){
        DeckPreviewStatistics deckPreviewStatistics = new DeckPreviewStatistics();
        deckPreviewStatistics.execute(col, view);
        return deckPreviewStatistics;
    }

    private class CreateChartTask extends AsyncTask<View, Void, PlotSheet>{
        private ChartView mImageView;
        private ProgressBar mProgressBar;

        private boolean mIsRunning = false;
        private Stats.ChartType mChartType;

        public CreateChartTask(Stats.ChartType chartType){
            super();
            mIsRunning = true;
            mChartType = chartType;
        }

        @Override
        protected PlotSheet doInBackground(View... params) {
            //make sure only one task of CreateChartTask is running, first to run should get sLock
            //only necessary on lower APIs because after honeycomb only one thread is used for all asynctasks
            sLock.lock();
            try {
                if (!mIsRunning) {
                    Timber.d("Quitting CreateChartTask (%s) before execution", mChartType.name());
                    return null;
                } else {
                    Timber.d("Starting CreateChartTask, type: %s", mChartType.name());
                }
                mImageView = (ChartView) params[0];
                mProgressBar = (ProgressBar) params[1];
                ChartBuilder chartBuilder = new ChartBuilder(mImageView, mCollectionData,
                        mIsWholeCollection, mChartType);
                return chartBuilder.renderChart(mStatType);
            } finally {
                sLock.unlock();
            }
        }

        @Override
        protected void onCancelled() {
            mIsRunning = false;
        }

        @Override
        protected void onPostExecute(PlotSheet plotSheet) {
            if (plotSheet != null && mIsRunning) {
                mImageView.setData(plotSheet);
                mProgressBar.setVisibility(View.GONE);
                mImageView.setVisibility(View.VISIBLE);
                mImageView.invalidate();
            }
        }
    }

    private class CreateStatisticsOverview extends AsyncTask<View, Void, String>{
        private WebView mWebView;
        private ProgressBar mProgressBar;

        private boolean mIsRunning = false;

        public CreateStatisticsOverview(){
            super();
            mIsRunning = true;
        }

        @Override
        protected String doInBackground(View... params) {
            //make sure only one task of CreateChartTask is running, first to run should get sLock
            //only necessary on lower APIs because after honeycomb only one thread is used for all asynctasks
            sLock.lock();
            try {
                if (!mIsRunning) {
                    Timber.d("Quitting CreateStatisticsOverview before execution");
                    return null;
                } else {
                    Timber.d("Starting CreateStatisticsOverview");
                }
                mWebView = (WebView) params[0];
                mProgressBar = (ProgressBar) params[1];
                OverviewStatsBuilder overviewStatsBuilder = new OverviewStatsBuilder(mWebView, mCollectionData, mIsWholeCollection, mStatType);
                return overviewStatsBuilder.createInfoHtmlString();
            } finally {
                sLock.unlock();
            }
        }

        @Override
        protected void onCancelled() {
            mIsRunning = false;
        }

        @Override
        protected void onPostExecute(String html) {
            if (html != null && mIsRunning) {
                try {
                    mWebView.loadData(URLEncoder.encode(html, "UTF-8").replaceAll("\\+", " "), "text/html; charset=utf-8", "utf-8");
                } catch (UnsupportedEncodingException e) {
                    e.printStackTrace();
                }
                mProgressBar.setVisibility(View.GONE);
                int backgroundColor = Themes.getColorFromAttr(mWebView.getContext(), android.R.attr.colorBackground);
                mWebView.setBackgroundColor(backgroundColor);
                mWebView.setVisibility(View.VISIBLE);
                mWebView.invalidate();
            }
        }
    }

    private static class DeckPreviewStatistics extends AsyncTask<Object, Void, String> {
        private TextView mTextView;

        private boolean mIsRunning = false;

        public DeckPreviewStatistics() {
            super();
            mIsRunning = true;
        }

        @Override
        protected String doInBackground(Object... params) {
            //make sure only one task of CreateChartTask is running, first to run should get sLock
            //only necessary on lower APIs because after honeycomb only one thread is used for all asynctasks
            sLock.lock();
            try {
                Collection collection = (Collection) params[0];
                if (!mIsRunning || collection == null || collection.getDb() == null) {
                    Timber.d("Quitting DeckPreviewStatistics before execution");
                    return null;
                } else {
                    Timber.d("Starting DeckPreviewStatistics");
                }
                mTextView = (TextView) params[1];

                //eventually put this in Stats (in desktop it is not though)
                int cards;
                int minutes;
                Cursor cur = null;
                String query = "select count(), sum(time)/1000 from revlog where id > " + ((collection.getSched().getDayCutoff() - 86400) * 1000);
                Timber.d("DeckPreviewStatistics query: " + query);

                try {
                    cur = collection.getDb()
                            .getDatabase()
                            .rawQuery(query, null);

                    cur.moveToFirst();
                    cards = cur.getInt(0);
                    minutes = (int) Math.round(cur.getInt(1) / 60.0);
                } finally {
                    if (cur != null && !cur.isClosed()) {
                        cur.close();
                    }
                }
                Resources res = collection.getContext().getResources();
                final String span = res.getQuantityString(R.plurals.time_span_minutes, minutes, minutes);
                return res.getQuantityString(R.plurals.studied_cards_today, cards, cards, span);
            } finally {
                sLock.unlock();
            }
        }

        @Override
        protected void onCancelled() {
            mIsRunning = false;
        }

        @Override
        protected void onPostExecute(String todayStatString) {
            if (todayStatString != null && mIsRunning) {
                mTextView.setText(todayStatString);
                mTextView.setVisibility(View.VISIBLE);
                mTextView.invalidate();
            }
        }
    }



    public float getmStandardTextSize() {
        return mStandardTextSize;
    }

    public void setmStandardTextSize(float mStandardTextSize) {
        this.mStandardTextSize = mStandardTextSize;
    }

    public Stats.AxisType getStatType() {
        return mStatType;
    }

    public void setStatType(Stats.AxisType mStatType) {
        this.mStatType = mStatType;
    }

}
/****************************************************************************************
 * Copyright (c) 2014 Michael Goldbach <michael@m-goldbach.net>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/
package com.ichi2.anki.stats;

import android.graphics.Paint;

import com.ichi2.anki.R;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Stats;
import com.ichi2.themes.Themes;
import com.wildplot.android.rendering.BarGraph;
import com.wildplot.android.rendering.LegendDrawable;
import com.wildplot.android.rendering.Lines;
import com.wildplot.android.rendering.PieChart;
import com.wildplot.android.rendering.PlotSheet;
import com.wildplot.android.rendering.XAxis;
import com.wildplot.android.rendering.XGrid;
import com.wildplot.android.rendering.YAxis;
import com.wildplot.android.rendering.YGrid;
import com.wildplot.android.rendering.graphics.wrapper.ColorWrap;
import com.wildplot.android.rendering.graphics.wrapper.RectangleWrap;

import timber.log.Timber;


public class ChartBuilder {
    private static final float BAR_OPACITY = 0.7f;
    private static final double STARTING_BAR_THICKNESS = 0.6;
    private static final double Y_AXIS_STRETCH_FACTOR = 1.05;

    private final Stats.ChartType mChartType;
    private boolean mIsWholeCollection = false;
    private ChartView mChartView;
    private Collection mCollectionData;

    int mMaxCards = 0;
    private boolean mBackwards;
    private int[] mValueLabels;
    private int[] mColors;
    private int[] mAxisTitles;
    private double[][] mSeriesList;
    private double mLastElement = 0;
    private double[][] mCumulative = null;
    private double mFirstElement;
    private boolean mHasColoredCumulative;
    private double mMcount;
    private boolean mDynamicAxis;

    public ChartBuilder(ChartView chartView, Collection collectionData, boolean isWholeCollection, Stats.ChartType chartType){
        mChartView = chartView;
        mCollectionData = collectionData;
        mIsWholeCollection = isWholeCollection;
        mChartType = chartType;
    }

    private void calcStats(Stats.AxisType type){
        Stats stats = new Stats(mCollectionData, mIsWholeCollection);
        switch (mChartType){
            case FORECAST:
                stats.calculateDue(mChartView.getContext(), type);
                break;
            case REVIEW_COUNT:
                stats.calculateReviewCount(type);
                break;
            case REVIEW_TIME:
                stats.calculateReviewTime(type);
                break;
            case INTERVALS:
                stats.calculateIntervals(mChartView.getContext(), type);
                break;
            case HOURLY_BREAKDOWN:
                stats.calculateBreakdown(type);
                break;
            case WEEKLY_BREAKDOWN:
                stats.calculateWeeklyBreakdown(type);
                break;
            case ANSWER_BUTTONS:
                stats.calculateAnswerButtons(type);
                break;
            case CARDS_TYPES:
                stats.calculateCardTypes(type);
                break;
        }
        mCumulative = stats.getCumulative();
        mSeriesList = stats.getSeriesList();
        Object[] metaData = stats.getMetaInfo();
        mBackwards = (Boolean) metaData[2];
        mValueLabels = (int[]) metaData[3];
        mColors = (int[]) metaData[4];
        mAxisTitles = (int[]) metaData[5];
        mMaxCards = (Integer) metaData[7];
        mLastElement = (Double) metaData[10];
        mFirstElement = (Double) metaData[9];
        mHasColoredCumulative = (Boolean) metaData[19];
        mMcount = (Double) metaData[18];
        mDynamicAxis = (Boolean) metaData[20];
    }

    public PlotSheet renderChart(Stats.AxisType type){
        calcStats(type);
        Paint paint = new Paint(Paint.LINEAR_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
        paint.setStyle(Paint.Style.STROKE);

        int height = mChartView.getMeasuredHeight();
        int width = mChartView.getMeasuredWidth();
        Timber.d("height: %d, width: %d, %d", height, width, mChartView.getWidth());

        if (height <= 0 || width <= 0) {
            return null;
        }

        RectangleWrap rect = new RectangleWrap(width, height);
        float textSize = AnkiStatsTaskHandler.getInstance().getmStandardTextSize() * 0.85f;
        paint.setTextSize(textSize);
        float FontHeight = paint.getTextSize();
        int desiredPixelDistanceBetweenTicks = Math.round(paint.measureText("100000") * 2.6f);
        int frameThickness = Math.round(FontHeight * 4.0f);

        //System.out.println("frame thickness: " + mFrameThickness);

        PlotSheet plotSheet = new PlotSheet(mFirstElement - 0.5, mLastElement + 0.5, 0, mMaxCards * Y_AXIS_STRETCH_FACTOR);
        plotSheet.setFrameThickness(frameThickness * 0.66f, frameThickness * 0.66f, frameThickness, frameThickness * 0.9f);
        plotSheet.setFontSize(textSize);
        int backgroundColor = Themes.getColorFromAttr(mChartView.getContext(), android.R.attr.colorBackground);
        plotSheet.setBackgroundColor(new ColorWrap(backgroundColor));
        int textColor = Themes.getColorFromAttr(mChartView.getContext(), android.R.attr.textColor);
        plotSheet.setTextColor(new ColorWrap(textColor));
        plotSheet.setIsBackwards(mBackwards);

        if (mChartType == Stats.ChartType.CARDS_TYPES) {
            return createPieChart(plotSheet);
        }

        PlotSheet hiddenPlotSheet = new PlotSheet(mFirstElement - 0.5, mLastElement + 0.5, 0, mMcount * Y_AXIS_STRETCH_FACTOR);     //for second y-axis
        hiddenPlotSheet.setFrameThickness(frameThickness * 0.66f, frameThickness * 0.66f, frameThickness, frameThickness * 0.9f);

        setupCumulative(plotSheet, hiddenPlotSheet);
        setupBarGraphs(plotSheet, hiddenPlotSheet);

        double xTicks = ticksCalcX(desiredPixelDistanceBetweenTicks, rect, mFirstElement, mLastElement);
        setupXaxis(plotSheet, xTicks, true);

        double yTicks = ticksCalcY(desiredPixelDistanceBetweenTicks, rect, 0, mMaxCards * Y_AXIS_STRETCH_FACTOR);
        setupYaxis(plotSheet, hiddenPlotSheet, yTicks, mAxisTitles[1], false, true);

        //0 = X-axis title
        //1 = Y-axis title left
        //2 = Y-axis title right (optional)
        if(mAxisTitles.length == 3) {
            double rightYtics = ticsCalc(desiredPixelDistanceBetweenTicks, rect, mMcount * Y_AXIS_STRETCH_FACTOR);
            setupYaxis(plotSheet, hiddenPlotSheet, rightYtics, mAxisTitles[2], true, true);
        }
        setupGrid(plotSheet, yTicks * 0.5, xTicks * 0.5);

        return plotSheet;
    }


    private PlotSheet createPieChart(PlotSheet plotSheet) {
        ColorWrap[] colors = {new ColorWrap(Themes.getColorFromAttr(mChartView.getContext(), mColors[0])),
                              new ColorWrap(Themes.getColorFromAttr(mChartView.getContext(), mColors[1])),
                              new ColorWrap(Themes.getColorFromAttr(mChartView.getContext(), mColors[2])),
                              new ColorWrap(Themes.getColorFromAttr(mChartView.getContext(), mColors[3]))};

        PieChart pieChart = new PieChart(plotSheet, mSeriesList[0], colors);
        pieChart.setName(mChartView.getResources().getString(mValueLabels[0]) + ": " + (int) mSeriesList[0][0]);
        LegendDrawable legendDrawable1 = new LegendDrawable();
        LegendDrawable legendDrawable2 = new LegendDrawable();
        LegendDrawable legendDrawable3 = new LegendDrawable();
        legendDrawable1.setColor(new ColorWrap(Themes.getColorFromAttr(mChartView.getContext(), mColors[1])));
        legendDrawable2.setColor(new ColorWrap(Themes.getColorFromAttr(mChartView.getContext(), mColors[2])));
        legendDrawable3.setColor(new ColorWrap(Themes.getColorFromAttr(mChartView.getContext(), mColors[3])));

        legendDrawable1.setName(mChartView.getResources().getString(mValueLabels[1]) + ": " + (int) mSeriesList[0][1]);
        legendDrawable2.setName(mChartView.getResources().getString(mValueLabels[2]) + ": " + (int) mSeriesList[0][2]);
        legendDrawable3.setName(mChartView.getResources().getString(mValueLabels[3]) + ": " + (int) mSeriesList[0][3]);

        plotSheet.unsetBorder();
        plotSheet.addDrawable(pieChart);
        plotSheet.addDrawable(legendDrawable1);
        plotSheet.addDrawable(legendDrawable2);
        plotSheet.addDrawable(legendDrawable3);

        return plotSheet;
    }


    private void setupBarGraphs(PlotSheet plotSheet, PlotSheet hiddenPlotSheet) {
        int length = mSeriesList.length;
        if (mChartType == Stats.ChartType.HOURLY_BREAKDOWN || mChartType == Stats.ChartType.WEEKLY_BREAKDOWN) {
            length--;   //there is data in hourly breakdown that is never used (even in Anki-Desktop)
        }
        for (int i = 1; i < length; i++) {
            double[][] bars = new double[2][];
            bars[0] = mSeriesList[0];
            bars[1] = mSeriesList[i];

            PlotSheet usedPlotSheet = plotSheet;
            double barThickness = STARTING_BAR_THICKNESS;
            if ((mChartType == Stats.ChartType.HOURLY_BREAKDOWN || mChartType == Stats.ChartType.WEEKLY_BREAKDOWN)) {
                barThickness = 0.8;
                if (i == 2) {
                    usedPlotSheet = hiddenPlotSheet;
                    barThickness = 0.2;
                }
            }
            ColorWrap color;
            switch (mChartType) {
                case ANSWER_BUTTONS:
                case HOURLY_BREAKDOWN:
                case WEEKLY_BREAKDOWN:
                case INTERVALS:
                    color = new ColorWrap(Themes.getColorFromAttr(mChartView.getContext(), mColors[i - 1]), BAR_OPACITY);
                    break;
                case REVIEW_COUNT:
                case REVIEW_TIME:
                case FORECAST:
                    if (i == 1) {
                        color = new ColorWrap(Themes.getColorFromAttr(mChartView.getContext(), mColors[i - 1]), BAR_OPACITY);
                        break;
                    }
                default:
                    color = new ColorWrap(Themes.getColorFromAttr(mChartView.getContext(), mColors[i - 1]));
            }

            BarGraph barGraph = new BarGraph(usedPlotSheet, barThickness, bars, color);
            barGraph.setFilling(true);
            barGraph.setName(mChartView.getResources().getString(mValueLabels[i - 1]));
            //barGraph.setFillColor(Color.GREEN.darker());
            barGraph.setFillColor(color);
            plotSheet.addDrawable(barGraph);
        }
    }


    private void setupCumulative(PlotSheet plotSheet, PlotSheet hiddenPlotSheet){
        if (mCumulative == null) {
            return;
        }
        for (int i = 1; i < mCumulative.length; i++) {
            double[][] cumulative = {mCumulative[0], mCumulative[i]};

            ColorWrap usedColor = new ColorWrap(Themes.getColorFromAttr(mChartView.getContext(), R.attr.stats_cumulative));
            String name = mChartView.getResources().getString(R.string.stats_cumulative);
            if (mHasColoredCumulative) {      //also non colored Cumulatives have names!
                usedColor = new ColorWrap(Themes.getColorFromAttr(mChartView.getContext(), mColors[i - 1]));
            } else {
                if (mChartType == Stats.ChartType.INTERVALS) {
                    name = mChartView.getResources().getString(R.string.stats_cumulative_percentage);
                }
            }

            Lines lines = new Lines(hiddenPlotSheet, cumulative, usedColor);
            lines.setSize(3f);
            lines.setShadow(5f, 2f, 2f, ColorWrap.BLACK);
            if (!mHasColoredCumulative) {
                lines.setName(name);
            }
            plotSheet.addDrawable(lines);
        }
    }


    private void setupXaxis(PlotSheet plotSheet, double xTicks, boolean hasName) {
        XAxis xAxis = new XAxis(plotSheet, 0, xTicks, xTicks / 2.0);
        xAxis.setOnFrame();
        if (hasName) {
            if (mDynamicAxis) {
                xAxis.setName(mChartView.getResources().getStringArray(R.array.due_x_axis_title)[mAxisTitles[0]]);
            } else {
                xAxis.setName(mChartView.getResources().getString(mAxisTitles[0]));
            }
        }
        double[] timePositions;

        //some explicit x-axis naming:
        switch (mChartType) {
            case ANSWER_BUTTONS:
                timePositions = new double[]{1, 2, 3, 6, 7, 8, 9, 11, 12, 13, 14};
                xAxis.setExplicitTicks(timePositions, mChartView.getResources().getStringArray(R.array.stats_eases_ticks));
                break;
            case HOURLY_BREAKDOWN:
                timePositions = new double[]{0, 6, 12, 18, 23};
                xAxis.setExplicitTicks(timePositions, mChartView.getResources().getStringArray(R.array.stats_day_time_strings));
                break;
            case WEEKLY_BREAKDOWN:
                timePositions = new double[]{0, 1, 2, 3, 4, 5, 6};
                xAxis.setExplicitTicks(timePositions, mChartView.getResources().getStringArray(R.array.stats_week_days));
                break;
        }

        xAxis.setIntegerNumbering(true);
        plotSheet.addDrawable(xAxis);
    }


    private void setupYaxis(PlotSheet plotSheet, PlotSheet hiddenPlotSheet, double yTicks, int title,
                            boolean isOnRight, boolean hasName) {
        YAxis yAxis;
        if (isOnRight && hiddenPlotSheet != null) {
            yAxis = new YAxis(hiddenPlotSheet, 0, yTicks, yTicks / 2.0);
        } else {
            yAxis = new YAxis(plotSheet, 0, yTicks, yTicks / 2.0);
        }

        yAxis.setIntegerNumbering(true);
        if (hasName) {
            yAxis.setName(mChartView.getResources().getString(title));
        }
        if (isOnRight) {
            yAxis.setOnRightSideFrame();
        } else {
            yAxis.setOnFrame();
        }

        yAxis.setHasNumbersRotated();
        plotSheet.addDrawable(yAxis);
    }


    private void setupGrid(PlotSheet plotSheet, double yTicks, double xTicks) {
        int red = ColorWrap.LIGHT_GRAY.getRed();
        int green = ColorWrap.LIGHT_GRAY.getGreen();
        int blue = ColorWrap.LIGHT_GRAY.getBlue();

        ColorWrap newGridColor = new ColorWrap(red, green, blue, 222);

        XGrid xGrid = new XGrid(plotSheet, 0, yTicks);  //ticks are not wrong, xgrid is vertical to yaxis -> yticks
        YGrid yGrid = new YGrid(plotSheet, 0, xTicks);

        double[] timePositions;

        //some explicit x-axis naming:
        switch (mChartType) {
            case ANSWER_BUTTONS:
                timePositions = new double[]{1, 2, 3, 6, 7, 8, 9, 11, 12, 13, 14};
                yGrid.setExplicitTicks(timePositions);
                break;
            case HOURLY_BREAKDOWN:
                timePositions = new double[]{0, 6, 12, 18, 23};
                yGrid.setExplicitTicks(timePositions);
                break;
            case WEEKLY_BREAKDOWN:
                timePositions = new double[]{0, 1, 2, 3, 4, 5, 6};
                yGrid.setExplicitTicks(timePositions);
                break;
        }
        xGrid.setColor(newGridColor);
        yGrid.setColor(newGridColor);
        plotSheet.addDrawable(xGrid);
        plotSheet.addDrawable(yGrid);
    }


    public double ticksCalcX(int pixelDistance, RectangleWrap field, double start, double end) {
        double deltaRange = end - start;
        int ticlimit = field.width / pixelDistance;
        double tics = Math.pow(10, (int) Math.log10(deltaRange / ticlimit));
        while (2.0 * (deltaRange / (tics)) <= ticlimit) {
            tics /= 2.0;
        }
        while ((deltaRange / (tics)) / 2 >= ticlimit) {
            tics *= 2.0;
        }
        return tics;
    }

    public double ticksCalcY(int pixelDistance, RectangleWrap field, double start, double end) {

        double size = ticsCalc(pixelDistance, field, end - start);
        Timber.d("ChartBuilder ticksCalcY: pixelDistance: %d, ticks: %,.2f, start: %,.2f, end: %,.2f, height: %d", pixelDistance, size, start, end, field.height);
        return size;
    }

    public double ticsCalc(int pixelDistance, RectangleWrap field, double deltaRange) {

        //Make approximation of number of ticks based on desired number of pixels per tick
        double numTicks = field.height / pixelDistance;

        //Compute size of one tick in graph-units
        double delta = deltaRange / numTicks;

        //Write size of one tick in the form norm * magn
        double dec = Math.floor(Math.log(delta) / Math.log(10));
        double magn = Math.pow(10, dec);

        double norm = delta / magn; // norm is between 1.0 and 10.0

        //Write size of one tick in the form size * magn
        //Where size in (1, 2, 2.5, 5, 10)
        double size;

        if (norm < 1.5) {
            size = 1;
        } else if (norm < 3) {
            size = 2;
            // special case for 2.5, requires an extra decimal
            if (norm > 2.25) {
                size = 2.5;
            }
        } else if (norm < 7.5) {
            size = 5;
        } else {
            size = 10;
        }

        //Compute size * magn so that we return one number
        size *= magn;

        Timber.d("ChartBuilder ticksCalc : pixelDistance: %d, ticks: %,.2f, deltaRange: %,.2f, height: %d", pixelDistance, size, deltaRange, field.height);

        return size;
    }
}
/****************************************************************************************
 * Copyright (c) 2014 Michael Goldbach <michael@wildplot.com>                           *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/
package com.ichi2.anki.stats;


import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Rect;
import android.util.AttributeSet;
import android.view.View;

import com.ichi2.anki.Statistics;
import com.wildplot.android.rendering.PlotSheet;
import com.wildplot.android.rendering.graphics.wrapper.GraphicsWrap;
import com.wildplot.android.rendering.graphics.wrapper.RectangleWrap;

import timber.log.Timber;

public class ChartView extends View {

    private Statistics.ChartFragment mFragment;
    private PlotSheet mPlotSheet;
    private boolean mDataIsSet;

    //The following constructors are needed for the layout inflater
    public ChartView(Context context) {
        super(context);
        setWillNotDraw(false);
    }

    public ChartView(Context context, AttributeSet attrs) {
        super(context, attrs);
        setWillNotDraw(false);
    }

    public ChartView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        setWillNotDraw(false);
    }


    @Override
    public void onDraw(Canvas canvas) {
        //Timber.d("drawing chart");
        if (mDataIsSet) {
            //Paint paint = new Paint(Paint.LINEAR_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
            Paint paint = new Paint(Paint.LINEAR_TEXT_FLAG);
            paint.setAntiAlias(true);
            paint.setStyle(Paint.Style.STROKE);
            GraphicsWrap g = new GraphicsWrap(canvas, paint);

            Rect field = new Rect();
            this.getDrawingRect(field);
            g.setClip(new RectangleWrap(field));
            if (mPlotSheet != null) {
                mPlotSheet.paint(g);
            } else {
                super.onDraw(canvas);
            }
        } else {
            super.onDraw(canvas);
        }
    }


    public void addFragment(Statistics.ChartFragment fragment) {
        mFragment = fragment;
    }


    public void setData(PlotSheet plotSheet) {
        mPlotSheet = plotSheet;
        mDataIsSet = true;
    }


    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        Timber.d("ChartView sizeChange!");
        if (mFragment != null) {
            mFragment.checkAndUpdate();
        }
    }
}
/****************************************************************************************
 * Copyright (c) 2014 Michael Goldbach <michael@m-goldbach.net>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/
package com.ichi2.anki.stats;


import android.content.res.Resources;
import android.database.Cursor;
import android.webkit.WebView;

import com.ichi2.anki.R;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Stats;
import com.ichi2.libanki.Utils;
import com.ichi2.themes.Themes;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import timber.log.Timber;

public class OverviewStatsBuilder {
    private static final int CARDS_INDEX = 0;
    private static final int THETIME_INDEX = 1;
    private static final int FAILED_INDEX = 2;
    private static final int LRN_INDEX = 3;
    private static final int REV_INDEX = 4;
    private static final int RELRN_INDEX = 5;
    private static final int FILT_INDEX = 6;
    private static final int MCNT_INDEX = 7;
    private static final int MSUM_INDEX = 8;

    private final WebView mWebView; //for resources access
    private final Collection mCol;
    private final boolean mWholeCollection;
    private final Stats.AxisType mType;


    public class OverviewStats {
        public int forecastTotalReviews;
        public double forecastAverageReviews;
        public int forecastDueTomorrow;
        public double reviewsPerDayOnAll;
        public double reviewsPerDayOnStudyDays;
        public int allDays;
        public int daysStudied;
        public double timePerDayOnAll;
        public double timePerDayOnStudyDays;
        public double totalTime;
        public int totalReviews;
        public double newCardsPerDay;
        public int totalNewCards;
        public double averageInterval;
        public double longestInterval;
    }

    public OverviewStatsBuilder(WebView chartView, Collection collectionData, boolean isWholeCollection, Stats.AxisType mStatType) {
        mWebView = chartView;
        mCol = collectionData;
        mWholeCollection = isWholeCollection;
        mType = mStatType;
    }

    public String createInfoHtmlString() {
        int textColorInt = Themes.getColorFromAttr(mWebView.getContext(), android.R.attr.textColor);
        String textColor = String.format("#%06X", (0xFFFFFF & textColorInt)); // Color to hex string

        String css = "<style>\n" +
                "h1, h3 { margin-bottom: 0; margin-top: 1em; text-transform: capitalize; }\n" +
                ".pielabel { text-align:center; padding:0px; color:white; }\n" +
                "body {color:" + textColor + ";}\n" +
                "</style>";

        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("<center>");
        stringBuilder.append(css);
        appendTodaysStats(stringBuilder);

        appendOverViewStats(stringBuilder);

        stringBuilder.append("</center>");
        return stringBuilder.toString();
    }

    private void appendOverViewStats(StringBuilder stringBuilder) {
        Stats stats = new Stats(mCol, mWholeCollection);

        OverviewStats oStats = new OverviewStats();
        stats.calculateOverviewStatistics(mType, oStats);
        Resources res = mWebView.getResources();

        stringBuilder.append(_title(res.getString(mType.descriptionId)));

        boolean allDaysStudied = oStats.daysStudied == oStats.allDays;
        String daysStudied = res.getString(R.string.stats_overview_days_studied,
                (int) ((float) oStats.daysStudied / (float) oStats.allDays * 100),
                oStats.daysStudied, oStats.allDays);


        // FORECAST
        // Fill in the forecast summaries first
        calculateForecastOverview(mType, oStats);

        stringBuilder.append(_subtitle(res.getString(R.string.stats_forecast).toUpperCase()));
        stringBuilder.append(res.getString(R.string.stats_overview_forecast_total, oStats.forecastTotalReviews));
        stringBuilder.append("<br>");
        stringBuilder.append(res.getString(R.string.stats_overview_forecast_average, oStats.forecastAverageReviews));
        stringBuilder.append("<br>");
        stringBuilder.append(res.getString(R.string.stats_overview_forecast_due_tomorrow, oStats.forecastDueTomorrow));

        stringBuilder.append("<br>");

        // REVIEW COUNT
        stringBuilder.append(_subtitle(res.getString(R.string.stats_review_count).toUpperCase()));
        stringBuilder.append(daysStudied);
        stringBuilder.append("<br>");
        stringBuilder.append(res.getString(R.string.stats_overview_total_reviews, oStats.totalReviews));
        stringBuilder.append("<br>");
        stringBuilder.append(res.getString(R.string.stats_overview_reviews_per_day_studydays, oStats.reviewsPerDayOnStudyDays));
        if (!allDaysStudied) {
            stringBuilder.append("<br>");
            stringBuilder.append(res.getString(R.string.stats_overview_reviews_per_day_all, oStats.reviewsPerDayOnAll));
        }

        stringBuilder.append("<br>");

        //REVIEW TIME
        stringBuilder.append(_subtitle(res.getString(R.string.stats_review_time).toUpperCase()));
        stringBuilder.append(daysStudied);
        stringBuilder.append("<br>");
        // TODO: Total: x minutes
        stringBuilder.append(res.getString(R.string.stats_overview_time_per_day_studydays, oStats.timePerDayOnStudyDays));
        if (!allDaysStudied) {
            stringBuilder.append("<br>");
            stringBuilder.append(res.getString(R.string.stats_overview_time_per_day_all, oStats.timePerDayOnAll));
        }
        // TODO: Average answer time: x.xs (x.x cards/minute)

        stringBuilder.append("<br>");

        // ADDED
        stringBuilder.append(_subtitle(res.getString(R.string.stats_added).toUpperCase()));
        stringBuilder.append(res.getString(R.string.stats_overview_total_new_cards, oStats.totalNewCards));
        stringBuilder.append("<br>");
        stringBuilder.append(res.getString(R.string.stats_overview_new_cards_per_day, oStats.newCardsPerDay));

        stringBuilder.append("<br>");

        // INTERVALS
        stringBuilder.append(_subtitle(res.getString(R.string.stats_review_intervals).toUpperCase()));
        stringBuilder.append(res.getString(R.string.stats_overview_average_interval));
        stringBuilder.append(Utils.roundedTimeSpan(mWebView.getContext(), (int) Math.round(oStats.averageInterval * Stats.SECONDS_PER_DAY)));
        stringBuilder.append("<br>");
        stringBuilder.append(res.getString(R.string.stats_overview_longest_interval));
        stringBuilder.append(Utils.roundedTimeSpan(mWebView.getContext(), (int) Math.round(oStats.longestInterval * Stats.SECONDS_PER_DAY)));
    }

    private void appendTodaysStats(StringBuilder stringBuilder) {
        Stats stats = new Stats(mCol, mWholeCollection);
        int[] todayStats = stats.calculateTodayStats();
        stringBuilder.append(_title(mWebView.getResources().getString(R.string.stats_today)));
        Resources res = mWebView.getResources();
        final int minutes = (int) Math.round(todayStats[THETIME_INDEX] / 60.0);
        final String span = res.getQuantityString(R.plurals.time_span_minutes, minutes, minutes);
        stringBuilder.append(res.getQuantityString(R.plurals.stats_today_cards,
                todayStats[CARDS_INDEX], todayStats[CARDS_INDEX], span));
        stringBuilder.append("<br>");
        stringBuilder.append(res.getString(R.string.stats_today_again_count, todayStats[FAILED_INDEX]));
        if (todayStats[CARDS_INDEX] > 0) {
            stringBuilder.append(" ");
            stringBuilder.append(res.getString(R.string.stats_today_correct_count, (((1 - todayStats[FAILED_INDEX] / (float) (todayStats[CARDS_INDEX])) * 100.0))));
        }
        stringBuilder.append("<br>");
        stringBuilder.append(res.getString(R.string.stats_today_type_breakdown, todayStats[LRN_INDEX], todayStats[REV_INDEX], todayStats[RELRN_INDEX], todayStats[FILT_INDEX]));
        stringBuilder.append("<br>");
        if (todayStats[MCNT_INDEX] != 0) {
            stringBuilder.append(res.getString(R.string.stats_today_mature_cards, todayStats[MSUM_INDEX], todayStats[MCNT_INDEX], (todayStats[MSUM_INDEX] / (float) (todayStats[MCNT_INDEX]) * 100.0)));
        } else {
            stringBuilder.append(res.getString(R.string.stats_today_no_mature_cards));
        }
    }


    private String _title(String title) {
        return "<h1>" + title + "</h1>";
    }


    private String _subtitle(String title) {
        return "<h3>" + title + "</h3>";
    }

    // This is a copy of Stats#calculateDue that is more similar to the original desktop version which
    // allows us to easily fetch the values required for the summary. In the future, this version
    // should replace the one in Stats.java.
    private void calculateForecastOverview(Stats.AxisType type, OverviewStats oStats) {
        Integer start = null;
        Integer end = null;
        int chunk = 0;
        switch (type) {
            case TYPE_MONTH:
                start = 0; end = 31; chunk = 1;
                break;
            case TYPE_YEAR:
                start = 0; end = 52; chunk = 7;
                break;
            case TYPE_LIFE:
                start = 0; end = null; chunk = 30;
                break;
        }
        List<int[]> d = _due(start, end, chunk);
        List<int[]> yng = new ArrayList<>();
        List<int[]> mtr = new ArrayList<>();
        int tot = 0;
        List<int[]> totd = new ArrayList<>();
        for (int[] day : d) {
            yng.add(new int[] {day[0], day[1]});
            mtr.add(new int[] {day[0], day[2]});
            tot += day[1]+day[2];
            totd.add(new int[] {day[0], tot});
        }

        // Fill in the overview stats
        oStats.forecastTotalReviews = tot;
        oStats.forecastAverageReviews = totd.size() == 0 ? 0 : (double) tot / (totd.size() * chunk);
        oStats.forecastDueTomorrow = mCol.getDb().queryScalar(String.format(Locale.US,
                "select count() from cards where did in %s and queue in (2,3) " +
                        "and due = ?", _limit()), new String[]{Integer.toString(mCol.getSched().getToday() + 1)});
    }

    private List<int[]> _due(Integer start, Integer end, int chunk) {
        String lim = "";
        if (start != null) {
            lim += String.format(Locale.US, " and due-%d >= %d", mCol.getSched().getToday(), start);
        }
        if (end != null) {
            lim += String.format(Locale.US, " and day < %d", end);
        }

        List<int[]> d = new ArrayList<>();
        Cursor cur = null;
        try {
            String query;
            query = String.format(Locale.US,
                    "select (due-%d)/%d as day,\n" +
                    "sum(case when ivl < 21 then 1 else 0 end), -- yng\n" +
                    "sum(case when ivl >= 21 then 1 else 0 end) -- mtr\n" +
                    "from cards\n" +
                    "where did in %s and queue in (2,3)\n" +
                    "%s\n" +
                    "group by day order by day",
                    mCol.getSched().getToday(), chunk, _limit(), lim);
            cur = mCol.getDb().getDatabase().rawQuery(query, null);
            while (cur.moveToNext()) {
                d.add(new int[]{cur.getInt(0), cur.getInt(1), cur.getInt(2)});
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        return d;
    }


    private String _limit() {
        if (mWholeCollection) {
            ArrayList<Long> ids = new ArrayList<>();
            for (JSONObject d : mCol.getDecks().all()) {
                try {
                    ids.add(d.getLong("id"));
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
            }
            return Utils.ids2str(Utils.arrayList2array(ids));
        } else {
            return mCol.getSched()._deckLimit();
        }
    }
}
/****************************************************************************************
 * Copyright (c) 2016 Jeffrey van Prehn <jvanprehn@gmail.com>                           *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.stats;

import com.ichi2.libanki.Stats;

/**
 * Interface between Stats.java and AdvancedStatistics.java
 */
public class StatsMetaInfo {
    boolean mDynamicAxis = false;
    boolean mHasColoredCumulative = false;
    Stats.AxisType mType;
    int mTitle;
    boolean mBackwards;
    int[] mValueLabels;
    int[] mColors;
    int[] mAxisTitles;
    int mMaxCards = 0;
    int mMaxElements = 0;
    double mFirstElement = 0;
    double mLastElement = 0;
    int mZeroIndex = 0;
    double[][] mCumulative = null;
    double mMcount;

    double[][] mSeriesList;

    boolean statsCalculated;
    boolean dataAvailable;

    public boolean isStatsCalculated() {
        return statsCalculated;
    }

    public void setStatsCalculated(boolean statsCalculated) {
        this.statsCalculated = statsCalculated;
    }

    public double[][] getmSeriesList() {
        return mSeriesList;
    }

    public void setmSeriesList(double[][] mSeriesList) {
        this.mSeriesList = mSeriesList;
    }

    public boolean isDataAvailable() {
        return dataAvailable;
    }

    public void setDataAvailable(boolean dataAvailable) {
        this.dataAvailable = dataAvailable;
    }

    public boolean ismDynamicAxis() {
        return mDynamicAxis;
    }

    public void setmDynamicAxis(boolean mDynamicAxis) {
        this.mDynamicAxis = mDynamicAxis;
    }

    public boolean ismHasColoredCumulative() {
        return mHasColoredCumulative;
    }

    public void setmHasColoredCumulative(boolean mHasColoredCumulative) {
        this.mHasColoredCumulative = mHasColoredCumulative;
    }

    public Stats.AxisType getmType() {
        return mType;
    }

    public void setmType(Stats.AxisType mType) {
        this.mType = mType;
    }

    public int getmTitle() {
        return mTitle;
    }

    public void setmTitle(int mTitle) {
        this.mTitle = mTitle;
    }

    public boolean ismBackwards() {
        return mBackwards;
    }

    public void setmBackwards(boolean mBackwards) {
        this.mBackwards = mBackwards;
    }

    public int[] getmValueLabels() {
        return mValueLabels;
    }

    public void setmValueLabels(int[] mValueLabels) {
        this.mValueLabels = mValueLabels;
    }

    public int[] getmColors() {
        return mColors;
    }

    public void setmColors(int[] mColors) {
        this.mColors = mColors;
    }

    public int[] getmAxisTitles() {
        return mAxisTitles;
    }

    public void setmAxisTitles(int[] mAxisTitles) {
        this.mAxisTitles = mAxisTitles;
    }

    public int getmMaxCards() {
        return mMaxCards;
    }

    public void setmMaxCards(int mMaxCards) {
        this.mMaxCards = mMaxCards;
    }

    public int getmMaxElements() {
        return mMaxElements;
    }

    public void setmMaxElements(int mMaxElements) {
        this.mMaxElements = mMaxElements;
    }

    public double getmFirstElement() {
        return mFirstElement;
    }

    public void setmFirstElement(double mFirstElement) {
        this.mFirstElement = mFirstElement;
    }

    public double getmLastElement() {
        return mLastElement;
    }

    public void setmLastElement(double mLastElement) {
        this.mLastElement = mLastElement;
    }

    public int getmZeroIndex() {
        return mZeroIndex;
    }

    public void setmZeroIndex(int mZeroIndex) {
        this.mZeroIndex = mZeroIndex;
    }

    public double[][] getmCumulative() {
        return mCumulative;
    }

    public void setmCumulative(double[][] mCumulative) {
        this.mCumulative = mCumulative;
    }

    public double getmMcount() {
        return mMcount;
    }

    public void setmMcount(double mMcount) {
        this.mMcount = mMcount;
    }
}
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.web;

import android.content.Context;

import org.apache.http.HttpResponse;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.apache.http.protocol.BasicHttpContext;
import org.apache.http.protocol.HttpContext;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.Charset;

/**
 * Helper class to donwload from web.
 * <p>
 * Used in AsyncTasks in Translation and Pronunication activities, and more...
 */
public class HttpFetcher {

    public static String fetchThroughHttp(String address) {
        return fetchThroughHttp(address, "utf-8");
    }


    public static String fetchThroughHttp(String address, String encoding) {

        try {
            HttpClient httpClient = new DefaultHttpClient();
			HttpParams params = httpClient.getParams();
			HttpConnectionParams.setConnectionTimeout(params, 10000);
			HttpConnectionParams.setSoTimeout(params, 60000);
            HttpContext localContext = new BasicHttpContext();
            HttpGet httpGet = new HttpGet(address);
            HttpResponse response = httpClient.execute(httpGet, localContext);
            if (response.getStatusLine().getStatusCode() != 200) {
                return "FAILED";
            }

            BufferedReader reader = new BufferedReader(new InputStreamReader(response.getEntity().getContent(),
                    Charset.forName(encoding)));

            StringBuilder stringBuilder = new StringBuilder();

            String line = null;
            while ((line = reader.readLine()) != null) {
                stringBuilder.append(line);
            }

            return stringBuilder.toString();

        } catch (Exception e) {
            return "FAILED with exception: " + e.getMessage();
        }

    }


    // public static String downloadFileToCache(String UrlToFile, Context context, String prefix)
    // {
    // try
    // {
    // URL url = new URL(UrlToFile);
    //
    // String extension = UrlToFile.substring(UrlToFile.length() - 4);
    //
    // HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
    // urlConnection.setRequestMethod("GET");
    // urlConnection.setDoOutput(true);
    // urlConnection.connect();
    //
    // File outputDir = context.getCacheDir();
    // File file = File.createTempFile(prefix, extension, outputDir);
    //
    // FileOutputStream fileOutput = new FileOutputStream(file);
    // InputStream inputStream = urlConnection.getInputStream();
    //
    // byte[] buffer = new byte[1024];
    // int bufferLength = 0;
    //
    // while ((bufferLength = inputStream.read(buffer)) > 0)
    // {
    // fileOutput.write(buffer, 0, bufferLength);
    // }
    // fileOutput.close();
    //
    // return file.getAbsolutePath();
    //
    // }
    // catch (Exception e)
    // {
    // return "FAILED " + e.getMessage();
    // }
    // }

    public static String downloadFileToSdCard(String UrlToFile, Context context, String prefix) {
        String str = downloadFileToSdCardMethod(UrlToFile, context, prefix, "GET");
        if (str.startsWith("FAIL")) {
            str = downloadFileToSdCardMethod(UrlToFile, context, prefix, "POST");
        }

        return str;
    }


    public static String downloadFileToSdCardMethod(String UrlToFile, Context context, String prefix, String method) {
        try {
            URL url = new URL(UrlToFile);

            String extension = UrlToFile.substring(UrlToFile.length() - 4);

            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
            urlConnection.setRequestMethod(method);
            urlConnection.setRequestProperty("Referer", "com.ichi2.anki");
            urlConnection.setRequestProperty("User-Agent", "Mozilla/5.0 ( compatible ) ");
            urlConnection.setRequestProperty("Accept", "*/*");
			urlConnection.setConnectTimeout(10000);
			urlConnection.setReadTimeout(60000);
            urlConnection.connect();

            File file = File.createTempFile(prefix, extension, context.getCacheDir());

            FileOutputStream fileOutput = new FileOutputStream(file);
            InputStream inputStream = urlConnection.getInputStream();

            byte[] buffer = new byte[1024];
            int bufferLength = 0;

            while ((bufferLength = inputStream.read(buffer)) > 0) {
                fileOutput.write(buffer, 0, bufferLength);
            }
            fileOutput.close();

            return file.getAbsolutePath();

        } catch (Exception e) {
            return "FAILED " + e.getMessage();
        }
    }

}
/****************************************************************************************
 * Copyright (c) 2015 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.widgets;

import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;
import android.support.v4.content.ContextCompat;
import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.ichi2.anki.R;
import com.ichi2.compat.CompatHelper;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Sched;

import org.json.JSONObject;

import java.util.ArrayList;
import java.util.List;

public class DeckAdapter extends RecyclerView.Adapter<DeckAdapter.ViewHolder> {

    private LayoutInflater mLayoutInflater;
    private List<Sched.DeckDueTreeNode> mDeckList;
    private int mZeroCountColor;
    private int mNewCountColor;
    private int mLearnCountColor;
    private int mReviewCountColor;
    private int mRowCurrentDrawable;
    private int mDeckNameDefaultColor;
    private int mDeckNameDynColor;
    private Drawable mExpandImage;
    private Drawable mCollapseImage;
    private Drawable mNoExpander = new ColorDrawable(Color.TRANSPARENT);

    // Listeners
    private View.OnClickListener mDeckClickListener;
    private View.OnClickListener mDeckExpanderClickListener;
    private View.OnLongClickListener mDeckLongClickListener;
    private View.OnClickListener mCountsClickListener;

    private Collection mCol;

    // Totals accumulated as each deck is processed
    private int mNew;
    private int mLrn;
    private int mRev;

    // Flags
    private boolean mHasSubdecks;

    // ViewHolder class to save inflated views for recycling
    public class ViewHolder extends RecyclerView.ViewHolder {
        public RelativeLayout deckLayout;
        public LinearLayout countsLayout;
        public ImageButton deckExpander;
        public ImageButton indentView;
        public TextView deckName;
        public TextView deckNew, deckLearn, deckRev;

        public ViewHolder(View v) {
            super(v);
            deckLayout = (RelativeLayout) v.findViewById(R.id.DeckPickerHoriz);
            countsLayout = (LinearLayout) v.findViewById(R.id.counts_layout);
            deckExpander = (ImageButton) v.findViewById(R.id.deckpicker_expander);
            indentView = (ImageButton) v.findViewById(R.id.deckpicker_indent);
            deckName = (TextView) v.findViewById(R.id.deckpicker_name);
            deckNew = (TextView) v.findViewById(R.id.deckpicker_new);
            deckLearn = (TextView) v.findViewById(R.id.deckpicker_lrn);
            deckRev = (TextView) v.findViewById(R.id.deckpicker_rev);
        }
    }

    public DeckAdapter(LayoutInflater layoutInflater, Context context) {
        mLayoutInflater = layoutInflater;
        mDeckList = new ArrayList<>();
        // Get the colors from the theme attributes
        int[] attrs = new int[] {
                R.attr.zeroCountColor,
                R.attr.newCountColor,
                R.attr.learnCountColor,
                R.attr.reviewCountColor,
                R.attr.currentDeckBackground,
                android.R.attr.textColor,
                R.attr.dynDeckColor,
                R.attr.expandRef,
                R.attr.collapseRef };
        TypedArray ta = context.obtainStyledAttributes(attrs);
        mZeroCountColor = ta.getColor(0, ContextCompat.getColor(context, R.color.black));
        mNewCountColor = ta.getColor(1, ContextCompat.getColor(context, R.color.black));
        mLearnCountColor = ta.getColor(2, ContextCompat.getColor(context, R.color.black));
        mReviewCountColor = ta.getColor(3, ContextCompat.getColor(context, R.color.black));
        mRowCurrentDrawable = ta.getResourceId(4, 0);
        mDeckNameDefaultColor = ta.getColor(5, ContextCompat.getColor(context, R.color.black));
        mDeckNameDynColor = ta.getColor(6, ContextCompat.getColor(context, R.color.material_blue_A700));
        mExpandImage = ta.getDrawable(7);
        mCollapseImage = ta.getDrawable(8);
        ta.recycle();
    }

    public void setDeckClickListener(View.OnClickListener listener) {
        mDeckClickListener = listener;
    }

    public void setCountsClickListener(View.OnClickListener listener) {
        mCountsClickListener = listener;
    }

    public void setDeckExpanderClickListener(View.OnClickListener listener) {
        mDeckExpanderClickListener = listener;
    }

    public void setDeckLongClickListener(View.OnLongClickListener listener) {
        mDeckLongClickListener = listener;
    }


    /**
     * Consume a list of {@link Sched.DeckDueTreeNode}s to render a new deck list.
     */
    public void buildDeckList(List<Sched.DeckDueTreeNode> nodes, Collection col) {
        mCol = col;
        mDeckList.clear();
        mNew = mLrn = mRev = 0;
        mHasSubdecks = false;
        processNodes(nodes);
        notifyDataSetChanged();
    }


    @Override
    public DeckAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View v = mLayoutInflater.inflate(R.layout.deck_item, parent, false);
        return new ViewHolder(v);
    }


    @Override
    public void onBindViewHolder(ViewHolder holder, int position) {
        // Update views for this node
        Sched.DeckDueTreeNode node = mDeckList.get(position);
        // Set the expander icon and padding according to whether or not there are any subdecks
        RelativeLayout deckLayout = holder.deckLayout;
        int rightPadding = (int) deckLayout.getResources().getDimension(R.dimen.deck_picker_right_padding);
        if (mHasSubdecks) {
            int smallPadding = (int) deckLayout.getResources().getDimension(R.dimen.deck_picker_left_padding_small);
            deckLayout.setPadding(smallPadding, 0, rightPadding, 0);
            holder.deckExpander.setVisibility(View.VISIBLE);
            // Create the correct expander for this deck
            setDeckExpander(holder.deckExpander, holder.indentView, node);
        } else {
            holder.deckExpander.setVisibility(View.GONE);
            int normalPadding = (int) deckLayout.getResources().getDimension(R.dimen.deck_picker_left_padding);
            deckLayout.setPadding(normalPadding, 0, rightPadding, 0);
        }

        if (node.children.size() > 0) {
            holder.deckExpander.setTag(node.did);
            holder.deckExpander.setOnClickListener(mDeckExpanderClickListener);
        } else {
            holder.deckExpander.setOnClickListener(null);
        }
        holder.deckLayout.setBackgroundResource(mRowCurrentDrawable);
        // Set background colour. The current deck has its own color
        if (node.did == mCol.getDecks().current().optLong("id")) {
            holder.deckLayout.setBackgroundResource(mRowCurrentDrawable);
        } else {
            CompatHelper.getCompat().setSelectableBackground(holder.deckLayout);
        }
        // Set deck name and colour. Filtered decks have their own colour
        holder.deckName.setText(node.names[0]);
        if (mCol.getDecks().isDyn(node.did)) {
            holder.deckName.setTextColor(mDeckNameDynColor);
        } else {
            holder.deckName.setTextColor(mDeckNameDefaultColor);
        }

        // Set the card counts and their colors
        holder.deckNew.setText(String.valueOf(node.newCount));
        holder.deckNew.setTextColor((node.newCount == 0) ? mZeroCountColor : mNewCountColor);
        holder.deckLearn.setText(String.valueOf(node.lrnCount));
        holder.deckLearn.setTextColor((node.lrnCount == 0) ? mZeroCountColor : mLearnCountColor);
        holder.deckRev.setText(String.valueOf(node.revCount));
        holder.deckRev.setTextColor((node.revCount == 0) ? mZeroCountColor : mReviewCountColor);

        // Store deck ID in layout's tag for easy retrieval in our click listeners
        holder.deckLayout.setTag(node.did);
        holder.countsLayout.setTag(node.did);

        // Set click listeners
        holder.deckLayout.setOnClickListener(mDeckClickListener);
        holder.deckLayout.setOnLongClickListener(mDeckLongClickListener);
        holder.countsLayout.setOnClickListener(mCountsClickListener);
    }

    @Override
    public int getItemCount() {
        return mDeckList.size();
    }


    private void setDeckExpander(ImageButton expander, ImageButton indent, Sched.DeckDueTreeNode node){
        boolean collapsed = mCol.getDecks().get(node.did).optBoolean("collapsed", false);
        // Apply the correct expand/collapse drawable
        if (collapsed) {
            expander.setImageDrawable(mExpandImage);
            expander.setContentDescription(expander.getContext().getString(R.string.expand));
        } else if (node.children.size() > 0) {
            expander.setImageDrawable(mCollapseImage);
            expander.setContentDescription(expander.getContext().getString(R.string.collapse));
        } else {
            expander.setImageDrawable(mNoExpander);
        }
        // Add some indenting for each nested level
        int width = (int) indent.getResources().getDimension(R.dimen.keyline_1) * node.depth;
        indent.setMinimumWidth(width);
    }


    private void processNodes(List<Sched.DeckDueTreeNode> nodes) {
        processNodes(nodes, 0);
    }


    private void processNodes(List<Sched.DeckDueTreeNode> nodes, int depth) {
        for (Sched.DeckDueTreeNode node : nodes) {
            // If the default deck is empty, hide it by not adding it to the deck list.
            // We don't hide it if it's the only deck or if it has sub-decks.
            if (node.did == 1 && nodes.size() > 1 && node.children.size() == 0) {
                if (mCol.getDb().queryScalar("select 1 from cards where did = 1") == 0) {
                    continue;
                }
            }
            // If any of this node's parents are collapsed, don't add it to the deck list
            for (JSONObject parent : mCol.getDecks().parents(node.did)) {
                mHasSubdecks = true;    // If a deck has a parent it means it's a subdeck so set a flag
                if (parent.optBoolean("collapsed")) {
                    return;
                }
            }
            mDeckList.add(node);
            // Keep track of the depth. It's used to determine visual properties like indenting later
            node.depth = depth;

            // Add this node's counts to the totals if it's a parent deck
            if (depth == 0) {
                mNew += node.newCount;
                mLrn += node.lrnCount;
                mRev += node.revCount;
            }
            // Process sub-decks
            processNodes(node.children, depth + 1);
        }
    }


    /**
     * Return the position of the deck in the deck list. If the deck is a child of a collapsed deck
     * (i.e., not visible in the deck list), then the position of the parent deck is returned instead.
     *
     * An invalid deck ID will return position 0.
     */
    public int findDeckPosition(long did) {
        for (int i = 0; i < mDeckList.size(); i++) {
            if (mDeckList.get(i).did == did) {
                return i;
            }
        }
        // If the deck is not in our list, we search again using the immediate parent
        List<JSONObject> parents = mCol.getDecks().parents(did);
        if (parents.size() == 0) {
            return 0;
        } else {
            return findDeckPosition(parents.get(parents.size() - 1).optLong("id", 0));
        }
    }


    public int getEta() {
        return mCol.getSched().eta(new int[]{mNew, mLrn, mRev});
    }

    public int getDue() {
        return mNew + mLrn + mRev;
    }

    public List<Sched.DeckDueTreeNode> getDeckList() {
        return mDeckList;
    }
}package com.ichi2.anki.widgets;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.TextView;

import com.ichi2.anki.R;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;



public final class DeckDropDownAdapter extends BaseAdapter {

    public interface SubtitleListener {
        public String getSubtitleText();
    }

    private Context context;
    private ArrayList<JSONObject> decks;

    public DeckDropDownAdapter(Context context, ArrayList<JSONObject> decks) {
        this.context = context;
        this.decks = decks;
    }

    static class DeckDropDownViewHolder {
        public TextView deckNameView;
        public TextView deckCountsView;
    }


    @Override
    public int getCount() {
        return decks.size() + 1;
    }


    @Override
    public Object getItem(int position) {
        if (position == 0) {
            return null;
        } else {
            return decks.get(position + 1);
        }
    }


    @Override
    public long getItemId(int position) {
        return position;
    }


    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        DeckDropDownViewHolder viewHolder;
        TextView deckNameView;
        TextView deckCountsView;
        if (convertView == null) {
            convertView = LayoutInflater.from(context).inflate(R.layout.dropdown_deck_selected_item, parent, false);
            deckNameView = (TextView) convertView.findViewById(R.id.dropdown_deck_name);
            deckCountsView = (TextView) convertView.findViewById(R.id.dropdown_deck_counts);
            viewHolder = new DeckDropDownViewHolder();
            viewHolder.deckNameView = deckNameView;
            viewHolder.deckCountsView = deckCountsView;
            convertView.setTag(viewHolder);
        } else {
            viewHolder = (DeckDropDownViewHolder) convertView.getTag();
            deckNameView = viewHolder.deckNameView;
            deckCountsView = viewHolder.deckCountsView;
        }
        if (position == 0) {
            deckNameView.setText(context.getResources().getString(R.string.deck_summary_all_decks));
        } else {
            JSONObject deck = decks.get(position - 1);
            try {
                String deckName = deck.getString("name");
                deckNameView.setText(deckName);
            } catch (JSONException ex) {
                new RuntimeException();
            }
        }
        deckCountsView.setText(((SubtitleListener) context).getSubtitleText());
        return convertView;
    }


    @Override
    public View getDropDownView(int position, View convertView, ViewGroup parent) {
        TextView deckNameView;
        if (convertView == null) {
            convertView = LayoutInflater.from(context).inflate(R.layout.dropdown_deck_item, parent, false);
            deckNameView = (TextView) convertView.findViewById(R.id.dropdown_deck_name);
            convertView.setTag(deckNameView);
        } else {
            deckNameView = (TextView) convertView.getTag();
        }
        if (position == 0) {
            deckNameView.setText(context.getResources().getString(R.string.deck_summary_all_decks));
        } else {
            JSONObject deck = decks.get(position - 1);
            try {
                String deckName = deck.getString("name");
                deckNameView.setText(deckName);
            } catch (JSONException ex) {
                new RuntimeException();
            }
        }
        return convertView;
    }
}/****************************************************************************************
 * Copyright (c) 2015 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/
package com.ichi2.anki.widgets;

import android.content.Context;
import android.support.design.widget.CoordinatorLayout;
import android.support.design.widget.Snackbar;
import android.support.v4.view.ViewCompat;
import android.util.AttributeSet;
import android.view.View;

import com.getbase.floatingactionbutton.FloatingActionsMenu;

import java.util.List;

/**
 * Originally created by Paul Woitaschek (http://www.paul-woitaschek.de, woitaschek@posteo.de)
 * Defines the behavior for the floating action button. If the dependency is a Snackbar, move the
 * fab up.
 */
public class FabBehavior extends CoordinatorLayout.Behavior<FloatingActionsMenu> {

    private float mTranslationY;

    public FabBehavior() {
        super();
    }

    public FabBehavior(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    private static float getFabTranslationYForSnackbar(CoordinatorLayout parent, FloatingActionsMenu fab) {
        float minOffset = 0.0F;
        List dependencies = parent.getDependencies(fab);
        int i = 0;

        for (int z = dependencies.size(); i < z; ++i) {
            View view = (View) dependencies.get(i);
            if (view instanceof Snackbar.SnackbarLayout && parent.doViewsOverlap(fab, view)) {
                minOffset = Math.min(minOffset, ViewCompat.getTranslationY(view) - (float) view.getHeight());
            }
        }

        return minOffset;
    }

    @Override
    public boolean layoutDependsOn(CoordinatorLayout parent, FloatingActionsMenu child, View dependency) {
        return dependency instanceof Snackbar.SnackbarLayout;
    }

    @Override
    public boolean onDependentViewChanged(CoordinatorLayout parent, FloatingActionsMenu fab, View dependency) {
        if (dependency instanceof Snackbar.SnackbarLayout && fab.getVisibility() == View.VISIBLE) {
            float translationY = getFabTranslationYForSnackbar(parent, fab);
            if (translationY != this.mTranslationY) {
                ViewCompat.animate(fab).cancel();
                ViewCompat.setTranslationY(fab, translationY);
                this.mTranslationY = translationY;
            }
        }
        return false;
    }
}package com.ichi2.anki.widgets;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import android.content.Context;
import android.support.v7.widget.PopupMenu;
import android.view.View;

/**
 * A simple little hack to force the icons to display in the PopupMenu
 */
public class PopupMenuWithIcons extends PopupMenu {

    public PopupMenuWithIcons(Context context, View anchor, boolean showIcons) {
        super(context, anchor);       
        if (showIcons) {
            try {
                Field[] fields = PopupMenu.class.getDeclaredFields();
                for (Field field : fields) {
                    if ("mPopup".equals(field.getName())) {
                        field.setAccessible(true);
                        Object menuPopupHelper = field.get(this);
                        Class<?> classPopupHelper = Class.forName(menuPopupHelper
                                .getClass().getName());
                        Method setForceIcons = classPopupHelper.getMethod(
                                "setForceShowIcon", boolean.class);
                        setForceIcons.invoke(menuPopupHelper, true);
                        break;
                    }
                }
            } catch (Exception e) {}        
        }
    }
}/****************************************************************************************
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.async;

import android.os.AsyncTask;

import com.ichi2.utils.MethodLogger;
import com.ichi2.utils.Threads;

public class BaseAsyncTask<Params, Progress, Result> extends AsyncTask<Params, Progress, Result> {

    /** Set this to {@code true} to enable detailed debugging for this class. */
    private static final boolean DEBUG = false;

    static {
        // This can actually happen if the first reference to an AsyncTask is made not from the main thread.
        //
        // In that case, the static constructor will be invoked by the class loader on the thread that is making the
        // reference.
        //
        // Unfortunately this leads to unexpected consequences, including a Handler being constructed on the wrong
        // thread.
        //
        // See https://code.google.com/p/android/issues/detail?id=20915
        if (DEBUG) {
            MethodLogger.log();
        }
        Threads.checkMainThread();
    }


    public BaseAsyncTask() {
        if (DEBUG) {
            MethodLogger.log();
        }
        Threads.checkMainThread();
    }


    @Override
    protected void onPreExecute() {
        if (DEBUG) {
            MethodLogger.log();
        }
        Threads.checkMainThread();
        super.onPreExecute();
    }


    @Override
    protected void onPostExecute(Result result) {
        if (DEBUG) {
            MethodLogger.log();
        }
        Threads.checkMainThread();
        super.onPostExecute(result);
    }


    @Override
    protected void onProgressUpdate(Progress... values) {
        if (DEBUG) {
            MethodLogger.log();
        }
        Threads.checkMainThread();
        super.onProgressUpdate(values);
    }


    @Override
    protected void onCancelled() {
        if (DEBUG) {
            MethodLogger.log();
        }
        Threads.checkMainThread();
        super.onCancelled();
    }


    @Override
    protected Result doInBackground(Params... arg0) {
        if (DEBUG) {
            MethodLogger.log();
        }
        Threads.checkNotMainThread();
        return null;
    }

}
package com.ichi2.async;

import android.content.Context;
import android.support.v4.content.AsyncTaskLoader;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.CollectionHelper;
import com.ichi2.libanki.Collection;

import timber.log.Timber;

public class CollectionLoader extends AsyncTaskLoader<Collection> {

    public CollectionLoader(Context context) {
        super(context);
    }

    @Override
    public Collection loadInBackground() {
        // load collection
        try {
            Timber.d("CollectionLoader accessing collection");
            return CollectionHelper.getInstance().getCol(getContext());
        } catch (RuntimeException e) {
            Timber.e(e, "loadInBackground - RuntimeException on opening collection");
            AnkiDroidApp.sendExceptionReport(e, "CollectionLoader.loadInBackground");
            return null;
        }
    }
    
    @Override
    public void deliverResult(Collection col) {
        Timber.d("CollectionLoader.deliverResult()");
        // Loader has been reset so don't forward data to listener
        if (isReset()) {
            if (col != null) {
                return;
            }
        }
        // Loader is running so forward data to listener
        if (isStarted()) {
            super.deliverResult(col);
        }
    }
    
    @Override
    protected void onStartLoading() {
        // Don't touch collection if lockCollection flag is set
        if (CollectionHelper.getInstance().isCollectionLocked()) {
            Timber.w("onStartLoading() :: Another thread has requested to keep the collection closed.");
            return;
        }
        // Since the CollectionHelper only opens if necessary, we can just force every time
        forceLoad();
    }
    
    @Override
    protected void onStopLoading() {
        // The Loader has been put in a stopped state, so we should attempt to cancel the current load (if there is one).
        Timber.d("CollectionLoader.onStopLoading()");
        cancelLoad();
    }
    
    @Override
    protected void onReset() {
        // Ensure the loader is stopped.
        Timber.d("CollectionLoader.onReset()");
        onStopLoading();
    }
}/****************************************************************************************
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 * Copyright (c) 2012 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.async;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.AsyncTask;
import android.os.PowerManager;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.R;
import com.ichi2.anki.exception.MediaSyncException;
import com.ichi2.anki.exception.UnknownHttpResponseException;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.sync.FullSyncer;
import com.ichi2.libanki.sync.HttpSyncer;
import com.ichi2.libanki.sync.MediaSyncer;
import com.ichi2.libanki.sync.RemoteMediaServer;
import com.ichi2.libanki.sync.RemoteServer;
import com.ichi2.libanki.sync.Syncer;

import org.apache.http.HttpResponse;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.lang.ref.WeakReference;

import timber.log.Timber;

public class Connection extends BaseAsyncTask<Connection.Payload, Object, Connection.Payload> {

    public static final int TASK_TYPE_LOGIN = 0;
    public static final int TASK_TYPE_SYNC = 1;
    public static final int CONN_TIMEOUT = 30000;


    private static Connection sInstance;
    private TaskListener mListener;
    private static boolean sIsCancelled;
    private static boolean sIsCancellable;

    /**
     * Before syncing, we acquire a wake lock and then release it once the sync is complete.
     * This ensures that the device remains awake until the sync is complete. Without it,
     * the process will be paused and the sync can fail due to timing conflicts with AnkiWeb.
     */
    private final PowerManager.WakeLock mWakeLock;

    public static synchronized boolean getIsCancelled() {
        return sIsCancelled;
    }

    public Connection() {
        sIsCancelled = false;
        sIsCancellable = false;
        Context context = AnkiDroidApp.getInstance().getApplicationContext();
        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Connection");
    }

    private static Connection launchConnectionTask(TaskListener listener, Payload data) {

        if (!isOnline()) {
            data.success = false;
            listener.onDisconnected();
            return null;
        }

        try {
            if ((sInstance != null) && (sInstance.getStatus() != AsyncTask.Status.FINISHED)) {
                sInstance.get();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        sInstance = new Connection();
        sInstance.mListener = listener;

        sInstance.execute(data);
        return sInstance;
    }


    /*
     * Runs on GUI thread
     */
    @Override
    protected void onCancelled() {
        super.onCancelled();
        Timber.i("Connection onCancelled() method called");
        // Sync has ended so release the wake lock
        mWakeLock.release();
        if (mListener instanceof CancellableTaskListener) {
            ((CancellableTaskListener) mListener).onCancelled();
        }
    }


    /*
     * Runs on GUI thread
     */
    @Override
    protected void onPreExecute() {
        super.onPreExecute();
        // Acquire the wake lock before syncing to ensure CPU remains on until the sync completes.
        mWakeLock.acquire();
        if (mListener != null) {
            mListener.onPreExecute();
        }
    }


    /*
     * Runs on GUI thread
     */
    @Override
    protected void onPostExecute(Payload data) {
        super.onPostExecute(data);
        // Sync has ended so release the wake lock
        mWakeLock.release();
        if (mListener != null) {
            mListener.onPostExecute(data);
        }
    }


    /*
     * Runs on GUI thread
     */
    @Override
    protected void onProgressUpdate(Object... values) {
        super.onProgressUpdate(values);
        if (mListener != null) {
            mListener.onProgressUpdate(values);
        }
    }


    public static Connection login(TaskListener listener, Payload data) {
        data.taskType = TASK_TYPE_LOGIN;
        return launchConnectionTask(listener, data);
    }


    public static Connection sync(TaskListener listener, Payload data) {
        data.taskType = TASK_TYPE_SYNC;
        return launchConnectionTask(listener, data);
    }


    @Override
    protected Payload doInBackground(Payload... params) {
        super.doInBackground(params);
        if (params.length != 1) {
            throw new IllegalArgumentException();
        }
        return doOneInBackground(params[0]);
    }


    private Payload doOneInBackground(Payload data) {
        switch (data.taskType) {
            case TASK_TYPE_LOGIN:
                return doInBackgroundLogin(data);

            case TASK_TYPE_SYNC:
                return doInBackgroundSync(data);

            default:
                return null;
        }
    }


    private Payload doInBackgroundLogin(Payload data) {
        String username = (String) data.data[0];
        String password = (String) data.data[1];
        HttpSyncer server = new RemoteServer(this, null);
        HttpResponse ret;
        try {
            ret = server.hostKey(username, password);
        } catch (UnknownHttpResponseException e) {
            data.success = false;
            data.result = new Object[] { "error", e.getResponseCode(), e.getMessage() };
            return data;
        } catch (Exception e2) {
            // Ask user to report all bugs which aren't timeout errors
            if (!timeoutOccured(e2)) {
                AnkiDroidApp.sendExceptionReport(e2, "doInBackgroundLogin");
            }
            data.success = false;
            data.result = new Object[] {"connectionError" };
            return data;
        }
        String hostkey = null;
        boolean valid = false;
        if (ret != null) {
            data.returnType = ret.getStatusLine().getStatusCode();
            Timber.d("doInBackgroundLogin - response from server: %d, (%s)", data.returnType, ret.getStatusLine().getReasonPhrase());
            if (data.returnType == 200) {
                try {
                    JSONObject jo = (new JSONObject(server.stream2String(ret.getEntity().getContent())));
                    hostkey = jo.getString("key");
                    valid = (hostkey != null) && (hostkey.length() > 0);
                } catch (JSONException e) {
                    valid = false;
                } catch (IllegalStateException | IOException e) {
                    throw new RuntimeException(e);
                }
            }
        } else {
            Timber.e("doInBackgroundLogin - empty response from server");
        }
        if (valid) {
            data.success = true;
            data.data = new String[] { username, hostkey };
        } else {
            data.success = false;
        }
        return data;
    }


    private boolean timeoutOccured(Exception e) {
        String msg = e.getMessage();
        return msg.contains("UnknownHostException") ||
                msg.contains("HttpHostConnectException") ||
                msg.contains("SSLException while building HttpClient") ||
                msg.contains("SocketTimeoutException") ||
                msg.contains("ClientProtocolException") ||
                msg.contains("TimeoutException");
    }


    private Payload doInBackgroundSync(Payload data) {
        sIsCancellable = true;
        Timber.d("doInBackgroundSync()");
        // Block execution until any previous background task finishes, or timeout after 5s
        boolean ok = DeckTask.waitToFinish(5);

        String hkey = (String) data.data[0];
        boolean media = (Boolean) data.data[1];
        String conflictResolution = (String) data.data[2];
        // Use safe version that catches exceptions so that full sync is still possible
        Collection col = CollectionHelper.getInstance().getColSafe(AnkiDroidApp.getInstance());

        boolean colCorruptFullSync = false;
        if (!CollectionHelper.getInstance().colIsOpen() || !ok) {
            if (conflictResolution != null && conflictResolution.equals("download")) {
                colCorruptFullSync = true;
            } else {
                data.success = false;
                data.result = new Object[] { "genericError" };
                return data;
            }
        }
        try {
            CollectionHelper.getInstance().lockCollection();
            HttpSyncer server = new RemoteServer(this, hkey);
            Syncer client = new Syncer(col, server);

            // run sync and check state
            boolean noChanges = false;
            if (conflictResolution == null) {
                Timber.i("Sync - starting sync");
                publishProgress(R.string.sync_prepare_syncing);
                Object[] ret = client.sync(this);
                data.message = client.getSyncMsg();
                if (ret == null) {
                    data.success = false;
                    data.result = new Object[] { "genericError" };
                    return data;
                }
                String retCode = (String) ret[0];
                if (!retCode.equals("noChanges") && !retCode.equals("success")) {
                    data.success = false;
                    data.result = ret;
                    // Check if there was a sanity check error
                    if (retCode.equals("sanityCheckError")) {
                        // Force full sync next time
                        col.modSchemaNoCheck();
                        col.save();
                    }
                    return data;
                }
                // save and note success state
                if (retCode.equals("noChanges")) {
                    // publishProgress(R.string.sync_no_changes_message);
                    noChanges = true;
                } else {
                    // publishProgress(R.string.sync_database_acknowledge);
                }
            } else {
                try {
                    // Disable sync cancellation for full-sync
                    sIsCancellable = false;
                    server = new FullSyncer(col, hkey, this);
                    if (conflictResolution.equals("upload")) {
                        Timber.i("Sync - fullsync - upload collection");
                        publishProgress(R.string.sync_preparing_full_sync_message);
                        Object[] ret = server.upload();
                        col.reopen();
                        if (ret == null) {
                            data.success = false;
                            data.result = new Object[] { "genericError" };
                            return data;
                        }
                        if (!ret[0].equals(HttpSyncer.ANKIWEB_STATUS_OK)) {
                            data.success = false;
                            data.result = ret;
                            return data;
                        }
                    } else if (conflictResolution.equals("download")) {
                        Timber.i("Sync - fullsync - download collection");
                        publishProgress(R.string.sync_downloading_message);
                        Object[] ret = server.download();
                        if (ret == null) {
                            data.success = false;
                            data.result = new Object[] { "genericError" };
                            return data;
                        }
                        if (ret[0].equals("success")) {
                            data.success = true;
                            col.reopen();
                        }
                        if (!ret[0].equals("success")) {
                            data.success = false;
                            data.result = ret;
                            if (!colCorruptFullSync) {
                                col.reopen();
                            }
                            return data;
                        }
                    }
                } catch (OutOfMemoryError e) {
                    AnkiDroidApp.sendExceptionReport(e, "doInBackgroundSync-fullSync");
                    data.success = false;
                    data.result = new Object[] { "OutOfMemoryError" };
                    return data;
                } catch (RuntimeException e) {
                    if (timeoutOccured(e)) {
                        data.result = new Object[] {"connectionError" };
                    } else if (e.getMessage().equals("UserAbortedSync")) {
                        data.result = new Object[] {"UserAbortedSync" };
                    } else {
                        AnkiDroidApp.sendExceptionReport(e, "doInBackgroundSync-fullSync");
                        data.result = new Object[] { "IOException" };
                    }
                    data.success = false;
                    return data;
                }
            }

            // clear undo to avoid non syncing orphans (because undo resets usn too
            if (!noChanges) {
                col.clearUndo();
            }
            // then move on to media sync
            sIsCancellable = true;
            boolean noMediaChanges = false;
            String mediaError = null;
            if (media) {
                server = new RemoteMediaServer(col, hkey, this);
                MediaSyncer mediaClient = new MediaSyncer(col, (RemoteMediaServer) server, this);
                String ret;
                try {
                    ret = mediaClient.sync();
                    if (ret == null) {
                        mediaError = AnkiDroidApp.getAppResources().getString(R.string.sync_media_error);
                    } else {
                        if (ret.equals("noChanges")) {
                            publishProgress(R.string.sync_media_no_changes);
                            noMediaChanges = true;
                        }
                        if (ret.equals("sanityFailed")) {
                            mediaError = AnkiDroidApp.getAppResources().getString(R.string.sync_media_sanity_failed);
                        } else {
                            publishProgress(R.string.sync_media_success);
                        }
                    }
                } catch (RuntimeException e) {
                    if (timeoutOccured(e)) {
                        data.result = new Object[] {"connectionError" };
                    } else if (e.getMessage().equals("UserAbortedSync")) {
                        data.result = new Object[] {"UserAbortedSync" };
                    } else {
                        AnkiDroidApp.sendExceptionReport(e, "doInBackgroundSync-mediaSync");
                    }
                    mediaError = e.getLocalizedMessage();
                }
            }
            if (noChanges && (!media || noMediaChanges)) {
                data.success = false;
                data.result = new Object[] { "noChanges" };
                return data;
            } else {
                data.success = true;
                data.data = new Object[] { conflictResolution, col, mediaError };
                return data;
            }
        } catch (MediaSyncException e) {
            Timber.e("Media sync rejected by server");
            data.success = false;
            data.result = new Object[] {"mediaSyncServerError"};
            AnkiDroidApp.sendExceptionReport(e, "doInBackgroundSync");
            return data;
        } catch (UnknownHttpResponseException e) {
            Timber.e("doInBackgroundSync -- unknown response code error");
            e.printStackTrace();
            data.success = false;
            Integer code = e.getResponseCode();
            String msg = e.getLocalizedMessage();
            data.result = new Object[] { "error", code , msg };
            return data;
        } catch (Exception e) {
            // Global error catcher.
            // Try to give a human readable error, otherwise print the raw error message
            Timber.e("doInBackgroundSync error");
            e.printStackTrace();
            data.success = false;
            if (timeoutOccured(e)) {
                data.result = new Object[]{"connectionError"};
            } else if (e.getMessage().equals("UserAbortedSync")) {
                data.result = new Object[] {"UserAbortedSync" };
            } else {
                AnkiDroidApp.sendExceptionReport(e, "doInBackgroundSync");
                data.result = new Object[] {e.getLocalizedMessage()};
            }
            return data;
        } finally {
            // don't bump mod time unless we explicitly save
            if (col != null) {
                col.close(false);
            }
            CollectionHelper.getInstance().unlockCollection();
        }
    }


    public void publishProgress(int id) {
        super.publishProgress(id);
    }


    public void publishProgress(String message) {
        super.publishProgress(message);
    }


    public void publishProgress(int id, long up, long down) {
        super.publishProgress(id, up, down);
    }

    public static boolean isOnline() {
        ConnectivityManager cm = (ConnectivityManager) AnkiDroidApp.getInstance().getApplicationContext()
                .getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo netInfo = cm.getActiveNetworkInfo();
        if (netInfo == null || !netInfo.isConnected() || !netInfo.isAvailable()) {
            return false;
        }
        return true;
    }


    public static interface TaskListener {
        public void onPreExecute();


        public void onProgressUpdate(Object... values);


        public void onPostExecute(Payload data);


        public void onDisconnected();
    }

    public static interface CancellableTaskListener extends TaskListener {
        public void onCancelled();
    }

    public static class Payload {
        public int taskType;
        public Object[] data;
        public Object result;
        public boolean success;
        public int returnType;
        public Exception exception;
        public String message;
        public Collection col;


        public Payload() {
            data = null;
            success = true;
        }


        public Payload(Object[] data) {
            this.data = data;
            success = true;
        }


        public Payload(int taskType, Object[] data) {
            this.taskType = taskType;
            this.data = data;
            success = true;
        }

        public Payload(int taskType, Object[] data, String path) {
            this.taskType = taskType;
            this.data = data;
            success = true;
        }
    }

    public synchronized static void cancel() {
        Timber.d("Cancelled Connection task");
        sInstance.cancel(true);
        sIsCancelled = true;
    }

    public synchronized static boolean isCancellable() {
        return sIsCancellable;
    }

    public class CancelCallback {
        private WeakReference<ThreadSafeClientConnManager> mConnectionManager = null;


        public void setConnectionManager(ThreadSafeClientConnManager connectionManager) {
            mConnectionManager = new WeakReference<>(connectionManager);
        }


        public void cancelAllConnections() {
            Timber.d("cancelAllConnections()");
            if (mConnectionManager != null) {
                ThreadSafeClientConnManager connectionManager = mConnectionManager.get();
                if (connectionManager != null) {
                    connectionManager.shutdown();
                }
            }
        }
    }
}
/****************************************************************************************
 * Copyright (c) 2009 Daniel Sv盲rd <daniel.svard@gmail.com>                             *
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.async;

import android.content.Context;
import android.content.res.Resources;
import android.os.AsyncTask;

import com.google.gson.stream.JsonReader;
import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.BackupManager;
import com.ichi2.anki.CardBrowser;
import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.R;
import com.ichi2.anki.exception.ConfirmModSchemaException;
import com.ichi2.libanki.AnkiPackageExporter;
import com.ichi2.libanki.Card;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.DB;
import com.ichi2.libanki.Note;
import com.ichi2.libanki.Sched;
import com.ichi2.libanki.Storage;
import com.ichi2.libanki.Utils;
import com.ichi2.libanki.importer.AnkiPackageImporter;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.zip.ZipFile;

import timber.log.Timber;

/**
 * Loading in the background, so that AnkiDroid does not look like frozen.
 */
public class DeckTask extends BaseAsyncTask<DeckTask.TaskData, DeckTask.TaskData, DeckTask.TaskData> {

    public static final int TASK_TYPE_SAVE_COLLECTION = 2;
    public static final int TASK_TYPE_ANSWER_CARD = 3;
    public static final int TASK_TYPE_ADD_FACT = 6;
    public static final int TASK_TYPE_UPDATE_FACT = 7;
    public static final int TASK_TYPE_UNDO = 8;
    public static final int TASK_TYPE_DISMISS = 11;
    public static final int TASK_TYPE_CHECK_DATABASE = 14;
    public static final int TASK_TYPE_REPAIR_DECK = 20;
    public static final int TASK_TYPE_LOAD_DECK_COUNTS = 22;
    public static final int TASK_TYPE_UPDATE_VALUES_FROM_DECK = 23;
    public static final int TASK_TYPE_DELETE_DECK = 25;
    public static final int TASK_TYPE_REBUILD_CRAM = 26;
    public static final int TASK_TYPE_EMPTY_CRAM = 27;
    public static final int TASK_TYPE_IMPORT = 28;
    public static final int TASK_TYPE_IMPORT_REPLACE = 29;
    public static final int TASK_TYPE_SEARCH_CARDS = 30;
    public static final int TASK_TYPE_EXPORT_APKG = 31;
    public static final int TASK_TYPE_REORDER = 32;
    public static final int TASK_TYPE_CONF_CHANGE = 33;
    public static final int TASK_TYPE_CONF_RESET = 34;
    public static final int TASK_TYPE_CONF_REMOVE = 35;
    public static final int TASK_TYPE_CONF_SET_SUBDECKS = 36;
    public static final int TASK_TYPE_RENDER_BROWSER_QA = 37;
    public static final int TASK_TYPE_CHECK_MEDIA = 38;
    public static final int TASK_TYPE_ADD_TEMPLATE = 39;
    public static final int TASK_TYPE_REMOVE_TEMPLATE = 40;
    public static final int TASK_TYPE_COUNT_MODELS = 41;
    public static final int TASK_TYPE_DELETE_MODEL = 42;
    public static final int TASK_TYPE_DELETE_FIELD = 43;
    public static final int TASK_TYPE_REPOSITION_FIELD = 44;
    public static final int TASK_TYPE_ADD_FIELD = 45;
    public static final int TASK_TYPE_CHANGE_SORT_FIELD = 46;
    public static final int TASK_TYPE_SAVE_MODEL = 47;
    public static final int TASK_TYPE_FIND_EMPTY_CARDS = 48;

    /**
     * A reference to the application context to use to fetch the current Collection object.
     */
    private Context mContext;


    /**
     * The most recently started {@link DeckTask} instance.
     */
    private static DeckTask sLatestInstance;

    private static boolean sHadCardQueue = false;


    /**
     * Starts a new {@link DeckTask}.
     * <p>
     * Tasks will be executed serially, in the order in which they are started.
     * <p>
     * This method must be called on the main thread.
     *
     * @param type of the task to start
     * @param listener to the status and result of the task
     * @param params to pass to the task
     * @return the newly created task
     */
    public static DeckTask launchDeckTask(int type, Listener listener, TaskData... params) {
        // Start new task
        DeckTask newTask = new DeckTask(type, listener, sLatestInstance);
        newTask.execute(params);
        return newTask;
    }


    /**
     * Block the current thread until the currently running DeckTask instance (if any) has finished.
     */
    public static void waitToFinish() {
        waitToFinish(null);
    }

    /**
     * Block the current thread until the currently running DeckTask instance (if any) has finished.
     * @param timeout timeout in seconds
     * @return whether or not the previous task was successful or not
     */
    public static boolean waitToFinish(Integer timeout) {
        try {
            if ((sLatestInstance != null) && (sLatestInstance.getStatus() != AsyncTask.Status.FINISHED)) {
                Timber.d("DeckTask: waiting for task %d to finish...", sLatestInstance.mType);
                if (timeout != null) {
                    sLatestInstance.get(timeout, TimeUnit.SECONDS);
                } else {
                    sLatestInstance.get();
                }

            }
            return true;
        } catch (Exception e) {
            Timber.e(e, "Exception waiting for task to finish");
            return false;
        }
    }


    public static void cancelTask() {
        //cancel the current task
        try {
            if ((sLatestInstance != null) && (sLatestInstance.getStatus() != AsyncTask.Status.FINISHED)) {
                sLatestInstance.cancel(true);
                Timber.i("Cancelled task %d", sLatestInstance.mType);
            }
        } catch (Exception e) {
            return;
        }
    }


    public static void cancelTask(int taskType) {
        // cancel the current task only if it's of type taskType
        if (sLatestInstance != null && sLatestInstance.mType == taskType) {
            cancelTask();
        }
    }


    private final int mType;
    private final Listener mListener;
    private DeckTask mPreviousTask;


    public DeckTask(int type, Listener listener, DeckTask previousTask) {
        mType = type;
        mListener = listener;
        mPreviousTask = previousTask;
    }


    // This method and those that are called here are executed in a new thread
    @Override
    protected TaskData doInBackground(TaskData... params) {
        super.doInBackground(params);
        // Wait for previous thread (if any) to finish before continuing
        if (mPreviousTask != null && mPreviousTask.getStatus() != AsyncTask.Status.FINISHED) {
            Timber.d("Waiting for %d to finish before starting %d", mPreviousTask.mType, mType);
            try {
                mPreviousTask.get();
                Timber.d("Finished waiting for %d to finish. Status= %s", mPreviousTask.mType, mPreviousTask.getStatus());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                // We have been interrupted, return immediately.
                Timber.e(e, "interrupted while waiting for previous task: %d", mPreviousTask.mType);
                return null;
            } catch (ExecutionException e) {
                // Ignore failures in the previous task.
                Timber.e(e, "previously running task failed with exception: %d", mPreviousTask.mType);
            } catch (CancellationException e) {
                // Ignore cancellation of previous task
                Timber.e(e, "previously running task was cancelled: %d", mPreviousTask.mType);
            }
        }
        sLatestInstance = this;
        mContext = AnkiDroidApp.getInstance().getApplicationContext();

        // Skip the task if the collection cannot be opened
        if (mType != TASK_TYPE_REPAIR_DECK && CollectionHelper.getInstance().getColSafe(mContext) == null) {
            Timber.e("Aborting DeckTask %d as Collection could not be opened", mType);
            return null;
        }
        // Actually execute the task now that we are at the front of the queue.
        switch (mType) {
            case TASK_TYPE_LOAD_DECK_COUNTS:
                return doInBackgroundLoadDeckCounts(params);

            case TASK_TYPE_SAVE_COLLECTION:
                return doInBackgroundSaveCollection(params);

            case TASK_TYPE_ANSWER_CARD:
                return doInBackgroundAnswerCard(params);

            case TASK_TYPE_ADD_FACT:
                return doInBackgroundAddNote(params);

            case TASK_TYPE_UPDATE_FACT:
                return doInBackgroundUpdateNote(params);

            case TASK_TYPE_UNDO:
                return doInBackgroundUndo(params);

            case TASK_TYPE_SEARCH_CARDS:
                return doInBackgroundSearchCards(params);

            case TASK_TYPE_DISMISS:
                return doInBackgroundDismissNote(params);

            case TASK_TYPE_CHECK_DATABASE:
                return doInBackgroundCheckDatabase(params);

            case TASK_TYPE_REPAIR_DECK:
                return doInBackgroundRepairDeck(params);

            case TASK_TYPE_UPDATE_VALUES_FROM_DECK:
                return doInBackgroundUpdateValuesFromDeck(params);

            case TASK_TYPE_DELETE_DECK:
                return doInBackgroundDeleteDeck(params);

            case TASK_TYPE_REBUILD_CRAM:
                return doInBackgroundRebuildCram(params);

            case TASK_TYPE_EMPTY_CRAM:
                return doInBackgroundEmptyCram(params);

            case TASK_TYPE_IMPORT:
                return doInBackgroundImportAdd(params);

            case TASK_TYPE_IMPORT_REPLACE:
                return doInBackgroundImportReplace(params);

            case TASK_TYPE_EXPORT_APKG:
                return doInBackgroundExportApkg(params);

            case TASK_TYPE_REORDER:
                return doInBackgroundReorder(params);

            case TASK_TYPE_CONF_CHANGE:
                return doInBackgroundConfChange(params);

            case TASK_TYPE_CONF_RESET:
                return doInBackgroundConfReset(params);

            case TASK_TYPE_CONF_REMOVE:
                return doInBackgroundConfRemove(params);

            case TASK_TYPE_CONF_SET_SUBDECKS:
                return doInBackgroundConfSetSubdecks(params);

            case TASK_TYPE_RENDER_BROWSER_QA:
                return doInBackgroundRenderBrowserQA(params);

            case TASK_TYPE_CHECK_MEDIA:
                return doInBackgroundCheckMedia(params);

            case TASK_TYPE_ADD_TEMPLATE:
                return doInBackgroundAddTemplate(params);

            case TASK_TYPE_REMOVE_TEMPLATE:
                return doInBackgroundRemoveTemplate(params);

            case TASK_TYPE_COUNT_MODELS:
                return doInBackgroundCountModels(params);

            case TASK_TYPE_DELETE_MODEL:
                return  doInBackGroundDeleteModel(params);

            case TASK_TYPE_DELETE_FIELD:
                return doInBackGroundDeleteField(params);

            case TASK_TYPE_REPOSITION_FIELD:
                return doInBackGroundRepositionField(params);

            case TASK_TYPE_ADD_FIELD:
                return doInBackGroundAddField(params);

            case TASK_TYPE_CHANGE_SORT_FIELD:
                return doInBackgroundChangeSortField(params);

            case TASK_TYPE_SAVE_MODEL:
                return doInBackgroundSaveModel(params);
            case TASK_TYPE_FIND_EMPTY_CARDS:
                return doInBackGroundFindEmptyCards(params);

            default:
                Timber.e("unknown task type: %d", mType);
                return null;
        }
    }


    /** Delegates to the {@link TaskListener} for this task. */
    @Override
    protected void onPreExecute() {
        super.onPreExecute();
        mListener.onPreExecute(this);
    }


    /** Delegates to the {@link TaskListener} for this task. */
    @Override
    protected void onProgressUpdate(TaskData... values) {
        super.onProgressUpdate(values);
        mListener.onProgressUpdate(this, values);
    }


    /** Delegates to the {@link TaskListener} for this task. */
    @Override
    protected void onPostExecute(TaskData result) {
        super.onPostExecute(result);
        mListener.onPostExecute(this, result);
        Timber.d("enabling garbage collection of mPreviousTask...");
        mPreviousTask = null;
    }

    @Override
    protected void onCancelled(){
        mListener.onCancelled();
    }

    private TaskData doInBackgroundAddNote(TaskData[] params) {
        Timber.d("doInBackgroundAddNote");
        Note note = params[0].getNote();
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        try {
            DB db = col.getDb();
            db.getDatabase().beginTransaction();
            try {
                publishProgress(new TaskData(col.addNote(note)));
                db.getDatabase().setTransactionSuccessful();
            } finally {
                db.getDatabase().endTransaction();
            }
        } catch (RuntimeException e) {
            Timber.e(e, "doInBackgroundAddNote - RuntimeException on adding fact");
            AnkiDroidApp.sendExceptionReport(e, "doInBackgroundAddNote");
            return new TaskData(false);
        }
        return new TaskData(true);
    }


    private TaskData doInBackgroundUpdateNote(TaskData[] params) {
        Timber.d("doInBackgroundUpdateNote");
        // Save the note
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        Sched sched = col.getSched();
        Card editCard = params[0].getCard();
        Note editNote = editCard.note();
        boolean fromReviewer = params[0].getBoolean();

        try {
            col.getDb().getDatabase().beginTransaction();
            try {
                // TODO: undo integration
                editNote.flush();
                // flush card too, in case, did has been changed
                editCard.flush();
                if (fromReviewer) {
                    Card newCard;
                    if (col.getDecks().active().contains(editCard.getDid())) {
                        newCard = editCard;
                        newCard.load();
                        // reload qa-cache
                        newCard.q(true);
                    } else {
                        newCard = getCard(sched);
                    }
                    publishProgress(new TaskData(newCard));
                } else {
                    publishProgress(new TaskData(editCard, editNote.stringTags()));
                }
                col.getDb().getDatabase().setTransactionSuccessful();
            } finally {
                col.getDb().getDatabase().endTransaction();
            }
        } catch (RuntimeException e) {
            Timber.e(e, "doInBackgroundUpdateNote - RuntimeException on updating fact");
            AnkiDroidApp.sendExceptionReport(e, "doInBackgroundUpdateNote");
            return new TaskData(false);
        }
        return new TaskData(true);
    }


    private TaskData doInBackgroundAnswerCard(TaskData... params) {
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        Sched sched = col.getSched();
        Card oldCard = params[0].getCard();
        int ease = params[0].getInt();
        Card newCard = null;
        try {
            DB db = col.getDb();
            db.getDatabase().beginTransaction();
            try {
                if (oldCard != null) {
                    sched.answerCard(oldCard, ease);
                }
                if (newCard == null) {
                    newCard = getCard(sched);
                }
                if (newCard != null) {
                    // render cards before locking database
                    newCard._getQA(true);
                }
                publishProgress(new TaskData(newCard));
                db.getDatabase().setTransactionSuccessful();
            } finally {
                db.getDatabase().endTransaction();
            }
        } catch (RuntimeException e) {
            Timber.e(e, "doInBackgroundAnswerCard - RuntimeException on answering card");
            AnkiDroidApp.sendExceptionReport(e, "doInBackgroundAnswerCard");
            return new TaskData(false);
        }
        return new TaskData(true);
    }


    private Card getCard(Sched sched) {
        if (sHadCardQueue) {
            sched.reset();
            sHadCardQueue = false;
        }
        return sched.getCard();
    }


    private TaskData doInBackgroundLoadDeckCounts(TaskData... params) {
        Timber.d("doInBackgroundLoadDeckCounts");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        try {
            // Get due tree
            Object[] o = new Object[] {col.getSched().deckDueTree()};
            return new TaskData(o);
        } catch (RuntimeException e) {
            Timber.e(e, "doInBackgroundLoadDeckCounts - error");
            return null;
        }
    }


    private TaskData doInBackgroundSaveCollection(TaskData... params) {
        Timber.d("doInBackgroundSaveCollection");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        if (col != null) {
            try {
                col.save();
            } catch (RuntimeException e) {
                Timber.e(e, "Error on saving deck in background");
            }
        }
        return null;
    }


    private TaskData doInBackgroundDismissNote(TaskData... params) {
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        Sched sched = col.getSched();
        Object[] data = params[0].getObjArray();
        Card card = (Card) data[0];
        Collection.DismissType type = (Collection.DismissType) data[1];
        Note note = card.note();
        try {
            col.getDb().getDatabase().beginTransaction();
            try {
                switch (type) {
                    case BURY_CARD:
                        // collect undo information
                        col.markUndo(type, new Object[] { col.getDirty(), note.cards(), card.getId() });
                        // then bury
                        sched.buryCards(new long[] { card.getId() });
                        sHadCardQueue = true;
                        break;
                    case BURY_NOTE:
                        // collect undo information
                        col.markUndo(type, new Object[] { col.getDirty(), note.cards(), card.getId() });
                        // then bury
                        sched.buryNote(note.getId());
                        sHadCardQueue = true;
                        break;
                    case SUSPEND_CARD:
                        // collect undo information
                        col.markUndo(type, new Object[] { card });
                        // suspend card
                        if (card.getQueue() == -1) {
                            sched.unsuspendCards(new long[] { card.getId() });
                        } else {
                            sched.suspendCards(new long[] { card.getId() });
                        }
                        sHadCardQueue = true;
                        break;
                    case SUSPEND_NOTE:
                        // collect undo information
                        ArrayList<Card> cards = note.cards();
                        long[] cids = new long[cards.size()];
                        for (int i = 0; i < cards.size(); i++) {
                            cids[i] = cards.get(i).getId();
                        }
                        col.markUndo(type, new Object[] { cards, card.getId() });
                        // suspend note
                        sched.suspendCards(cids);
                        sHadCardQueue = true;
                        break;
                    case DELETE_NOTE:
                        // collect undo information
                        ArrayList<Card> allCs = note.cards();
                        col.markUndo(type, new Object[] { note, allCs, card.getId() });
                        // delete note
                        col.remNotes(new long[] { note.getId() });
                        sHadCardQueue = true;
                        break;
                }
                publishProgress(new TaskData(getCard(col.getSched()), 0));
                col.getDb().getDatabase().setTransactionSuccessful();
            } finally {
                col.getDb().getDatabase().endTransaction();
            }
        } catch (RuntimeException e) {
            Timber.e(e, "doInBackgroundSuspendCard - RuntimeException on suspending card");
            AnkiDroidApp.sendExceptionReport(e, "doInBackgroundSuspendCard");
            return new TaskData(false);
        }
        return new TaskData(true);
    }


    private TaskData doInBackgroundUndo(TaskData... params) {
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        Sched sched = col.getSched();
        try {
            col.getDb().getDatabase().beginTransaction();
            Card newCard;
            try {
                long cid = col.undo();
                if (cid != 0) {
                    // a review was undone,
                    newCard = col.getCard(cid);
                    newCard.startTimer();
                    col.reset();
                    col.getSched().decrementCounts(newCard);
                    sHadCardQueue = true;
                } else {
                    // TODO: do not fetch new card if a non review operation has
                    // been undone
                    col.reset();
                    newCard = getCard(sched);
                }
                // TODO: handle leech undoing properly
                publishProgress(new TaskData(newCard, 0));
                col.getDb().getDatabase().setTransactionSuccessful();
            } finally {
                col.getDb().getDatabase().endTransaction();
            }
        } catch (RuntimeException e) {
            Timber.e(e, "doInBackgroundUndo - RuntimeException on undoing");
            AnkiDroidApp.sendExceptionReport(e, "doInBackgroundUndo");
            return new TaskData(false);
        }
        return new TaskData(true);
    }


    private TaskData doInBackgroundSearchCards(TaskData... params) {
        Timber.d("doInBackgroundSearchCards");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        Map<String, String> deckNames = (HashMap<String, String>) params[0].getObjArray()[0];
        String query = (String) params[0].getObjArray()[1];
        Boolean order = (Boolean) params[0].getObjArray()[2];
        int numCardsToRender = (int) params[0].getObjArray()[3];
        List<Map<String,String>> searchResult = col.findCardsForCardBrowser(query, order, deckNames);
        // Render the first few items
        for (int i = 0; i < Math.min(numCardsToRender, searchResult.size()); i++) {
            Card c = col.getCard(Long.parseLong(searchResult.get(i).get("id"), 10));
            CardBrowser.updateSearchItemQA(searchResult.get(i), c);
        }
        // Finish off the task
        if (isCancelled()) {
            Timber.d("doInBackgroundSearchCards was cancelled so return null");
            return null;
        } else {
            publishProgress(new TaskData(searchResult));
        }
        return new TaskData(col.cardCount(col.getDecks().allIds()));
    }


    private TaskData doInBackgroundRenderBrowserQA(TaskData... params) {
        Timber.d("doInBackgroundRenderBrowserQA");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        List<Map<String, String>> items = (List<Map<String, String>>) params[0].getObjArray()[0];
        Integer startPos = (Integer) params[0].getObjArray()[1];
        Integer n = (Integer) params[0].getObjArray()[2];

        // for each specified card in the browser list
        for (int i = startPos; i < startPos + n; i++) {
            if (i >= 0 && i < items.size() && items.get(i).get("answer").equals("")) {
                // Extract card item
                Card c = col.getCard(Long.parseLong(items.get(i).get("id"), 10));
                // Update item
                CardBrowser.updateSearchItemQA(items.get(i), c);
                // Stop if cancelled
                if (isCancelled()) {
                    Timber.d("doInBackgroundRenderBrowserQA was aborted");
                    return null;
                } else {
                    float progress = (float) i / n * 100;
                    publishProgress(new TaskData((int) progress));
                }
            }
        }
        return new TaskData(items);
    }


    private TaskData doInBackgroundCheckDatabase(TaskData... params) {
        Timber.d("doInBackgroundCheckDatabase");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        // Don't proceed if collection closed
        if (col == null) {
            Timber.e("doInBackgroundCheckDatabase :: supplied collection was null");
            return new TaskData(false);
        }

        long result = col.fixIntegrity();
        if (result == -1) {
            return new TaskData(false);
        } else {
            // Close the collection and we restart the app to reload
            CollectionHelper.getInstance().closeCollection(true);
            return new TaskData(0, result, true);
        }
    }


    private TaskData doInBackgroundRepairDeck(TaskData... params) {
        Timber.d("doInBackgroundRepairDeck");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        if (col != null) {
            col.close(false);
        }
        return new TaskData(BackupManager.repairCollection(col));
    }


    private TaskData doInBackgroundUpdateValuesFromDeck(TaskData... params) {
        Timber.d("doInBackgroundUpdateValuesFromDeck");
        try {
            Collection col = CollectionHelper.getInstance().getCol(mContext);
            Sched sched = col.getSched();
            Object[] obj = params[0].getObjArray();
            boolean reset = (Boolean) obj[0];
            if (reset) {
                sched.reset();
            }
            int[] counts = sched.counts();
            int totalNewCount = sched.totalNewForCurrentDeck();
            int totalCount = sched.cardCount();
            return new TaskData(new Object[]{counts[0], counts[1], counts[2], totalNewCount,
                    totalCount, sched.eta(counts)});
        } catch (RuntimeException e) {
            Timber.e(e, "doInBackgroundUpdateValuesFromDeck - an error occurred");
            return null;
        }
    }


    private TaskData doInBackgroundDeleteDeck(TaskData... params) {
        Timber.d("doInBackgroundDeleteDeck");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        long did = params[0].getLong();
        col.getDecks().rem(did, true);

        return new TaskData(true);
    }


    private TaskData doInBackgroundRebuildCram(TaskData... params) {
        Timber.d("doInBackgroundRebuildCram");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        col.getSched().rebuildDyn(col.getDecks().selected());
        return doInBackgroundUpdateValuesFromDeck(new DeckTask.TaskData(new Object[]{true}));
    }


    private TaskData doInBackgroundEmptyCram(TaskData... params) {
        Timber.d("doInBackgroundEmptyCram");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        col.getSched().emptyDyn(col.getDecks().selected());
        return doInBackgroundUpdateValuesFromDeck(new DeckTask.TaskData(new Object[]{true}));
    }


    private TaskData doInBackgroundImportAdd(TaskData... params) {
        Timber.d("doInBackgroundImportAdd");
        Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        String path = params[0].getString();
        AnkiPackageImporter imp = new AnkiPackageImporter(col, path);
        imp.setProgressCallback(new ProgressCallback(this, res));
        imp.run();
        return new TaskData(new Object[] {imp});
    }


    private TaskData doInBackgroundImportReplace(TaskData... params) {
        Timber.d("doInBackgroundImportReplace");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        String path = params[0].getString();
        Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();

        // extract the deck from the zip file
        String colPath = col.getPath();
        File dir = new File(new File(colPath).getParentFile(), "tmpzip");
        if (dir.exists()) {
            BackupManager.removeDir(dir);
        }

        // from anki2.py
        String colFile = new File(dir, "collection.anki2").getAbsolutePath();
        ZipFile zip;
        try {
            zip = new ZipFile(new File(path), ZipFile.OPEN_READ);
        } catch (IOException e) {
            Timber.e(e, "doInBackgroundImportReplace - Error while unzipping");
            AnkiDroidApp.sendExceptionReport(e, "doInBackgroundImportReplace0");
            return new TaskData(false);
        }
        try {
            Utils.unzipFiles(zip, dir.getAbsolutePath(), new String[] { "collection.anki2", "media" }, null);
        } catch (IOException e) {
            return new TaskData(-2, null, false);
        }
        if (!(new File(colFile)).exists()) {
            return new TaskData(-2, null, false);
        }

        Collection tmpCol = null;
        try {
            tmpCol = Storage.Collection(mContext, colFile);
            if (!tmpCol.validCollection()) {
                tmpCol.close();
                return new TaskData(-2, null, false);
            }
        } catch (Exception e) {
            Timber.e("Error opening new collection file... probably it's invalid");
            try {
                tmpCol.close();
            } catch (Exception e2) {
                // do nothing
            }
            return new TaskData(-2, null, false);
        } finally {
            if (tmpCol != null) {
                tmpCol.close();
            }
        }

        publishProgress(new TaskData(res.getString(R.string.importing_collection)));
        if (col != null) {
            // unload collection and trigger a backup
            CollectionHelper.getInstance().closeCollection(true);
            CollectionHelper.getInstance().lockCollection();
            BackupManager.performBackupInBackground(colPath, true);
        }
        // overwrite collection
        File f = new File(colFile);
        if (!f.renameTo(new File(colPath))) {
            // Exit early if this didn't work
            return new TaskData(-2, null, false);
        }
        int addedCount = -1;
        try {
            CollectionHelper.getInstance().unlockCollection();

            // because users don't have a backup of media, it's safer to import new
            // data and rely on them running a media db check to get rid of any
            // unwanted media. in the future we might also want to duplicate this step
            // import media
            HashMap<String, String> nameToNum = new HashMap<>();
            HashMap<String, String> numToName = new HashMap<>();
            File mediaMapFile = new File(dir.getAbsolutePath(), "media");
            if (mediaMapFile.exists()) {
                JsonReader jr = new JsonReader(new FileReader(mediaMapFile));
                jr.beginObject();
                String name;
                String num;
                while (jr.hasNext()) {
                    num = jr.nextName();
                    name = jr.nextString();
                    nameToNum.put(name, num);
                    numToName.put(num, name);
                }
                jr.endObject();
                jr.close();
            }
            String mediaDir = col.getMedia().dir();
            int total = nameToNum.size();
            int i = 0;
            for (Map.Entry<String, String> entry : nameToNum.entrySet()) {
                String file = entry.getKey();
                String c = entry.getValue();
                File of = new File(mediaDir, file);
                if (!of.exists()) {
                    Utils.unzipFiles(zip, mediaDir, new String[] { c }, numToName);
                }
                ++i;
                publishProgress(new TaskData(res.getString(R.string.import_media_count, (i + 1) * 100 / total)));
            }
            zip.close();
            // delete tmp dir
            BackupManager.removeDir(dir);
            return new TaskData(true);
        } catch (RuntimeException e) {
            Timber.e(e, "doInBackgroundImportReplace - RuntimeException");
            AnkiDroidApp.sendExceptionReport(e, "doInBackgroundImportReplace1");
            return new TaskData(false);
        } catch (FileNotFoundException e) {
            Timber.e(e, "doInBackgroundImportReplace - FileNotFoundException");
            AnkiDroidApp.sendExceptionReport(e, "doInBackgroundImportReplace2");
            return new TaskData(false);
        } catch (IOException e) {
            Timber.e(e, "doInBackgroundImportReplace - IOException");
            AnkiDroidApp.sendExceptionReport(e, "doInBackgroundImportReplace3");
            return new TaskData(false);
        }
    }


    private TaskData doInBackgroundExportApkg(TaskData... params) {
        Timber.d("doInBackgroundExportApkg");
        Object[] data = params[0].getObjArray();
        Collection col = (Collection) data[0];
        String apkgPath = (String) data[1];
        Long did = (Long) data[2];
        boolean includeSched = (Boolean) data[3];
        boolean includeMedia = (Boolean) data[4];
        
        try {
            AnkiPackageExporter exporter = new AnkiPackageExporter(col);
            exporter.setIncludeSched(includeSched);
            exporter.setIncludeMedia(includeMedia);
            exporter.setDid(did);
            exporter.exportInto(apkgPath, mContext);
        } catch (FileNotFoundException e) {
            Timber.e(e, "FileNotFoundException in doInBackgroundExportApkg");
            return new TaskData(false);
        } catch (IOException e) {
            Timber.e(e, "IOException in doInBackgroundExportApkg");
            return new TaskData(false);
        } catch (JSONException e) {
            Timber.e(e, "JSOnException in doInBackgroundExportApkg");
            return new TaskData(false);
        }
        return new TaskData(apkgPath);
    }


    private TaskData doInBackgroundReorder(TaskData... params) {
        Timber.d("doInBackgroundReorder");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        Object[] data = params[0].getObjArray();
        JSONObject conf = (JSONObject) data[0];
        col.getSched().resortConf(conf);
        return new TaskData(true);
    }


    private TaskData doInBackgroundConfChange(TaskData... params) {
        Timber.d("doInBackgroundConfChange");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        Object[] data = params[0].getObjArray();
        JSONObject deck = (JSONObject) data[0];
        JSONObject conf = (JSONObject) data[1];
        try {
            long newConfId = conf.getLong("id");
            // If new config has a different sorting order, reorder the cards
            int oldOrder = col.getDecks().getConf(deck.getLong("conf")).getJSONObject("new").getInt("order");
            int newOrder = col.getDecks().getConf(newConfId).getJSONObject("new").getInt("order");
            if (oldOrder != newOrder) {
                switch (newOrder) {
                    case 0:
                        col.getSched().randomizeCards(deck.getLong("id"));
                        break;
                    case 1:
                        col.getSched().orderCards(deck.getLong("id"));
                        break;
                }
            }
            col.getDecks().setConf(deck, newConfId);
            col.save();
            return new TaskData(true);
        } catch (JSONException e) {
            return new TaskData(false);
        }
    }


    private TaskData doInBackgroundConfReset(TaskData... params) {
        Timber.d("doInBackgroundConfReset");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        Object[] data = params[0].getObjArray();
        JSONObject conf = (JSONObject) data[0];
        col.getDecks().restoreToDefault(conf);
        col.save();
        return new TaskData(true);
    }


    private TaskData doInBackgroundConfRemove(TaskData... params) {
        Timber.d("doInBackgroundConfRemove");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        Object[] data = params[0].getObjArray();
        JSONObject conf = (JSONObject) data[0];
        try {
            // Note: We do the actual removing of the options group in the main thread so that we 
            // can ask the user to confirm if they're happy to do a full sync, and just do the resorting here

            // When a conf is deleted, all decks using it revert to the default conf.
            // Cards must be reordered according to the default conf.
            int order = conf.getJSONObject("new").getInt("order");
            int defaultOrder = col.getDecks().getConf(1).getJSONObject("new").getInt("order");
            if (order != defaultOrder) {
                conf.getJSONObject("new").put("order", defaultOrder);
                col.getSched().resortConf(conf);
            }
            col.save();
            return new TaskData(true);
        } catch (JSONException e) {
            return new TaskData(false);
        }
    }


    private TaskData doInBackgroundConfSetSubdecks(TaskData... params) {
        Timber.d("doInBackgroundConfSetSubdecks");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        Object[] data = params[0].getObjArray();
        JSONObject deck = (JSONObject) data[0];
        JSONObject conf = (JSONObject) data[1];
        try {
            TreeMap<String, Long> children = col.getDecks().children(deck.getLong("id"));
            for (Map.Entry<String, Long> entry : children.entrySet()) {
                JSONObject child = col.getDecks().get(entry.getValue());
                if (child.getInt("dyn") == 1) {
                    continue;
                }
                TaskData newParams = new TaskData(new Object[] { child, conf });
                boolean changed = doInBackgroundConfChange(newParams).getBoolean();
                if (!changed) {
                    return new TaskData(false);
                }
            }
            return new TaskData(true);
        } catch (JSONException e) {
            return new TaskData(false);
        }
    }


    /**
     * @return The results list from the check, or false if any errors.
     */
    private TaskData doInBackgroundCheckMedia(TaskData... params) {
        Timber.d("doInBackgroundCheckMedia");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        // A media check on AnkiDroid will also update the media db
        col.getMedia().findChanges(true);
        // Then do the actual check
        List<List<String>> result = col.getMedia().check();
        return new TaskData(0, new Object[]{result}, true);
    }

    /**
     * Add a new card template
     */
    private TaskData doInBackgroundAddTemplate(TaskData... params) {
        Timber.d("doInBackgroundAddTemplate");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        Object [] args = params[0].getObjArray();
        JSONObject model = (JSONObject) args[0];
        JSONObject template = (JSONObject) args[1];
        // add the new template
        try {
            col.getModels().addTemplate(model, template);
            col.save();
        } catch (ConfirmModSchemaException e) {
            Timber.e("doInBackgroundAddTemplate :: ConfirmModSchemaException");
            return new TaskData(false);
        }
        return new TaskData(true);
    }

    /**
     * Remove a card template. Note: it's necessary to call save model after this to re-generate the cards
     */
    private TaskData doInBackgroundRemoveTemplate(TaskData... params) {
        Timber.d("doInBackgroundRemoveTemplate");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        Object [] args = params[0].getObjArray();
        JSONObject model = (JSONObject) args[0];
        JSONObject template = (JSONObject) args[1];
        try {
            boolean success = col.getModels().remTemplate(model, template);
            if (! success) {
                return new TaskData("removeTemplateFailed", false);
            }
            col.save();
        } catch (ConfirmModSchemaException e) {
            Timber.e("doInBackgroundRemoveTemplate :: ConfirmModSchemaException");
            return new TaskData(false);
        }
        return new TaskData(true);
    }

    /**
     * Regenerate all the cards in a model
     */
    private TaskData doInBackgroundSaveModel(TaskData... params) {
        Timber.d("doInBackgroundSaveModel");
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        Object [] args = params[0].getObjArray();
        JSONObject model = (JSONObject) args[0];
        col.getModels().save(model, true);
        col.reset();
        col.save();
        return new TaskData(true);
    }


    /*
     * Async task for the ModelBrowser Class
     * Returns an ArrayList of all models alphabetically ordered and the number of notes
     * associated with each model.
     *
     * @return {ArrayList<JSONObject> models, ArrayList<Integer> cardCount}
     */
    private TaskData doInBackgroundCountModels(TaskData... params){
        Timber.d("doInBackgroundLoadModels");
        Collection col = CollectionHelper.getInstance().getCol(mContext);

        ArrayList<JSONObject> models = col.getModels().all();
        ArrayList<Integer> cardCount = new ArrayList<>();
        Collections.sort(models, new Comparator<JSONObject>() {
            @Override
            public int compare(JSONObject a, JSONObject b) {
                try {
                    return a.getString("name").compareTo(b.getString("name"));
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
            }
        });

        try{
            for (JSONObject n : models) {
                long modID = n.getLong("id");
                cardCount.add(col.getModels().nids(col.getModels().get(modID)).size());
            }
        } catch (JSONException e) {
                Timber.e("doInBackgroundLoadModels :: JSONException");
                return new TaskData(false);
        }

        Object[] data = new Object[2];
        data[0] = models;
        data[1] = cardCount;
        return (new TaskData(0, data, true));
    }


    /**
     * Deletes the given model (stored in the long field of TaskData)
     * and all notes associated with it
     */
    private TaskData doInBackGroundDeleteModel(TaskData... params){
        Timber.d("doInBackGroundDeleteModel");
        long modID = params[0].getLong();
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        try {
            col.getModels().rem(col.getModels().get(modID));
            col.save();
        } catch (ConfirmModSchemaException e) {
            Timber.e("doInBackGroundDeleteModel :: ConfirmModSchemaException");
            return new TaskData(false);
        }
        return new TaskData(true);
    }

    /**
     * Deletes thje given field in the given model
     */
    private TaskData doInBackGroundDeleteField(TaskData... params){
        Timber.d("doInBackGroundDeleteField");
        Object[] objects = params[0].getObjArray();

        JSONObject model = (JSONObject) objects[0];
        JSONObject field = (JSONObject) objects[1];


        Collection col = CollectionHelper.getInstance().getCol(mContext);
        try {
            col.getModels().remField(model, field);
            col.save();
        } catch (ConfirmModSchemaException e) {
            //Should never be reached
            return new TaskData(false);
        }
        return new TaskData(true);
    }

    /**
     * Repositions the given field in the given model
     */
    private TaskData doInBackGroundRepositionField(TaskData... params){
        Timber.d("doInBackgroundRepositionField");
        Object[] objects = params[0].getObjArray();

        JSONObject model = (JSONObject) objects[0];
        JSONObject field = (JSONObject) objects[1];
        int index = (Integer) objects[2];


        Collection col = CollectionHelper.getInstance().getCol(mContext);
        try {
            col.getModels().moveField(model, field, index);
            col.save();
        } catch (ConfirmModSchemaException e) {
            //Should never be reached
            return new TaskData(false);
        }
        return new TaskData(true);
    }

    /**
     * Adds a field of with name in given model
     */
    private TaskData doInBackGroundAddField(TaskData... params){
        Timber.d("doInBackgroundRepositionField");
        Object[] objects = params[0].getObjArray();

        JSONObject model = (JSONObject) objects[0];
        String fieldName = (String) objects[1];

        Collection col = CollectionHelper.getInstance().getCol(mContext);
        try {
            col.getModels().addField(model, col.getModels().newField(fieldName));
            col.save();
        } catch (ConfirmModSchemaException e) {
            //Should never be reached
            return new TaskData(false);
        }
        return new TaskData(true);
    }

    /**
     * Adds a field of with name in given model
     */
    private TaskData doInBackgroundChangeSortField(TaskData... params){
        try {
            Timber.d("doInBackgroundChangeSortField");
            Object[] objects = params[0].getObjArray();

            JSONObject model = (JSONObject) objects[0];
            int idx = (int) objects[1];

            Collection col = CollectionHelper.getInstance().getCol(mContext);
            col.getModels().setSortIdx(model, idx);
            col.save();
        } catch(Exception e){
            Timber.e(e, "Error changing sort field");
            return new TaskData(false);
        }
        return new TaskData(true);
    }

    public TaskData doInBackGroundFindEmptyCards(TaskData... params) {
        Collection col = CollectionHelper.getInstance().getCol(mContext);
        List<Long> cids = col.emptyCids();
        return new TaskData(new Object[] { cids});
    }

    /**
     * Listener for the status and result of a {@link DeckTask}.
     * <p>
     * Its methods are guaranteed to be invoked on the main thread.
     * <p>
     * Their semantics is equivalent to the methods of {@link AsyncTask}.
     */
    public interface Listener {

        /** Invoked before the task is started. */
        void onPreExecute(DeckTask task);


        /**
         * Invoked after the task has completed.
         * <p>
         * The semantics of the result depends on the task itself.
         */
        void onPostExecute(DeckTask task, TaskData result);


        /**
         * Invoked when the background task publishes an update.
         * <p>
         * The semantics of the update data depends on the task itself.
         */
        void onProgressUpdate(DeckTask task, TaskData... values);

        /**
         * Invoked when the background task is cancelled.
         */        
        void onCancelled();

    }

    /**
     * Adapter for the old interface, where the DeckTask itself was not passed to the listener.
     * <p>
     * All methods are invoked on the main thread.
     * <p>
     * The semantics of the methods is equivalent to the semantics of the methods in the regular {@link Listener}.
     */
    public static abstract class TaskListener implements Listener {

        /** Invoked before the task is started. */
        public abstract void onPreExecute();


        /**
         * Invoked after the task has completed.
         * <p>
         * The semantics of the result depends on the task itself.
         */
        public abstract void onPostExecute(TaskData result);


        /**
         * Invoked when the background task publishes an update.
         * <p>
         * The semantics of the update data depends on the task itself.
         */
        public abstract void onProgressUpdate(TaskData... values);


        @Override
        public void onPreExecute(DeckTask task) {
            onPreExecute();
        }


        @Override
        public void onPostExecute(DeckTask task, TaskData result) {
            onPostExecute(result);
        }


        @Override
        public void onProgressUpdate(DeckTask task, TaskData... values) {
            onProgressUpdate(values);
        }

    }

    /**
     * Helper class for allowing inner function to publish progress of an AsyncTask.
     */
    public class ProgressCallback {
        private Resources res;
        private DeckTask task;


        public ProgressCallback(DeckTask task, Resources res) {
            this.res = res;
            if (res != null) {
                this.task = task;
            } else {
                this.task = null;
            }
        }


        public Resources getResources() {
            return res;
        }


        public void publishProgress(TaskData values) {
            if (task != null) {
                task.doProgress(values);
            }
        }
    }


    public void doProgress(TaskData values) {
        publishProgress(values);
    }

    public static class TaskData {
        private Card mCard;
        private Note mNote;
        private int mInteger;
        private String mMsg;
        private boolean mBool = false;
        private List<Map<String, String>> mCards;
        private long mLong;
        private Context mContext;
        private int mType;
        private Comparator mComparator;
        private Object[] mObjects;


        public TaskData(Object[] obj) {
            mObjects = obj;
        }


        public TaskData(int value, Object[] obj, boolean bool) {
            mObjects = obj;
            mInteger = value;
            mBool = bool;
        }


        public TaskData(int value, Card card) {
            this(value);
            mCard = card;
        }


        public TaskData(int value, long cardId, boolean bool) {
            this(value);
            mLong = cardId;
            mBool = bool;
        }


        public TaskData(Card card) {
            mCard = card;
        }


        public TaskData(Card card, String tags) {
            mCard = card;
            mMsg = tags;
        }


        public TaskData(Card card, int integer) {
            mCard = card;
            mInteger = integer;
        }


        public TaskData(Context context, int type, int period) {
            mContext = context;
            mType = type;
            mInteger = period;
        }


        public TaskData(List<Map<String, String>> cards) {
            mCards = cards;
        }


        public TaskData(List<Map<String, String>> cards, Comparator comparator) {
            mCards = cards;
            mComparator = comparator;
        }


        public TaskData(boolean bool) {
            mBool = bool;
        }


        public TaskData(String string, boolean bool) {
            mMsg = string;
            mBool = bool;
        }


        public TaskData(long value, boolean bool) {
            mLong = value;
            mBool = bool;
        }


        public TaskData(int value, boolean bool) {
            mInteger = value;
            mBool = bool;
        }


        public TaskData(Card card, boolean bool) {
            mBool = bool;
            mCard = card;
        }


        public TaskData(int value) {
            mInteger = value;
        }


        public TaskData(long l) {
            mLong = l;
        }


        public TaskData(String msg) {
            mMsg = msg;
        }


        public TaskData(Note note) {
            mNote = note;
        }


        public TaskData(int value, String msg) {
            mMsg = msg;
            mInteger = value;
        }


        public TaskData(String msg, long cardId, boolean bool) {
            mMsg = msg;
            mLong = cardId;
            mBool = bool;
        }


        public List<Map<String, String>> getCards() {
            return mCards;
        }


        public void setCards(List<Map<String, String>> cards) {
            mCards = cards;
        }


        public Comparator getComparator() {
            return mComparator;
        }


        public Card getCard() {
            return mCard;
        }


        public Note getNote() {
            return mNote;
        }


        public long getLong() {
            return mLong;
        }


        public int getInt() {
            return mInteger;
        }


        public String getString() {
            return mMsg;
        }


        public boolean getBoolean() {
            return mBool;
        }


        public Context getContext() {
            return mContext;
        }


        public int getType() {
            return mType;
        }


        public Object[] getObjArray() {
            return mObjects;
        }
    }

    public static synchronized DeckTask getInstance() {
        return sLatestInstance;
    }
}
/****************************************************************************************
 * Copyright (c) 2011 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.compat;

import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.speech.tts.TextToSpeech;
import android.view.View;
import android.view.Window;
import android.webkit.WebSettings;
import android.widget.RemoteViews;

import com.ichi2.anki.AbstractFlashcardViewer;
import com.ichi2.anki.AnkiActivity;
import com.ichi2.anki.DeckPicker;

import java.io.File;

import io.requery.android.database.sqlite.SQLiteDatabase;

/**
 * This interface defines a set of functions that are not available on all platforms.
 * <p>
 * A set of implementations for the supported platforms are available.
 * <p>
 * Each implementation ends with a {@code V<n>} prefix, identifying the minimum API version on which this implementation
 * can be used. For example, see {@link CompatV10}.
 * <p>
 * Each implementation should extend the previous implementation and implement this interface.
 * <p>
 * Each implementation should only override the methods that first become available in its own version, use @Override.
 * <p>
 * Methods not supported by its API will default to the empty implementations of CompatV8.  Methods first supported
 * by lower APIs will default to those implementations since we extended them.
 * <p>
 * Example: CompatV9 extends CompatV8. This means that the nfcNormalized function that uses classes only available
 * in API 9, should be implemented properly in CompatV9 with @Override annotation. On the other hand a method
 * like setOverScrollModeNever that first becomes available in API 9 need not be implemented again in CompatV10,
 * unless the behaviour is supposed to be different there.
 */
public interface Compat {

    /* Mock the Intent PROCESS_TEXT constants introduced in API 23. */
    public static final String ACTION_PROCESS_TEXT = "android.intent.action.PROCESS_TEXT";
    public static final String EXTRA_PROCESS_TEXT = "android.intent.extra.PROCESS_TEXT";

    String detagged(String txt);
    void setTtsOnUtteranceProgressListener(TextToSpeech tts);
    void disableDatabaseWriteAheadLogging(SQLiteDatabase db);
    void enableCookiesForFileSchemePages();
    void updateWidgetDimensions(Context context, RemoteViews updateViews, Class<?> cls);
    void restartActivityInvalidateBackstack(AnkiActivity activity);
    void setFullScreen(AbstractFlashcardViewer activity);
    void setSelectableBackground(View view);
    void openUrl(AnkiActivity activity, Uri uri);
    void supportAddContentMenu(final DeckPicker a);
    Intent getPreferenceSubscreenIntent(Context context, String subscreen);
    void prepareWebViewCookies(Context context);
    void flushWebViewCookies();
    void setHTML5MediaAutoPlay(WebSettings settings, Boolean allow);
    void setStatusBarColor(Window window, int color);

    /** Returns true if the system UI currently visible during immersive mode */
    boolean isImmersiveSystemUiVisible(AnkiActivity activity);
    boolean deleteDatabase(File db);
    Uri getExportUri(Context context, File file);
}

/***************************************************************************************
 * Copyright (c) 2015 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.compat;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Build;
import android.preference.PreferenceManager;
import android.view.KeyCharacterMap;

public class CompatHelper {
    private static CompatHelper sInstance;
    private Compat mCompat;


    private CompatHelper() {

        if (isNookHdOrHdPlus() && getSdkVersion() == 15) {
            mCompat = new CompatV15NookHdOrHdPlus();
        } else if (getSdkVersion() >= 23) {
            mCompat = new CompatV23();
        } else if (getSdkVersion() >= 21) {
            mCompat = new CompatV21();
        } else if (getSdkVersion() >= 19) {
            mCompat = new CompatV19();
        } else if (getSdkVersion() >= 17) {
            mCompat = new CompatV17();
        } else if (getSdkVersion() >= 16) {
            mCompat = new CompatV16();
        } else if (getSdkVersion() >= 15) {
            mCompat = new CompatV15();
        } else if (getSdkVersion() >= 11) {
            mCompat = new CompatV11();
        } else if (getSdkVersion() >= 12) {
            mCompat = new CompatV12();
        } else {
            mCompat = new CompatV10();
        }
    }

    /** Get the current Android API level. */
    public static int getSdkVersion() {
        return Build.VERSION.SDK_INT;
    }


    /** Determine if the device is running API level 11 or higher. */
    public static boolean isHoneycomb() {
        return getSdkVersion() >= Build.VERSION_CODES.HONEYCOMB;
    }
    /** Determine if the device is running API level 21 or higher. */
    public static boolean isLollipop() {
        return getSdkVersion() >= Build.VERSION_CODES.LOLLIPOP;
    }
    /** Determine if the device is running API level 23 or higher. */
    public static boolean isMarshmallow() {
        return getSdkVersion() >= Build.VERSION_CODES.M;
    }

    /**
     * Main public method to get the compatibility class
     */
    public static Compat getCompat() {
        return getInstance().mCompat;
    }

    public static synchronized CompatHelper getInstance() {
        if (sInstance == null) {
            sInstance = new CompatHelper();
        }
        return sInstance;
    }

    private boolean isNookHdOrHdPlus() {
        return isNookHd() || isNookHdPlus();
    }

    private boolean isNookHdPlus() {
        return android.os.Build.BRAND.equals("NOOK") && android.os.Build.PRODUCT.equals("HDplus")
                && android.os.Build.DEVICE.equals("ovation");
    }

    private boolean isNookHd () {
        return android.os.Build.MODEL.equalsIgnoreCase("bntv400") && android.os.Build.BRAND.equals("NOOK");
    }


    public static boolean isNook() {
        return android.os.Build.MODEL.equalsIgnoreCase("nook") || android.os.Build.DEVICE.equalsIgnoreCase("nook");
    }


    public static boolean isChromebook() {
        return android.os.Build.BRAND.equalsIgnoreCase("chromium") || android.os.Build.MANUFACTURER.equalsIgnoreCase("chromium");
    }

    public static boolean isKindle() {
        return Build.BRAND.equalsIgnoreCase("amazon") || Build.MANUFACTURER.equalsIgnoreCase("amazon");
    }

    public static boolean hasKanaAndEmojiKeys() {
        return KeyCharacterMap.deviceHasKey(94) && KeyCharacterMap.deviceHasKey(95);
    }

    public static boolean hasScrollKeys() {
        return KeyCharacterMap.deviceHasKey(92) || KeyCharacterMap.deviceHasKey(93);
    }

    public static void removeHiddenPreferences(Context context) {
        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
        if (isHoneycomb()){
            preferences.edit().remove("longclickWorkaround").commit();
        }
        if (getSdkVersion() >= 13) {
            preferences.edit().remove("safeDisplay").commit();
        }
        if (getSdkVersion() >= 15) {
            preferences.edit().remove("inputWorkaround").commit();
        }
        if (getSdkVersion() >= 16) {
            preferences.edit().remove("fixHebrewText").commit();
        }
    }
}

package com.ichi2.compat;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.Intent;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.net.Uri;
import android.speech.tts.TextToSpeech;
import android.speech.tts.TextToSpeech.OnUtteranceCompletedListener;
import android.support.annotation.NonNull;
import android.support.v4.content.ContextCompat;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.webkit.CookieSyncManager;
import android.webkit.WebSettings;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.RemoteViews;

import com.afollestad.materialdialogs.DialogAction;
import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.AbstractFlashcardViewer;
import com.ichi2.anki.AnkiActivity;
import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.DeckPicker;
import com.ichi2.anki.Preferences;
import com.ichi2.anki.R;
import com.ichi2.anki.ReadText;
import com.ichi2.compat.customtabs.CustomTabsFallback;

import java.io.File;

import io.requery.android.database.sqlite.SQLiteDatabase;
import timber.log.Timber;

/** Implementation of {@link Compat} for SDK level 7 */
@TargetApi(10)
public class CompatV10 implements Compat {
    protected static final int FULLSCREEN_ALL_GONE = 2;

    /*
     *  Return the input string in a form suitable for display on a HTML page. Replace 鈥
package com.ichi2.compat;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.preference.PreferenceActivity;
import android.support.v4.app.TaskStackBuilder;

import com.ichi2.anki.AnkiActivity;
import com.ichi2.anki.Preferences;

import io.requery.android.database.sqlite.SQLiteDatabase;
import timber.log.Timber;

/** Implementation of {@link Compat} for SDK level 11 (Honeycomb) */
@TargetApi(11)
public class CompatV11 extends CompatV10 implements Compat {

    /**
     * Restart the activity and discard old backstack, creating it new from the heirarchy in the manifest
     */
    public void restartActivityInvalidateBackstack(AnkiActivity activity) {
        Timber.i("AnkiActivity -- restartActivityInvalidateBackstack()");
        Intent intent = new Intent();
        intent.setClass(activity, activity.getClass());
        TaskStackBuilder stackBuilder = TaskStackBuilder.create(activity);
        stackBuilder.addNextIntentWithParentStack(intent);
        stackBuilder.startActivities(new Bundle());
        activity.finishWithoutAnimation();
    }

    @Override
    public void disableDatabaseWriteAheadLogging(SQLiteDatabase db) {
        // disableWriteAheadLogging() method only available from API 16
        db.rawQuery("PRAGMA journal_mode = DELETE", null);
    }

    @Override
    public Intent getPreferenceSubscreenIntent(Context context, String subscreen) {
        Intent i = new Intent(context, Preferences.class);
        i.putExtra(PreferenceActivity.EXTRA_SHOW_FRAGMENT, "com.ichi2.anki.Preferences$SettingsFragment");
        Bundle extras = new Bundle();
        extras.putString("subscreen", subscreen);
        i.putExtra(PreferenceActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS, extras);
        i.putExtra(PreferenceActivity.EXTRA_NO_HEADERS, true);
        return i;
    }
}
package com.ichi2.compat;

import android.annotation.TargetApi;
import android.webkit.CookieManager;

import timber.log.Timber;

/** Implementation of {@link Compat} for SDK level 12 */
@TargetApi(12)
public class CompatV12 extends CompatV11 implements Compat {

    // On API level 12 and higher, WebKit prevents file scheme pages from accessing cookies.
    // This function removes this restriction.
    @Override
    public void enableCookiesForFileSchemePages() {
        try {
            CookieManager.setAcceptFileSchemeCookies(true);
        } catch (Throwable e) {
            Timber.e(e, "Runtime exception enabling cookies");
        }
    }
}
package com.ichi2.compat;

import android.annotation.TargetApi;
import android.speech.tts.TextToSpeech;
import android.speech.tts.UtteranceProgressListener;

import com.ichi2.anki.ReadText;

/** Implementation of {@link Compat} for SDK level 15 */
@TargetApi(15)
public class CompatV15 extends CompatV12 implements Compat {

    @Override
    public void setTtsOnUtteranceProgressListener(TextToSpeech tts) {
        tts.setOnUtteranceProgressListener(new UtteranceProgressListener() {
            @Override
            public void onDone(String arg0) {
                if (ReadText.sTextQueue.size() > 0) {
                    String[] text = ReadText.sTextQueue.remove(0);
                    ReadText.speak(text[0], text[1]);
                }
            }
            @Override
            public void onError(String arg0) {
            }
            @Override
            public void onStart(String arg0) {
            }
        });
    }

}

package com.ichi2.compat;

import android.annotation.TargetApi;

import io.requery.android.database.sqlite.SQLiteDatabase;

/**
 * Implementation of {@link Compat} for SDK level 15 for Nook HD Plus.
 * <p>
 * This device actually supports disabling WAL via this hidden API and not doing so seems to create issues on this
 * device.
 */
@TargetApi(16)
public class CompatV15NookHdOrHdPlus extends CompatV15 implements Compat {

    @Override
    public void disableDatabaseWriteAheadLogging(SQLiteDatabase db) {
        db.disableWriteAheadLogging();
    }

}

package com.ichi2.compat;

import android.annotation.TargetApi;
import android.appwidget.AppWidgetManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.res.Configuration;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.os.Bundle;
import android.support.customtabs.CustomTabsIntent;
import android.support.v4.content.ContextCompat;
import android.support.v4.content.FileProvider;
import android.text.Html;
import android.util.TypedValue;
import android.widget.RemoteViews;

import com.ichi2.anki.AnkiActivity;
import com.ichi2.anki.R;
import com.ichi2.compat.customtabs.CustomTabActivityHelper;
import com.ichi2.compat.customtabs.CustomTabsFallback;
import com.ichi2.compat.customtabs.CustomTabsHelper;

import java.io.File;

import io.requery.android.database.sqlite.SQLiteDatabase;

/** Implementation of {@link Compat} for SDK level 16 */
@TargetApi(16)
public class CompatV16 extends CompatV15 implements Compat {

    @Override
    public void disableDatabaseWriteAheadLogging(SQLiteDatabase db) {
        db.disableWriteAheadLogging();
    }

    @Override
    public String detagged(String txt) {
        return Html.escapeHtml(txt);
    }

    /*
    *  Update dimensions of widget from V16 on (elder versions do not support widget measuring)
    */
    @Override
    public void updateWidgetDimensions(Context context, RemoteViews updateViews, Class<?> cls) {
        AppWidgetManager manager = AppWidgetManager.getInstance(context);
        int[] ids = manager.getAppWidgetIds(new ComponentName(context, cls));
        for (int id : ids) {
            final float scale = context.getResources().getDisplayMetrics().density;
            Bundle options = manager.getAppWidgetOptions(id);
            float width, height;
            if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {
                width = options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH);
                height = options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT);
            } else {
                width = options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH);
                height = options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);
            }
            int horizontal, vertical;
            float text;
            if ((width / height) > 0.8) {
                horizontal = (int) (((width - (height * 0.8))/2 + 4) * scale + 0.5f);
                vertical = (int) (4 * scale + 0.5f);
                text = (float)(Math.sqrt(height * 0.8 / width) * 18);
            } else {
                vertical = (int) (((height - (width * 1.25))/2 + 4) * scale + 0.5f);
                horizontal = (int) (4 * scale + 0.5f);
                text = (float)(Math.sqrt(width * 1.25 / height) * 18);
            }

            updateViews.setTextViewTextSize(R.id.widget_due, TypedValue.COMPLEX_UNIT_SP, text);
            updateViews.setTextViewTextSize(R.id.widget_eta, TypedValue.COMPLEX_UNIT_SP, text);
            updateViews.setViewPadding(R.id.ankidroid_widget_text_layout, horizontal, vertical, horizontal, vertical);
        }
    }


    @Override
    public void openUrl(AnkiActivity activity, Uri uri) {
        CustomTabActivityHelper helper = activity.getCustomTabActivityHelper();
        CustomTabsIntent.Builder builder = new CustomTabsIntent.Builder(helper.getSession());
        builder.setToolbarColor(ContextCompat.getColor(activity, R.color.material_light_blue_500)).setShowTitle(true);
        builder.setStartAnimations(activity, R.anim.slide_right_in, R.anim.slide_left_out);
        builder.setExitAnimations(activity, R.anim.slide_left_in, R.anim.slide_right_out);
        builder.setCloseButtonIcon(BitmapFactory.decodeResource(activity.getResources(), R.drawable.ic_arrow_back_white_24dp));
        CustomTabsIntent customTabsIntent = builder.build();
        CustomTabsHelper.addKeepAliveExtra(activity, customTabsIntent.intent);
        CustomTabActivityHelper.openCustomTab(activity, customTabsIntent, uri, new CustomTabsFallback());
    }

    @Override
    public boolean deleteDatabase(File db) {
        return SQLiteDatabase.deleteDatabase(db);
    }

    @Override
    public Uri getExportUri(Context context, File file) {
        // Use FileProvider for exporting (this requires Jellybean for reliable sending via migrateExtraStreamtoClipData())
        return FileProvider.getUriForFile(context, "com.ichi2.anki.apkgfileprovider", file);
    }
}
package com.ichi2.compat;

import android.annotation.TargetApi;
import android.webkit.WebSettings;

import timber.log.Timber;

/** Implementation of {@link Compat} for SDK level 17 */
@TargetApi(17)
public class CompatV17 extends CompatV16 implements Compat {

    @Override
    public void setHTML5MediaAutoPlay(WebSettings webSettings, Boolean allow) {
        webSettings.setMediaPlaybackRequiresUserGesture(!allow);
    }
}

package com.ichi2.compat;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.annotation.TargetApi;
import android.content.SharedPreferences;
import android.support.v7.widget.Toolbar;
import android.view.View;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;

import com.ichi2.anki.AbstractFlashcardViewer;
import com.ichi2.anki.AnkiActivity;
import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.R;
import com.ichi2.themes.Themes;

/** Implementation of {@link Compat} for SDK level 19 */
@TargetApi(19)
public class CompatV19 extends CompatV17 implements Compat {
    private static final int ANIMATION_DURATION = 200;
    private static final float TRANSPARENCY = 0.90f;

    @Override
    public void setFullScreen(final AbstractFlashcardViewer a) {
        // Set appropriate flags to enable Sticky Immersive mode.
        a.getWindow().getDecorView().setSystemUiVisibility(
                        View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                        | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                        | View.SYSTEM_UI_FLAG_FULLSCREEN
                        | View.SYSTEM_UI_FLAG_LOW_PROFILE
                        | View.SYSTEM_UI_FLAG_IMMERSIVE
        );
        // Show / hide the Action bar together with the status bar
        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(a);
        final int fullscreenMode = Integer.parseInt(prefs.getString("fullscreenMode", "0"));
        CompatHelper.getCompat().setStatusBarColor(a.getWindow(), Themes.getColorFromAttr(a, R.attr.colorPrimaryDark));
        View decorView = a.getWindow().getDecorView();
        decorView.setOnSystemUiVisibilityChangeListener
                (new View.OnSystemUiVisibilityChangeListener() {
                    @Override
                    public void onSystemUiVisibilityChange(int flags) {
                        final Toolbar toolbar = (Toolbar) a.findViewById(R.id.toolbar);
                        final LinearLayout answerButtons = (LinearLayout) a.findViewById(R.id.answer_options_layout);
                        final RelativeLayout topbar = (RelativeLayout) a.findViewById(R.id.top_bar);
                        if (toolbar == null || topbar == null || answerButtons == null) {
                            return;
                        }
                        // Note that system bars will only be "visible" if none of the
                        // LOW_PROFILE, HIDE_NAVIGATION, or FULLSCREEN flags are set.
                        boolean visible = (flags & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
                        if (visible) {
                            showViewWithAnimation(toolbar);
                            if (fullscreenMode >= FULLSCREEN_ALL_GONE) {
                                showViewWithAnimation(topbar);
                                showViewWithAnimation(answerButtons);
                            }
                        } else {
                            hideViewWithAnimation(toolbar);
                            if (fullscreenMode >= FULLSCREEN_ALL_GONE) {
                                hideViewWithAnimation(topbar);
                                hideViewWithAnimation(answerButtons);
                            }
                        }
                    }
                });
    }

    private void showViewWithAnimation(final View view) {
        view.setAlpha(0.0f);
        view.setVisibility(View.VISIBLE);
        view.animate().alpha(TRANSPARENCY).setDuration(ANIMATION_DURATION).setListener(null);
    }

    private void hideViewWithAnimation(final View view) {
        view.animate()
                .alpha(0f)
                .setDuration(ANIMATION_DURATION)
                .setListener(new AnimatorListenerAdapter() {
                    @Override
                    public void onAnimationEnd(Animator animation) {
                        view.setVisibility(View.GONE);
                    }
                });
    }

    @Override
    public boolean isImmersiveSystemUiVisible(AnkiActivity activity) {
        return (activity.getWindow().getDecorView().getSystemUiVisibility() & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
    }
}
package com.ichi2.compat;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.res.TypedArray;
import android.view.View;
import android.view.Window;
import android.webkit.CookieManager;

/** Implementation of {@link Compat} for SDK level 21 */
@TargetApi(21)
public class CompatV21 extends CompatV19 implements Compat {
    @Override
    public void setSelectableBackground(View view) {
        // Ripple effect
        int[] attrs = new int[] {android.R.attr.selectableItemBackground};
        TypedArray ta = view.getContext().obtainStyledAttributes(attrs);
        view.setBackgroundResource(ta.getResourceId(0, 0));
        ta.recycle();
    }

    // On API level 21 and higher, CookieManager will be set automatically, so there is nothing to do here.
    @Override
    public void prepareWebViewCookies(Context context) {

    }

    // A data of cookies may be lost when an application exists just after it was written.
    // On API level 21 and higher, this problem can be solved by using CookieManager.flush().
    @Override
    public void flushWebViewCookies() {
        CookieManager.getInstance().flush();
    }

    @Override
    public void setStatusBarColor(Window window, int color) {
        window.setStatusBarColor(color);
    }
}package com.ichi2.compat;

import android.annotation.TargetApi;
import android.content.Intent;

/** Implementation of {@link Compat} for SDK level 23 */
@TargetApi(23)
public class CompatV23 extends CompatV21 implements Compat {

    public static final String ACTION_PROCESS_TEXT = Intent.ACTION_PROCESS_TEXT;
    public static final String EXTRA_PROCESS_TEXT = Intent.EXTRA_PROCESS_TEXT;

}
// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.ichi2.compat.customtabs;

import android.app.Activity;
import android.net.Uri;
import android.os.Bundle;
import android.support.customtabs.CustomTabsClient;
import android.support.customtabs.CustomTabsIntent;
import android.support.customtabs.CustomTabsServiceConnection;
import android.support.customtabs.CustomTabsSession;

import java.util.List;

import timber.log.Timber;


/**
 * This is a helper class to manage the connection to the Custom Tabs Service.
 */
public class CustomTabActivityHelper implements ServiceConnectionCallback {
    private CustomTabsSession mCustomTabsSession;
    private CustomTabsClient mClient;
    private CustomTabsServiceConnection mConnection;

    /**
     * Opens the URL on a Custom Tab if possible. Otherwise fallsback to opening it on a WebView.
     *
     * @param activity The host activity.
     * @param customTabsIntent a CustomTabsIntent to be used if Custom Tabs is available.
     * @param uri the Uri to be opened.
     * @param fallback a CustomTabFallback to be used if Custom Tabs is not available.
     */
    public static void openCustomTab(Activity activity,
                                     CustomTabsIntent customTabsIntent,
                                     Uri uri,
                                     CustomTabFallback fallback) {
        String packageName = CustomTabsHelper.getPackageNameToUse(activity);

        //If we cant find a package name, it means theres no browser that supports
        //Chrome Custom Tabs installed. So, we fallback to the webview
        if (packageName == null) {
            if (fallback != null) {
                fallback.openUri(activity, uri);
            } else {
                Timber.e("A version of Chrome supporting custom tabs was not available, and the fallback was null");
            }
        } else {
            customTabsIntent.intent.setPackage(packageName);
            customTabsIntent.launchUrl(activity, uri);
        }
    }

    /**
     * Unbinds the Activity from the Custom Tabs Service.
     * @param activity the activity that is connected to the service.
     */
    public void unbindCustomTabsService(Activity activity) {
        if (mConnection == null) return;
        activity.unbindService(mConnection);
        mClient = null;
        mCustomTabsSession = null;
        mConnection = null;
    }

    /**
     * Creates or retrieves an exiting CustomTabsSession.
     *
     * @return a CustomTabsSession.
     */
    public CustomTabsSession getSession() {
        if (mClient == null) {
            mCustomTabsSession = null;
        } else if (mCustomTabsSession == null) {
            mCustomTabsSession = mClient.newSession(null);
        }
        return mCustomTabsSession;
    }

    /**
     * Binds the Activity to the Custom Tabs Service.
     * @param activity the activity to be binded to the service.
     */
    public void bindCustomTabsService(Activity activity) {
        if (mClient != null) return;

        String packageName = CustomTabsHelper.getPackageNameToUse(activity);
        if (packageName == null) return;

        mConnection = new ServiceConnection(this);
        CustomTabsClient.bindCustomTabsService(activity, packageName, mConnection);
    }

    /**
     * @see {@link CustomTabsSession#mayLaunchUrl(Uri, Bundle, List)}.
     * @return true if call to mayLaunchUrl was accepted.
     */
    public boolean mayLaunchUrl(Uri uri, Bundle extras, List<Bundle> otherLikelyBundles) {
        if (mClient == null) return false;

        CustomTabsSession session = getSession();
        if (session == null) return false;

        return session.mayLaunchUrl(uri, extras, otherLikelyBundles);
    }


    @Override
    public void onServiceConnected(CustomTabsClient client) {
        mClient = client;
        mClient.warmup(0L);
        getSession();
    }

    @Override
    public void onServiceDisconnected() {
        mClient = null;
        mCustomTabsSession = null;
    }


    /**
     * To be used as a fallback to open the Uri when Custom Tabs is not available.
     */
    public interface CustomTabFallback {
        /**
         *
         * @param activity The Activity that wants to open the Uri.
         * @param uri The uri to be opened by the fallback.
         */
        void openUri(Activity activity, Uri uri);
    }

}// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package com.ichi2.compat.customtabs;

import android.app.Activity;
import android.content.Intent;
import android.net.Uri;

/**
 * A Fallback that opens a Webview when Custom Tabs is not available
 */
public class CustomTabsFallback implements CustomTabActivityHelper.CustomTabFallback {
    @Override
    public void openUri(Activity activity, Uri uri) {
        Intent intent = new Intent(Intent.ACTION_VIEW, uri);
        activity.startActivity(intent);
    }
}
// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.ichi2.compat.customtabs;

import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.net.Uri;
import android.support.customtabs.CustomTabsService;
import android.text.TextUtils;
import android.util.Log;

import com.ichi2.compat.CompatHelper;

import java.util.ArrayList;
import java.util.List;

/**
 * Helper class for Custom Tabs.
 */
public class CustomTabsHelper {
    private static final String TAG = "CustomTabsHelper";
    static final String STABLE_PACKAGE = "com.android.chrome";
    static final String BETA_PACKAGE = "com.chrome.beta";
    static final String DEV_PACKAGE = "com.chrome.dev";
    static final String LOCAL_PACKAGE = "com.google.android.apps.chrome";
    private static final String EXTRA_CUSTOM_TABS_KEEP_ALIVE =
            "android.support.customtabs.extra.KEEP_ALIVE";

    private static String sPackageNameToUse;
    private static final int MIN_SDK = 16;

    private CustomTabsHelper() {}

    public static void addKeepAliveExtra(Context context, Intent intent) {
        Intent keepAliveIntent = new Intent().setClassName(
                context.getPackageName(), KeepAliveService.class.getCanonicalName());
        intent.putExtra(EXTRA_CUSTOM_TABS_KEEP_ALIVE, keepAliveIntent);
    }

    /**
     * Goes through all apps that handle VIEW intents and have a warmup service. Picks
     * the one chosen by the user if there is one, otherwise makes a best effort to return a
     * valid package name.
     *
     * This is <strong>not</strong> threadsafe.
     *
     * @param context {@link Context} to use for accessing {@link PackageManager}.
     * @return The package name recommended to use for connecting to custom tabs related components.
     */
    public static String getPackageNameToUse(Context context) {
        if (CompatHelper.getSdkVersion() < MIN_SDK) {
            return null;
        }
        if (sPackageNameToUse != null) return sPackageNameToUse;

        PackageManager pm = context.getPackageManager();
        // Get default VIEW intent handler.
        Intent activityIntent = new Intent(Intent.ACTION_VIEW, Uri.parse("http://www.example.com"));
        ResolveInfo defaultViewHandlerInfo = pm.resolveActivity(activityIntent, 0);
        String defaultViewHandlerPackageName = null;
        if (defaultViewHandlerInfo != null) {
            defaultViewHandlerPackageName = defaultViewHandlerInfo.activityInfo.packageName;
        }

        // Get all apps that can handle VIEW intents.
        List<ResolveInfo> resolvedActivityList = pm.queryIntentActivities(activityIntent, 0);
        List<String> packagesSupportingCustomTabs = new ArrayList<>();
        for (ResolveInfo info : resolvedActivityList) {
            Intent serviceIntent = new Intent();
            serviceIntent.setAction(CustomTabsService.ACTION_CUSTOM_TABS_CONNECTION);
            serviceIntent.setPackage(info.activityInfo.packageName);
            if (pm.resolveService(serviceIntent, 0) != null) {
                packagesSupportingCustomTabs.add(info.activityInfo.packageName);
            }
        }

        // Now packagesSupportingCustomTabs contains all apps that can handle both VIEW intents
        // and service calls.
        if (packagesSupportingCustomTabs.isEmpty()) {
            sPackageNameToUse = null;
        } else if (packagesSupportingCustomTabs.size() == 1) {
            sPackageNameToUse = packagesSupportingCustomTabs.get(0);
        } else if (!TextUtils.isEmpty(defaultViewHandlerPackageName)
                && !hasSpecializedHandlerIntents(context, activityIntent)
                && packagesSupportingCustomTabs.contains(defaultViewHandlerPackageName)) {
            sPackageNameToUse = defaultViewHandlerPackageName;
        } else if (packagesSupportingCustomTabs.contains(STABLE_PACKAGE)) {
            sPackageNameToUse = STABLE_PACKAGE;
        } else if (packagesSupportingCustomTabs.contains(BETA_PACKAGE)) {
            sPackageNameToUse = BETA_PACKAGE;
        } else if (packagesSupportingCustomTabs.contains(DEV_PACKAGE)) {
            sPackageNameToUse = DEV_PACKAGE;
        } else if (packagesSupportingCustomTabs.contains(LOCAL_PACKAGE)) {
            sPackageNameToUse = LOCAL_PACKAGE;
        }
        return sPackageNameToUse;
    }

    /**
     * Used to check whether there is a specialized handler for a given intent.
     * @param intent The intent to check with.
     * @return Whether there is a specialized handler for the given intent.
     */
    private static boolean hasSpecializedHandlerIntents(Context context, Intent intent) {
        try {
            PackageManager pm = context.getPackageManager();
            List<ResolveInfo> handlers = pm.queryIntentActivities(
                    intent,
                    PackageManager.GET_RESOLVED_FILTER);
            if (handlers == null || handlers.size() == 0) {
                return false;
            }
            for (ResolveInfo resolveInfo : handlers) {
                IntentFilter filter = resolveInfo.filter;
                if (filter == null) continue;
                if (filter.countDataAuthorities() == 0 || filter.countDataPaths() == 0) continue;
                if (resolveInfo.activityInfo == null) continue;
                return true;
            }
        } catch (RuntimeException e) {
            Log.e(TAG, "Runtime exception while getting specialized handlers");
        }
        return false;
    }

    /**
     * @return All possible chrome package names that provide custom tabs feature.
     */
    public static String[] getPackages() {
        return new String[]{"", STABLE_PACKAGE, BETA_PACKAGE, DEV_PACKAGE, LOCAL_PACKAGE};
    }


}
// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.ichi2.compat.customtabs;

import android.app.Service;
import android.content.Intent;
import android.os.Binder;
import android.os.IBinder;

/**
 * Empty service used by the custom tab to bind to, raising the application's importance.
 */
public class KeepAliveService extends Service {
    private static final Binder sBinder = new Binder();

    @Override
    public IBinder onBind(Intent intent) {
        return sBinder;
    }
}package com.ichi2.compat.customtabs;
// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


import android.content.ComponentName;
import android.support.customtabs.CustomTabsClient;
import android.support.customtabs.CustomTabsServiceConnection;

import java.lang.ref.WeakReference;

/**
 * Implementation for the CustomTabsServiceConnection that avoids leaking the
 * ServiceConnectionCallback
 */
public class ServiceConnection extends CustomTabsServiceConnection {
    // A weak reference to the ServiceConnectionCallback to avoid leaking it.
    private WeakReference<ServiceConnectionCallback> mConnectionCallback;

    public ServiceConnection(ServiceConnectionCallback connectionCallback) {
        mConnectionCallback = new WeakReference<>(connectionCallback);
    }

    @Override
    public void onCustomTabsServiceConnected(ComponentName name, CustomTabsClient client) {
        ServiceConnectionCallback connectionCallback = mConnectionCallback.get();
        if (connectionCallback != null) connectionCallback.onServiceConnected(client);
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
        ServiceConnectionCallback connectionCallback = mConnectionCallback.get();
        if (connectionCallback != null) connectionCallback.onServiceDisconnected();
    }
}
package com.ichi2.compat.customtabs;
// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import android.support.customtabs.CustomTabsClient;

/**
 * Callback for events when connecting and disconnecting from Custom Tabs Service.
 */
public interface ServiceConnectionCallback {
    /**
     * Called when the service is connected.
     * @param client a CustomTabsClient
     */
    void onServiceConnected(CustomTabsClient client);

    /**
     * Called when the service is disconnected.
     */
    void onServiceDisconnected();
}/****************************************************************************************
 * Copyright (c) 2014 Timothy Rae   <perceptualchaos2@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

import android.content.Context;

import com.ichi2.compat.CompatHelper;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import timber.log.Timber;

class Exporter {
    Collection mCol;
    Long mDid;


    public Exporter(Collection col) {
        mCol = col;
        mDid = null;
    }


    public Exporter(Collection col, Long did) {
        mCol = col;
        mDid = did;
    }
}



class AnkiExporter extends Exporter {
    boolean mIncludeSched;
    boolean mIncludeMedia;
    Collection mSrc;
    String mMediaDir;
    int mCount;
    ArrayList<String> mMediaFiles = new ArrayList<>();


    public AnkiExporter(Collection col) {
        super(col);
        mIncludeSched = false;
        mIncludeMedia = true;
    }


    /**
     * Export source database into new destination database Note: The following python syntax isn't supported in
     * Android: for row in mSrc.db.execute("select * from cards where id in "+ids2str(cids)): therefore we use a
     * different method for copying tables
     * 
     * @param path String path to destination database
     * @throws JSONException
     * @throws IOException
     */

    public void exportInto(String path, Context context) throws JSONException, IOException {
        // create a new collection at the target
        new File(path).delete();
        Collection dst = Storage.Collection(context, path);
        mSrc = mCol;
        // find cards
        Long[] cids;
        if (mDid == null) {
            cids = Utils.list2ObjectArray(mSrc.getDb().queryColumn(Long.class, "SELECT id FROM cards", 0));
        } else {
            cids = mSrc.getDecks().cids(mDid, true);
        }
        // attach dst to src so we can copy data between them. This isn't done in original libanki as Python more
        // flexible
        dst.close();
        Timber.d("Attach DB");
        mSrc.getDb().getDatabase().execSQL("ATTACH '" + path + "' AS DST_DB");
        // copy cards, noting used nids (as unique set)
        Timber.d("Copy cards");
        mSrc.getDb().getDatabase()
                .execSQL("INSERT INTO DST_DB.cards select * from cards where id in " + Utils.ids2str(cids));
        Set<Long> nids = new HashSet<>(mSrc.getDb().queryColumn(Long.class,
                "select nid from cards where id in " + Utils.ids2str(cids), 0));
        // notes
        Timber.d("Copy notes");
        ArrayList<Long> uniqueNids = new ArrayList<>(nids);
        String strnids = Utils.ids2str(uniqueNids);
        mSrc.getDb().getDatabase().execSQL("INSERT INTO DST_DB.notes select * from notes where id in " + strnids);
        // remove system tags if not exporting scheduling info
        if (!mIncludeSched) {
            Timber.d("Stripping system tags from list");
            ArrayList<String> srcTags = mSrc.getDb().queryColumn(String.class,
                    "select tags from notes where id in " + strnids, 0);
            ArrayList<Object[]> args = new ArrayList<>(srcTags.size());
            Object [] arg = new Object[2];
            for (int row = 0; row < srcTags.size(); row++) {
                arg[0]=removeSystemTags(srcTags.get(row));
                arg[1]=uniqueNids.get(row);
                args.add(row, arg);
            }
            mSrc.getDb().executeMany("UPDATE DST_DB.notes set tags=? where id=?", args);
        }
        // models used by the notes
        Timber.d("Finding models used by notes");
        ArrayList<Long> mids = mSrc.getDb().queryColumn(Long.class,
                "select distinct mid from DST_DB.notes where id in " + strnids, 0);
        // card history and revlog
        if (mIncludeSched) {
            Timber.d("Copy history and revlog");
            mSrc.getDb().getDatabase()
                    .execSQL("insert into DST_DB.revlog select * from revlog where cid in " + Utils.ids2str(cids));
            // reopen collection to destination database (different from original python code)
            mSrc.getDb().getDatabase().execSQL("DETACH DST_DB");
            dst.reopen();
        } else {
            Timber.d("Detaching destination db and reopening");
            // first reopen collection to destination database (different from original python code)
            mSrc.getDb().getDatabase().execSQL("DETACH DST_DB");
            dst.reopen();
            // then need to reset card state
            Timber.d("Resetting cards");
            dst.getSched().resetCards(cids);
        }
        // models - start with zero
        Timber.d("Copy models");
        for (JSONObject m : mSrc.getModels().all()) {
            if (mids.contains(m.getLong("id"))) {
                dst.getModels().update(m);
            }
        }
        // decks
        Timber.d("Copy decks");
        ArrayList<Long> dids = new ArrayList<>();
        if (mDid != null) {
            dids.add(mDid);
            for (Long x : mSrc.getDecks().children(mDid).values()) {
                dids.add(x);
            }
        }
        JSONObject dconfs = new JSONObject();
        for (JSONObject d : mSrc.getDecks().all()) {
            if (d.getString("id").equals("1")) {
                continue;
            }
            if (mDid != null && !dids.contains(d.getLong("id"))) {
                continue;
            }
            if (d.getInt("dyn") != 1 && d.getLong("conf") != 1L) {
                if (mIncludeSched) {
                    dconfs.put(Long.toString(d.getLong("conf")), true);
                }
            }
            if (!mIncludeSched) {
                // scheduling not included, so reset deck settings to default
                d.put("conf", 1);
            }
            dst.getDecks().update(d);
        }
        // copy used deck confs
        Timber.d("Copy deck options");
        for (JSONObject dc : mSrc.getDecks().allConf()) {
            if (dconfs.has(dc.getString("id"))) {
                dst.getDecks().updateConf(dc);
            }
        }
        // find used media
        Timber.d("Find used media");
        JSONObject media = new JSONObject();
        mMediaDir = mSrc.getMedia().dir();
        if (mIncludeMedia) {
            ArrayList<Long> mid = mSrc.getDb().queryColumn(Long.class, "select mid from notes where id in " + strnids,
                    0);
            ArrayList<String> flds = mSrc.getDb().queryColumn(String.class,
                    "select flds from notes where id in " + strnids, 0);
            for (int idx = 0; idx < mid.size(); idx++) {
                for (String file : mSrc.getMedia().filesInStr(mid.get(idx), flds.get(idx))) {
                    media.put(file, true);
                }
            }
            if (mMediaDir != null) {
                for (File f : new File(mMediaDir).listFiles()) {
                    String fname = f.getName();
                    if (fname.startsWith("_")) {
                        // Loop through every model that will be exported, and check if it contains a reference to f
                        for (int idx = 0; idx < mid.size(); idx++) {
                            if (_modelHasMedia(mSrc.getModels().get(idx), fname)) {
                                media.put(fname, true);
                                break;
                            }
                        }
                    }
                }
            }
        }
        JSONArray keys = media.names();
        if (keys != null) {
            for (int i = 0; i < keys.length(); i++) {
                mMediaFiles.add(keys.getString(i));
            }
        }
        Timber.d("Cleanup");
        dst.setCrt(mSrc.getCrt());
        // todo: tags?
        mCount = dst.cardCount();
        dst.setMod();
        postExport();
        dst.close();
    }

    /**
     * Returns whether or not the specified model contains a reference to the given media file.
     * In order to ensure relatively fast operation we only check if the styling, front, back templates *contain* fname,
     * and thus must allow for occasional false positives.
     * @param model the model to scan
     * @param fname the name of the media file to check for
     * @return
     * @throws JSONException
     */
    private boolean _modelHasMedia(JSONObject model, String fname) throws JSONException {
        // Don't crash if the model is null
        if (model == null) {
            Timber.w("_modelHasMedia given null model");
            return true;
        }
        // First check the styling
        if (model.getString("css").contains(fname)) {
            return true;
        }
        // If not there then check the templates
        JSONArray tmpls = model.getJSONArray("tmpls");
        for (int idx = 0; idx < tmpls.length(); idx++) {
            JSONObject tmpl = tmpls.getJSONObject(idx);
            if (tmpl.getString("qfmt").contains(fname) || tmpl.getString("afmt").contains(fname)) {
                return true;
            }
        }
        return false;
    }


    /**
     * overwrite to apply customizations to the deck before it's closed, such as update the deck description
     */
    protected void postExport() {
    }


    private String removeSystemTags(String tags) {
        return mSrc.getTags().remFromStr("marked leech", tags);
    }


    public void setIncludeSched(boolean includeSched) {
        mIncludeSched = includeSched;
    }


    public void setIncludeMedia(boolean includeMedia) {
        mIncludeMedia = includeMedia;
    }


    public void setDid(Long did) {
        mDid = did;
    }
}



public final class AnkiPackageExporter extends AnkiExporter {

    public AnkiPackageExporter(Collection col) {
        super(col);
    }


    @Override
    public void exportInto(String path, Context context) throws IOException, JSONException {
        // open a zip file
        ZipFile z = new ZipFile(path);
        // if all decks and scheduling included, full export
        JSONObject media;
        if (mIncludeSched && mDid == null) {
            media = exportVerbatim(z);
        } else {
            // otherwise, filter
            media = exportFiltered(z, path, context);
        }
        // media map
        z.writeStr("media", Utils.jsonToString(media));
        z.close();
    }


    private JSONObject exportVerbatim(ZipFile z) throws IOException {
        // close our deck & write it into the zip file, and reopen
        mCount = mCol.cardCount();
        mCol.close();
        z.write(mCol.getPath(), "collection.anki2");
        mCol.reopen();
        // copy all media
        JSONObject media = new JSONObject();
        if (!mIncludeMedia) {
            return media;
        }
        File mdir = new File(mCol.getMedia().dir());
        if (mdir.exists() && mdir.isDirectory()) {
            File[] mediaFiles = mdir.listFiles();
            int c = 0;
            for (File f : mediaFiles) {
                z.write(f.getPath(), Integer.toString(c));
                try {
                    media.put(Integer.toString(c), f.getName());
                    c++;
                } catch (JSONException e) {
                    e.printStackTrace();
                }
            }
        }
        return media;
    }


    private JSONObject exportFiltered(ZipFile z, String path, Context context) throws IOException, JSONException {
        // export into the anki2 file
        String colfile = path.replace(".apkg", ".anki2");
        super.exportInto(colfile, context);
        z.write(colfile, "collection.anki2");
        // and media
        prepareMedia();
        JSONObject media = new JSONObject();
        File mdir = new File(mCol.getMedia().dir());
        if (mdir.exists() && mdir.isDirectory()) {
            int c = 0;
            for (String file : mMediaFiles) {
                File mpath = new File(mdir,file);
                if (mpath.exists()) {
                    z.write(mpath.getPath(), Integer.toString(c));
                }
                try {
                    media.put(Integer.toString(c), file);
                    c++;
                } catch (JSONException e) {
                    e.printStackTrace();
                }
            }
        }
        // tidy up intermediate files
        CompatHelper.getCompat().deleteDatabase(new File(colfile));
        CompatHelper.getCompat().deleteDatabase(new File(path.replace(".apkg", ".media.ad.db2")));
        String tempPath = path.replace(".apkg", ".media");
        File file = new File(tempPath);
        if (file.exists()) {
            String deleteCmd = "rm -r " + tempPath;
            Runtime runtime = Runtime.getRuntime();
            try {
                runtime.exec(deleteCmd);
            } catch (IOException e) {
            }
        }
        return media;
    }


    protected void prepareMedia() {
        // chance to move each file in self.mediaFiles into place before media
        // is zipped up
    }
}



/**
 * Wrapper around standard Python zip class used in this module for exporting to APKG
 * 
 * @author Tim
 */
class ZipFile {
    final int BUFFER_SIZE = 1024;
    private ZipOutputStream mZos;


    public ZipFile(String path) throws FileNotFoundException {
        mZos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(path)));
    }


    public void write(String path, String entry) throws IOException {
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(path), BUFFER_SIZE);
        ZipEntry ze = new ZipEntry(entry);
        writeEntry(bis, ze);
    }


    public void writeStr(String entry, String value) throws IOException {
        // TODO: Does this work with abnormal characters?
        InputStream is = new ByteArrayInputStream(value.getBytes());
        BufferedInputStream bis = new BufferedInputStream(is, BUFFER_SIZE);
        ZipEntry ze = new ZipEntry(entry);
        writeEntry(bis, ze);
    }


    private void writeEntry(BufferedInputStream bis, ZipEntry ze) throws IOException {
        byte[] buf = new byte[BUFFER_SIZE];
        mZos.putNextEntry(ze);
        int len;
        while ((len = bis.read(buf, 0, BUFFER_SIZE)) != -1) {
            mZos.write(buf, 0, len);
        }
        mZos.closeEntry();
        bis.close();
    }


    public void close() {
        try {
            mZos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
/****************************************************************************************
 * Copyright (c) 2009 Daniel Sv盲rd <daniel.svard@gmail.com>                             *
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2014 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

import android.content.ContentValues;
import android.database.Cursor;
import android.text.TextUtils;

import org.json.JSONException;
import org.json.JSONObject;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

/**
 A Card is the ultimate entity subject to review; it encapsulates the scheduling parameters (from which to derive
 the next interval), the note it is derived from (from which field data is retrieved), its own ownership (which deck it
 currently belongs to), and the retrieval of presentation elements (filled-in templates).
 
 Card presentation has two components: the question (front) side and the answer (back) side. The presentation of the
 card is derived from the template of the card's Card Type. The Card Type is a component of the Note Type (see Models)
 that this card is derived from.
 
 This class is responsible for:
 - Storing and retrieving database entries that map to Cards in the Collection
 - Providing the HTML representation of the Card's question and answer
 - Recording the results of review (answer chosen, time taken, etc)

 It does not:
 - Generate new cards (see Collection)
 - Store the templates or the style sheet (see Models)
 
 Type: 0=new, 1=learning, 2=due
 Queue: same as above, and:
        -1=suspended, -2=user buried, -3=sched buried
 Due is used differently for different queues.
 - new queue: note id or random int
 - rev queue: integer day
 - lrn queue: integer timestamp
 */
public class Card implements Cloneable {

    public static final int TYPE_NEW = 0;
    public static final int TYPE_LRN = 1;
    public static final int TYPE_REV = 2;
    public static final int QUEUE_SUSP = -1;
    public static final int QUEUE_USER_BRD = -2;
    public static final int QUEUE_SCHED_BRD = -3;

    private Collection mCol;
    private double mTimerStarted;

    // Not in LibAnki. Record time spent reviewing in order to restore when resuming.
    private double mElapsedTime;

    // BEGIN SQL table entries
    private long mId;
    private long mNid;
    private long mDid;
    private int mOrd;
    private long mMod;
    private int mUsn;
    private int mType;
    private int mQueue;
    private long mDue;
    private int mIvl;
    private int mFactor;
    private int mReps;
    private int mLapses;
    private int mLeft;
    private long mODue;
    private long mODid;
    private int mFlags;
    private String mData;
    // END SQL table entries

    private HashMap<String, String> mQA;
    private Note mNote;

    // Used by Sched to determine which queue to move the card to after answering.
    private boolean mWasNew;

    // Used by Sched to record the original interval in the revlog after answering.
    private int mLastIvl;


    public Card(Collection col) {
        this(col, null);
    }


    public Card(Collection col, Long id) {
        mCol = col;
        mTimerStarted = Double.NaN;
        mQA = null;
        mNote = null;
        if (id != null) {
            mId = id;
            load();
        } else {
            // to flush, set nid, ord, and due
            mId = Utils.timestampID(mCol.getDb(), "cards");
            mDid = 1;
            mType = 0;
            mQueue = 0;
            mIvl = 0;
            mFactor = 0;
            mReps = 0;
            mLapses = 0;
            mLeft = 0;
            mODue = 0;
            mODid = 0;
            mFlags = 0;
            mData = "";
        }
    }


    public void load() {
        Cursor cursor = null;
        try {
            cursor = mCol.getDb().getDatabase().rawQuery("SELECT * FROM cards WHERE id = " + mId, null);
            if (!cursor.moveToFirst()) {
                throw new RuntimeException(" No card with id " + mId);
            }
            mId = cursor.getLong(0);
            mNid = cursor.getLong(1);
            mDid = cursor.getLong(2);
            mOrd = cursor.getInt(3);
            mMod = cursor.getLong(4);
            mUsn = cursor.getInt(5);
            mType = cursor.getInt(6);
            mQueue = cursor.getInt(7);
            mDue = cursor.getInt(8);
            mIvl = cursor.getInt(9);
            mFactor = cursor.getInt(10);
            mReps = cursor.getInt(11);
            mLapses = cursor.getInt(12);
            mLeft = cursor.getInt(13);
            mODue = cursor.getLong(14);
            mODid = cursor.getLong(15);
            mFlags = cursor.getInt(16);
            mData = cursor.getString(17);
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        mQA = null;
        mNote = null;
    }



    public void flush() {
        flush(true);
    }

    public void flush(boolean changeModUsn) {
        if (changeModUsn) {
            mMod = Utils.intNow();
            mUsn = mCol.usn();
        }
        // bug check
        if ((mQueue == 2 && mODue != 0) && !mCol.getDecks().isDyn(mDid)) {
            // TODO: runHook("odueInvalid");
        }
        assert (mDue < Long.valueOf("4294967296"));
        mCol.getDb().execute(
                "insert or replace into cards values " +
                "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                new Object[]{
                mId,
                mNid,
                mDid,
                mOrd,
                mMod,
                mUsn,
                mType,
                mQueue,
                mDue,
                mIvl,
                mFactor,
                mReps,
                mLapses,
                mLeft,
                mODue,
                mODid,
                mFlags,
                mData
        });
        mCol.log(this);
    }


    public void flushSched() {
        mMod = Utils.intNow();
        mUsn = mCol.usn();
        // bug check
        if ((mQueue == 2 && mODue != 0) && !mCol.getDecks().isDyn(mDid)) {
            // TODO: runHook("odueInvalid");
        }
        assert (mDue < Long.valueOf("4294967296"));

        ContentValues values = new ContentValues();
        values.put("mod", mMod);
        values.put("usn", mUsn);
        values.put("type", mType);
        values.put("queue", mQueue);
        values.put("due", mDue);
        values.put("ivl", mIvl);
        values.put("factor", mFactor);
        values.put("reps", mReps);
        values.put("lapses", mLapses);
        values.put("left", mLeft);
        values.put("odue", mODue);
        values.put("odid", mODid);
        values.put("did", mDid);
        // TODO: The update DB call sets mod=true. Verify if this is intended.
        mCol.getDb().update("cards", values, "id = " + mId, null);
        mCol.log(this);
    }


    public String q() {
        return q(false);
    }


    public String q(boolean reload) {
        return q(reload, false);
    }


    public String q(boolean reload, boolean browser) {
        return css() + _getQA(reload, browser).get("q");
    }


    public String a() {
        return css() + _getQA().get("a");
    }


    public String css() {
        try {
            return String.format(Locale.US, "<style>%s</style>", model().get("css"));
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public HashMap<String, String> _getQA() {
        return _getQA(false);
    }


    public HashMap<String, String> _getQA(boolean reload) {
        return _getQA(reload, false);
    }


    public HashMap<String, String> _getQA(boolean reload, boolean browser) {
        if (mQA == null || reload) {
            Note f = note(reload);
            JSONObject m = model();
            JSONObject t = template();
            Object[] data;
            try {
                data = new Object[] { mId, f.getId(), m.getLong("id"), mODid != 0L ? mODid : mDid, mOrd,
                        f.stringTags(), f.joinedFields() };
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }

            if (browser) {
                try {
                    String bqfmt = t.getString("bqfmt");
                    String bafmt = t.getString("bafmt");
                    mQA = mCol._renderQA(data, bqfmt, bafmt);
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
            } else {
                mQA = mCol._renderQA(data);
            }
        }
        return mQA;
    }


    public Note note() {
        return note(false);
    }


    public Note note(boolean reload) {
        if (mNote == null || reload) {
            mNote = mCol.getNote(mNid);
        }
        return mNote;
    }


    public JSONObject model() {
        return mCol.getModels().get(note().getMid());
    }


    public JSONObject template() {
        JSONObject m = model();
        try {
            if (m.getInt("type") == Consts.MODEL_STD) {
                return m.getJSONArray("tmpls").getJSONObject(mOrd);
            } else {
                return model().getJSONArray("tmpls").getJSONObject(0);
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public void startTimer() {
        mTimerStarted = Utils.now();
    }


    /**
     * Time limit for answering in milliseconds.
     */
    public int timeLimit() {
        JSONObject conf = mCol.getDecks().confForDid(mODid == 0 ? mDid : mODid);
        try {
            return conf.getInt("maxTaken") * 1000;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public boolean shouldShowTimer() {
        try {
            return mCol.getDecks().confForDid(mODid == 0 ? mDid : mODid).getInt("timer") != 0;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /*
     * Time taken to answer card, in integer MS.
     */
    public int timeTaken() {
        int total = (int) ((Utils.now() - mTimerStarted) * 1000);
        return Math.min(total, timeLimit());
    }


    public boolean isEmpty() {
        ArrayList<Integer> ords = mCol.getModels().availOrds(model(), Utils.joinFields(note().getFields()));
        return !ords.contains(mOrd);
    }


    /*
     * ***********************************************************
     * The methods below are not in LibAnki.
     * ***********************************************************
     */


    public String qSimple() {
        return _getQA(false).get("q");
    }


    /*
     * Returns the answer with anything before the <hr id=answer> tag removed
     */
    public String getPureAnswer() {
        String s = _getQA(false).get("a");
        String target = "<hr id=answer>";
        int pos = s.indexOf(target);
        if (pos == -1) {
            return s;
        }
        return s.substring(pos + target.length()).trim();
    }

    /**
     * Save the currently elapsed reviewing time so it can be restored on resume.
     *
     * Use this method whenever a review session (activity) has been paused. Use the resumeTimer()
     * method when the session resumes to start counting review time again.
     */
    public void stopTimer() {
        mElapsedTime = Utils.now() - mTimerStarted;
    }


    /**
     * Resume the timer that counts the time spent reviewing this card.
     *
     * Unlike the desktop client, AnkiDroid must pause and resume the process in the middle of
     * reviewing. This method is required to keep track of the actual amount of time spent in
     * the reviewer and *must* be called on resume before any calls to timeTaken() take place
     * or the result of timeTaken() will be wrong.
     */
    public void resumeTimer() {
        mTimerStarted = Utils.now() - mElapsedTime;
    }

    public void setTimerStarted(double timeStarted){ mTimerStarted = timeStarted; }

    public long getId() {
        return mId;
    }


    public void setMod(long mod) {
        mMod = mod;
    }


    public void setUsn(int usn) {
        mUsn = usn;
    }


    public long getNid() {
        return mNid;
    }


    public int getType() {
        return mType;
    }


    public void setType(int type) {
        mType = type;
    }


    public void setLeft(int left) {
        mLeft = left;
    }


    public int getLeft() {
        return mLeft;
    }


    public int getQueue() {
        return mQueue;
    }


    public void setQueue(int queue) {
        mQueue = queue;
    }


    public long getODue() {
        return mODue;
    }


    public void setODid(long odid) {
        mODid = odid;
    }


    public long getODid() {
        return mODid;
    }


    public void setODue(long odue) {
        mODue = odue;
    }


    public long getDue() {
        return mDue;
    }


    public void setDue(long due) {
        mDue = due;
    }


    public int getIvl() {
        return mIvl;
    }


    public void setIvl(int ivl) {
        mIvl = ivl;
    }


    public int getFactor() {
        return mFactor;
    }


    public void setFactor(int factor) {
        mFactor = factor;
    }


    public int getReps() {
        return mReps;
    }


    public int setReps(int reps) {
        return mReps = reps;
    }


    public int getLapses() {
        return mLapses;
    }


    public void setLapses(int lapses) {
        mLapses = lapses;
    }


    public void setNid(long nid) {
        mNid = nid;
    }


    public void setOrd(int ord) {
        mOrd = ord;
    }


    public int getOrd() {
        return mOrd;
    }


    public void setDid(long did) {
        mDid = did;
    }


    public long getDid() {
        return mDid;
    }


    public boolean getWasNew() {
        return mWasNew;
    }


    public void setWasNew(boolean wasNew) {
        mWasNew = wasNew;
    }


    public int getLastIvl() {
        return mLastIvl;
    }


    public void setLastIvl(int ivl) {
        mLastIvl = ivl;
    }


    // Needed for tests
    public Collection getCol() {
        return mCol;
    }


    // Needed for tests
    public void setCol(Collection col) {
        mCol = col;
    }


    public boolean showTimer() {
        return mCol.getDecks().confForDid(mODid == 0 ? mDid : mODid).optInt("timer", 1) != 0;
    }


    public Card clone() {
        try {
            return (Card)super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }


    // A list of class members to skip in the toString() representation
    public static final Set<String> SKIP_PRINT = new HashSet<>(Arrays.asList("SKIP_PRINT", "$assertionsDisabled", "TYPE_LRN",
            "TYPE_NEW", "TYPE_REV", "mNote", "mQA", "mCol", "mTimerStarted", "mTimerStopped"));

    public String toString() {
        List<String> members = new ArrayList<>();
        for (Field f : this.getClass().getDeclaredFields()) {
            try {
                // skip non-useful elements
                if (SKIP_PRINT.contains(f.getName())) {
                    continue;
                }
                members.add(String.format("'%s': %s", f.getName(), f.get(this)));
            } catch (IllegalAccessException | IllegalArgumentException e) {
                members.add(String.format("'%s': %s", f.getName(), "N/A"));
            }
        }
        return TextUtils.join(",  ", members);
    }
}
package com.ichi2.libanki;

import android.content.Context;
import android.content.res.Resources;

import com.ichi2.anki.R;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;

public class CardStats {

    public static String report(Context context, Card c, Collection col) {
        Calendar cal = Calendar.getInstance();
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd");

        Resources res = context.getResources();
        StringBuilder builder = new StringBuilder();
        builder.append("<html><body ><table><colgroup><col span=\"1\" style=\"width: 40%;\"></col><col span=\"1\" style=\"width: 60%;\"></col></colgroup><tr><td valign=\"top\">");
        builder.append(res.getString(R.string.card_details_question));
        builder.append("</td><td>");
        builder.append(c._getQA(false).get("q"));
        builder.append("</td></tr><tr><td valign=\"top\">");
        builder.append(res.getString(R.string.card_details_answer));
        builder.append("</td><td>");
        builder.append(Utils.stripHTML(c._getQA(false).get("a")));
        builder.append("</td></tr><tr><td valign=\"top\">");

        long next = 0;
        if (c.getType() == 1 || c.getType() == 2) {
            if (c.getODid() != 0 || c.getQueue() < 0) {
                next = 0;
            } else {
                if (c.getQueue() == 2 || c.getQueue() == 3) {
                    next = Utils.intNow(1000) + ((c.getDue() - col.getSched().getToday()) * 86400000);
                } else {
                    next = c.getDue();
                }
            }
            if (next != 0) {
                cal.setTimeInMillis(next);
                builder.append(res.getString(R.string.card_details_due));
                builder.append("</td><td>");
                builder.append(df.format(cal.getTime()));
                builder.append("</td></tr><tr><td valign=\"top\">");
            }

        }

//      builder.append("</td></tr><tr><td>");

////        builder.append(res.getString(R.string.card_details_interval));
//      builder.append("</td><td>");
////        if (mInterval == 0) {
////            builder.append("-");
////        } else {
////            builder.append(Utils.getReadableInterval(context, mInterval));
////        }


//      builder.append("</td></tr><tr><td>");
////        builder.append(res.getString(R.string.card_details_ease));
//      builder.append("</td><td>");
//      double ease = Math.round(mFactor * 100);
//      builder.append(ease / 100);

//      builder.append("</td></tr><tr><td>");
////        builder.append(res.getString(R.string.card_details_average_time));
//      builder.append("</td><td>");
////        if (mYesCount + mNoCount == 0) {
////            builder.append("-");
////        } else {
////            builder.append(Utils.doubleToTime(mAverageTime));
////        }

//      builder.append("</td></tr><tr><td>");
////        builder.append(res.getString(R.string.card_details_total_time));
//      builder.append("</td><td>");
////        builder.append(Utils.doubleToTime(mReviewTime));

//      builder.append("</td></tr><tr><td>");
////        builder.append(res.getString(R.string.card_details_yes_count));
//      builder.append("</td><td>");
////        builder.append(mYesCount);

//      builder.append("</td></tr><tr><td>");
////        builder.append(res.getString(R.string.card_details_no_count));
//      builder.append("</td><td>");
////        builder.append(mNoCount);

//      builder.append("</td></tr><tr><td>");
////        builder.append(res.getString(R.string.card_details_added));
//      builder.append("</td><td>");
////        builder.append(DateFormat.getDateFormat(context).format(
////                (long) (mCreated - mDeck.getUtcOffset()) * 1000l));

//      builder.append("</td></tr><tr><td>");
////        builder.append(res.getString(R.string.card_details_changed));
//      builder.append("</td><td>");
////        builder.append(DateFormat.getDateFormat(context).format(
////                (long) (mModified - mDeck.getUtcOffset()) * 1000l));

//      builder.append("</td></tr><tr><td>");
////        builder.append(res.getString(R.string.card_details_tags));
//      builder.append("</td><td>");
////        String tags = Arrays.toString(mDeck
////                .allUserTags("WHERE id = " + mFactId));
////        builder.append(tags.substring(1, tags.length() - 1));

//      builder.append("</td></tr><tr><td>");
////        builder.append(res.getString(R.string.card_details_model));
//      builder.append("</td><td>");
////        Model model = Model.getModel(mDeck, mCardModelId, false);
////        builder.append(model.getName());

//      builder.append("</td></tr><tr><td>");
////        builder.append(res.getString(R.string.card_details_card_model));
//      builder.append("</td><td>");
////        builder.append(model.getCardModel(mCardModelId).getName());
        builder.append("</table></html></body>");
        return builder.toString();
    }

}
/****************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General private License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General private License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General private License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

import android.content.ContentValues;
import android.content.Context;
import android.content.res.Resources;
import android.database.Cursor;
import android.text.TextUtils;
import android.util.Pair;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.R;
import com.ichi2.anki.UIUtils;
import com.ichi2.anki.exception.ConfirmModSchemaException;
import com.ichi2.compat.CompatHelper;
import com.ichi2.libanki.hooks.Hooks;
import com.ichi2.libanki.template.Template;
import com.ichi2.utils.VersionUtils;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Random;
import java.util.regex.Pattern;

import io.requery.android.database.sqlite.SQLiteDatabase;
import timber.log.Timber;

// Anki maintains a cache of used tags so it can quickly present a list of tags
// for autocomplete and in the browser. For efficiency, deletions are not
// tracked, so unused tags can only be removed from the list with a DB check.
//
// This module manages the tag cache and tags for notes.

public class Collection {

    private Context mContext;

    private DB mDb;
    private boolean mServer;
    private double mLastSave;
    private Media mMedia;
    private Decks mDecks;
    private Models mModels;
    private Tags mTags;

    private Sched mSched;

    private double mStartTime;
    private int mStartReps;

    // BEGIN: SQL table columns
    private long mCrt;
    private long mMod;
    private long mScm;
    private boolean mDty;
    private int mUsn;
    private long mLs;
    private JSONObject mConf;
    // END: SQL table columns

    private LinkedList<Object[]> mUndo;

    private String mPath;
    private boolean mDebugLog;
    private PrintWriter mLogHnd;

    private static final Pattern fClozePatternQ = Pattern.compile("\\{\\{(?!type:)(.*?)cloze:");
    private static final Pattern fClozePatternA = Pattern.compile("\\{\\{(.*?)cloze:");
    private static final Pattern fClozeTagStart = Pattern.compile("<%cloze:");

    // other options
    public static final String defaultConf = "{"
            +
            // review options
            "'activeDecks': [1], " + "'curDeck': 1, " + "'newSpread': " + Consts.NEW_CARDS_DISTRIBUTE + ", "
            + "'collapseTime': 1200, " + "'timeLim': 0, " + "'estTimes': True, " + "'dueCounts': True, "
            +
            // other config
            "'curModel': null, " + "'nextPos': 1, " + "'sortType': \"noteFld\", "
            + "'sortBackwards': False, 'addToCur': True }"; // add new to currently selected deck?

    public enum DismissType {
        REVIEW(R.string.undo_action_review),
        BURY_CARD(R.string.undo_action_bury_card),
        BURY_NOTE(R.string.undo_action_bury_note),
        SUSPEND_CARD(R.string.undo_action_suspend_card),
        SUSPEND_NOTE(R.string.undo_action_suspend_note),
        DELETE_NOTE(R.string.undo_action_delete);

        public int undoNameId;

        DismissType(int undoNameId) {
            this.undoNameId = undoNameId;
        }
    }

    private static final int UNDO_SIZE_MAX = 20;

    public Collection(Context context, DB db, String path) {
        this(context, db, path, false);
    }

    public Collection(Context context, DB db, String path, boolean server) {
        this(context, db, path, false, false);
    }

    public Collection(Context context, DB db, String path, boolean server, boolean log) {
        mContext = context;
        mDebugLog = log;
        mDb = db;
        mPath = path;
        _openLog();
        log(path, VersionUtils.getPkgVersionName());
        mServer = server;
        mLastSave = Utils.now();
        clearUndo();
        mMedia = new Media(this, server);
        mModels = new Models(this);
        mDecks = new Decks(this);
        mTags = new Tags(this);
        load();
        if (mCrt == 0) {
            mCrt = UIUtils.getDayStart() / 1000;
        }
        mStartReps = 0;
        mStartTime = 0;
        mSched = new Sched(this);
        if (!mConf.optBoolean("newBury", false)) {
            try {
                mConf.put("newBury", true);
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            setMod();
        }
    }


    public String name() {
        String n = (new File(mPath)).getName().replace(".anki2", "");
        // TODO:
        return n;
    }


    /**
     * DB-related *************************************************************** ********************************
     */

    public void load() {
        Cursor cursor = null;
        try {
            // Read in deck table columns
            cursor = mDb.getDatabase().rawQuery(
                    "SELECT crt, mod, scm, dty, usn, ls, " +
                    "conf, models, decks, dconf, tags FROM col", null);
            if (!cursor.moveToFirst()) {
                return;
            }
            mCrt = cursor.getLong(0);
            mMod = cursor.getLong(1);
            mScm = cursor.getLong(2);
            mDty = cursor.getInt(3) == 1; // No longer used
            mUsn = cursor.getInt(4);
            mLs = cursor.getLong(5);
            try {
                mConf = new JSONObject(cursor.getString(6));
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            mModels.load(cursor.getString(7));
            mDecks.load(cursor.getString(8), cursor.getString(9));
            mTags.load(cursor.getString(10));
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }


    /**
     * Mark DB modified. DB operations and the deck/tag/model managers do this automatically, so this is only necessary
     * if you modify properties of this object or the conf dict.
     */
    public void setMod() {
        mDb.setMod(true);
    }


    public void flush() {
        flush(0);
    }


    /**
     * Flush state to DB, updating mod time.
     */
    public void flush(long mod) {
        Timber.i("flush - Saving information to DB...");
        mMod = (mod == 0 ? Utils.intNow(1000) : mod);
        ContentValues values = new ContentValues();
        values.put("crt", mCrt);
        values.put("mod", mMod);
        values.put("scm", mScm);
        values.put("dty", mDty ? 1 : 0);
        values.put("usn", mUsn);
        values.put("ls", mLs);
        values.put("conf", Utils.jsonToString(mConf));
        mDb.update("col", values);
    }


    /**
     * Flush, commit DB, and take out another write lock.
     */
    public synchronized void save() {
        save(null, 0);
    }


    public synchronized void save(long mod) {
        save(null, mod);
    }


    public synchronized void save(String name, long mod) {
        // let the managers conditionally flush
        mModels.flush();
        mDecks.flush();
        mTags.flush();
        // and flush deck + bump mod if db has been changed
        if (mDb.getMod()) {
            flush(mod);
            mDb.commit();
            lock();
            mDb.setMod(false);
        }
        // undoing non review operation is handled differently in ankidroid
//        _markOp(name);
        mLastSave = Utils.now();
    }
    

    /** make sure we don't accidentally bump mod time */
    public void lock() {
        // make sure we don't accidentally bump mod time
        boolean mod = mDb.getMod();
        mDb.execute("UPDATE col SET mod=mod");
        mDb.setMod(mod);
    }


    /**
     * Disconnect from DB.
     */
    public synchronized void close() {
        close(true);
    }


    public synchronized void close(boolean save) {
        if (mDb != null) {
            try {
                SQLiteDatabase db = mDb.getDatabase();
                if (save) {
                    db.beginTransaction();
                    try {
                        save();
                        db.setTransactionSuccessful();
                    } finally {
                        db.endTransaction();
                    }
                } else {
                    if (db.inTransaction()) {
                        db.endTransaction();
                    }
                }
            } catch (RuntimeException e) {
                AnkiDroidApp.sendExceptionReport(e, "closeDB");
            }
            if (!mServer) {
                CompatHelper.getCompat().disableDatabaseWriteAheadLogging(mDb.getDatabase());
            }
            mDb.close();
            mDb = null;
            mMedia.close();
            _closeLog();
            Timber.i("Collection closed");
        }
    }


    public void reopen() {
        if (mDb == null) {
            mDb = new DB(mPath);
            mMedia.connect();
            _openLog();
        }
    }


    /** Note: not in libanki.
     * Mark schema modified to force a full sync, but with the confirmation checking function disabled
     * This is a convenience method which doesn't throw ConfirmModSchemaException
     */
    public void modSchemaNoCheck() {
        try {
            modSchema(false);
        } catch (ConfirmModSchemaException e) {
            // This will never be reached as we disable confirmation via the "false" argument
            throw new RuntimeException(e);
        }
    }

    /** Mark schema modified to force a full sync.
     * ConfirmModSchemaException will be thrown if the user needs to be prompted to confirm the action.
     * If the user chooses to confirm then modSchema(false) should be called, after which the exception can
     * be safely ignored, and the outer code called again.
     *
     * @throws ConfirmModSchemaException */
    public void modSchema() throws ConfirmModSchemaException {
        modSchema(true);
    }

    /** Mark schema modified to force a full sync.
     * If check==true and the schema has not already been marked modified then ConfirmModSchemaException will be thrown.
     * If the user chooses to confirm then modSchema(false) should be called, after which the exception can
     * be safely ignored, and the outer code called again.
     *
     * @param check
     * @throws ConfirmModSchemaException
     */
    public void modSchema(boolean check) throws ConfirmModSchemaException {
        if (!schemaChanged()) {
            if (check) {
                /* In Android we can't show a dialog which blocks the main UI thread
                 Therefore we can't wait for the user to confirm if they want to do
                 a full sync here, and we instead throw an exception asking the outer
                 code to handle the user's choice */
                throw new ConfirmModSchemaException();
            }
        }
        mScm = Utils.intNow(1000);
        setMod();
    }


    /** True if schema changed since last sync. */
    public boolean schemaChanged() {
        return mScm > mLs;
    }


    public int usn() {
        if (mServer) {
            return mUsn;
        } else {
            return -1;
        }
    }


    /** called before a full upload */
    public void beforeUpload() {
        String[] tables = new String[] { "notes", "cards", "revlog" };
        for (String t : tables) {
            mDb.execute("UPDATE " + t + " SET usn=0 WHERE usn=-1");
        }
        // we can save space by removing the log of deletions
        mDb.execute("delete from graves");
        mUsn += 1;
        mModels.beforeUpload();
        mTags.beforeUpload();
        mDecks.beforeUpload();
        modSchemaNoCheck();
        mLs = mScm;
        // ensure db is compacted before upload
        mDb.execute("vacuum");
        mDb.execute("analyze");
        close();
    }


    /**
     * Object creation helpers **************************************************
     * *********************************************
     */

    public Card getCard(long id) {
        return new Card(this, id);
    }


    public Note getNote(long id) {
        return new Note(this, id);
    }


    /**
     * Utils ******************************************************************** ***************************
     */

    public int nextID(String type) {
        type = "next" + Character.toUpperCase(type.charAt(0)) + type.substring(1);
        int id;
        try {
            id = mConf.getInt(type);
        } catch (JSONException e) {
            id = 1;
        }
        try {
            mConf.put(type, id + 1);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return id;
    }


    /**
     * Rebuild the queue and reload data after DB modified.
     */
    public void reset() {
        mSched.reset();
    }


    /**
     * Deletion logging ********************************************************* **************************************
     */

    public void _logRem(long[] ids, int type) {
        for (long id : ids) {
            ContentValues values = new ContentValues();
            values.put("usn", usn());
            values.put("oid", id);
            values.put("type", type);
            mDb.insert("graves", null, values);
        }
    }


    /**
     * Notes ******************************************************************** ***************************
     */

    public int noteCount() {
        return mDb.queryScalar("SELECT count() FROM notes");
    }

    /**
     * Return a new note with the default model from the deck
     * @return The new note
     */
    public Note newNote() {
        return newNote(true);
    }

    /**
     * Return a new note with the model derived from the deck or the configuration
     * @param forDeck When true it uses the model specified in the deck (mid), otherwise it uses the model specified in
     *                the configuration (curModel)
     * @return The new note
     */
    public Note newNote(boolean forDeck) {
        return newNote(mModels.current(forDeck));
    }

    /**
     * Return a new note with a specific model
     * @param m The model to use for the new note
     * @return The new note
     */
    public Note newNote(JSONObject m) {
        return new Note(this, m);
    }


    /**
     * Add a note to the collection. Return number of new cards.
     */
    public int addNote(Note note) {
        // check we have card models available, then save
        ArrayList<JSONObject> cms = findTemplates(note);
        if (cms.size() == 0) {
            return 0;
        }
        note.flush();
        // deck conf governs which of these are used
        int due = nextID("pos");
        // add cards
        int ncards = 0;
        for (JSONObject template : cms) {
            _newCard(note, template, due);
            ncards += 1;
        }
        return ncards;
    }


    public void remNotes(long[] ids) {
        ArrayList<Long> list = mDb
                .queryColumn(Long.class, "SELECT id FROM cards WHERE nid IN " + Utils.ids2str(ids), 0);
        long[] cids = new long[list.size()];
        int i = 0;
        for (long l : list) {
            cids[i++] = l;
        }
        remCards(cids);
    }


    /**
     * Bulk delete facts by ID. Don't call this directly.
     */
    public void _remNotes(long[] ids) {
        if (ids.length == 0) {
            return;
        }
        String strids = Utils.ids2str(ids);
        // we need to log these independently of cards, as one side may have
        // more card templates
        _logRem(ids, Consts.REM_NOTE);
        mDb.execute("DELETE FROM notes WHERE id IN " + strids);
    }


    /**
     * Card creation ************************************************************ ***********************************
     */

    /**
     * @return (active), non-empty templates.
     */
    public ArrayList<JSONObject> findTemplates(Note note) {
        JSONObject model = note.model();
        ArrayList<Integer> avail = mModels.availOrds(model, Utils.joinFields(note.getFields()));
        return _tmplsFromOrds(model, avail);
    }


    private ArrayList<JSONObject> _tmplsFromOrds(JSONObject model, ArrayList<Integer> avail) {
        ArrayList<JSONObject> ok = new ArrayList<>();
        JSONArray tmpls;
        try {
            if (model.getInt("type") == Consts.MODEL_STD) {
                tmpls = model.getJSONArray("tmpls");
                for (int i = 0; i < tmpls.length(); i++) {
                    JSONObject t = tmpls.getJSONObject(i);
                    if (avail.contains(t.getInt("ord"))) {
                        ok.add(t);
                    }
                }
            } else {
                // cloze - generate temporary templates from first
                for (int ord : avail) {
                    JSONObject t = new JSONObject(model.getJSONArray("tmpls").getString(0));
                    t.put("ord", ord);
                    ok.add(t);
                }
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return ok;
    }


    /**
     * Generate cards for non-empty templates, return ids to remove.
     */
	public ArrayList<Long> genCards(List<Long> nids) {
	    return genCards(Utils.arrayList2array(nids));
	}
    public ArrayList<Long> genCards(long[] nids) {
        // build map of (nid,ord) so we don't create dupes
        String snids = Utils.ids2str(nids);
        HashMap<Long, HashMap<Integer, Long>> have = new HashMap<>();
        HashMap<Long, Long> dids = new HashMap<>();
        Cursor cur = null;
        try {
            cur = mDb.getDatabase().rawQuery("select id, nid, ord, did, odid from cards where nid in " + snids, null);
            while (cur.moveToNext()) {
                long nid = cur.getLong(1);
                long did = cur.getLong(3);
                long odid = cur.getLong(4);

                // existing cards
                if (!have.containsKey(nid)) {
                    have.put(nid, new HashMap<Integer, Long>());
                }
                have.get(nid).put(cur.getInt(2), cur.getLong(0));
                // if in a filtered deck, add new cards to original deck
                if (odid != 0) {
                    did = odid;
                }
                // and their dids
                if (dids.containsKey(nid)) {
                    if (dids.get(nid) != 0 && dids.get(nid) != did) {
                        // cards are in two or more different decks; revert to model default
                        dids.put(nid, 0L);
                    }
                } else {
                    // first card or multiple cards in same deck
                    dids.put(nid, did);
                }
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        // build cards for each note
        ArrayList<Object[]> data = new ArrayList<>();
        long ts = Utils.maxID(mDb);
        long now = Utils.intNow();
        ArrayList<Long> rem = new ArrayList<>();
        int usn = usn();
        cur = null;
        try {
            cur = mDb.getDatabase().rawQuery("SELECT id, mid, flds FROM notes WHERE id IN " + snids, null);
            while (cur.moveToNext()) {
                JSONObject model = mModels.get(cur.getLong(1));
                ArrayList<Integer> avail = mModels.availOrds(model, cur.getString(2));
                long nid = cur.getLong(0);
                long did = dids.get(nid);
                if (did == 0) {
                    did = model.getLong("did");
                }
                // add any missing cards
                for (JSONObject t : _tmplsFromOrds(model, avail)) {
                    int tord = t.getInt("ord");
                    boolean doHave = have.containsKey(nid) && have.get(nid).containsKey(tord);
                    if (!doHave) {
                        // check deck is not a cram deck
                        long ndid;
                        try {
                            ndid = t.getLong("did");
                            if (ndid != 0) {
                                did = ndid;
                            }
                        } catch (JSONException e) {
                            // do nothing
                        }
                        if (getDecks().isDyn(did)) {
                            did = 1;
                        }
                        // if the deck doesn't exist, use default instead
                        did = mDecks.get(did).getLong("id");
                        // we'd like to use the same due# as sibling cards, but we can't retrieve that quickly, so we
                        // give it a new id instead
                        data.add(new Object[] { ts, nid, did, tord, now, usn, nextID("pos") });
                        ts += 1;
                    }
                }
                // note any cards that need removing
                if (have.containsKey(nid)) {
                    for (Map.Entry<Integer, Long> n : have.get(nid).entrySet()) {
                        if (!avail.contains(n.getKey())) {
                            rem.add(n.getValue());
                        }
                    }
                }
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        // bulk update
        mDb.executeMany("INSERT INTO cards VALUES (?,?,?,?,?,?,0,0,?,0,0,0,0,0,0,0,0,\"\")", data);
        return rem;
    }


	/**
	 * Return cards of a note, without saving them
	 * @param note The note whose cards are going to be previewed
     * @param type 0 - when previewing in add dialog, only non-empty
     *             1 - when previewing edit, only existing
     *             2 - when previewing in models dialog, all templates
     * @return list of cards
	 */
	public List<Card> previewCards(Note note, int type) {
	    ArrayList<JSONObject> cms = null;
	    if (type == 0) {
	        cms = findTemplates(note);
	    } else if (type == 1) {
	        cms = new ArrayList<>();
	        for (Card c : note.cards()) {
	            cms.add(c.template());
	        }
	    } else {
	        cms = new ArrayList<>();
	        try {
                JSONArray ja = note.model().getJSONArray("tmpls");
                for (int i = 0; i < ja.length(); ++i) {
                    cms.add(ja.getJSONObject(i));
                }
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
	    }
	    if (cms.isEmpty()) {
	        return new ArrayList<>();
	    }
	    List<Card> cards = new ArrayList<>();
	    for (JSONObject template : cms) {
	        cards.add(_newCard(note, template, 1, false));
	    }
	    return cards;
	}
    public List<Card> previewCards(Note note) {
        return previewCards(note, 0);
    }

    /**
     * Create a new card.
     */
    private Card _newCard(Note note, JSONObject template, int due) {
        return _newCard(note, template, due, true);
    }


    private Card _newCard(Note note, JSONObject template, int due, boolean flush) {
        Card card = new Card(this);
        card.setNid(note.getId());
        try {
            card.setOrd(template.getInt("ord"));
        } catch (JSONException e) {
            new RuntimeException(e);
        }
        // Use template did (deck override) if valid, otherwise model did
        long did = template.optLong("did", 0);
        if (did > 0 && mDecks.getDecks().containsKey(did)) {
            card.setDid(did);
        } else {
            card.setDid(note.model().optLong("did", 0));
        }
        try {
            // if invalid did, use default instead
            JSONObject deck = mDecks.get(card.getDid());
            if (deck.getInt("dyn") == 1) {
            	// must not be a filtered deck
            	card.setDid(1);
            } else {
                card.setDid(deck.getLong("id"));
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        card.setDue(_dueForDid(card.getDid(), due));
        if (flush) {
            card.flush();
        }
        return card;
    }


    public int _dueForDid(long did, int due) {
        JSONObject conf = mDecks.confForDid(did);
        // in order due?
        try {
            if (conf.getJSONObject("new").getInt("order") == Consts.NEW_CARDS_DUE) {
                return due;
            } else {
                // random mode; seed with note ts so all cards of this note get
                // the same random number
                Random r = new Random();
                r.setSeed(due);
                return r.nextInt(Math.max(due, 1000) - 1) + 1;
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Cards ******************************************************************** ***************************
     */

    public boolean isEmpty() {
        return mDb.queryScalar("SELECT 1 FROM cards LIMIT 1") == 0;
    }


    public int cardCount() {
        return mDb.queryScalar("SELECT count() FROM cards");
    }


    // NOT IN LIBANKI //
    public int cardCount(Long[] ls) {
        return mDb.queryScalar("SELECT count() FROM cards WHERE did IN " + Utils.ids2str(ls));
    }


    /**
     * Bulk delete cards by ID.
     */
    public void remCards(long[] ids) {
    	remCards(ids, true);
    }
    public void remCards(long[] ids, boolean notes) {
        if (ids.length == 0) {
            return;
        }
        String sids = Utils.ids2str(ids);
        long[] nids = Utils
                .arrayList2array(mDb.queryColumn(Long.class, "SELECT nid FROM cards WHERE id IN " + sids, 0));
        // remove cards
        _logRem(ids, Consts.REM_CARD);
        mDb.execute("DELETE FROM cards WHERE id IN " + sids);
        // then notes
        if (!notes) {
        	return;
        }
        nids = Utils
                .arrayList2array(mDb.queryColumn(Long.class, "SELECT id FROM notes WHERE id IN " + Utils.ids2str(nids)
                        + " AND id NOT IN (SELECT nid FROM cards)", 0));
        _remNotes(nids);
    }


    public List<Long> emptyCids() {
        List<Long> rem = new ArrayList<>();
        for (JSONObject m : getModels().all()) {
            rem.addAll(genCards(getModels().nids(m)));
        }
        return rem;
    }


    public String emptyCardReport(List<Long> cids) {
        StringBuilder rep = new StringBuilder();
        Cursor cur = null;
        try {
            cur = mDb.getDatabase().rawQuery("select group_concat(ord+1), count(), flds from cards c, notes n "
                                           + "where c.nid = n.id and c.id in " + Utils.ids2str(cids) + " group by nid", null);
            while (cur.moveToNext()) {
                String ords = cur.getString(0);
                int cnt = cur.getInt(1);
                String flds = cur.getString(2);
                rep.append(String.format("Empty card numbers: %s\nFields: %s\n\n", ords, flds.replace("\u001F", " / ")));
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        return rep.toString();
    }

    /**
     * Field checksums and sorting fields ***************************************
     * ********************************************************
     */

    private ArrayList<Object[]> _fieldData(String snids) {
        ArrayList<Object[]> result = new ArrayList<>();
        Cursor cur = null;
        try {
            cur = mDb.getDatabase().rawQuery("SELECT id, mid, flds FROM notes WHERE id IN " + snids, null);
            while (cur.moveToNext()) {
                result.add(new Object[] { cur.getLong(0), cur.getLong(1), cur.getString(2) });
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        return result;
    }


    /** Update field checksums and sort cache, after find&replace, etc. */
    public void updateFieldCache(long[] nids) {
        String snids = Utils.ids2str(nids);
        ArrayList<Object[]> r = new ArrayList<>();
        for (Object[] o : _fieldData(snids)) {
            String[] fields = Utils.splitFields((String) o[2]);
            JSONObject model = mModels.get((Long) o[1]);
            if (model == null) {
                // note point to invalid model
                continue;
            }
            r.add(new Object[] { Utils.stripHTML(fields[mModels.sortIdx(model)]), Utils.fieldChecksum(fields[0]), o[0] });
        }
        // apply, relying on calling code to bump usn+mod
        mDb.executeMany("UPDATE notes SET sfld=?, csum=? WHERE id=?", r);
    }


    /**
     * Q/A generation *********************************************************** ************************************
     */

    public ArrayList<HashMap<String, String>> renderQA() {
        return renderQA(null, "card");
    }


    public ArrayList<HashMap<String, String>> renderQA(int[] ids, String type) {
        String where;
        if (type.equals("card")) {
            where = "AND c.id IN " + Utils.ids2str(ids);
        } else if (type.equals("fact")) {
            where = "AND f.id IN " + Utils.ids2str(ids);
        } else if (type.equals("model")) {
            where = "AND m.id IN " + Utils.ids2str(ids);
        } else if (type.equals("all")) {
            where = "";
        } else {
            throw new RuntimeException();
        }
        ArrayList<HashMap<String, String>> result = new ArrayList<>();
        for (Object[] row : _qaData(where)) {
            result.add(_renderQA(row));
        }
        return result;
    }


    /**
     * Returns hash of id, question, answer.
     */
    public HashMap<String, String> _renderQA(Object[] data) {
        return _renderQA(data, null, null);
    }


    public HashMap<String, String> _renderQA(Object[] data, String qfmt, String afmt) {
        // data is [cid, nid, mid, did, ord, tags, flds]
        // unpack fields and create dict
        String[] flist = Utils.splitFields((String) data[6]);
        Map<String, String> fields = new HashMap<>();
        JSONObject model = mModels.get((Long) data[2]);
        Map<String, Pair<Integer, JSONObject>> fmap = mModels.fieldMap(model);
        for (String name : fmap.keySet()) {
            fields.put(name, flist[fmap.get(name).first]);
        }
        try {
            int cardNum = ((Integer) data[4]) + 1;
            fields.put("Tags", ((String) data[5]).trim());
            fields.put("Type", (String) model.get("name"));
            fields.put("Deck", mDecks.name((Long) data[3]));
            String[] parents = fields.get("Deck").split("::", -1);
            fields.put("Subdeck", parents[parents.length-1]);
            JSONObject template;
            if (model.getInt("type") == Consts.MODEL_STD) {
                template = model.getJSONArray("tmpls").getJSONObject((Integer) data[4]);
            } else {
                template = model.getJSONArray("tmpls").getJSONObject(0);
            }
            fields.put("Card", template.getString("name"));
            fields.put(String.format(Locale.US, "c%d", cardNum), "1");
            // render q & a
            HashMap<String, String> d = new HashMap<>();
            d.put("id", Long.toString((Long) data[0]));
            qfmt = TextUtils.isEmpty(qfmt) ? template.getString("qfmt") : qfmt;
            afmt = TextUtils.isEmpty(afmt) ? template.getString("afmt") : afmt;
            for (Pair<String, String> p : new Pair[]{new Pair<>("q", qfmt), new Pair<>("a", afmt)}) {
                String type = p.first;
                String format = p.second;
                if (type.equals("q")) {
                    format = fClozePatternQ.matcher(format).replaceAll(String.format(Locale.US, "{{$1cq-%d:", cardNum));
                    format = fClozeTagStart.matcher(format).replaceAll(String.format(Locale.US, "<%%cq:%d:", cardNum));
                } else {
                    format = fClozePatternA.matcher(format).replaceAll(String.format(Locale.US, "{{$1ca-%d:", cardNum));
                    format = fClozeTagStart.matcher(format).replaceAll(String.format(Locale.US, "<%%ca:%d:", cardNum));
                    // the following line differs from libanki // TODO: why?
                    fields.put("FrontSide", d.get("q")); // fields.put("FrontSide", mMedia.stripAudio(d.get("q")));
                }
                fields = (Map<String, String>) Hooks.runFilter("mungeFields", fields, model, data, this);
                String html = new Template(format, fields).render();
                d.put(type, (String) Hooks.runFilter("mungeQA", html, type, fields, model, data, this));
                // empty cloze?
                if (type.equals("q") && model.getInt("type") == Consts.MODEL_CLOZE) {
                    if (getModels()._availClozeOrds(model, (String) data[6], false).size() == 0) {
                        String link = String.format("<a href=%s#cloze>%s</a>", Consts.HELP_SITE, "help");
                        d.put("q", String.format("Please edit this note and add some cloze deletions. (%s)", link));
                    }
                }
            }
            return d;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Return [cid, nid, mid, did, ord, tags, flds] db query
     */
    public ArrayList<Object[]> _qaData() {
        return _qaData("");
    }


    public ArrayList<Object[]> _qaData(String where) {
        ArrayList<Object[]> data = new ArrayList<>();
        Cursor cur = null;
        try {
            cur = mDb.getDatabase().rawQuery(
                    "SELECT c.id, n.id, n.mid, c.did, c.ord, "
                            + "n.tags, n.flds FROM cards c, notes n WHERE c.nid == n.id " + where, null);
            while (cur.moveToNext()) {
                data.add(new Object[] { cur.getLong(0), cur.getLong(1), cur.getLong(2), cur.getLong(3), cur.getInt(4),
                        cur.getString(5), cur.getString(6) });
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        return data;
    }


    /**
     * Finding cards ************************************************************ ***********************************
     */

    /** Return a list of card ids */
    public List<Long> findCards(String search) {
        return new Finder(this).findCards(search, null);
    }


    /** Return a list of card ids */
    public List<Long> findCards(String search, String order) {
        return new Finder(this).findCards(search, order);
    }


    public List<Map<String, String>> findCardsForCardBrowser(String search, boolean order, Map<String, String> deckNames) {
        return new Finder(this).findCardsForCardBrowser(search, order, deckNames);
    }


    /** Return a list of note ids */
    public List<Long> findNotes(String query) {
        return new Finder(this).findNotes(query);
    }


    public int findReplace(List<Long> nids, String src, String dst) {
        return Finder.findReplace(this, nids, src, dst);
    }


    public int findReplace(List<Long> nids, String src, String dst, boolean regex) {
        return Finder.findReplace(this, nids, src, dst, regex);
    }


    public int findReplace(List<Long> nids, String src, String dst, String field) {
        return Finder.findReplace(this, nids, src, dst, field);
    }


    public int findReplace(List<Long> nids, String src, String dst, boolean regex, String field, boolean fold) {
        return Finder.findReplace(this, nids, src, dst, regex, field, fold);
    }


    public List<Pair<String, List<Long>>> findDupes(String fieldName) {
        return Finder.findDupes(this, fieldName, "");
    }


    public List<Pair<String, List<Long>>> findDupes(String fieldName, String search) {
        return Finder.findDupes(this, fieldName, search);
    }


    /**
     * Stats ******************************************************************** ***************************
     */

    // cardstats
    // stats

    /**
     * Timeboxing *************************************************************** ********************************
     */

    public void setTimeLimit(long seconds) {
        try {
            mConf.put("timeLim", seconds);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public long getTimeLimit() {
        long timebox = 0;
        try {
            timebox = mConf.getLong("timeLim");
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return timebox;
    }


    public void startTimebox() {
        mStartTime = Utils.now();
        mStartReps = mSched.getReps();
    }


    /* Return (elapsedTime, reps) if timebox reached, or null. */
    public Long[] timeboxReached() {
        try {
            if (mConf.getLong("timeLim") == 0) {
                // timeboxing disabled
                return null;
            }
            double elapsed = Utils.now() - mStartTime;
            if (elapsed > mConf.getLong("timeLim")) {
                return new Long[] { mConf.getLong("timeLim"), (long) (mSched.getReps() - mStartReps) };
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return null;
    }


    /**
     * Undo ********************************************************************* **************************
     */

    /**
     * [type, undoName, data] type 1 = review; type 2 =
     */
    public void clearUndo() {
        mUndo = new LinkedList<>();
    }


    /** Undo menu item name, or "" if undo unavailable. */
    public String undoName(Resources res) {
        if (mUndo.size() > 0) {
            DismissType type = (DismissType) mUndo.getLast()[0];
            return res.getString(type.undoNameId);
        }
        return "";
    }


    public boolean undoAvailable() {
        return mUndo.size() > 0;
    }


    public long undo() {
    	Object[] data = mUndo.removeLast();
    	switch ((DismissType) data[0]) {
            case REVIEW:
                Card c = (Card) data[1];
                // remove leech tag if it didn't have it before
                Boolean wasLeech = (Boolean) data[2];
                if (!wasLeech && c.note().hasTag("leech")) {
                    c.note().delTag("leech");
                    c.note().flush();
                }
                // write old data
                c.flush(false);
                // and delete revlog entry
                long last = mDb.queryLongScalar("SELECT id FROM revlog WHERE cid = " + c.getId() + " ORDER BY id DESC LIMIT 1");
                mDb.execute("DELETE FROM revlog WHERE id = " + last);
                // restore any siblings
                mDb.execute("update cards set queue=type,mod=?,usn=? where queue=-2 and nid=?",
                        new Object[]{Utils.intNow(), usn(), c.getNid()});
                // and finally, update daily count
                int n = c.getQueue() == 3 ? 1 : c.getQueue();
                String type = (new String[]{"new", "lrn", "rev"})[n];
                mSched._updateStats(c, type, -1);
                mSched.setReps(mSched.getReps() - 1);
                return c.getId();

            case BURY_NOTE:
                for (Card cc : (ArrayList<Card>) data[2]) {
                    cc.flush(false);
                }
                return (Long) data[3];

            case SUSPEND_CARD:
                Card suspendedCard = (Card) data[1];
                suspendedCard.flush(false);
                return suspendedCard.getId();

            case SUSPEND_NOTE:
                for (Card ccc : (ArrayList<Card>) data[1]) {
                    ccc.flush(false);
                }
                return (Long) data[2];

            case DELETE_NOTE:
                ArrayList<Long> ids = new ArrayList<>();
                Note note2 = (Note) data[1];
                note2.flush(note2.getMod(), false);
                ids.add(note2.getId());
                for (Card c4 : (ArrayList<Card>) data[2]) {
                    c4.flush(false);
                    ids.add(c4.getId());
                }
                mDb.execute("DELETE FROM graves WHERE oid IN " + Utils.ids2str(Utils.arrayList2array(ids)));
                return (Long) data[3];

            case BURY_CARD:
                for (Card cc : (ArrayList<Card>) data[2]) {
                    cc.flush(false);
                }
                return (Long) data[3];
            default:
                return 0;
        }
    }


    public void markUndo(DismissType type, Object[] o) {
    	switch(type) {
    	case REVIEW:
    		mUndo.add(new Object[]{type, ((Card)o[0]).clone(), o[1]});
    		break;
        case BURY_CARD:
            mUndo.add(new Object[]{type, o[0], o[1], o[2]});
            break;
        case BURY_NOTE:
            mUndo.add(new Object[]{type, o[0], o[1], o[2]});
            break;
        case SUSPEND_CARD:
            mUndo.add(new Object[]{type, ((Card)o[0]).clone()});
            break;
        case SUSPEND_NOTE:
            mUndo.add(new Object[]{type, o[0], o[1]});
            break;
    	case DELETE_NOTE:
    		mUndo.add(new Object[]{type, o[0], o[1], o[2]});
    		break;
    	}
    	while (mUndo.size() > UNDO_SIZE_MAX) {
    		mUndo.removeFirst();
    	}
    }


    public void markReview(Card card) {
        markUndo(DismissType.REVIEW, new Object[]{card, card.note().hasTag("leech")});
    }

    /**
     * DB maintenance *********************************************************** ************************************
     */


    /*
     * Basic integrity check for syncing. True if ok.
     */
    public boolean basicCheck() {
        // cards without notes
        if (mDb.queryScalar("select 1 from cards where nid not in (select id from notes) limit 1") > 0) {
            return false;
        }
        boolean badNotes = mDb.queryScalar(String.format(Locale.US,
                "select 1 from notes where id not in (select distinct nid from cards) " +
                "or mid not in %s limit 1", Utils.ids2str(mModels.ids()))) > 0;
        // notes without cards or models
        if (badNotes) {
            return false;
        }
        try {
            // invalid ords
            for (JSONObject m : mModels.all()) {
                // ignore clozes
                if (m.getInt("type") != Consts.MODEL_STD) {
                    continue;
                }
                // Make a list of valid ords for this model
                JSONArray tmpls = m.getJSONArray("tmpls");
                int[] ords = new int[tmpls.length()];
                for (int t = 0; t < tmpls.length(); t++) {
                    ords[t] = tmpls.getJSONObject(t).getInt("ord");
                }

                boolean badOrd = mDb.queryScalar(String.format(Locale.US,
                        "select 1 from cards where ord not in %s and nid in ( " +
                        "select id from notes where mid = %d) limit 1",
                        Utils.ids2str(ords), m.getLong("id"))) > 0;
                if (badOrd) {
                    return false;
                }
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return true;
    }


    /** Fix possible problems and rebuild caches. */
    public long fixIntegrity() {
        File file = new File(mPath);
        ArrayList<String> problems = new ArrayList<>();
        long oldSize = file.length();
        try {
            mDb.getDatabase().beginTransaction();
            try {
                save();
                if (!mDb.queryString("PRAGMA integrity_check").equals("ok")) {
                    return -1;
                }
                // note types with a missing model
                ArrayList<Long> ids = mDb.queryColumn(Long.class,
                        "SELECT id FROM notes WHERE mid NOT IN " + Utils.ids2str(mModels.ids()), 0);
                if (ids.size() != 0) {
                	problems.add("Deleted " + ids.size() + " note(s) with missing note type.");
	                _remNotes(Utils.arrayList2array(ids));
                }
                // for each model
                for (JSONObject m : mModels.all()) {
                    // cards with invalid ordinal
                    if (m.getInt("type") == Consts.MODEL_STD) {
                        ArrayList<Integer> ords = new ArrayList<>();
                        JSONArray tmpls = m.getJSONArray("tmpls");
                        for (int t = 0; t < tmpls.length(); t++) {
                            ords.add(tmpls.getJSONObject(t).getInt("ord"));
                        }
                        ids = mDb.queryColumn(Long.class,
                                "SELECT id FROM cards WHERE ord NOT IN " + Utils.ids2str(ords) + " AND nid IN ( " +
                                "SELECT id FROM notes WHERE mid = " + m.getLong("id") + ")", 0);
                        if (ids.size() > 0) {
                            problems.add("Deleted " + ids.size() + " card(s) with missing template.");
                            remCards(Utils.arrayList2array(ids));
                        }
                    }
                    // notes with invalid field counts
                    ids = new ArrayList<>();
                    Cursor cur = null;
                    try {
                        cur = mDb.getDatabase().rawQuery("select id, flds from notes where mid = " + m.getLong("id"), null);
                        while (cur.moveToNext()) {
                            String flds = cur.getString(1);
                            long id = cur.getLong(0);
                            int fldsCount = 0;
                            for (int i = 0; i < flds.length(); i++) {
                                if (flds.charAt(i) == 0x1f) {
                                    fldsCount++;
                                }
                            }
                            if (fldsCount + 1 != m.getJSONArray("flds").length()) {
                                ids.add(id);
                            }
                        }
                        if (ids.size() > 0) {
                            problems.add("Deleted " + ids.size() + " note(s) with wrong field count.");
                            _remNotes(Utils.arrayList2array(ids));
                        }
                    } finally {
                        if (cur != null && !cur.isClosed()) {
                            cur.close();
                        }
                    }
                }
                // delete any notes with missing cards
                ids = mDb.queryColumn(Long.class,
                        "SELECT id FROM notes WHERE id NOT IN (SELECT DISTINCT nid FROM cards)", 0);
                if (ids.size() != 0) {
                	problems.add("Deleted " + ids.size() + " note(s) with missing no cards.");
	                _remNotes(Utils.arrayList2array(ids));
                }
                // cards with missing notes
                ids = mDb.queryColumn(Long.class,
                        "SELECT id FROM cards WHERE nid NOT IN (SELECT id FROM notes)", 0);
                if (ids.size() != 0) {
                    problems.add("Deleted " + ids.size() + " card(s) with missing note.");
                    remCards(Utils.arrayList2array(ids));
                }
                // cards with odue set when it shouldn't be
                ids = mDb.queryColumn(Long.class,
                        "select id from cards where odue > 0 and (type=1 or queue=2) and not odid", 0);
                if (ids.size() != 0) {
                    problems.add("Fixed " + ids.size() + " card(s) with invalid properties.");
                    mDb.execute("update cards set odue=0 where id in " + Utils.ids2str(ids));
                }
                // cards with odid set when not in a dyn deck
                ArrayList<Long> dids = new ArrayList<>();
                for (long id : mDecks.allIds()) {
                    if (!mDecks.isDyn(id)) {
                        dids.add(id);
                    }
                }
                ids = mDb.queryColumn(Long.class,
                        "select id from cards where odid > 0 and did in " + Utils.ids2str(dids), 0);
                if (ids.size() != 0) {
                    problems.add("Fixed " + ids.size() + " card(s) with invalid properties.");
                    mDb.execute("update cards set odid=0, odue=0 where id in " + Utils.ids2str(ids));
                }
                // tags
                mTags.registerNotes();
                // field cache
                for (JSONObject m : mModels.all()) {
                    updateFieldCache(Utils.arrayList2array(mModels.nids(m)));
                }
                // new cards can't have a due position > 32 bits
                mDb.execute("UPDATE cards SET due = 1000000, mod = " + Utils.intNow() + ", usn = " + usn()
                        + " WHERE due > 1000000 AND queue = 0");
                // new card position
                mConf.put("nextPos", mDb.queryScalar("SELECT max(due) + 1 FROM cards WHERE type = 0"));
                // reviews should have a reasonable due
                ids = mDb.queryColumn(Long.class, "SELECT id FROM cards WHERE queue = 2 AND due > 10000", 0);
                if (ids.size() > 0) {
                	problems.add("Reviews had incorrect due date.");
                    mDb.execute("UPDATE cards SET due = 0, mod = " + Utils.intNow() + ", usn = " + usn()
                            + " WHERE id IN " + Utils.ids2str(Utils.arrayList2array(ids)));
                }
                mDb.getDatabase().setTransactionSuccessful();
                // DB must have indices. Older versions of AnkiDroid didn't create them for new collections.
                int ixs = mDb.queryScalar("select count(name) from sqlite_master where type = 'index'");
                if (ixs < 7) {
                    problems.add("Indices were missing.");
                    Storage.addIndices(mDb);
                }
            } catch (JSONException e) {
                throw new RuntimeException(e);
            } finally {
                mDb.getDatabase().endTransaction();
            }
        } catch (RuntimeException e) {
            Timber.e(e, "doInBackgroundCheckDatabase - RuntimeException on marking card");
            AnkiDroidApp.sendExceptionReport(e, "doInBackgroundCheckDatabase");
            return -1;
        }
        // and finally, optimize
        optimize();
        file = new File(mPath);
        long newSize = file.length();
        // if any problems were found, force a full sync
        if (problems.size() > 0) {
            modSchemaNoCheck();
        }
        // TODO: report problems
        return (oldSize - newSize) / 1024;
    }


    public void optimize() {
        Timber.i("executing VACUUM statement");
        mDb.execute("VACUUM");
        Timber.i("executing ANALYZE statement");
        mDb.execute("ANALYZE");
    }


    /**
     * Logging
     * ***********************************************************
     */

    public void log(Object... args) {
        if (!mDebugLog) {
            return;
        }
        StackTraceElement trace = Thread.currentThread().getStackTrace()[3];
        // Overwrite any args that need special handling for an appropriate string representation
        for (int i = 0; i < args.length; i++) {
            if (args[i] instanceof long[]) {
                args[i] = Arrays.toString((long []) args[i]);
            }
        }
        String s = String.format("[%s] %s:%s(): %s", Utils.intNow(), trace.getFileName(), trace.getMethodName(),
                TextUtils.join(",  ", args));
        mLogHnd.println(s);
        Timber.d(s);
    }


    private void _openLog() {
        if (!mDebugLog) {
            return;
        }
        try {
            File lpath = new File(mPath.replaceFirst("\\.anki2$", ".log"));
            if (lpath.exists() && lpath.length() > 10*1024*1024) {
                File lpath2 = new File(lpath + ".old");
                if (lpath2.exists()) {
                    lpath2.delete();
                }
                lpath.renameTo(lpath2);
            }
            mLogHnd = new PrintWriter(new BufferedWriter(new FileWriter(lpath, true)), true);
        } catch (IOException e) {
            // turn off logging if we can't open the log file
            Timber.e("Failed to open collection.log file - disabling logging");
            mDebugLog = false;
        }
    }


    private void _closeLog() {
        if (mLogHnd != null) {
            mLogHnd.close();
            mLogHnd = null;
        }
    }

    /**
     * Getters/Setters ********************************************************** *************************************
     */

    public DB getDb() {
        return mDb;
    }


    public Decks getDecks() {
        return mDecks;
    }


    public Media getMedia() {
        return mMedia;
    }


    public Models getModels() {
        return mModels;
    }

    /** Check if this collection is valid. */
    public boolean validCollection() {
    	//TODO: more validation code
    	return mModels.validateModel();
    }

    public JSONObject getConf() {
        return mConf;
    }


    public void setConf(JSONObject conf) {
        mConf = conf;
    }


    public long getScm() {
        return mScm;
    }


    public boolean getServer() {
        return mServer;
    }


    public void setLs(long ls) {
        mLs = ls;
    }


    public void setUsnAfterSync(int usn) {
        mUsn = usn;
    }


    public long getMod() {
        return mMod;
    }


    /* this getter is only for syncing routines, use usn() instead elsewhere */
    public int getUsnForSync() {
        return mUsn;
    }


    public Tags getTags() {
        return mTags;
    }


    public long getCrt() {
        return mCrt;
    }


    public void setCrt(long crt) {
        mCrt = crt;
    }


    public Sched getSched() {
        return mSched;
    }


    public String getPath() {
        return mPath;
    }


    public void setServer(boolean server) {
        mServer = server;
    }

    public boolean getDirty() {
        return mDty;
    }

    /**
     * @return The context that created this Collection.
     */
    public Context getContext() {
        return mContext;
    }

}
/****************************************************************************************
 * Copyright (c) 2014 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

public class Consts {

    // whether new cards should be mixed with reviews, or shown first or last
    public static final int NEW_CARDS_DISTRIBUTE = 0;
    public static final int NEW_CARDS_LAST = 1;
    public static final int NEW_CARDS_FIRST = 2;

    // new card insertion order
    public static final int NEW_CARDS_RANDOM = 0;
    public static final int NEW_CARDS_DUE = 1;

    // removal types
    public static final int REM_CARD = 0;
    public static final int REM_NOTE = 1;
    public static final int REM_DECK = 2;

    // count display
    public static final int COUNT_ANSWERED = 0;
    public static final int COUNT_REMAINING = 1;

    // media log
    public static final int MEDIA_ADD = 0;
    public static final int MEDIA_REM = 1;

    // dynamic deck order
    public static final int DYN_OLDEST = 0;
    public static final int DYN_RANDOM = 1;
    public static final int DYN_SMALLINT = 2;
    public static final int DYN_BIGINT = 3;
    public static final int DYN_LAPSES = 4;
    public static final int DYN_ADDED = 5;
    public static final int DYN_DUE = 6;
    public static final int DYN_REVADDED = 7;
    public static final int DYN_DUEPRIORITY = 8;

    public static final int DYN_MAX_SIZE = 99999;

    // model types
    public static final int MODEL_STD = 0;
    public static final int MODEL_CLOZE = 1;

    // deck schema & syncing vars
    public static final int SCHEMA_VERSION = 11;
    public static final int SYNC_ZIP_SIZE = (int)(2.5*1024*1024);
    public static final int SYNC_ZIP_COUNT = 25;
    public static final String SYNC_BASE = "https://sync.ankiweb.net/";
    public static final String SYNC_MEDIA_BASE = "https://sync.ankiweb.net/msync/";
    public static final int SYNC_VER = 8;

    public static final String HELP_SITE = "http://ankisrs.net/docs/manual.html";

    // The labels defined in consts.py are in AnkiDroid's resources files.
}
/****************************************************************************************
 * Copyright (c) 2009 Daniel Sv盲rd <daniel.svard@gmail.com>                             *
 * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>                                    *
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

import android.annotation.TargetApi;
import android.content.ContentValues;
import android.database.Cursor;
import android.database.SQLException;
import android.os.Build;
import android.widget.Toast;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.dialogs.DatabaseErrorDialog;
import com.ichi2.compat.CompatHelper;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import io.requery.android.database.DatabaseErrorHandler;
import io.requery.android.database.sqlite.SQLiteDatabase;
import timber.log.Timber;

/**
 * Database layer for AnkiDroid. Can read the native Anki format through Android's SQLite driver.
 */
public class DB {

    private static final String[] MOD_SQLS = new String[] { "insert", "update", "delete" };

    /**
     * The deck, which is actually an SQLite database.
     */
    private SQLiteDatabase mDatabase;
    private boolean mMod = false;


    /**
     * Open a database connection to an ".anki" SQLite file.
     */
    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    public DB(String ankiFilename) {
        // Since API 11 we can provide a custom error handler which doesn't delete the database on corruption
        if (CompatHelper.isHoneycomb()) {
            mDatabase = SQLiteDatabase.openDatabase(ankiFilename, null,
                    (SQLiteDatabase.OPEN_READWRITE + SQLiteDatabase.CREATE_IF_NECESSARY)
                            | SQLiteDatabase.NO_LOCALIZED_COLLATORS, new MyDbErrorHandler());
        } else {
            mDatabase = SQLiteDatabase.openDatabase(ankiFilename, null,
                    (SQLiteDatabase.OPEN_READWRITE + SQLiteDatabase.CREATE_IF_NECESSARY)
                            | SQLiteDatabase.NO_LOCALIZED_COLLATORS);
        }

        if (mDatabase != null) {
            // TODO: we can remove this eventually once everyone has stopped using old AnkiDroid clients with WAL
            CompatHelper.getCompat().disableDatabaseWriteAheadLogging(mDatabase);
            mDatabase.rawQuery("PRAGMA synchronous = 2", null);
        }
        // getDatabase().beginTransactionNonExclusive();
        mMod = false;
    }

    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    public class MyDbErrorHandler implements DatabaseErrorHandler {
        @Override
        public void onCorruption(SQLiteDatabase db) {
            Timber.e("The database has been corrupted...");
            AnkiDroidApp.sendExceptionReport(new RuntimeException("Database corrupted"), "DB.MyDbErrorHandler.onCorruption", "Db has been corrupted ");
            CollectionHelper.getInstance().closeCollection(false);
            DatabaseErrorDialog.databaseCorruptFlag = true;
        }
    }


    /**
     * Closes a previously opened database connection.
     */
    public void close() {
        mDatabase.close();
        Timber.d("Database %s closed = %s", mDatabase.getPath(), !mDatabase.isOpen());
    }


    public void commit() {
        // SQLiteDatabase db = getDatabase();
        // while (db.inTransaction()) {
        // db.setTransactionSuccessful();
        // db.endTransaction();
        // }
        // db.beginTransactionNonExclusive();
    }


    public SQLiteDatabase getDatabase() {
        return mDatabase;
    }


    public void setMod(boolean mod) {
        mMod = mod;
    }


    public boolean getMod() {
        return mMod;
    }


    /**
     * Convenience method for querying the database for a single integer result.
     *
     * @param query The raw SQL query to use.
     * @return The integer result of the query.
     */
    public int queryScalar(String query) {
        return queryScalar(query, null);
    }


    public int queryScalar(String query, String[] selectionArgs) {
        Cursor cursor = null;
        int scalar;
        try {
            cursor = mDatabase.rawQuery(query, selectionArgs);
            if (!cursor.moveToNext()) {
                return 0;
            }
            scalar = cursor.getInt(0);
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        return scalar;
    }


    public String queryString(String query) throws SQLException {
        Cursor cursor = null;
        try {
            cursor = mDatabase.rawQuery(query, null);
            if (!cursor.moveToNext()) {
                throw new SQLException("No result for query: " + query);
            }
            return cursor.getString(0);
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }


    public long queryLongScalar(String query) {
        Cursor cursor = null;
        long scalar;
        try {
            cursor = mDatabase.rawQuery(query, null);
            if (!cursor.moveToNext()) {
                return 0;
            }
            scalar = cursor.getLong(0);
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }

        return scalar;
    }


    /**
     * Convenience method for querying the database for an entire column. The column will be returned as an ArrayList of
     * the specified class. See Deck.initUndo() for a usage example.
     *
     * @param type The class of the column's data type. Example: int.class, String.class.
     * @param query The SQL query statement.
     * @param column The column id in the result set to return.
     * @return An ArrayList with the contents of the specified column.
     */
    public <T> ArrayList<T> queryColumn(Class<T> type, String query, int column) {
        int nullExceptionCount = 0;
        InvocationTargetException nullException = null; // to catch the null exception for reporting
        ArrayList<T> results = new ArrayList<>();
        Cursor cursor = null;

        try {
            cursor = mDatabase.rawQuery(query, null);
            String methodName = getCursorMethodName(type.getSimpleName());
            while (cursor.moveToNext()) {
                try {
                    // The magical line. Almost as illegible as python code ;)
                    results.add(type.cast(Cursor.class.getMethod(methodName, int.class).invoke(cursor, column)));
                } catch (InvocationTargetException e) {
                    if (cursor.isNull(column)) { // null value encountered
                        nullExceptionCount++;
                        if (nullExceptionCount == 1) { // Toast and error report first time only
                            nullException = e;
                            Toast.makeText(AnkiDroidApp.getInstance().getBaseContext(),
                                    "Error report pending: unexpected null in database.", Toast.LENGTH_LONG).show();
                        }
                    } else {
                        throw new RuntimeException(e);
                    }
                }
            }
        } catch (NoSuchMethodException | IllegalAccessException | IllegalArgumentException e) {
            // This is really coding error, so it should be revealed if it ever happens
            throw new RuntimeException(e);
        } finally {
            if (cursor != null) {
                cursor.close();
            }
            if (nullExceptionCount > 0) {
                if (nullException != null) {
                    StringBuilder sb = new StringBuilder();
                    sb.append("DB.queryColumn (column " + column + "): ");
                    sb.append("Exception due to null. Query: " + query);
                    sb.append(" Null occurrences during this query: " + nullExceptionCount);
                    AnkiDroidApp.sendExceptionReport(nullException, "queryColumn_encounteredNull", sb.toString());
                    Timber.w(sb.toString());
                } else { // nullException not properly initialized
                    StringBuilder sb = new StringBuilder();
                    sb.append("DB.queryColumn(): Critical error -- ");
                    sb.append("unable to pass in the actual exception to error reporting.");
                    AnkiDroidApp.sendExceptionReport(new RuntimeException("queryColumn null"), "queryColumn_encounteredNull", sb.toString());
                    Timber.e(sb.toString());
                }
            }
        }

        return results;
    }


    /**
     * Mapping of Java type names to the corresponding Cursor.get method.
     *
     * @param typeName The simple name of the type's class. Example: String.class.getSimpleName().
     * @return The name of the Cursor method to be called.
     */
    private static String getCursorMethodName(String typeName) {
        if (typeName.equals("String")) {
            return "getString";
        } else if (typeName.equals("Long")) {
            return "getLong";
        } else if (typeName.equals("Integer")) {
            return "getInt";
        } else if (typeName.equals("Float")) {
            return "getFloat";
        } else if (typeName.equals("Double")) {
            return "getDouble";
        } else {
            return null;
        }
    }


    public void execute(String sql) {
        execute(sql, null);
    }


    public void execute(String sql, Object[] object) {
        String s = sql.trim().toLowerCase(Locale.US);
        // mark modified?
        for (String mo : MOD_SQLS) {
            if (s.startsWith(mo)) {
                mMod = true;
                break;
            }
        }
        if (object == null) {
            this.getDatabase().execSQL(sql);
        } else {
            this.getDatabase().execSQL(sql, object);
        }
    }


    /**
     * WARNING: This is a convenience method that splits SQL scripts into separate queries with semicolons (;) 
     * as the delimiter. Only use this method on internal functions where we can guarantee that the script does
     * not contain any non-statement-terminating semicolons.
     */
    public void executeScript(String sql) {
        mMod = true;
        String[] queries = sql.split(";");
        for(String query : queries) {
            mDatabase.execSQL(query);
        }
    }


    /** update must always be called via DB in order to mark the db as changed */
    public int update(String table, ContentValues values) {
        return update(table, values, null, null);
    }


    /** update must always be called via DB in order to mark the db as changed */
    public int update(String table, ContentValues values, String whereClause, String[] whereArgs) {
        mMod = true;
        return getDatabase().update(table, values, whereClause, whereArgs);
    }


    /** insert must always be called via DB in order to mark the db as changed */
    public long insert(String table, String nullColumnHack, ContentValues values) {
        mMod = true;
        return getDatabase().insert(table, nullColumnHack, values);
    }


    public void executeMany(String sql, List<Object[]> list) {
        mMod = true;
        mDatabase.beginTransaction();
        try {
            for (Object[] o : list) {
                mDatabase.execSQL(sql, o);
            }
            mDatabase.setTransactionSuccessful();
        } finally {
            mDatabase.endTransaction();
        }
    }

    /**
     * @return The full path to this database file.
     */
    public String getPath() {
        return mDatabase.getPath();
    }
}
/****************************************************************************************
 * Copyright (c) 2009 Daniel Sv盲rd <daniel.svard@gmail.com>                             *
 * Copyright (c) 2009 Casey Link <unnamedrambler@gmail.com>                             *
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 * Copyright (c) 2010 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2015 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

import android.content.ContentValues;
import android.text.TextUtils;

import com.ichi2.anki.exception.ConfirmModSchemaException;
import com.ichi2.anki.exception.DeckRenameException;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.regex.Pattern;

// fixmes:
// - make sure users can't set grad interval < 1

public class Decks {


    public static final String defaultDeck = ""
            + "{"
                + "'newToday': [0, 0]," // currentDay, count
                + "'revToday': [0, 0],"
                + "'lrnToday': [0, 0],"
                + "'timeToday': [0, 0]," // time in ms
                + "'conf': 1,"
                + "'usn': 0,"
                + "'desc': \"\","
                + "'dyn': 0," // anki uses int/bool interchangably here
                + "'collapsed': False,"
                // added in beta11
                + "'extendNew': 10,"
                + "'extendRev': 50"
            + "}";

    private static final String defaultDynamicDeck = ""
            + "{"
                + "'newToday': [0, 0],"
                + "'revToday': [0, 0],"
                + "'lrnToday': [0, 0],"
                + "'timeToday': [0, 0],"
                + "'collapsed': False,"
                + "'dyn': 1,"
                + "'desc': \"\","
                + "'usn': 0,"
                + "'delays': null,"
                + "'separate': True,"
                // list of (search, limit, order); we only use first element for now
                + "'terms': [[\"\", 100, 0]],"
                + "'resched': True,"
                + "'return': True" // currently unused
            + "}";

    public static final String defaultConf = ""
            + "{"
                + "'name': \"Default\","
                + "'new': {"
                    + "'delays': [1, 10],"
                    + "'ints': [1, 4, 7]," // 7 is not currently used
                    + "'initialFactor': 2500,"
                    + "'separate': True,"
                    + "'order': " + Consts.NEW_CARDS_DUE + ","
                    + "'perDay': 20,"
                    // may not be set on old decks
                    + "'bury': True"
                + "},"
                + "'lapse': {"
                    + "'delays': [10],"
                    + "'mult': 0,"
                    + "'minInt': 1,"
                    + "'leechFails': 8,"
                    // type 0=suspend, 1=tagonly
                    + "'leechAction': 0"
                + "},"
                + "'rev': {"
                    + "'perDay': 100,"
                    + "'ease4': 1.3,"
                    + "'fuzz': 0.05,"
                    + "'minSpace': 1," // not currently used
                    + "'ivlFct': 1,"
                    + "'maxIvl': 36500,"
                    // may not be set on old decks
                    + "'bury': True"
                + "},"
                + "'maxTaken': 60,"
                + "'timer': 0,"
                + "'autoplay': True,"
                + "'replayq': True,"
                + "'mod': 0,"
                + "'usn': 0"
            +"}";


    private Collection mCol;
    private HashMap<Long, JSONObject> mDecks;
    private HashMap<Long, JSONObject> mDconf;
    private boolean mChanged;


    /**
     * Registry save/load
     * ***********************************************************
     */

    public Decks(Collection col) {
        mCol = col;
    }


    public void load(String decks, String dconf) {
        mDecks = new HashMap<>();
        mDconf = new HashMap<>();
        try {
            JSONObject decksarray = new JSONObject(decks);
            JSONArray ids = decksarray.names();
            for (int i = 0; i < ids.length(); i++) {
                String id = ids.getString(i);
                JSONObject o = decksarray.getJSONObject(id);
                long longId = Long.parseLong(id);
                mDecks.put(longId, o);
            }
            JSONObject confarray = new JSONObject(dconf);
            ids = confarray.names();
            for (int i = 0; ids != null && i < ids.length(); i++) {
                String id = ids.getString(i);
                mDconf.put(Long.parseLong(id), confarray.getJSONObject(id));
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        mChanged = false;
    }


    public void save() {
        save(null);
    }


    /**
     * Can be called with either a deck or a deck configuration.
     */
    public void save(JSONObject g) {
        if (g != null) {
            try {
                g.put("mod", Utils.intNow());
                g.put("usn", mCol.usn());
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }
        mChanged = true;
    }


    public void flush() {
        ContentValues values = new ContentValues();
        if (mChanged) {
            try {
                JSONObject decksarray = new JSONObject();
                for (Map.Entry<Long, JSONObject> d : mDecks.entrySet()) {
                    decksarray.put(Long.toString(d.getKey()), d.getValue());
                }
                values.put("decks", Utils.jsonToString(decksarray));
                JSONObject confarray = new JSONObject();
                for (Map.Entry<Long, JSONObject> d : mDconf.entrySet()) {
                    confarray.put(Long.toString(d.getKey()), d.getValue());
                }
                values.put("dconf", Utils.jsonToString(confarray));
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            mCol.getDb().update("col", values);
            mChanged = false;
        }
    }


    /**
     * Deck save/load
     * ***********************************************************
     */

    public Long id(String name) {
        return id(name, true);
    }


    public Long id(String name, boolean create) {
        return id(name, create, defaultDeck);
    }


    public Long id(String name, String type) {
        return id(name, true, type);
    }


    /**
     * Add a deck with NAME. Reuse deck if already exists. Return id as int.
     */
    public Long id(String name, boolean create, String type) {
        try {
            name = name.replace("\"", "");
            for (Map.Entry<Long, JSONObject> g : mDecks.entrySet()) {
                if (g.getValue().getString("name").equalsIgnoreCase(name)) {
                    return g.getKey();
                }
            }
            if (!create) {
                return null;
            }
            if (name.contains("::")) {
                // not top level; ensure all parents exist
                name = _ensureParents(name);
            }
            JSONObject g;
            long id;
            g = new JSONObject(type);
            g.put("name", name);
            while (true) {
                id = Utils.intNow(1000);
                if (!mDecks.containsKey(id)) {
                    break;
                }
            }
            g.put("id", id);
            mDecks.put(id, g);
            save(g);
            maybeAddToActive();
            //runHook("newDeck"); // TODO
            return id;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public void rem(long did) {
        rem(did, false);
    }


    public void rem(long did, boolean cardsToo) {
        rem(did, cardsToo, true);
    }


    /**
     * Remove the deck. If cardsToo, delete any cards inside.
     */
    public void rem(long did, boolean cardsToo, boolean childrenToo) {
        try {
            if (did == 1) {
            	// we won't allow the default deck to be deleted, but if it's a
            	// child of an existing deck then it needs to be renamed
            	JSONObject deck = get(did);
            	if (deck.getString("name").contains("::")) {
            		deck.put("name", "Default");
            		save(deck);
            	}
                return;
            }
            // log the removal regardless of whether we have the deck or not
            mCol._logRem(new long[] { did }, Consts.REM_DECK);
            // do nothing else if doesn't exist
            if (!mDecks.containsKey(did)) {
                return;
            }
            JSONObject deck = get(did);
            if (deck.getInt("dyn") != 0) {
                // deleting a cramming deck returns cards to their previous deck
                // rather than deleting the cards
                mCol.getSched().emptyDyn(did);
                if (childrenToo) {
                    for (long id : children(did).values()) {
                        rem(id, cardsToo);
                    }
                }
            } else {
                // delete children first
                if (childrenToo) {
                    // we don't want to delete children when syncing
                    for (long id : children(did).values()) {
                        rem(id, cardsToo);
                    }
                }
                // delete cards too?
                if (cardsToo) {
                    // don't use cids(), as we want cards in cram decks too
                    ArrayList<Long> cids = mCol.getDb().queryColumn(Long.class,
                            "SELECT id FROM cards WHERE did = " + did + " OR odid = " + did, 0);
                    mCol.remCards(Utils.arrayList2array(cids));
                }
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        // delete the deck and add a grave
        mDecks.remove(did);
        // ensure we have an active deck
        if (active().contains(did)) {
            select(mDecks.keySet().iterator().next());
        }
        save();
    }


    public ArrayList<String> allNames() {
        return allNames(true);
    }


    /**
     * An unsorted list of all deck names.
     */
    public ArrayList<String> allNames(boolean dyn) {
        ArrayList<String> list = new ArrayList<>();
        try {
            if (dyn) {
                for (JSONObject x : mDecks.values()) {
                    list.add(x.getString("name"));
                }
            } else {
                for (JSONObject x : mDecks.values()) {
                    if (x.getInt("dyn") == 0) {
                        list.add(x.getString("name"));
                    }
                }
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return list;
    }


    /**
     * A list of all decks.
     */
    public ArrayList<JSONObject> all() {
        ArrayList<JSONObject> decks = new ArrayList<>();
        for (JSONObject deck : mDecks.values()) {
            decks.add(deck);
        }
        return decks;
    }


    /**
     * Return the same deck list from all() but sorted using a comparator that ensures the same
     * sorting order for decks as the desktop client.
     *
     * This method does not exist in the original python module but *must* be used for any user
     * interface components that display a deck list to ensure the ordering is consistent.
     */
    public ArrayList<JSONObject> allSorted() {
        ArrayList<JSONObject> decks = all();
        Collections.sort(decks, new Comparator<JSONObject>() {
            @Override
            public int compare(JSONObject lhs, JSONObject rhs) {
                try {
                    return lhs.getString("name").compareTo(rhs.getString("name"));
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
            }
        });
        return decks;
    }


    public Long[] allIds() {
        return mDecks.keySet().toArray(new Long[mDecks.keySet().size()]);
    }


    public void collpase(long did) {
        try {
            JSONObject deck = get(did);
            deck.put("collapsed", !deck.getBoolean("collapsed"));
            save(deck);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public void collapseBrowser(long did) {
        try {
            JSONObject deck = get(did);
            boolean collapsed = deck.optBoolean("browserCollapsed", false);
            deck.put("browserCollapsed", !collapsed);
            save(deck);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Return the number of decks.
     */
    public int count() {
        return mDecks.size();
    }


    public JSONObject get(long did) {
        return get(did, true);
    }


    public JSONObject get(long did, boolean _default) {
        if (mDecks.containsKey(did)) {
            return mDecks.get(did);
        } else if (_default) {
            return mDecks.get(1L);
        } else {
            return null;
        }
    }


    /**
     * Get deck with NAME.
     */
    public JSONObject byName(String name) {
		try {
			for (JSONObject m : mDecks.values()) {
				if (m.get("name").equals(name)) {
					return m;
				}
			}
		} catch (JSONException e) {
			throw new RuntimeException(e);
		}
		return null;
    }


    /**
     * Add or update an existing deck. Used for syncing and merging.
     */
    public void update(JSONObject g) {
        try {
            mDecks.put(g.getLong("id"), g);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        maybeAddToActive();
        // mark registry changed, but don't bump mod time
        save();
    }


    /**
     * Rename deck prefix to NAME if not exists. Updates children.
     */
    public void rename(JSONObject g, String newName) throws DeckRenameException {
        // make sure target node doesn't already exist
        if (allNames().contains(newName)) {
            throw new DeckRenameException(DeckRenameException.ALREADY_EXISTS);
        }
        try {
            // ensure we have parents
            newName = _ensureParents(newName);
            // make sure we're not nesting under a filtered deck
            if (newName.contains("::")) {
                List<String> parts = Arrays.asList(newName.split("::", -1));
                String newParent = TextUtils.join("::", parts.subList(0, parts.size() - 1));
                if (byName(newParent).getInt("dyn") != 0) {
                    throw new DeckRenameException(DeckRenameException.FILTERED_NOSUBDEKCS);
                }
            }
            // rename children
            String oldName = g.getString("name");
            for (JSONObject grp : all()) {
                if (grp.getString("name").startsWith(oldName + "::")) {
                    // In Java, String.replaceFirst consumes a regex so we need to quote the pattern to be safe
                    grp.put("name", grp.getString("name").replaceFirst(Pattern.quote(oldName + "::"),
                            newName + "::"));
                    save(grp);
                }
            }
            // adjust name
            g.put("name", newName);
            // ensure we have parents again, as we may have renamed parent->child
            newName = _ensureParents(newName);
            save(g);
            // renaming may have altered active did order
            maybeAddToActive();
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public void renameForDragAndDrop(Long draggedDeckDid, Long ontoDeckDid) throws DeckRenameException {
        try {
            JSONObject draggedDeck = get(draggedDeckDid);
            String draggedDeckName = draggedDeck.getString("name");
            String ontoDeckName = get(ontoDeckDid).getString("name");

            if (ontoDeckDid == null) {
                if (_path(draggedDeckName).size() > 1) {
                    rename(draggedDeck, _basename(draggedDeckName));
                }
            } else if (_canDragAndDrop(draggedDeckName, ontoDeckName)) {
                draggedDeck = get(draggedDeckDid);
                draggedDeckName = draggedDeck.getString("name");
                ontoDeckName = get(ontoDeckDid).getString("name");
                rename(draggedDeck, ontoDeckName + "::" + _basename(draggedDeckName));
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    private boolean _canDragAndDrop(String draggedDeckName, String ontoDeckName) {
        if (draggedDeckName.equals(ontoDeckName)
                || _isParent(ontoDeckName, draggedDeckName)
                || _isAncestor(draggedDeckName, ontoDeckName)) {
            return false;
        } else {
            return true;
        }
    }


    private boolean _isParent(String parentDeckName, String childDeckName) {
        List<String> parentDeckPath = _path(parentDeckName);
        parentDeckPath.add(_basename(childDeckName));

        Iterator<String> cpIt = _path(childDeckName).iterator();
        Iterator<String> ppIt = parentDeckPath.iterator();
        while (cpIt.hasNext() && ppIt.hasNext()) {
            if (!cpIt.next().equals(ppIt.next())) {
                return false;
            }
        }
        return true;
    }


    private boolean _isAncestor(String ancestorDeckName, String descendantDeckName) {
        Iterator<String> apIt = _path(ancestorDeckName).iterator();
        Iterator<String> dpIt = _path(descendantDeckName).iterator();
        while (apIt.hasNext() && dpIt.hasNext()) {
            if (!apIt.next().equals(dpIt.next())) {
                return false;
            }
        }
        return true;
    }


    private List<String> _path(String name) {
        return Arrays.asList(name.split("::", -1));
    }
    private String _basename(String name) {
        List<String> path = _path(name);
        return path.get(path.size() - 1);
    }


    /**
     * Ensure parents exist, and return name with case matching parents.
     */
    public String _ensureParents(String name) {
        String s = "";
        List<String> path = _path(name);
        if (path.size() < 2) {
            return name;
        }
        for(String p : path.subList(0, path.size() - 1)) {
            if (TextUtils.isEmpty(s)) {
                s += p;
            } else {
                s += "::" + p;
            }
            // fetch or create
            long did = id(s);
            // get original case
            s = name(did);
        }
        name = s + "::" + path.get(path.size() - 1);
        return name;
    }


    /**
     * Deck configurations
     * ***********************************************************
     */


    /**
     * A list of all deck config.
     */
    public ArrayList<JSONObject> allConf() {
        ArrayList<JSONObject> confs = new ArrayList<>();
        for (JSONObject c : mDconf.values()) {
            confs.add(c);
        }
        return confs;
    }


    public JSONObject confForDid(long did) {
        JSONObject deck = get(did, false);
        assert deck != null;
        if (deck.has("conf")) {
            try {
                JSONObject conf = getConf(deck.getLong("conf"));
                conf.put("dyn", 0);
                return conf;
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }
        // dynamic decks have embedded conf
        return deck;
    }


    public JSONObject getConf(long confId) {
        return mDconf.get(confId);
    }


    public void updateConf(JSONObject g) {
        try {
            mDconf.put(g.getLong("id"), g);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        save();
    }


    public long confId(String name) {
        return confId(name, defaultConf);
    }


    /**
     * Create a new configuration and return id.
     */
    public long confId(String name, String cloneFrom) {
        JSONObject c;
        long id;
        try {
            c = new JSONObject(cloneFrom);
            while (true) {
                id = Utils.intNow(1000);
                if (!mDconf.containsKey(id)) {
                    break;
                }
            }
            c.put("id", id);
            c.put("name", name);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        mDconf.put(id, c);
        save(c);
        return id;
    }


    /**
     * Remove a configuration and update all decks using it.
     * @throws ConfirmModSchemaException 
     */
    public void remConf(long id) throws ConfirmModSchemaException {
        assert id != 1;
        mCol.modSchema(true);
        mDconf.remove(id);
        try {
            for (JSONObject g : all()) {
                // ignore cram decks
                if (!g.has("conf")) {
                    continue;
                }
                if (g.getString("conf").equals(Long.toString(id))) {
                    g.put("conf", 1);
                    save(g);
                }
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public void setConf(JSONObject grp, long id) {
        try {
            grp.put("conf", id);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        save(grp);
    }


    public List<Long> didsForConf(JSONObject conf) {
        List<Long> dids = new ArrayList<>();
        try {
            for(JSONObject deck : mDecks.values()) {
                if (deck.has("conf") && deck.getLong("conf") == conf.getLong("id")) {
                    dids.add(deck.getLong("id"));
                }
            }
            return dids;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public void restoreToDefault(JSONObject conf) {
        try {
            int oldOrder = conf.getJSONObject("new").getInt("order");
            JSONObject _new = new JSONObject(defaultConf);
            _new.put("id", conf.getLong("id"));
            _new.put("name", conf.getString("name"));
            mDconf.put(conf.getLong("id"), _new);
            save(_new);
            // if it was previously randomized, resort
            if (oldOrder == 0) {
                mCol.getSched().resortConf(_new);
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Deck utils
     * ***********************************************************
     */


    public String name(long did) {
        return name(did, false);
    }


    public String name(long did, boolean _default) {
        try {
            JSONObject deck = get(did, _default);
            if (deck != null) {
                return deck.getString("name");
            }
            return "[no deck]";
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public String nameOrNone(long did) {
        JSONObject deck = get(did, false);
        if (deck != null) {
            try {
                return deck.getString("name");
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }
        return null;
    }


    public void setDeck(long[] cids, long did) {
        mCol.getDb().execute("update cards set did=?,usn=?,mod=? where id in " + Utils.ids2str(cids),
                new Object[] { did, mCol.usn(), Utils.intNow() });
    }


    private void maybeAddToActive() {
        // reselect current deck, or default if current has disappeared
        JSONObject c = current();
        try {
            select(c.getLong("id"));
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public Long[] cids(long did) {
        return cids(did, false);
    }


    public Long[] cids(long did, boolean children) {
        if (!children) {
            return Utils.list2ObjectArray(mCol.getDb().queryColumn(Long.class, "select id from cards where did=" + did, 0));
        }
        List<Long> dids = new ArrayList<>();
        dids.add(did);
        for(Map.Entry<String, Long> entry : children(did).entrySet()) {
            dids.add(entry.getValue());
        }
        return Utils.list2ObjectArray(mCol.getDb().queryColumn(Long.class,
                "select id from cards where did in " + Utils.ids2str(Utils.arrayList2array(dids)), 0));
    }


    public void recoverOrphans() {
        Long[] dids = allIds();
        boolean mod = mCol.getDb().getMod();
        mCol.getDb().execute("update cards set did = 1 where did not in " + Utils.ids2str(dids));
        mCol.getDb().setMod(mod);
    }


    /**
     * Deck selection
     * ***********************************************************
     */


    /**
     * The currently active dids. Make sure to copy before modifying.
     */
    public LinkedList<Long> active() {
        try {
            JSONArray ja = mCol.getConf().getJSONArray("activeDecks");
            LinkedList<Long> result = new LinkedList<>();
            for (int i = 0; i < ja.length(); i++) {
                result.add(ja.getLong(i));
            }
            return result;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * The currently selected did.
     */
    public long selected() {
        try {
            return mCol.getConf().getLong("curDeck");
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public JSONObject current() {
        return get(selected());
    }


    /**
     * Select a new branch.
     */
    public void select(long did) {
        try {
            String name = mDecks.get(did).getString("name");

            // current deck
            mCol.getConf().put("curDeck", Long.toString(did));
            // and active decks (current + all children)
            TreeMap<String, Long> actv = children(did); // Note: TreeMap is already sorted
            actv.put(name, did);
            JSONArray ja = new JSONArray();
            for (Long n : actv.values()) {
                ja.put(n);
            }
            mCol.getConf().put("activeDecks", ja);
            mChanged = true;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * All children of did as nodes of (key:name, value:id)
     *
     * TODO: There is likely no need for this collection to be a TreeMap. This method should not
     * need to sort on behalf of select().
     */
    public TreeMap<String, Long> children(long did) {
        String name;
        try {
            name = get(did).getString("name");
            TreeMap<String, Long> actv = new TreeMap<>();
            for (JSONObject g : all()) {
                if (g.getString("name").startsWith(name + "::")) {
                    actv.put(g.getString("name"), g.getLong("id"));
                }
            }
            return actv;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * All parents of did.
     */
    public List<JSONObject> parents(long did) {
        // get parent and grandparent names
        List<String> parents = new ArrayList<>();
        try {
            List<String> parts = Arrays.asList(get(did).getString("name").split("::", -1));
            for (String part : parts.subList(0, parts.size() - 1)) {
                if (parents.size() == 0) {
                    parents.add(part);
                } else {
                    parents.add(parents.get(parents.size() - 1) + "::" + part);
                }
            }
            // convert to objects
            List<JSONObject> oParents = new ArrayList<>();
            for (int i = 0; i < parents.size(); i++) {
                oParents.add(i, get(id(parents.get(i))));
            }
            return oParents;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Sync handling
     * ***********************************************************
     */


    public void beforeUpload() {
        try {
            for (JSONObject d : all()) {
                d.put("usn", 0);
            }
            for (JSONObject c : allConf()) {
                c.put("usn", 0);
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        save();
    }


    /**
     * Dynamic decks
     ***************************************************************/


    /**
     * Return a new dynamic deck and set it as the current deck.
     */
    public long newDyn(String name) {
        long did = id(name, defaultDynamicDeck);
        select(did);
        return did;
    }


    public boolean isDyn(long did) {
        try {
            return get(did).getInt("dyn") != 0;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /*
    * ***********************************************************
    * The methods below are not in LibAnki.
    * ***********************************************************
    */


    public String getActualDescription() {
    	return current().optString("desc","");
    }


    public HashMap<Long, JSONObject> getDecks() {
        return mDecks;
    }
}
/****************************************************************************************
 * Copyright (c) 2012 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 * Copyright (c) 2014 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

import android.database.Cursor;
import android.database.SQLException;
import android.text.TextUtils;

import android.util.Pair;

import com.ichi2.async.DeckTask;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import timber.log.Timber;

public class Finder {

    private static final Pattern fPropPattern = Pattern.compile("(^.+?)(<=|>=|!=|=|<|>)(.+?$)");
    private static final Pattern fNidsPattern = Pattern.compile("[^0-9,]");
    private static final Pattern fMidPattern = Pattern.compile("[^0-9]");

    private Collection mCol;


    public Finder(Collection col) {
        mCol = col;
    }


    /*
     * NOTE: The python version of findCards can accept a boolean, a string, or no value for the _order parameter. The
     * type of _order also determines which _order() method is used. To maintain type safety, we expose the three valid
     * options here and safely type-cast accordingly at run-time.
     */

    /** Return a list of card ids for QUERY */
    public List<Long> findCards(String query) {
        return findCards(query, false);
    }


    public List<Long> findCards(String query, String _order) {
        return _findCards(query, _order);
    }


    public List<Long> findCards(String query, boolean _order) {
        return _findCards(query, _order);
    }


    private List<Long> _findCards(String query, Object _order) {
        String[] tokens = _tokenize(query);
        Pair<String, String[]> res1 = _where(tokens);
        String preds = res1.first;
        String[] args = res1.second;
        List<Long> res = new ArrayList<>();
        if (preds == null) {
            return res;
        }
        Pair<String, Boolean> res2 = _order instanceof Boolean ? _order((Boolean) _order) : _order((String) _order);
        String order = res2.first;
        boolean rev = res2.second;
        String sql = _query(preds, order);
        Cursor cur = null;
        try {
            cur = mCol.getDb().getDatabase().rawQuery(sql, args);
            while (cur.moveToNext()) {
                res.add(cur.getLong(0));
            }
        } catch (SQLException e) {
            // invalid grouping
            return new ArrayList<>();
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        if (rev) {
            Collections.reverse(res);
        }
        return res;
    }


    public List<Long> findNotes(String query) {
        String[] tokens = _tokenize(query);
        Pair<String, String[]> res1 = _where(tokens);
        String preds = res1.first;
        String[] args = res1.second;
        List<Long> res = new ArrayList<>();
        if (preds == null) {
            return res;
        }
        if (preds.equals("")) {
            preds = "1";
        } else {
            preds = "(" + preds + ")";
        }
        String sql = "select distinct(n.id) from cards c, notes n where c.nid=n.id and " + preds;
        Cursor cur = null;
        try {
            cur = mCol.getDb().getDatabase().rawQuery(sql, args);
            while (cur.moveToNext()) {
                res.add(cur.getLong(0));
            }
        } catch (SQLException e) {
            // invalid grouping
            return new ArrayList<>();
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        return res;
    }


    /**
     * Tokenizing
     * ***********************************************************
     */

    public String[] _tokenize(String query) {
        char inQuote = 0;
        List<String> tokens = new ArrayList<>();
        String token = "";
        for (int i = 0; i < query.length(); ++i) {
            // quoted text
            char c = query.charAt(i);
            if (c == '\'' || c == '"') {
                if (inQuote != 0) {
                    if (c == inQuote) {
                        inQuote = 0;
                    } else {
                        token += c;
                    }
                } else if (token.length() != 0) {
                    // quotes are allowed to start directly after a :
                    if (token.endsWith(":")) {
                        inQuote = c;
                    } else {
                        token += c;
                    }
                } else {
                    inQuote = c;
                }
                // separator
            } else if (c == ' ') {
                if (inQuote != 0) {
                    token += c;
                } else if (token.length() != 0) {
                    // space marks token finished
                    tokens.add(token);
                    token = "";
                }
                // nesting
            } else if (c == '(' || c == ')') {
                if (inQuote != 0) {
                    token += c;
                } else {
                    if (c == ')' && token.length() != 0) {
                        tokens.add(token);
                        token = "";
                    }
                    tokens.add(String.valueOf(c));
                }
                // negation
            } else if (c == '-') {
                if (token.length() != 0) {
                    token += c;
                } else if (tokens.size() == 0 || !tokens.get(tokens.size() - 1).equals("-")) {
                    tokens.add("-");
                }
                // normal character
            } else {
                token += c;
            }
        }
        // if we finished in a token, add it
        if (token.length() != 0) {
            tokens.add(token);
        }
        return tokens.toArray(new String[tokens.size()]);
    }


    /**
     * Query building
     * ***********************************************************
     */

    /**
     * LibAnki creates a dictionary and operates on it with an inner function inside _where().
     * AnkiDroid combines the two in this class instead.
     */
    public class SearchState {
        public boolean isnot;
        public boolean isor;
        public boolean join;
        public String q = "";
        public boolean bad;
        
        public void add(String txt) {
            add(txt, true);
        }

        public void add(String txt, boolean wrap) {
            // failed command?
            if (TextUtils.isEmpty(txt)) {
                // if it was to be negated then we can just ignore it
                if (isnot) {
                    isnot = false;
                    return;
                } else {
                    bad = true;
                    return;
                }
            } else if (txt.equals("skip")) {
                return;
            }
            // do we need a conjunction?
            if (join) {
                if (isor) {
                    q += " or ";
                    isor = false;
                } else {
                    q += " and ";
                }
            }
            if (isnot) {
                q += " not ";
                isnot = false;
            }
            if (wrap) {
                txt = "(" + txt + ")";
            }
            q += txt;
            join = true;
        }
    }


    public Pair<String, String[]> _where(String[] tokens) {
        // state and query
        SearchState s = new SearchState();
        List<String> args = new ArrayList<>();
        for (String token : tokens) {
            if (s.bad) {
                return new Pair<>(null, null);
            }
            // special tokens
            if (token.equals("-")) {
                s.isnot = true;
            } else if (token.equalsIgnoreCase("or")) {
                s.isor = true;
            } else if (token.equals("(")) {
                s.add(token, false);
                s.join = false;
            } else if (token.equals(")")) {
                s.q += ")";
                // commands
            } else if (token.contains(":")) {
                String[] spl = token.split(":", 2);
                String cmd = spl[0].toLowerCase(Locale.US);
                String val = spl[1];
                
                if (cmd.equals("added")) {
                    s.add(_findAdded(val));
                } else if (cmd.equals("card")) {
                    s.add(_findTemplate(val));
                } else if (cmd.equals("deck")) {
                    s.add(_findDeck(val));
                } else if (cmd.equals("mid")) {
                    s.add(_findMid(val));
                } else if (cmd.equals("nid")) {
                    s.add(_findNids(val));
                } else if (cmd.equals("cid")) {
                    s.add(_findCids(val));
                } else if (cmd.equals("note")) {
                    s.add(_findModel(val));
                } else if (cmd.equals("prop")) {
                    s.add(_findProp(val));
                } else if (cmd.equals("rated")) {
                    s.add(_findRated(val));
                } else if (cmd.equals("tag")) {
                    s.add(_findTag(val, args));
                } else if (cmd.equals("dupe")) {
                    s.add(_findDupes(val));
                } else if (cmd.equals("is")) {
                    s.add(_findCardState(val));
                } else {
                    s.add(_findField(cmd, val));
                }
            // normal text search
            } else {
                s.add(_findText(token, args));
            }
        }
        if (s.bad) {
            return new Pair<>(null, null);
        }
        return new Pair<>(s.q, args.toArray(new String[args.size()]));
    }


    private String _query(String preds, String order) {
        // can we skip the note table?
        String sql;
        if (!preds.contains("n.") && !order.contains("n.")) {
            sql = "select c.id from cards c where ";
        } else {
            sql = "select c.id from cards c, notes n where c.nid=n.id and ";
        }
        // combine with preds
        if (!TextUtils.isEmpty(preds)) {
            sql += "(" + preds + ")";
        } else {
            sql += "1";
        }
        // order
        if (!TextUtils.isEmpty(order)) {
            sql += " " + order;
        }
        return sql;
    }


    /**
     * Ordering
     * ***********************************************************
     */

    /*
     * NOTE: In the python code, _order() follows a code path based on:
     * - Empty order string (no order)
     * - order = False (no order)
     * - Non-empty order string (custom order)
     * - order = True (built-in order)
     * The python code combines all code paths in one function. In Java, we must overload the method
     * in order to consume either a String (no order, custom order) or a Boolean (no order, built-in order).
     */
    
    private Pair<String, Boolean> _order(String order) {
        if (TextUtils.isEmpty(order)) {
            return _order(false);
        } else {
            // custom order string provided
            return new Pair<>(" order by " + order, false);
        }
    }
    
    private Pair<String, Boolean> _order(Boolean order) {
        if (!order) {
            return new Pair<>("", false);
        }
        try {
            // use deck default
            String type = mCol.getConf().getString("sortType");
            String sort = null;
            if (type.startsWith("note")) {
                if (type.startsWith("noteCrt")) {
                    sort = "n.id, c.ord";
                } else if (type.startsWith("noteMod")) {
                    sort = "n.mod, c.ord";
                } else if (type.startsWith("noteFld")) {
                    sort = "n.sfld COLLATE NOCASE, c.ord";
                }
            } else if (type.startsWith("card")) {
                if (type.startsWith("cardMod")) {
                    sort = "c.mod";
                } else if (type.startsWith("cardReps")) {
                    sort = "c.reps";
                } else if (type.startsWith("cardDue")) {
                    sort = "c.type, c.due";
                } else if (type.startsWith("cardEase")) {
                    sort = "c.factor";
                } else if (type.startsWith("cardLapses")) {
                    sort = "c.lapses";
                } else if (type.startsWith("cardIvl")) {
                    sort = "c.ivl";
                }
            }
            if (sort == null) {
            	// deck has invalid sort order; revert to noteCrt
            	sort = "n.id, c.ord";
            }
            boolean sortBackwards = mCol.getConf().getBoolean("sortBackwards");
            return new Pair<>(" ORDER BY " + sort, sortBackwards);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Commands
     * ***********************************************************
     */

    private String _findTag(String val, List<String> args) {
        if (val.equals("none")) {
            return "n.tags = \"\"";
        }
        val = val.replace("*", "%");
        if (!val.startsWith("%")) {
            val = "% " + val;
        }
        if (!val.endsWith("%")) {
            val += " %";
        }
        args.add(val);
        return "n.tags like ?";
    }


    private String _findCardState(String val) {
        int n;
        if (val.equals("review") || val.equals("new") || val.equals("learn")) {
            if (val.equals("review")) {
                n = 2;
            } else if (val.equals("new")) {
                n = 0;
            } else {
                return "queue IN (1, 3)";
            }
            return "type = " + n;
        } else if (val.equals("suspended")) {
            return "c.queue = -1";
        } else if (val.equals("buried")) {
            return "c.queue = -2";
        } else if (val.equals("due")) {
            return "(c.queue in (2,3) and c.due <= " + mCol.getSched().getToday() +
                    ") or (c.queue = 1 and c.due <= " + mCol.getSched().getDayCutoff() + ")";
        } else {
            return null;
        }
    }


    private String _findRated(String val) {
        // days(:optional_ease)
        String[] r = val.split(":");
        int days;
        try {
            days = Integer.parseInt(r[0]);
        } catch (NumberFormatException e) {
            return null;
        }
        days = Math.min(days, 31);
        // ease
        String ease = "";
        if (r.length > 1) {
            if (!Arrays.asList("1", "2", "3", "4").contains(r[1])) {
                return null;
            }
            ease = "and ease=" + r[1];
        }
        long cutoff = (mCol.getSched().getDayCutoff() - 86400 * days) * 1000;
        return "c.id in (select cid from revlog where id>" + cutoff + " " + ease + ")";
    }


    private String _findAdded(String val) {
        int days;
        try {
            days = Integer.parseInt(val);
        } catch (NumberFormatException e) {
            return null;
        }
        long cutoff = (mCol.getSched().getDayCutoff() - 86400 * days) * 1000;
        return "c.id > " + cutoff;
    }


    private String _findProp(String _val) {
        // extract
        Matcher m = fPropPattern.matcher(_val);
        if (!m.matches()) {
            return null;
        }
        String prop = m.group(1).toLowerCase(Locale.US);
        String cmp = m.group(2);
        String sval = m.group(3);
        int val;
        // is val valid?
        try {
            if (prop.equals("ease")) {
                // LibAnki does this below, but we do it here to avoid keeping a separate float value.
                val = (int)(Double.parseDouble(sval) * 1000);
            } else {
                val = Integer.parseInt(sval);
            }
        } catch (NumberFormatException e) {
            return null;
        }
        // is prop valid?
        if (!Arrays.asList("due", "ivl", "reps", "lapses", "ease").contains(prop)) {
            return null;
        }
        // query
        String q = "";
        if (prop.equals("due")) {
            val += mCol.getSched().getToday();
            // only valid for review/daily learning
            q = "(c.queue in (2,3)) and ";
        } else if (prop.equals("ease")) {
            prop = "factor";
            // already done: val = int(val*1000)
        }
        q += "(" + prop + " " + cmp + " " + val + ")";
        return q;
    }


    private String _findText(String val, List<String> args) {
        val = val.replace("*", "%");
        args.add("%" + val + "%");
        args.add("%" + val + "%");
        return "(n.sfld like ? escape '\\' or n.flds like ? escape '\\')";
    }


    private String _findNids(String val) {
        if (fNidsPattern.matcher(val).find()) {
            return null;
        }
        return "n.id in (" + val + ")";
    }


    private String _findCids(String val) {
        if (fNidsPattern.matcher(val).find()) {
            return null;
        }
        return "c.id in (" + val + ")";
    }


    private String _findMid(String val) {
        if (fMidPattern.matcher(val).find()) {
            return null;
        }
        return "n.mid = " + val;
    }


    private String _findModel(String val) {
        LinkedList<Long> ids = new LinkedList<>();
        try {
            for (JSONObject m : mCol.getModels().all()) {
                if (m.getString("name").equalsIgnoreCase(val)) {
                    ids.add(m.getLong("id"));
                }
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return "n.mid in " + Utils.ids2str(ids);
    }


    private List<Long> dids(Long did) {
        if (did == null) {
            return null;
        }
        TreeMap<String, Long> children = mCol.getDecks().children(did);
        List<Long> res = new ArrayList<>();
        res.add(did);
        res.addAll(children.values());
        return res;
    }


    public String _findDeck(String val) {
        // if searching for all decks, skip
        if (val.equals("*")) {
            return "skip";
            // deck types
        } else if (val.equals("filtered")) {
            return "c.odid";
        }
        List<Long> ids = null;
        // current deck?
        try {
            if (val.equalsIgnoreCase("current")) {
                ids = dids(mCol.getDecks().current().getLong("id"));
            } else if (!val.contains("*")) {
                // single deck
                ids = dids(mCol.getDecks().id(val, false));
            } else {
                // wildcard
                ids = new ArrayList<>();
                val = val.replace("*", ".*");
                val = val.replace("+", "\\+");
                for (JSONObject d : mCol.getDecks().all()) {
                    if (d.getString("name").matches("(?i)" + val)) {
                        for (long id : dids(d.getLong("id"))) {
                            if (!ids.contains(id)) {
                                ids.add(id);
                            }
                        }
                    }
                }
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        if (ids == null || ids.size() == 0) {
            return null;
        }
        String sids = Utils.ids2str(ids);
        return "c.did in " + sids + " or c.odid in " + sids;
    }


    private String _findTemplate(String val) {
        // were we given an ordinal number?
        Integer num = null;
        try {
            num = Integer.parseInt(val) - 1;
        } catch (NumberFormatException e) {
            num = null;
        }
        if (num != null) {
            return "c.ord = " + num;
        }
        // search for template names
        List<String> lims = new ArrayList<>();
        try {
            for (JSONObject m : mCol.getModels().all()) {
                JSONArray tmpls = m.getJSONArray("tmpls");
                for (int ti = 0; ti < tmpls.length(); ++ti) {
                    JSONObject t = tmpls.getJSONObject(ti);
                    if (t.getString("name").equalsIgnoreCase(val)) {
                        if (m.getInt("type") == Consts.MODEL_CLOZE) {
                            // if the user has asked for a cloze card, we want
                            // to give all ordinals, so we just limit to the
                            // model instead
                            lims.add("(n.mid = " + m.getLong("id") + ")");
                        } else {
                            lims.add("(n.mid = " + m.getLong("id") + " and c.ord = " +
                                    t.getInt("ord") + ")");
                        }
                    }
                }
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return TextUtils.join(" or ", lims.toArray(new String[lims.size()]));
    }


    private String _findField(String field, String val) {
        /*
         * We need two expressions to query the cards: One that will use JAVA REGEX syntax and another
         * that should use SQLITE LIKE clause syntax.
         */
        String sqlVal = val
                .replace("%","\\%") // For SQLITE, we escape all % signs
                .replace("*","%"); // And then convert the * into non-escaped % signs

        /*
         * The following three lines make sure that only _ and * are valid wildcards.
         * Any other characters are enclosed inside the \Q \E markers, which force
         * all meta-characters in between them to lose their special meaning
         */
        String javaVal = val
                    .replace("_","\\E.\\Q")
                    .replace("*","\\E.*\\Q");
        /*
         * For the pattern, we use the javaVal expression that uses JAVA REGEX syntax
         */
        Pattern pattern = Pattern.compile("\\Q" + javaVal + "\\E", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);

        // find models that have that field
        Map<Long, Object[]> mods = new HashMap<>();
        try {
            for (JSONObject m : mCol.getModels().all()) {
                JSONArray flds = m.getJSONArray("flds");
                for (int fi = 0; fi < flds.length(); ++fi) {
                    JSONObject f = flds.getJSONObject(fi);
                    if (f.getString("name").equalsIgnoreCase(field)) {
                        mods.put(m.getLong("id"), new Object[] { m, f.getInt("ord") });
                    }
                }
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        if (mods.isEmpty()) {
            // nothing has that field
            return null;
        }
        LinkedList<Long> nids = new LinkedList<>();
        Cursor cur = null;
        try {
            /*
             * Here we use the sqlVal expression, that is required for LIKE syntax in sqllite.
             * There is no problem with special characters, because only % and _ are special
             * characters in this syntax.
             */
            cur = mCol.getDb().getDatabase().rawQuery(
                    "select id, mid, flds from notes where mid in " +
                            Utils.ids2str(new LinkedList<>(mods.keySet())) +
                            " and flds like ? escape '\\'", new String[] { "%" + sqlVal + "%" });

            while (cur.moveToNext()) {
                String[] flds = Utils.splitFields(cur.getString(2));
                int ord = (Integer)mods.get(cur.getLong(1))[1];
                String strg = flds[ord];
                if (pattern.matcher(strg).matches()) {
                    nids.add(cur.getLong(0));
                }
            }
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        if (nids.isEmpty()) {
            return "0";
        }
        return "n.id in " + Utils.ids2str(nids);
    }


    private String _findDupes(String val) {
        // caller must call stripHTMLMedia on passed val
        String[] split = val.split(",", 1);
        if (split.length != 2) {
            return null;
        }
        String mid = split[0];
        val = split[1];
        String csum = Long.toString(Utils.fieldChecksum(val));
        List<Long> nids = new ArrayList<>();
        Cursor cur = null;
        try {
            cur = mCol.getDb().getDatabase().rawQuery(
                    "select id, flds from notes where mid=? and csum=?",
                    new String[] { mid, csum });
            long nid = cur.getLong(0);
            String flds = cur.getString(1);
            if (Utils.stripHTMLMedia(Utils.splitFields(flds)[0]).equals(val)) {
                nids.add(nid);
            }
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        return "n.id in " +  Utils.ids2str(nids);
    }


    /**
     * Find and replace
     * ***********************************************************
     */

    /**
     * Find and replace fields in a note
     *
     * @param col The collection to search into.
     * @param nids The cards to be searched for.
     * @param src The original text to find.
     * @param dst The text to change to.
     * @param regex If true, the src is treated as a regex. Default = false.
     * @param field Limit the search to specific field. If null, it searches all fields.
     * @param fold If true the search is case-insensitive. Default = true.
     * @return
     */
    public static int findReplace(Collection col, List<Long> nids, String src, String dst) {
        return findReplace(col, nids, src, dst, false, null, true);
    }


    public static int findReplace(Collection col, List<Long> nids, String src, String dst, boolean regex) {
        return findReplace(col, nids, src, dst, regex, null, true);
    }


    public static int findReplace(Collection col, List<Long> nids, String src, String dst, String field) {
        return findReplace(col, nids, src, dst, false, field, true);
    }


    public static int findReplace(Collection col, List<Long> nids, String src, String dst, boolean isRegex,
            String field, boolean fold) {
        Map<Long, Integer> mmap = new HashMap<>();
        if (field != null) {
            try {
                for (JSONObject m : col.getModels().all()) {
                    JSONArray flds = m.getJSONArray("flds");
                    for (int fi = 0; fi < flds.length(); ++fi) {
                        JSONObject f = flds.getJSONObject(fi);
                        if (f.getString("name").equals(field)) {
                            mmap.put(m.getLong("id"), f.getInt("ord"));
                        }
                    }
                }
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            if (mmap.isEmpty()) {
                return 0;
            }
        }
        // find and gather replacements
        if (!isRegex) {
            src = Pattern.quote(src);
        }
        if (fold) {
            src = "(?i)" + src;
        }
        Pattern regex = Pattern.compile(src);

        ArrayList<Object[]> d = new ArrayList<>();
        String snids = Utils.ids2str(nids);
        nids = new ArrayList<>();
        Cursor cur = null;
        try {
            cur = col.getDb().getDatabase().rawQuery(
                    "select id, mid, flds from notes where id in " + snids, null);
            while (cur.moveToNext()) {
                String flds = cur.getString(2);
                String origFlds = flds;
                // does it match?
                String[] sflds = Utils.splitFields(flds);
                if (field != null) {
                    long mid = cur.getLong(1);
                    if (!mmap.containsKey(mid)) {
                        // note doesn't have that field
                        continue;
                    }
                    int ord = mmap.get(mid);
                    sflds[ord] = regex.matcher(sflds[ord]).replaceAll(dst);
                } else {
                    for (int i = 0; i < sflds.length; ++i) {
                        sflds[i] = regex.matcher(sflds[i]).replaceAll(dst);
                    }
                }
                flds = Utils.joinFields(sflds);
                if (!flds.equals(origFlds)) {
                    long nid = cur.getLong(0);
                    nids.add(nid);
                    d.add(new Object[] { flds, Utils.intNow(), col.usn(), nid }); // order based on query below
                }
            }
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        if (d.isEmpty()) {
            return 0;
        }
        // replace
        col.getDb().executeMany("update notes set flds=?,mod=?,usn=? where id=?", d);
        long[] pnids = Utils.toPrimitive(nids);
        col.updateFieldCache(pnids);
        col.genCards(pnids);
        return d.size();
    }


    public List<String> fieldNames(Collection col) {
        return fieldNames(col, true);
    }

    public List<String> fieldNames(Collection col, boolean downcase) {
        Set<String> fields = new HashSet<>();
        List<String> names = new ArrayList<>();
        try {
            for (JSONObject m : col.getModels().all()) {
                JSONArray flds = m.getJSONArray("flds");
                for (int fi = 0; fi < flds.length(); ++fi) {
                    JSONObject f = flds.getJSONObject(fi);
                    if (!fields.contains(f.getString("name").toLowerCase(Locale.US))) {
                        names.add(f.getString("name"));
                        fields.add(f.getString("name").toLowerCase(Locale.US));
                    }
                }
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        if (downcase) {
            return new ArrayList<>(fields);
        }
        return names;
    }


    /**
     * Find duplicates
     * ***********************************************************
     */

    public static Integer ordForMid(Collection col, Map<Long, Integer> fields, long mid, String fieldName) {
        if (!fields.containsKey(mid)) {
            JSONObject model = col.getModels().get(mid);
            try {
                JSONArray flds = model.getJSONArray("flds");
                for (int c = 0; c < flds.length(); c++) {
                    JSONObject f = flds.getJSONObject(c);
                    if (f.getString("name").equalsIgnoreCase(fieldName)) {
                        fields.put(mid, c);
                        break;
                    }
                }
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }
        return fields.get(mid);
    }


    public static List<Pair<String, List<Long>>> findDupes(Collection col, String fieldName) {
        return findDupes(col, fieldName, "");
    }


    /**
     * @return List of Pair("dupestr", List[nids])
     */
    public static List<Pair<String, List<Long>>> findDupes(Collection col, String fieldName, String search) {
        // limit search to notes with applicable field name
    	if (!TextUtils.isEmpty(search)) {
            search = "(" + search + ") ";
    	}
        search += "'" + fieldName + ":*'";
        // go through notes
        Map<String, List<Long>> vals = new HashMap<>();
        List<Pair<String, List<Long>>> dupes = new ArrayList<>();
        Map<Long, Integer> fields = new HashMap<>();
        Cursor cur = null;
        try {
            cur = col.getDb().getDatabase().rawQuery(
                    "select id, mid, flds from notes where id in " + Utils.ids2str(col.findNotes(search)), null);
            while (cur.moveToNext()) {
                long nid = cur.getLong(0);
                long mid = cur.getLong(1);
                String[] flds = Utils.splitFields(cur.getString(2));
                Integer ord = ordForMid(col, fields, mid, fieldName);
                if (ord == null) {
                    continue;
                }
                String val = flds[fields.get(mid)];
                val = Utils.stripHTMLMedia(val);
                // empty does not count as duplicate
                if (TextUtils.isEmpty(val)) {
                    continue;
                }
                if (!vals.containsKey(val)) {
                    vals.put(val, new ArrayList<Long>());
                }
                vals.get(val).add(nid);
                if (vals.get(val).size() == 2) {
                    dupes.add(new Pair<>(val, vals.get(val)));
                }
            }
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        return dupes;
    }

    /*
     * ***********************************************************
     * The methods below are not in LibAnki.
     * ***********************************************************
     */

    public List<Map<String, String>> findCardsForCardBrowser(String query, boolean _order, Map<String, String> deckNames) {
        return _findCardsForCardBrowser(query, _order, deckNames);
    }


    public List<Map<String, String>> findCardsForCardBrowser(String query, String _order, Map<String, String> deckNames) {
        return _findCardsForCardBrowser(query, _order, deckNames);
    }


    /** Return a list of card ids for QUERY */
    private List<Map<String, String>> _findCardsForCardBrowser(String query, Object _order, Map<String, String> deckNames) {
        String[] tokens = _tokenize(query);
        Pair<String, String[]> res1 = _where(tokens);
        String preds = res1.first;
        String[] args = res1.second;
        List<Map<String, String>> res = new ArrayList<>();
        if (preds == null) {
            return res;
        }
        Pair<String, Boolean> res2 = _order instanceof Boolean ? _order((Boolean) _order) : _order((String) _order);
        String order = res2.first;
        boolean rev = res2.second;
        String sql = _queryForCardBrowser(preds, order);
        Cursor cur = null;
        try {
            cur = mCol.getDb().getDatabase().rawQuery(sql, args);
            DeckTask task = DeckTask.getInstance();
            while (cur.moveToNext()) {
                // cancel if the launching task was cancelled. 
                if (task.isCancelled()){
                    Timber.i("_findCardsForCardBrowser() cancelled...");
                    return null;
                }                
                Map<String, String> map = new HashMap<>();
                map.put("id", cur.getString(0));
                map.put("sfld", cur.getString(1));
                map.put("deck", deckNames.get(cur.getString(2)));
                int queue = cur.getInt(3);
                String tags = cur.getString(4);
                map.put("flags", Integer.toString((queue == -1 ? 1 : 0) + (tags.matches(".*[Mm]arked.*") ? 2 : 0)));
                map.put("tags", tags);
                res.add(map);
                // add placeholder for question and answer
                map.put("question", "");
                map.put("answer", "");
            }
        } catch (SQLException e) {
            // invalid grouping
            Timber.e("Invalid grouping, sql: " + sql);
            return new ArrayList<>();
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        if (rev) {
            Collections.reverse(res);
        }
        return res;
    }
    
    /**
     * A copy of _query() with a custom SQL query specific to the AnkiDroid card browser.
     */
    private String _queryForCardBrowser(String preds, String order) {
        String sql = "select c.id, n.sfld, c.did, c.queue, n.tags from cards c, notes n where c.nid=n.id and ";
        // combine with preds
        if (!TextUtils.isEmpty(preds)) {
            sql += "(" + preds + ")";
        } else {
            sql += "1";
        }
        // order
        if (!TextUtils.isEmpty(order)) {
            sql += " " + order;
        }
        return sql;
    }
}
/***************************************************************************************
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 * Copyright (c) 2015 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

import com.ichi2.libanki.hooks.Hook;
import com.ichi2.libanki.hooks.Hooks;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This class is used to detect LaTeX tags in HTML and convert them to their corresponding image
 * file names.
 *
 * Anki provides shortcut forms for certain expressions. These three forms are considered valid
 * LaTeX tags in Anki:
 * 1 - [latex]...[/latex]
 * 2 - [$]...[$]
 * 3 - [$$]...[$$]
 *
 * Unlike the original python implementation of this class, the AnkiDroid version does not support
 * the generation of LaTeX images.
 */
public class LaTeX {

    /**
     * Patterns used to identify LaTeX tags
     */
    public static Pattern sStandardPattern = Pattern.compile("\\[latex\\](.+?)\\[/latex\\]",
            Pattern.DOTALL | Pattern.CASE_INSENSITIVE);
    public static Pattern sExpressionPattern = Pattern.compile("\\[\\$\\](.+?)\\[/\\$\\]",
            Pattern.DOTALL | Pattern.CASE_INSENSITIVE);
    public static Pattern sMathPattern = Pattern.compile("\\[\\$\\$\\](.+?)\\[/\\$\\$\\]",
            Pattern.DOTALL | Pattern.CASE_INSENSITIVE);


    /**
     * Convert HTML with embedded latex tags to image links.
     * NOTE: Unlike the original python version of this method, only two parameters are required
     * in AnkiDroid. The omitted parameters are used to generate LaTeX images. AnkiDroid does not
     * support the generation of LaTeX media and the provided parameters are sufficient for all
     * other cases.
     * NOTE: _imgLink produces an alphanumeric filename so there is no need to escape the replacement string.
     */
    public static String mungeQA(String html, Collection col) {
        StringBuffer sb = new StringBuffer();
        Matcher matcher = sStandardPattern.matcher(html);
        while (matcher.find()) {
            matcher.appendReplacement(sb, _imgLink(col, matcher.group(1)));
        }
        matcher.appendTail(sb);

        matcher = sExpressionPattern.matcher(sb.toString());
        sb = new StringBuffer();
        while (matcher.find()) {
            matcher.appendReplacement(sb, _imgLink(col, "$" + matcher.group(1) + "$"));
        }
        matcher.appendTail(sb);

        matcher = sMathPattern.matcher(sb.toString());
        sb = new StringBuffer();
        while (matcher.find()) {
            matcher.appendReplacement(sb,
                    _imgLink(col, "\\begin{displaymath}" + matcher.group(1) + "\\end{displaymath}"));
        }
        matcher.appendTail(sb);

        return sb.toString();
    }


    /**
     * Return an img link for LATEX.
     */
    private static String _imgLink(Collection col, String latex) {
        String txt = _latexFromHtml(col, latex);
        String fname = "latex-" + Utils.checksum(txt) + ".png";
        return "<img class=latex src=\"" + fname + "\">";
    }


    /**
     * Convert entities and fix newlines.
     */
    private static String _latexFromHtml(Collection col, String latex) {
        latex = latex.replaceAll("<br( /)?>|<div>", "\n");
        latex = Utils.stripHTML(latex);
        return latex;
    }

    public class LaTeXFilter extends Hook {
        @Override
        public Object runFilter(Object arg, Object... args) {
            return LaTeX.mungeQA((String) arg, (Collection) args[4]);
        }
    }


    public void installHook(Hooks h) {
        h.addHook("mungeQA", new LaTeXFilter());
    }
}
/****************************************************************************************
 * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 * Copyright (c) 2014 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

import android.database.Cursor;
import android.database.SQLException;
import android.net.Uri;
import android.text.TextUtils;

import android.util.Pair;

import com.ichi2.libanki.template.Template;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

import timber.log.Timber;

/**
 * Media manager - handles the addition and removal of media files from the media directory (collection.media) and
 * maintains the media database (collection.media.ad.db2) which is used to determine the state of files for syncing.
 * Note that the media database has an additional prefix for AnkiDroid (.ad) to avoid any potential issues caused by
 * users copying the file to the desktop client and vice versa.
 * <p>
 * Unlike the python version of this module, we do not (and cannot) modify the current working directory (CWD) before
 * performing operations on media files. In python, the CWD is changed to the media directory, allowing it to easily
 * refer to the files in the media directory by name only. In Java, we must be cautious about when to specify the full
 * path to the file and when we need to use the filename only. In general, when we refer to a file on disk (i.e.,
 * creating a new File() object), we must include the full path. Use the dir() method to make this step easier.<br>
 * E.g: new File(dir(), "filename.jpg")
 */
public class Media {

    private static final Pattern fIllegalCharReg = Pattern.compile("[><:\"/?*^\\\\|\\x00\\r\\n]");
    private static final Pattern fRemotePattern  = Pattern.compile("(https?|ftp)://");

    /*
     * A note about the regular expressions below: the python code uses named groups for the image and sound patterns.
     * Our version of Java doesn't support named groups, so we must use indexes instead. In the expressions below, the
     * group names (e.g., ?P<fname>) have been stripped and a comment placed above indicating the index of the group
     * name in the original. Refer to these indexes whenever the python code makes use of a named group.
     */

    /**
     * Group 1 = Contents of [sound:] tag <br>
     * Group 2 = "fname"
     */
    private static final Pattern fSoundRegexps = Pattern.compile("(?i)(\\[sound:([^]]+)\\])");

    // src element quoted case
    /**
     * Group 1 = Contents of <img> tag <br>
     * Group 2 = "str" <br>
     * Group 3 = "fname" <br>
     * Group 4 = Backreference to "str" (i.e., same type of quote character)
     */
    private static final Pattern fImgRegExpQ = Pattern.compile("(?i)(<img[^>]* src=([\\\"'])([^>]+?)(\\2)[^>]*>)");

    // unquoted case
    /**
     * Group 1 = Contents of <img> tag <br>
     * Group 2 = "fname"
     */
    private static final Pattern fImgRegExpU = Pattern.compile("(?i)(<img[^>]* src=(?!['\\\"])([^ >]+)[^>]*?>)");

    public static List<Pattern> mRegexps =  Arrays.asList(fSoundRegexps, fImgRegExpQ, fImgRegExpU);

    private Collection mCol;
    private String mDir;
    private DB mDb;


    public Media(Collection col, boolean server) {
        mCol = col;
        if (server) {
            mDir = null;
            return;
        }
        // media directory
        mDir = col.getPath().replaceFirst("\\.anki2$", ".media");
        File fd = new File(mDir);
        if (!fd.exists()) {
            if (!fd.mkdir()) {
                Timber.e("Cannot create media directory: " + mDir);
            }
        }
        // change database
        connect();
    }


    public void connect() {
        if (mCol.getServer()) {
            return;
        }
        // NOTE: We use a custom prefix for AnkiDroid to avoid issues caused by copying
        // the db to the desktop or vice versa.
        String path = dir() + ".ad.db2";
        File dbFile = new File(path);
        boolean create = !(dbFile.exists());
        mDb = new DB(path);
        if (create) {
            _initDB();
        }
        maybeUpgrade();
    }


    public void _initDB() {
        String sql = "create table media (\n" +
                     " fname text not null primary key,\n" +
                     " csum text,           -- null indicates deleted file\n" +
                     " mtime int not null,  -- zero if deleted\n" +
                     " dirty int not null\n" +
                     ");\n" +
                     "create index idx_media_dirty on media (dirty);\n" +
                     "create table meta (dirMod int, lastUsn int); insert into meta values (0, 0);";
        mDb.executeScript(sql);
    }


    public void maybeUpgrade() {
        String oldpath = dir() + ".db";
        File oldDbFile = new File(oldpath);
        if (oldDbFile.exists()) {
            mDb.execute(String.format(Locale.US, "attach \"%s\" as old", oldpath));
            try {
                String sql = "insert into media\n" +
                             " select m.fname, csum, mod, ifnull((select 1 from log l2 where l2.fname=m.fname), 0) as dirty\n" +
                             " from old.media m\n" +
                             " left outer join old.log l using (fname)\n" +
                             " union\n" +
                             " select fname, null, 0, 1 from old.log where type=1;";
                mDb.execute(sql);
                mDb.execute("delete from meta");
                mDb.execute("insert into meta select dirMod, usn from old.meta");
                mDb.commit();
            } catch (Exception e) {
                // if we couldn't import the old db for some reason, just start anew
                StringWriter sw = new StringWriter();
                e.printStackTrace(new PrintWriter(sw));
                mCol.log("failed to import old media db:" + sw.toString());
            }
            mDb.execute("detach old");
            File newDbFile = new File(oldpath + ".old");
            if (newDbFile.exists()) {
                newDbFile.delete();
            }
            oldDbFile.renameTo(newDbFile);
        }
    }


    public void close() {
        if (mCol.getServer()) {
            return;
        }
        mDb.close();
        mDb = null;
    }


    public String dir() {
        return mDir;
    }


    /**
     * Adding media
     * ***********************************************************
     */

    /**
     * In AnkiDroid, adding a media file will not only copy it to the media directory, but will also insert an entry
     * into the media database marking it as a new addition.
     */
    public String addFile(File ofile) throws IOException {
        String fname = writeData(ofile);
        markFileAdd(fname);
        return fname;
    }


    /**
     * Copy a file to the media directory and return the filename it was stored as.
     * <p>
     * Unlike the python version of this method, we don't read the file into memory as a string. All our operations are
     * done on streams opened on the file, so there is no second parameter for the string object here.
     */
    private String writeData(File ofile) throws IOException {
        // get the file name
        String fname = ofile.getName();
        // make sure we write it in NFC form and return an NFC-encoded reference
        fname = Utils.nfcNormalized(fname);
        // remove any dangerous characters
        String base = stripIllegal(fname);
        String[] split = Utils.splitFilename(base);
        String root = split[0];
        String ext = split[1];
        // find the first available name
        String csum = Utils.fileChecksum(ofile);
        while (true) {
            fname = root + ext;
            File path = new File(dir(), fname);
            // if it doesn't exist, copy it directly
            if (!path.exists()) {
                Utils.copyFile(ofile, path);
                return fname;
            }
            // if it's identical, reuse
            if (Utils.fileChecksum(path).equals(csum)) {
                return fname;
            }
            // otherwise, increment the index in the filename
            Pattern reg = Pattern.compile(" \\((\\d+)\\)$");
            Matcher m = reg.matcher(root);
            if (!m.find()) {
                root = root + " (1)";
            } else {
                int n = Integer.parseInt(m.group(1));
                root = String.format(Locale.US, " (%d)", n + 1);
            }
        }
    }


    /**
     * String manipulation
     * ***********************************************************
     */

    public List<String> filesInStr(Long mid, String string) {
        return filesInStr(mid, string, false);
    }


    /**
     * Extract media filenames from an HTML string.
     *
     * @param string The string to scan for media filenames ([sound:...] or <img...>).
     * @param includeRemote If true will also include external http/https/ftp urls.
     * @return A list containing all the sound and image filenames found in the input string.
     */
    public List<String> filesInStr(Long mid, String string, boolean includeRemote) {
        List<String> l = new ArrayList<>();
        JSONObject model = mCol.getModels().get(mid);
        List<String> strings = new ArrayList<>();
        try {
            if (model.getInt("type") == Consts.MODEL_CLOZE && string.contains("{{c")) {
                // if the field has clozes in it, we'll need to expand the
                // possibilities so we can render latex
                strings = _expandClozes(string);
            } else {
                strings.add(string);
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }

        for (String s : strings) {
            // handle latex
            s =  LaTeX.mungeQA(s, mCol);
            // extract filenames
            Matcher m;
            for (Pattern p : mRegexps) {
                // NOTE: python uses the named group 'fname'. Java doesn't have named groups, so we have to determine
                // the index based on which pattern we are using
                int fnameIdx = p == fSoundRegexps ? 2 : p == fImgRegExpU ? 2 : 3;
                m = p.matcher(s);
                while (m.find()) {
                    String fname = m.group(fnameIdx);
                    boolean isLocal = !fRemotePattern.matcher(fname.toLowerCase(Locale.US)).find();
                    if (isLocal || includeRemote) {
                        l.add(fname);
                    }
                }
            }
        }
        return l;
    }


    private List<String> _expandClozes(String string) {
        Set<String> ords = new TreeSet<>();
        Matcher m = Pattern.compile("\\{\\{c(\\d+)::.+?\\}\\}").matcher(string);
        while (m.find()) {
            ords.add(m.group(1));
        }
        ArrayList<String> strings = new ArrayList<>();
        String clozeReg = Template.clozeReg;
        
        for (String ord : ords) {
            StringBuffer buf = new StringBuffer();
            m = Pattern.compile(String.format(Locale.US, clozeReg, ord)).matcher(string);
            while (m.find()) {
                if (!TextUtils.isEmpty(m.group(3))) {
                    m.appendReplacement(buf, "[$3]");
                } else {
                    m.appendReplacement(buf, "[...]");
                }
            }
            m.appendTail(buf);
            String s = buf.toString().replaceAll(String.format(Locale.US, clozeReg, ".+?"), "$1");
            strings.add(s);
        }
        strings.add(string.replaceAll(String.format(Locale.US, clozeReg, ".+?"), "$1"));
        return strings;
    }


    /**
     * Strips a string from media references.
     *
     * @param txt The string to be cleared of media references.
     * @return The media-free string.
     */
    public String strip(String txt) {
        for (Pattern p : mRegexps) {
            txt = p.matcher(txt).replaceAll("");
        }
        return txt;
    }


    public String escapeImages(String string) {
        return escapeImages(string, false);
    }


    /**
     * Percent-escape UTF-8 characters in local image filenames.
     * @param string The string to search for image references and escape the filenames.
     * @return The string with the filenames of any local images percent-escaped as UTF-8.
     */
    public String escapeImages(String string, boolean unescape) {
        for (Pattern p : Arrays.asList(fImgRegExpQ, fImgRegExpU)) {
            Matcher m = p.matcher(string);
            // NOTE: python uses the named group 'fname'. Java doesn't have named groups, so we have to determine
            // the index based on which pattern we are using
            int fnameIdx = p == fImgRegExpU ? 2 : 3;
            while (m.find()) {
                String tag = m.group(0);
                String fname = m.group(fnameIdx);
                if (fRemotePattern.matcher(fname).find()) {
                    //dont't do any escaping if remote image
                } else {
                    if (unescape) {
                        string = string.replace(tag,tag.replace(fname, Uri.decode(fname)));
                    } else {
                        string = string.replace(tag,tag.replace(fname, Uri.encode(fname)));
                    }
                }
            }
        }
        return string;
    }


    /**
     * Rebuilding DB
     * ***********************************************************
     */

    /**
     * Finds missing, unused and invalid media files
     *
     * @return A list containing three lists of files (missingFiles, unusedFiles, invalidFiles)
     */
    public List<List<String>> check() {
        return check(null);
    }


    private List<List<String>> check(File[] local) {
        File mdir = new File(dir());
        // gather all media references in NFC form
        Set<String> allRefs = new HashSet<>();
        Cursor cur = null;
        try {
            cur = mCol.getDb().getDatabase().rawQuery("select id, mid, flds from notes", null);
            while (cur.moveToNext()) {
                long nid = cur.getLong(0);
                long mid = cur.getLong(1);
                String flds = cur.getString(2);
                List<String> noteRefs = filesInStr(mid, flds);
                // check the refs are in NFC
                for (String f : noteRefs) {
                    // if they're not, we'll need to fix them first
                    if (!f.equals(Utils.nfcNormalized(f))) {
                        _normalizeNoteRefs(nid);
                        noteRefs = filesInStr(mid, flds);
                        break;
                    }
                }
                allRefs.addAll(noteRefs);
            }
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        // loop through media folder
        List<String> unused = new ArrayList<>();
        List<String> invalid = new ArrayList<>();
        File[] files;
        if (local == null) {
            files = mdir.listFiles();
        } else {
            files = local;
        }
        boolean renamedFiles = false;
        for (File file : files) {
            if (local == null) {
                if (file.isDirectory()) {
                    // ignore directories
                    continue;
                }
            }
            if (file.getName().startsWith("_")) {
                // leading _ says to ignore file
                continue;
            }
            File nfcFile = new File(dir(), Utils.nfcNormalized(file.getName()));
            // we enforce NFC fs encoding
            if (local == null) {
                if (!file.getName().equals(nfcFile.getName())) {
                    // delete if we already have the NFC form, otherwise rename
                    if (nfcFile.exists()) {
                        file.delete();
                        renamedFiles = true;
                    } else {
                        file.renameTo(nfcFile);
                        renamedFiles = true;
                    }
                    file = nfcFile;
                }
            }
            // compare
            if (!allRefs.contains(nfcFile.getName())) {
                unused.add(file.getName());
            } else {
                allRefs.remove(nfcFile.getName());
            }
        }
        // if we renamed any files to nfc format, we must rerun the check
        // to make sure the renamed files are not marked as unused
        if (renamedFiles) {
            return check(local);
        }
        List<String> nohave = new ArrayList<>();
        for (String x : allRefs) {
            if (!x.startsWith("_")) {
                nohave.add(x);
            }
        }
        List<List<String>> result = new ArrayList<>();
        result.add(nohave);
        result.add(unused);
        result.add(invalid);
        return result;
    }


    private void _normalizeNoteRefs(long nid) {
        Note note = mCol.getNote(nid);
        String[] flds = note.getFields();
        for (int c = 0; c < flds.length; c++) {
            String fld = flds[c];
            String nfc = Utils.nfcNormalized(fld);
            if (!nfc.equals(fld)) {
                note.setField(c, nfc);
            }
        }
        note.flush();
    }


    /**
     * Copying on import
     * ***********************************************************
     */

    public boolean have(String fname) {
        return new File(dir(), fname).exists();
    }

    /**
     * Illegal characters
     * ***********************************************************
     */

    public String stripIllegal(String str) {
        Matcher m = fIllegalCharReg.matcher(str);
        return m.replaceAll("");
    }


    public boolean hasIllegal(String str) {
        Matcher m = fIllegalCharReg.matcher(str);
        return m.find();
    }


    /**
     * Tracking changes
     * ***********************************************************
     */

    /**
     * Scan the media folder if it's changed, and note any changes.
     */
    public void findChanges() {
        findChanges(false);
    }


    /**
     * @param force Unconditionally scan the media folder for changes (i.e., ignore differences in recorded and current
     *            directory mod times). Use this when rebuilding the media database.
     */
    public void findChanges(boolean force) {
        if (force || _changed() != null) {
            _logChanges();
        }
    }


    public boolean haveDirty() {
        return mDb.queryScalar("select 1 from media where dirty=1 limit 1") > 0;
    }


    /**
     * Returns the number of seconds from epoch since the last modification to the file in path. Important: this method
     * does not automatically append the root media directory to the path; the FULL path of the file must be specified.
     *
     * @param path The path to the file we are checking. path can be a file or a directory.
     * @return The number of seconds (rounded down).
     */
    private long _mtime(String path) {
        File f = new File(path);
        return f.lastModified() / 1000;
    }


    private String _checksum(String path) {
        return Utils.fileChecksum(path);
    }


    /**
     * Return dir mtime if it has changed since the last findChanges()
     * Doesn't track edits, but user can add or remove a file to update
     * 
     * @return The modification time of the media directory if it has changed since the last call of findChanges(). If
     *         it hasn't, it returns null.
     */
    public Long _changed() {
        long mod = mDb.queryLongScalar("select dirMod from meta");
        long mtime = _mtime(dir());
        if (mod != 0 && mod == mtime) {
            return null;
        }
        return mtime;
    }


    private void _logChanges()  {
        Pair<List<String>, List<String>> result = _changes();
        List<String> added = result.first;
        List<String> removed = result.second;
        ArrayList<Object[]> media = new ArrayList<>();
        for (String f : added) {
            String path = new File(dir(), f).getAbsolutePath();
            long mt = _mtime(path);
            media.add(new Object[] { f, _checksum(path), mt, 1 });
        }
        for (String f : removed) {
            media.add(new Object[] { f, null, 0, 1});
        }
        // update media db
        mDb.executeMany("insert or replace into media values (?,?,?,?)", media);
        mDb.execute("update meta set dirMod = ?", new Object[] { _mtime(dir()) });
        mDb.commit();
    }


    private Pair<List<String>, List<String>> _changes() {
        Map<String, Object[]> cache = new HashMap<>();
        Cursor cur = null;
        try {
            cur = mDb.getDatabase().rawQuery("select fname, csum, mtime from media where csum is not null", null);
            while (cur.moveToNext()) {
                String name = cur.getString(0);
                String csum = cur.getString(1);
                Long mod = cur.getLong(2);
                cache.put(name, new Object[] { csum, mod, false });
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        List<String> added = new ArrayList<>();
        List<String> removed = new ArrayList<>();
        // loop through on-disk files
        for (File f : new File(dir()).listFiles()) {
            // ignore folders and thumbs.db
            if (f.isDirectory()) {
                continue;
            }
            String fname = f.getName();
            if (fname.equalsIgnoreCase("thumbs.db")) {
                continue;
            }
            // and files with invalid chars
            if (hasIllegal(fname)) {
                continue;
            }
            // empty files are invalid; clean them up and continue
            long sz = f.length();
            if (sz == 0) {
                f.delete();
                continue;
            }
            if (sz > 100*1024*1024) {
                mCol.log("ignoring file over 100MB", f);
                continue;
            }
            // check encoding
            String normf = Utils.nfcNormalized(fname);
            if (!fname.equals(normf)) {
                // wrong filename encoding which will cause sync errors
                File nf = new File(dir(), normf);
                if (nf.exists()) {
                    f.delete();
                } else {
                    f.renameTo(nf);
                }
            }
            // newly added?
            if (!cache.containsKey(fname)) {
                added.add(fname);
            } else {
                // modified since last time?
                if (_mtime(f.getAbsolutePath()) != (Long) cache.get(fname)[1]) {
                    // and has different checksum?
                    if (!_checksum(f.getAbsolutePath()).equals(cache.get(fname)[0])) {
                        added.add(fname);
                    }
                }
                // mark as used
                cache.get(fname)[2] = true;
            }
        }
        // look for any entries in the cache that no longer exist on disk
        for (String fname : cache.keySet()) {
            if (!((Boolean)cache.get(fname)[2])) {
                removed.add(fname);
            }
        }
        return new Pair<>(added, removed);
    }


    /**
     * Syncing related
     * ***********************************************************
     */

    public int lastUsn() {
        return mDb.queryScalar("select lastUsn from meta");
    }


    public void setLastUsn(int usn) {
        mDb.execute("update meta set lastUsn = ?", new Object[] { usn });
        mDb.commit();
    }


    public Pair<String, Integer> syncInfo(String fname) {
        Cursor cur = null;
        try {
            cur = mDb.getDatabase().rawQuery("select csum, dirty from media where fname=?", new String[] { fname });
            if (cur.moveToNext()) {
                String csum = cur.getString(0);
                int dirty = cur.getInt(1);
                return new Pair<>(csum, dirty);
            } else {
                return new Pair<>(null, 0);
            }
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
    }


    public void markClean(List<String> fnames) {
        for (String fname : fnames) {
            mDb.execute("update media set dirty=0 where fname=?", new Object[] { fname });
        }
    }


    public void syncDelete(String fname) {
        File f = new File(dir(), fname);
        if (f.exists()) {
            f.delete();
        }
        mDb.execute("delete from media where fname=?", new Object[] { fname });
    }


    public int mediacount() {
        return mDb.queryScalar("select count() from media where csum is not null");
    }


    public int dirtyCount() {
        return mDb.queryScalar("select count() from media where dirty=1");
    }


    public void forceResync() {
        mDb.execute("delete from media");
        mDb.execute("update meta set lastUsn=0,dirMod=0");
        mDb.execute("vacuum");
        mDb.execute("analyze");
        mDb.commit();
    }


    /**
     * Media syncing: zips
     * ***********************************************************
     */

    /**
     * Unlike python, our temp zip file will be on disk instead of in memory. This avoids storing
     * potentially large files in memory which is not feasible with Android's limited heap space.
     * <p>
     * Notes:
     * <p>
     * - The maximum size of the changes zip is decided by the constant SYNC_ZIP_SIZE. If a media file exceeds this
     * limit, only that file (in full) will be zipped to be sent to the server.
     * <p>
     * - This method will be repeatedly called from MediaSyncer until there are no more files (marked "dirty" in the DB)
     * to send.
     * <p>
     * - Since AnkiDroid avoids scanning the media folder on every sync, it is possible for a file to be marked as a
     * new addition but actually have been deleted (e.g., with a file manager). In this case we skip over the file
     * and mark it as removed in the database. (This behaviour differs from the desktop client).
     * <p>
     */
    public Pair<File, List<String>> mediaChangesZip() {
        File f = new File(mCol.getPath().replaceFirst("collection\\.anki2$", "tmpSyncToServer.zip"));
        Cursor cur = null;
        try {
            ZipOutputStream z = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(f)));
            z.setMethod(ZipOutputStream.DEFLATED);

            List<String> fnames = new ArrayList<>();
            // meta is a list of (fname, zipname), where zipname of null is a deleted file
            // NOTE: In python, meta is a list of tuples that then gets serialized into json and added
            // to the zip as a string. In our version, we use JSON objects from the start to avoid the
            // serialization step. Instead of a list of tuples, we use JSONArrays of JSONArrays.
            JSONArray meta = new JSONArray();
            int sz = 0;
            byte buffer[] = new byte[2048];
            cur = mDb.getDatabase().rawQuery(
                    "select fname, csum from media where dirty=1 limit " + Consts.SYNC_ZIP_COUNT, null);

            for (int c = 0; cur.moveToNext(); c++) {
                String fname = cur.getString(0);
                String csum = cur.getString(1);
                fnames.add(fname);
                String normname = Utils.nfcNormalized(fname);

                if (!TextUtils.isEmpty(csum)) {
                    try {
                        mCol.log("+media zip " + fname);
                        File file = new File(dir(), fname);
                        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file), 2048);
                        z.putNextEntry(new ZipEntry(Integer.toString(c)));
                        int count = 0;
                        while ((count = bis.read(buffer, 0, 2048)) != -1) {
                            z.write(buffer, 0, count);
                        }
                        z.closeEntry();
                        bis.close();
                        meta.put(new JSONArray().put(normname).put(Integer.toString(c)));
                        sz += file.length();
                    } catch (FileNotFoundException e) {
                        // A file has been marked as added but no longer exists in the media directory.
                        // Skip over it and mark it as removed in the db.
                        removeFile(fname);
                    }
                } else {
                    mCol.log("-media zip " + fname);
                    meta.put(new JSONArray().put(normname).put(""));
                }
                if (sz >= Consts.SYNC_ZIP_SIZE) {
                    break;
                }
            }

            z.putNextEntry(new ZipEntry("_meta"));
            z.write(Utils.jsonToString(meta).getBytes());
            z.closeEntry();
            z.close();
            // Don't leave lingering temp files if the VM terminates.
            f.deleteOnExit();
            return new Pair<>(f, fnames);
        } catch (IOException e) {
            Timber.e("Failed to create media changes zip", e);
            throw new RuntimeException(e);
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
    }


    /**
     * Extract zip data; return the number of files extracted. Unlike the python version, this method consumes a
     * ZipFile stored on disk instead of a String buffer. Holding the entire downloaded data in memory is not feasible
     * since some devices can have very limited heap space.
     *
     * This method closes the file before it returns.
     */
    public int addFilesFromZip(ZipFile z) throws IOException {
        try {
            List<Object[]> media = new ArrayList<>();
            // get meta info first
            JSONObject meta = new JSONObject(Utils.convertStreamToString(z.getInputStream(z.getEntry("_meta"))));
            // then loop through all files
            int cnt = 0;
            for (ZipEntry i : Collections.list(z.entries())) {
                if (i.getName().equals("_meta")) {
                    // ignore previously-retrieved meta
                    continue;
                } else {
                    String name = meta.getString(i.getName());
                    // normalize name for platform
                    name = Utils.nfcNormalized(name);
                    // save file
                    String destPath = dir().concat(File.separator).concat(name);
                    Utils.writeToFile(z.getInputStream(i), destPath);
                    String csum = Utils.fileChecksum(destPath);
                    // update db
                    media.add(new Object[] {name, csum, _mtime(destPath), 0});
                    cnt += 1;
                }
            }
            if (media.size() > 0) {
                mDb.executeMany("insert or replace into media values (?,?,?,?)", media);
            }
            return cnt;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        } finally {
            z.close();
        }
    }


    /*
     * ***********************************************************
     * The methods below are not in LibAnki.
     * ***********************************************************
     */

    /**
     * Used by unit tests only.
     */
    public DB getDb() {
        return mDb;
    }


    /**
     * Used by other classes to determine the index of a regular expression group named "fname"
     * (Anki2Importer needs this). This is needed because we didn't implement the "transformNames"
     * function and have delegated its job to the caller of this class.
     */
    public static int indexOfFname(Pattern p) {
        int fnameIdx = p == fSoundRegexps ? 2 : p == fImgRegExpU ? 2 : 3;
        return fnameIdx;
    }


    /**
     * Add an entry into the media database for file named fname, or update it
     * if it already exists.
     */
    public void markFileAdd(String fname) {
        Timber.d("Marking media file addition in media db: %s", fname);
        String path = new File(dir(), fname).getAbsolutePath();
        mDb.execute("insert or replace into media values (?,?,?,?)",
                new Object[] { fname, _checksum(path), _mtime(path), 1 });
    }


    /**
     * Remove a file from the media directory if it exists and mark it as removed in the media database.
     */
    public void removeFile(String fname) {
        File f = new File(dir(), fname);
        if (f.exists()) {
            f.delete();
        }
        Timber.d("Marking media file removal in media db: %s", fname);
        mDb.execute("insert or replace into media values (?,?,?,?)",
                new Object[] { fname, null, 0, 1 });
    }


    /**
     * @return True if the media db has not been populated yet.
     */
    public boolean needScan() {
        long mod = mDb.queryLongScalar("select dirMod from meta");
        if (mod == 0) {
            return true;
        } else {
            return false;
        }
    }
}
/****************************************************************************************
 * Copyright (c) 2009 Daniel Sv盲rd <daniel.svard@gmail.com>                             *
 * Copyright (c) 2010 Rick Gruber-Riemer <rick@vanosten.net>                            *
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

import android.content.ContentValues;
import android.database.Cursor;
import android.util.Pair;

import com.ichi2.anki.exception.ConfirmModSchemaException;
import com.ichi2.libanki.template.Template;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Models {
    private static final Pattern fClozePattern1 = Pattern.compile("\\{\\{[^}]*?cloze:(?:[^}]?:)*(.+?)\\}\\}");
    private static final Pattern fClozePattern2 = Pattern.compile("<%cloze:(.+?)%>");
    private static final Pattern fClozeOrdPattern = Pattern.compile("\\{\\{c(\\d+)::.+?\\}\\}");


    public static final String defaultModel =
              "{'sortf': 0, "
            + "'did': 1, "
            + "'latexPre': \""
            + "\\\\documentclass[12pt]{article}\\n"
            + "\\\\special{papersize=3in,5in}\\n"
            + "\\\\usepackage[utf8]{inputenc}\\n"
            + "\\\\usepackage{amssymb,amsmath}\\n"
            + "\\\\pagestyle{empty}\\n"
            + "\\\\setlength{\\\\parindent}{0in}\\n"
            + "\\\\begin{document}\\n"
            + "\", "
            + "'latexPost': \"\\\\end{document}\", "
            + "'mod': 0, "
            + "'usn': 0, "
            + "'vers': [], " // FIXME: remove when other clients have caught up
            + "'type': "
            + Consts.MODEL_STD
            + ", "
            + "'css': \".card {\\n"
            + " font-family: arial;\\n"
            + " font-size: 20px;\\n"
            + " text-align: center;\\n"
            + " color: black;\\n"
            + " background-color: white;\\n"
            + "}\""
            + "}";

    private static final String defaultField = "{'name': \"\", " + "'ord': null, " + "'sticky': False, " +
    // the following alter editing, and are used as defaults for the template wizard
            "'rtl': False, " + "'font': \"Arial\", " + "'size': 20, " +
            // reserved for future use
            "'media': [] }";

    private static final String defaultTemplate = "{'name': \"\", " + "'ord': null, " + "'qfmt': \"\", "
            + "'afmt': \"\", " + "'did': null, " + "'bqfmt': \"\"," + "'bafmt': \"\"," + "'bfont': \"Arial\"," +
            "'bsize': 12 }";

    // /** Regex pattern used in removing tags from text before diff */
    // private static final Pattern sFactPattern = Pattern.compile("%\\([tT]ags\\)s");
    // private static final Pattern sModelPattern = Pattern.compile("%\\(modelTags\\)s");
    // private static final Pattern sTemplPattern = Pattern.compile("%\\(cardModel\\)s");

    private Collection mCol;
    private boolean mChanged;
    private HashMap<Long, JSONObject> mModels;

    // BEGIN SQL table entries
    private int mId;
    private String mName = "";
    private long mCrt = Utils.intNow();
    private long mMod = Utils.intNow();
    private JSONObject mConf;
    private String mCss = "";
    private JSONArray mFields;
    private JSONArray mTemplates;
    // BEGIN SQL table entries

    // private Decks mDeck;
    // private DB mDb;
    //
    /** Map for compiled Mustache Templates */
    private Map<String, Template> mCmpldTemplateMap = new HashMap<>();


    //
    // /** Map for convenience and speed which contains FieldNames from current model */
    // private TreeMap<String, Integer> mFieldMap = new TreeMap<String, Integer>();
    //
    // /** Map for convenience and speed which contains Templates from current model */
    // private TreeMap<Integer, JSONObject> mTemplateMap = new TreeMap<Integer, JSONObject>();
    //
    // /** Map for convenience and speed which contains the CSS code related to a Template */
    // private HashMap<Integer, String> mCssTemplateMap = new HashMap<Integer, String>();
    //
    // /**
    // * The percentage chosen in preferences for font sizing at the time when the css for the CardModels related to
    // this
    // * Model was calculated in prepareCSSForCardModels.
    // */
    // private transient int mDisplayPercentage = 0;
    // private boolean mNightMode = false;

    /**
     * Saving/loading registry
     * ***********************************************************************************************
     */

    public Models(Collection col) {
        mCol = col;
    }


    /**
     * Load registry from JSON.
     */
    public void load(String json) {
        mChanged = false;
        mModels = new HashMap<>();
        try {
            JSONObject modelarray = new JSONObject(json);
            JSONArray ids = modelarray.names();
            if (ids != null) {
                for (int i = 0; i < ids.length(); i++) {
                    String id = ids.getString(i);
                    JSONObject o = modelarray.getJSONObject(id);
                    mModels.put(o.getLong("id"), o);
                }
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Mark M modified if provided, and schedule registry flush.
     */
    public void save() {
        save(null, false);
    }


    public void save(JSONObject m) {
        save(m, false);
    }

    /**
     * Save a model
     * @param m model to save
     * @param templates flag which (when true) re-generates the cards for each note which uses the model
     */
    public void save(JSONObject m, boolean templates) {
        if (m != null && m.has("id")) {
            try {
                m.put("mod", Utils.intNow());
                m.put("usn", mCol.usn());
                // TODO: fix empty id problem on _updaterequired (needed for model adding)
                if (m.getLong("id") != 0) {
                    _updateRequired(m);
                }
                if (templates) {
                    _syncTemplates(m);
                }
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }
        mChanged = true;
        // The following hook rebuilds the tree in the Anki Desktop browser -- we don't need it
        // runHook("newModel")
    }


    /**
     * Flush the registry if any models were changed.
     */
    public void flush() {
        if (mChanged) {
            JSONObject array = new JSONObject();
            try {
                for (Map.Entry<Long, JSONObject> o : mModels.entrySet()) {
                    array.put(Long.toString(o.getKey()), o.getValue());
                }
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            ContentValues val = new ContentValues();
            val.put("models", Utils.jsonToString(array));
            mCol.getDb().update("col", val);
            mChanged = false;
        }
    }


    /**
     * Retrieving and creating models
     * ***********************************************************************************************
     */

    /**
     * Get current model.
     * @return The JSONObject of the model, or null if not found in the deck and in the configuration.
     */
    public JSONObject current() {
        return current(true);
    }

    /**
     * Get current model.
     * @param forDeck If true, it tries to get the deck specified in deck by mid, otherwise or if the former is not
     *                found, it uses the configuration`s field curModel.
     * @return The JSONObject of the model, or null if not found in the deck and in the configuration.
     */
    public JSONObject current(boolean forDeck) {
        JSONObject m = null;
        if (forDeck) {
            m = get(mCol.getDecks().current().optLong("mid", -1));
        }
        if (m == null) {
            m = get(mCol.getConf().optLong("curModel", -1));
        }
        if (m == null) {
            if (!mModels.isEmpty()) {
                m = mModels.values().iterator().next();
            }
        }
        return m;
    }


    public void setCurrent(JSONObject m) {
        try {
            mCol.getConf().put("curModel", m.get("id"));
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        mCol.setMod();
    }


    /** get model with ID, or none. */
    public JSONObject get(long id) {
        if (mModels.containsKey(id)) {
            return mModels.get(id);
        } else {
            return null;
        }
    }


    /** get all models */
    public ArrayList<JSONObject> all() {
        ArrayList<JSONObject> models = new ArrayList<>();
        for (JSONObject jsonObject : mModels.values()) {
            models.add(jsonObject);
        }
        return models;
    }


    /** get model with NAME. */
    public JSONObject byName(String name) {
        for (JSONObject m : mModels.values()) {
            try {
                if (m.getString("name").equals(name)) {
                    return m;
                }
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }
        return null;
    }


    /** Create a new model, save it in the registry, and return it. */
    public JSONObject newModel(String name) {
        // caller should call save() after modifying
        JSONObject m;
        try {
            m = new JSONObject(defaultModel);
            m.put("name", name);
            m.put("mod", Utils.intNow());
            m.put("flds", new JSONArray());
            m.put("tmpls", new JSONArray());
            m.put("tags", new JSONArray());
            m.put("id", 0);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return m;
    }


    /** Delete model, and all its cards/notes. 
     * @throws ConfirmModSchemaException */
    public void rem(JSONObject m) throws ConfirmModSchemaException {
        mCol.modSchema(true);
        try {
            long id = m.getLong("id");
            boolean current = current().getLong("id") == id;
            // delete notes/cards
            mCol.remCards(Utils.arrayList2array(mCol.getDb().queryColumn(Long.class,
                    "SELECT id FROM cards WHERE nid IN (SELECT id FROM notes WHERE mid = " + id + ")", 0)));
            // then the model
            mModels.remove(id);
            save();
            // GUI should ensure last model is not deleted
            if (current) {
                setCurrent(mModels.values().iterator().next());
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public void add(JSONObject m) {
        _setID(m);
        update(m);
        setCurrent(m);
        save(m);
    }


    /** Add or update an existing model. Used for syncing and merging. */
    public void update(JSONObject m) {
        try {
            mModels.put(m.getLong("id"), m);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        // mark registry changed, but don't bump mod time
        save();
    }


    private void _setID(JSONObject m) {
        long id = Utils.intNow(1000);
        while (mModels.containsKey(id)) {
            id = Utils.intNow(1000);
        }
        try {
            m.put("id", id);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public boolean have(long id) {
        return mModels.containsKey(id);
    }


    public long[] ids() {
        Iterator<Long> it = mModels.keySet().iterator();
        long[] ids = new long[mModels.size()];
        int i = 0;
        while (it.hasNext()) {
            ids[i] = it.next();
            i++;
        }
        return ids;
    }


    /**
     * Tools ***********************************************************************************************
     */

    /** Note ids for M */
    public ArrayList<Long> nids(JSONObject m) {
        try {
            return mCol.getDb().queryColumn(Long.class, "SELECT id FROM notes WHERE mid = " + m.getLong("id"), 0);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Number of notes using m
     * @param m The model to the count the notes of.
     * @return The number of notes with that model.
     */
    public int useCount(JSONObject m) {
        try {
            return mCol.getDb().queryScalar("select count() from notes where mid = " + m.getLong("id"));
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Number of notes using m
     * @param m The model to the count the notes of.
     * @param ord The index of the card template
     * @return The number of notes with that model.
     */
    public int tmplUseCount(JSONObject m, int ord) {
        try {
            return mCol.getDb().queryScalar("select count() from cards, notes where cards.nid = notes.id and notes.mid = " + m.getLong("id") + " and cards.ord = " + ord);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Copying ***********************************************************************************************
     */

    /** Copy, save and return. */
    public JSONObject copy(JSONObject m) {
        JSONObject m2 = null;
        try {
            m2 = new JSONObject(Utils.jsonToString(m));
            m2.put("name", m2.getString("name") + " copy");
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        add(m2);
        return m2;
    }


    /**
     * Fields ***********************************************************************************************
     */

    public JSONObject newField(String name) {
        JSONObject f;
        try {
            f = new JSONObject(defaultField);
            f.put("name", name);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return f;
    }


    /** "Mapping of field name -> (ord, field). */
    public Map<String, Pair<Integer, JSONObject>> fieldMap(JSONObject m) {
        JSONArray ja;
        try {
            ja = m.getJSONArray("flds");
            // TreeMap<Integer, String> map = new TreeMap<Integer, String>();
            Map<String, Pair<Integer, JSONObject>> result = new HashMap<>();
            for (int i = 0; i < ja.length(); i++) {
                JSONObject f = ja.getJSONObject(i);
                result.put(f.getString("name"), new Pair<>(f.getInt("ord"), f));
            }
            return result;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public ArrayList<String> fieldNames(JSONObject m) {
        JSONArray ja;
        try {
            ja = m.getJSONArray("flds");
            ArrayList<String> names = new ArrayList<>();
            for (int i = 0; i < ja.length(); i++) {
                names.add(ja.getJSONObject(i).getString("name"));
            }
            return names;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }

    }


    public int sortIdx(JSONObject m) {
        try {
            return m.getInt("sortf");
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public void setSortIdx(JSONObject m, int idx) throws ConfirmModSchemaException{
        try {
            mCol.modSchema(true);
            m.put("sortf", idx);
            mCol.updateFieldCache(Utils.toPrimitive(nids(m)));
            save(m);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public void addField(JSONObject m, JSONObject field) throws ConfirmModSchemaException {
        // only mod schema if model isn't new
        try {
            if (m.getLong("id") != 0) {
                mCol.modSchema(true);
            }
            JSONArray ja = m.getJSONArray("flds");
            ja.put(field);
            m.put("flds", ja);
            _updateFieldOrds(m);
            save(m);
            _transformFields(m, new TransformFieldAdd());
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }

    }

    class TransformFieldAdd implements TransformFieldVisitor {
        @Override
        public String[] transform(String[] fields) {
            String[] f = new String[fields.length + 1];
            System.arraycopy(fields, 0, f, 0, fields.length);
            f[fields.length] = "";
            return f;
        }
    }


    public void remField(JSONObject m, JSONObject field) throws ConfirmModSchemaException {
        mCol.modSchema(true);
        try {
            JSONArray ja = m.getJSONArray("flds");
            JSONArray ja2 = new JSONArray();
            int idx = -1;
            for (int i = 0; i < ja.length(); ++i) {
                if (field.equals(ja.getJSONObject(i))) {
                    idx = i;
                    continue;
                }
                ja2.put(ja.get(i));
            }
            m.put("flds", ja2);
            int sortf = m.getInt("sortf");
            if (sortf >= m.getJSONArray("flds").length()) {
                m.put("sortf", sortf - 1);
            }
            _updateFieldOrds(m);
            _transformFields(m, new TransformFieldDelete(idx));
            if (idx == sortIdx(m)) {
                // need to rebuild
                mCol.updateFieldCache(Utils.toPrimitive(nids(m)));
            }
            renameField(m, field, null);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }

    }

    class TransformFieldDelete implements TransformFieldVisitor {
        private int idx;


        public TransformFieldDelete(int _idx) {
            idx = _idx;
        }


        @Override
        public String[] transform(String[] fields) {
            ArrayList<String> fl = new ArrayList<>(Arrays.asList(fields));
            fl.remove(idx);
            return fl.toArray(new String[fl.size()]);
        }
    }


    public void moveField(JSONObject m, JSONObject field, int idx) throws ConfirmModSchemaException {
        mCol.modSchema(true);
        try {
            JSONArray ja = m.getJSONArray("flds");
            ArrayList<JSONObject> l = new ArrayList<>();
            int oldidx = -1;
            for (int i = 0; i < ja.length(); ++i) {
                l.add(ja.getJSONObject(i));
                if (field.equals(ja.getJSONObject(i))) {
                    oldidx = i;
                    if (idx == oldidx) {
                        return;
                    }
                }
            }
            // remember old sort field
            String sortf = Utils.jsonToString(m.getJSONArray("flds").getJSONObject(m.getInt("sortf")));
            // move
            l.remove(oldidx);
            l.add(idx, field);
            m.put("flds", new JSONArray(l));
            // restore sort field
            ja = m.getJSONArray("flds");
            for (int i = 0; i < ja.length(); ++i) {
                if (Utils.jsonToString(ja.getJSONObject(i)).equals(sortf)) {
                    m.put("sortf", i);
                    break;
                }
            }
            _updateFieldOrds(m);
            save(m);
            _transformFields(m, new TransformFieldMove(idx, oldidx));
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }

    }

    class TransformFieldMove implements TransformFieldVisitor {
        private int idx;
        private int oldidx;


        public TransformFieldMove(int _idx, int _oldidx) {
            idx = _idx;
            oldidx = _oldidx;
        }


        @Override
        public String[] transform(String[] fields) {
            String val = fields[oldidx];
            ArrayList<String> fl = new ArrayList<>(Arrays.asList(fields));
            fl.remove(oldidx);
            fl.add(idx, val);
            return fl.toArray(new String[fl.size()]);
        }
    }


    public void renameField(JSONObject m, JSONObject field, String newName) throws ConfirmModSchemaException {
        mCol.modSchema(true);
        try {
            String pat = String.format("\\{\\{([^{}]*)([:#^/]|[^:#/^}][^:}]*?:|)%s\\}\\}",
                    Pattern.quote(field.getString("name")));
            if (newName == null) {
                newName = "";
            }
            String repl = "{{$1$2" + newName + "}}";

            JSONArray tmpls = m.getJSONArray("tmpls");
            for (int i = 0; i < tmpls.length(); ++i) {
                JSONObject t = tmpls.getJSONObject(i);
                for (String fmt : new String[] { "qfmt", "afmt" }) {
                    if (!newName.equals("")) {
                        t.put(fmt, t.getString(fmt).replaceAll(pat, repl));
                    } else {
                        t.put(fmt, t.getString(fmt).replaceAll(pat, ""));
                    }
                }
            }
            field.put("name", newName);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        save(m);
    }


    public void _updateFieldOrds(JSONObject m) {
        JSONArray ja;
        try {
            ja = m.getJSONArray("flds");
            for (int i = 0; i < ja.length(); i++) {
                JSONObject f = ja.getJSONObject(i);
                f.put("ord", i);
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }

    interface TransformFieldVisitor {
        public String[] transform(String[] fields);
    }


    public void _transformFields(JSONObject m, TransformFieldVisitor fn) {
        // model hasn't been added yet?
        try {
            if (m.getLong("id") == 0) {
                return;
            }
            ArrayList<Object[]> r = new ArrayList<>();
            Cursor cur = null;

            try {
                cur = mCol.getDb().getDatabase()
                        .rawQuery("select id, flds from notes where mid = " + m.getLong("id"), null);
                while (cur.moveToNext()) {
                    r.add(new Object[] {
                            Utils.joinFields(fn.transform(Utils.splitFields(cur.getString(1)))),
                            Utils.intNow(), mCol.usn(), cur.getLong(0) });
                }
            } finally {
                if (cur != null) {
                    cur.close();
                }
            }
            mCol.getDb().executeMany("update notes set flds=?,mod=?,usn=? where id = ?", r);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Templates ***********************************************************************************************
     */

    public JSONObject newTemplate(String name) {
        JSONObject t;
        try {
            t = new JSONObject(defaultTemplate);
            t.put("name", name);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return t;
    }


    /** Note: should col.genCards() afterwards. 
     * @throws ConfirmModSchemaException */
    public void addTemplate(JSONObject m, JSONObject template) throws ConfirmModSchemaException {
        try {
            if (m.getLong("id") != 0) {
                mCol.modSchema(true);
            }
            JSONArray ja = m.getJSONArray("tmpls");
            ja.put(template);
            m.put("tmpls", ja);
            _updateTemplOrds(m);
            save(m);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Removing a template
     *
     * @return False if removing template would leave orphan notes.
     * @throws ConfirmModSchemaException 
     */
    public boolean remTemplate(JSONObject m, JSONObject template) throws ConfirmModSchemaException {
        try {
            assert (m.getJSONArray("tmpls").length() > 1);
            // find cards using this template
            JSONArray ja = m.getJSONArray("tmpls");
            int ord = -1;
            for (int i = 0; i < ja.length(); ++i) {
                if (ja.get(i).equals(template)) {
                    ord = i;
                    break;
                }
            }
            String sql = "select c.id from cards c, notes f where c.nid=f.id and mid = " +
                    m.getLong("id") + " and ord = " + ord;
            long[] cids = Utils.toPrimitive(mCol.getDb().queryColumn(Long.class, sql, 0));
            // all notes with this template must have at least two cards, or we could end up creating orphaned notes
            sql = "select nid, count() from cards where nid in (select nid from cards where id in " +
                    Utils.ids2str(cids) + ") group by nid having count() < 2 limit 1";
            if (mCol.getDb().queryScalar(sql) != 0) {
                return false;
            }
            // ok to proceed; remove cards
            mCol.modSchema(true);
            mCol.remCards(cids);
            // shift ordinals
            mCol.getDb()
                    .execute(
                            "update cards set ord = ord - 1, usn = ?, mod = ? where nid in (select id from notes where mid = ?) and ord > ?",
                            new Object[] { mCol.usn(), Utils.intNow(), m.getLong("id"), ord });
            JSONArray tmpls = m.getJSONArray("tmpls");
            JSONArray ja2 = new JSONArray();
            for (int i = 0; i < tmpls.length(); ++i) {
                if (template.equals(tmpls.getJSONObject(i))) {
                    continue;
                }
                ja2.put(tmpls.get(i));
            }
            m.put("tmpls", ja2);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        _updateTemplOrds(m);
        save(m);
        return true;
    }


    public void _updateTemplOrds(JSONObject m) {
        JSONArray ja;
        try {
            ja = m.getJSONArray("tmpls");
            for (int i = 0; i < ja.length(); i++) {
                JSONObject f = ja.getJSONObject(i);
                f.put("ord", i);
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public void moveTemplate(JSONObject m, JSONObject template, int idx) {
        try {
            JSONArray ja = m.getJSONArray("tmpls");
            int oldidx = -1;
            ArrayList<JSONObject> l = new ArrayList<>();
            HashMap<Integer, Integer> oldidxs = new HashMap<>();
            for (int i = 0; i < ja.length(); ++i) {
                if (ja.get(i).equals(template)) {
                    oldidx = i;
                    if (idx == oldidx) {
                        return;
                    }
                }
                JSONObject t = ja.getJSONObject(i);
                oldidxs.put(t.hashCode(), t.getInt("ord"));
                l.add(t);
            }
            l.remove(oldidx);
            l.add(idx, template);
            m.put("tmpls", new JSONArray(l));
            _updateTemplOrds(m);
            // generate change map - We use StringBuilder
            StringBuilder sb = new StringBuilder();
            ja = m.getJSONArray("tmpls");
            for (int i = 0; i < ja.length(); ++i) {
                JSONObject t = ja.getJSONObject(i);
                sb.append("when ord = ").append(oldidxs.get(t.hashCode())).append(" then ").append(t.getInt("ord"));
                if (i != ja.length() - 1) {
                    sb.append(" ");
                }
            }
            // apply
            save(m);
            mCol.getDb().execute("update cards set ord = (case " + sb.toString() +
            		" end),usn=?,mod=? where nid in (select id from notes where mid = ?)",
                    new Object[] { mCol.usn(), Utils.intNow(), m.getLong("id") });
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    private void _syncTemplates(JSONObject m) {
        ArrayList<Long> rem = mCol.genCards(Utils.arrayList2array(nids(m)));
    }


    /**
     * Model changing ***********************************************************************************************
     */

    /**
     * Change a model
     * @param m The model to change.
     * @param nids The list of notes that the change applies to.
     * @param newModel For replacing the old model with another one. Should be self if the model is not changing
     * @param fmap Map for switching fields. This is ord->ord and there should not be duplicate targets
     * @param cmap Map for switching cards. This is ord->ord and there should not be duplicate targets
     * @throws ConfirmModSchemaException 
     */
    public void change(JSONObject m, long[] nids, JSONObject newModel, Map<Integer, Integer> fmap, Map<Integer, Integer> cmap) throws ConfirmModSchemaException {
        mCol.modSchema(true);
        try {
            assert (newModel.getLong("id") == m.getLong("id")) || (fmap != null && cmap != null);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        if (fmap != null) {
            _changeNotes(nids, newModel, fmap);
        }
        if (cmap != null) {
            _changeCards(nids, m, newModel, cmap);
        }
        mCol.genCards(nids);
    }

    private void _changeNotes(long[] nids, JSONObject newModel, Map<Integer, Integer> map) {
        List<Object[]> d = new ArrayList<>();
        int nfields;
        long mid;
        try {
            nfields = newModel.getJSONArray("flds").length();
            mid = newModel.getLong("id");
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        Cursor cur = null;
        try {
            cur = mCol.getDb().getDatabase().rawQuery(
                    "select id, flds from notes where id in ".concat(Utils.ids2str(nids)), null);
            while (cur.moveToNext()) {
                long nid = cur.getLong(0);
                String[] flds = Utils.splitFields(cur.getString(1));
                Map<Integer, String> newflds = new HashMap<>();

                for (Integer old : map.keySet()) {
                    newflds.put(map.get(old), flds[old]);
                }
                List<String> flds2 = new ArrayList<>();
                for (int c = 0; c < nfields; ++c) {
                    if (newflds.containsKey(c)) {
                        flds2.add(newflds.get(c));
                    } else {
                        flds2.add("");
                    }
                }
                String joinedFlds = Utils.joinFields(flds2.toArray(new String[flds2.size()]));
                d.add(new Object[] { joinedFlds, mid, Utils.intNow(), mCol.usn(), nid });
            }
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        mCol.getDb().executeMany("update notes set flds=?,mid=?,mod=?,usn=? where id = ?", d);
        mCol.updateFieldCache(nids);
    }

    private void _changeCards(long[] nids, JSONObject oldModel, JSONObject newModel, Map<Integer, Integer> map) {
        List<Object[]> d = new ArrayList<>();
        List<Long> deleted = new ArrayList<>();
        Cursor cur = null;
        int omType;
        int nmType;
        int nflds;
        try {
            omType = oldModel.getInt("type");
            nmType = newModel.getInt("type");
            nflds = newModel.getJSONArray("tmpls").length();
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        try {
            cur = mCol.getDb().getDatabase().rawQuery(
                    "select id, ord from cards where nid in ".concat(Utils.ids2str(nids)), null);
            while (cur.moveToNext()) {
                // if the src model is a cloze, we ignore the map, as the gui doesn't currently
                // support mapping them
                Integer newOrd;
                long cid = cur.getLong(0);
                int ord = cur.getInt(1);
                if (omType == Consts.MODEL_CLOZE) {
                    newOrd = cur.getInt(1);
                    if (nmType != Consts.MODEL_CLOZE) {
                        // if we're mapping to a regular note, we need to check if
                        // the destination ord is valid
                        if (nflds <= ord) {
                            newOrd = null;
                        }
                    }
                } else {
                    // mapping from a regular note, so the map should be valid
                    newOrd = map.get(ord);
                }
                if (newOrd != null) {
                    d.add(new Object[] { newOrd, mCol.usn(), Utils.intNow(), cid });
                } else {
                    deleted.add(cid);
                }
            }
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        mCol.getDb().executeMany("update cards set ord=?,usn=?,mod=? where id=?", d);
        mCol.remCards(Utils.toPrimitive(deleted));
    }

    /**
     * Schema hash ***********************************************************************************************
     */

    /** Return a hash of the schema, to see if models are compatible. */
    public String scmhash(JSONObject m) {
        String s = "";
        try {
        	JSONArray flds = m.getJSONArray("flds");
            for (int i = 0; i < flds.length(); ++i) {
                s += flds.getJSONObject(i).getString("name");
            }
            JSONArray tmpls = m.getJSONArray("tmpls");
            for (int i = 0; i < tmpls.length(); ++i) {
            	JSONObject t = tmpls.getJSONObject(i);
                s += t.getString("name");
           }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return Utils.checksum(s);
    }


    /**
     * Required field/text cache
     * ***********************************************************************************************
     */

    private void _updateRequired(JSONObject m) {
        try {
            if (m.getInt("type") == Consts.MODEL_CLOZE) {
                // nothing to do
                return;
            }
            JSONArray req = new JSONArray();
            ArrayList<String> flds = new ArrayList<>();
            JSONArray fields;
            fields = m.getJSONArray("flds");
            for (int i = 0; i < fields.length(); i++) {
                flds.add(fields.getJSONObject(i).getString("name"));
            }
            JSONArray templates = m.getJSONArray("tmpls");
            for (int i = 0; i < templates.length(); i++) {
                JSONObject t = templates.getJSONObject(i);
                Object[] ret = _reqForTemplate(m, flds, t);
                JSONArray r = new JSONArray();
                r.put(t.getInt("ord"));
                r.put(ret[0]);
                r.put(ret[1]);
                req.put(r);
            }
            m.put("req", req);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    private Object[] _reqForTemplate(JSONObject m, ArrayList<String> flds, JSONObject t) {
        try {
            ArrayList<String> a = new ArrayList<>();
            ArrayList<String> b = new ArrayList<>();
            for (String f : flds) {
                a.add("ankiflag");
                b.add("");
            }
            Object[] data;
            data = new Object[] {1L, 1L, m.getLong("id"), 1L, t.getInt("ord"), "",
                    Utils.joinFields(a.toArray(new String[a.size()])) };
            String full = mCol._renderQA(data).get("q");
            data = new Object[] {1L, 1L, m.getLong("id"), 1L, t.getInt("ord"), "",
                    Utils.joinFields(b.toArray(new String[b.size()])) };
            String empty = mCol._renderQA(data).get("q");
            // if full and empty are the same, the template is invalid and there is no way to satisfy it
            if (full.equals(empty)) {
                return new Object[] { "none", new JSONArray(), new JSONArray() };
            }
            String type = "all";
            JSONArray req = new JSONArray();
            ArrayList<String> tmp = new ArrayList<>();
            for (int i = 0; i < flds.size(); i++) {
                tmp.clear();
                tmp.addAll(a);
                tmp.set(i, "");
                data[6] = Utils.joinFields(tmp.toArray(new String[tmp.size()]));
                // if no field content appeared, field is required
                if (!mCol._renderQA(data).get("q").contains("ankiflag")) {
                    req.put(i);
                }
            }
            if (req.length() > 0) {
                return new Object[] { type, req };
            }
            // if there are no required fields, switch to any mode
            type = "any";
            req = new JSONArray();
            for (int i = 0; i < flds.size(); i++) {
                tmp.clear();
                tmp.addAll(b);
                tmp.set(i, "1");
                data[6] = Utils.joinFields(tmp.toArray(new String[tmp.size()]));
                // if not the same as empty, this field can make the card non-blank
                if (!mCol._renderQA(data).get("q").equals(empty)) {
                    req.put(i);
                }
            }
            return new Object[] { type, req };
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /** Given a joined field string, return available template ordinals */
    public ArrayList<Integer> availOrds(JSONObject m, String flds) {
        try {
            if (m.getInt("type") == Consts.MODEL_CLOZE) {
                return _availClozeOrds(m, flds);
            }
            String[] fields = Utils.splitFields(flds);
            for (String f : fields) {
                f = f.trim();
            }
            ArrayList<Integer> avail = new ArrayList<>();
            JSONArray reqArray = m.getJSONArray("req");
            for (int i = 0; i < reqArray.length(); i++) {
                JSONArray sr = reqArray.getJSONArray(i);

                int ord = sr.getInt(0);
                String type = sr.getString(1);
                JSONArray req = sr.getJSONArray(2);

                if (type.equals("none")) {
                    // unsatisfiable template
                    continue;
                } else if (type.equals("all")) {
                    // AND requirement?
                    boolean ok = true;
                    for (int j = 0; j < req.length(); j++) {
                        int idx = req.getInt(j);
                        if (fields[idx] == null || fields[idx].length() == 0) {
                            // missing and was required
                            ok = false;
                            break;
                        }
                    }
                    if (!ok) {
                        continue;
                    }
                } else if (type.equals("any")) {
                    // OR requirement?
                    boolean ok = false;
                    for (int j = 0; j < req.length(); j++) {
                        int idx = req.getInt(j);
                        if (fields[idx] != null && fields[idx].length() != 0) {
                            // missing and was required
                            ok = true;
                            break;
                        }
                    }
                    if (!ok) {
                        continue;
                    }
                }
                avail.add(ord);
            }
            return avail;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public ArrayList<Integer> _availClozeOrds(JSONObject m, String flds) {
        return _availClozeOrds(m, flds, true);
    }


    public ArrayList<Integer> _availClozeOrds(JSONObject m, String flds, boolean allowEmpty) {
        String[] sflds = Utils.splitFields(flds);
        Map<String, Pair<Integer, JSONObject>> map = fieldMap(m);
        Set<Integer> ords = new HashSet<>();
        List<String> matches = new ArrayList<>();
        Matcher mm;
        try {
            mm = fClozePattern1.matcher(m.getJSONArray("tmpls").getJSONObject(0).getString("qfmt"));
            while (mm.find()) {
                matches.add(mm.group(1));
            }
            mm = fClozePattern2.matcher(m.getJSONArray("tmpls").getJSONObject(0).getString("qfmt"));
            while (mm.find()) {
                matches.add(mm.group(1));
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        for (String fname : matches) {
            if (!map.containsKey(fname)) {
                continue;
            }
            int ord = map.get(fname).first;
            mm = fClozeOrdPattern.matcher(sflds[ord]);
            while (mm.find()) {
                ords.add(Integer.parseInt(mm.group(1)) - 1);
            }
        }
        if (ords.contains(-1)) {
            ords.remove(-1);
        }
        if (ords.isEmpty() && allowEmpty) {
            // empty clozes use first ord
            return new ArrayList<>(Arrays.asList(new Integer[]{0}));
        }
        return new ArrayList<>(ords);
    }


    /**
     * Sync handling ***********************************************************************************************
     */

    public void beforeUpload() {
        try {
            for (JSONObject m : all()) {
                m.put("usn", 0);
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        save();
    }


    /**
     * Routines from Stdmodels.py
     * *
     * @throws ConfirmModSchemaException **********************************************************************************************
     */

    public static JSONObject addBasicModel(Collection col) throws ConfirmModSchemaException {
        return addBasicModel(col, "Basic");
    }


    public static JSONObject addBasicModel(Collection col, String name) throws ConfirmModSchemaException {
        Models mm = col.getModels();
        JSONObject m = mm.newModel(name);
        JSONObject fm = mm.newField("Front");
        mm.addField(m, fm);
        fm = mm.newField("Back");
        mm.addField(m, fm);
        JSONObject t = mm.newTemplate("Card 1");
        try {
            t.put("qfmt", "{{Front}}");
            t.put("afmt", "{{FrontSide}}\n\n<hr id=answer>\n\n{{Back}}");
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        mm.addTemplate(m, t);
        mm.add(m);
        return m;
    }

    /* Forward & Reverse */

    public static JSONObject addForwardReverse(Collection col) throws ConfirmModSchemaException {
    	String name = "Basic (and reversed card)";
        Models mm = col.getModels();
        JSONObject m = addBasicModel(col);
        try {
            m.put("name", name);
            JSONObject t = mm.newTemplate("Card 2");
            t.put("qfmt", "{{Back}}");
            t.put("afmt", "{{FrontSide}}\n\n<hr id=answer>\n\n{{Front}}");
            mm.addTemplate(m, t);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return m;
    }


    /* Forward & Optional Reverse */

    public static JSONObject addForwardOptionalReverse(Collection col) throws ConfirmModSchemaException {
    	String name = "Basic (optional reversed card)";
        Models mm = col.getModels();
        JSONObject m = addBasicModel(col);
        try {
            m.put("name", name);
            JSONObject fm = mm.newField("Add Reverse");
            mm.addField(m, fm);
            JSONObject t = mm.newTemplate("Card 2");
            t.put("qfmt", "{{#Add Reverse}}{{Back}}{{/Add Reverse}}");
            t.put("afmt", "{{FrontSide}}\n\n<hr id=answer>\n\n{{Front}}");
            mm.addTemplate(m, t);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return m;
    }


    public static JSONObject addClozeModel(Collection col) throws ConfirmModSchemaException {
        Models mm = col.getModels();
        JSONObject m = mm.newModel("Cloze");
        try {
            m.put("type", Consts.MODEL_CLOZE);
            String txt = "Text";
            JSONObject fm = mm.newField(txt);
            mm.addField(m, fm);
            fm = mm.newField("Extra");
            mm.addField(m, fm);
            JSONObject t = mm.newTemplate("Cloze");
            String fmt = "{{cloze:" + txt + "}}";
            m.put("css", m.getString("css") + ".cloze {" + "font-weight: bold;" + "color: blue;" + "}");
            t.put("qfmt", fmt);
            t.put("afmt", fmt + "<br>\n{{Extra}}");
            mm.addTemplate(m, t);
            mm.add(m);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return m;
    }


    /**
     * Other stuff NOT IN LIBANKI
     * ***********************************************************************************************
     */

    public void setChanged() {
        mChanged = true;
    }


    public HashMap<Long, HashMap<Integer, String>> getTemplateNames() {
        HashMap<Long, HashMap<Integer, String>> result = new HashMap<>();
        for (JSONObject m : mModels.values()) {
            JSONArray templates;
            try {
                templates = m.getJSONArray("tmpls");
                HashMap<Integer, String> names = new HashMap<>();
                for (int i = 0; i < templates.length(); i++) {
                    JSONObject t = templates.getJSONObject(i);
                    names.put(t.getInt("ord"), t.getString("name"));
                }
                result.put(m.getLong("id"), names);
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }
        return result;
    }


    /**
     * @return the ID
     */
    public int getId() {
        return mId;
    }


    /**
     * @return the name
     */
    public String getName() {
        return mName;
    }


    public HashMap<Long, JSONObject> getModels() {
        return mModels;
    }

    /** Validate model entries. */
	public boolean validateModel() {
        for (Entry<Long, JSONObject> longJSONObjectEntry : mModels.entrySet()) {
            if (!validateBrackets(longJSONObjectEntry.getValue())) {
                return false;
            }
        }
		return true;
	}

	/** Check if there is a right bracket for every left bracket. */
	private boolean validateBrackets(JSONObject value) {
		String s = value.toString();
		int count = 0;
		boolean inQuotes = false;
		char[] ar = s.toCharArray();
		for (int i = 0; i < ar.length; i++) {
			char c = ar[i];
			// if in quotes, do not count
			if (c == '"' && (i == 0 || (ar[i-1] != '\\'))) {
				inQuotes = !inQuotes;
				continue;
			}
			if (inQuotes) {
				continue;
			}
			switch(c) {
			case '{':
				count++;
				break;
			case '}':
				count--;
				if (count < 0) {
					return false;
				}
				break;
			}
		}
		return (count == 0);
	}
}
/****************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2014 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

import android.database.Cursor;

import android.util.Pair;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;


public class Note implements Cloneable {

    private Collection mCol;

    private long mId;
    private String mGuId;
    private JSONObject mModel;
    private long mMid;
    private List<String> mTags;
    private String[] mFields;
    private int mFlags;
    private String mData;
    private Map<String, Pair<Integer, JSONObject>> mFMap;
    private long mScm;
    private int mUsn;
    private long mMod;
    private boolean mNewlyAdded;

    
    public Note(Collection col, Long id) {
        this(col, null, id);
    }


    public Note(Collection col, JSONObject model) {
        this(col, model, null);
    }


    public Note(Collection col, JSONObject model, Long id) {
        assert !(model != null && id != null);
        mCol = col;
        if (id != null) {
            mId = id;
            load();
        } else {
            mId = Utils.timestampID(mCol.getDb(), "notes");
            mGuId = Utils.guid64();
            mModel = model;
            try {
                mMid = model.getLong("id");
                mTags = new ArrayList<>();
                mFields = new String[model.getJSONArray("flds").length()];
                Arrays.fill(mFields, "");
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            mFlags = 0;
            mData = "";
            mFMap = mCol.getModels().fieldMap(mModel);
            mScm = mCol.getScm();
        }
    }


    public void load() {
        Cursor cursor = null;
        try {
            cursor = mCol.getDb().getDatabase()
                    .rawQuery("SELECT guid, mid, mod, usn, tags, flds, flags, data FROM notes WHERE id = " + mId, null);
            if (!cursor.moveToFirst()) {
                throw new RuntimeException("Notes.load(): No result from query for note " + mId);
            }
            mGuId = cursor.getString(0);
            mMid = cursor.getLong(1);
            mMod = cursor.getLong(2);
            mUsn = cursor.getInt(3);
            mTags = mCol.getTags().split(cursor.getString(4));
            mFields = Utils.splitFields(cursor.getString(5));
            mFlags = cursor.getInt(6);
            mData = cursor.getString(7);
            mModel = mCol.getModels().get(mMid);
            mFMap = mCol.getModels().fieldMap(mModel);
            mScm = mCol.getScm();
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }


    /*
     * If fields or tags have changed, write changes to disk.
     */
    public void flush() {
    	flush(null);
    }

    public void flush(Long mod) {
        flush(mod, true);
    }

    public void flush(Long mod, boolean changeUsn) {
        assert mScm == mCol.getScm();
        _preFlush();
        if (changeUsn) {
            mUsn = mCol.usn();
        }
        String sfld = Utils.stripHTMLMedia(mFields[mCol.getModels().sortIdx(mModel)]);
        String tags = stringTags();
        String fields = joinedFields();
        if (mod == null && mCol.getDb().queryScalar(
                "select 1 from notes where id = ? and tags = ? and flds = ?",
                new String[]{Long.toString(mId), tags, fields}) > 0) {
            return;
        }
        long csum = Utils.fieldChecksum(mFields[0]);
        mMod = mod != null ? mod : Utils.intNow();
        mCol.getDb().execute("insert or replace into notes values (?,?,?,?,?,?,?,?,?,?,?)",
                new Object[] { mId, mGuId, mMid, mMod, mUsn, tags, fields, sfld, csum, mFlags, mData });
        mCol.getTags().register(mTags);
        _postFlush();
    }

    public String joinedFields() {
        return Utils.joinFields(mFields);
    }


    public ArrayList<Card> cards() {
        ArrayList<Card> cards = new ArrayList<>();
        Cursor cur = null;
        try {
            cur = mCol.getDb().getDatabase()
                    .rawQuery("SELECT id FROM cards WHERE nid = " + mId + " ORDER BY ord", null);
            while (cur.moveToNext()) {
                cards.add(mCol.getCard(cur.getLong(0)));
            }
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        return cards;
    }


    public JSONObject model() {
        return mModel;
    }


    /**
     * Dict interface
     * ***********************************************************
     */

    public String[] keys() {
        return (String[])mFMap.keySet().toArray();
    }


    public String[] values() {
        return mFields;
    }


    public String[][] items() {
        // TODO: Revisit this method. The field order returned differs from Anki.
        // The items here are only used in the note editor, so it's a low priority.
        String[][] result = new String[mFMap.size()][2];
        for (String fname : mFMap.keySet()) {
            int i = mFMap.get(fname).first;
            result[i][0] = fname;
            result[i][1] = mFields[i];
        }
        return result;
    }


    private int _fieldOrd(String key) {
        return mFMap.get(key).first;
    }


    public String getItem(String key) {
        return mFields[_fieldOrd(key)];
    }


    public void setItem(String key, String value) {
        mFields[_fieldOrd(key)] = value;
    }
    
    public boolean contains(String key) {
    	return mFMap.containsKey(key);
    }


    /**
     * Tags
     * ***********************************************************
     */

    public boolean hasTag(String tag) {
        return mCol.getTags().inList(tag, mTags);
    }


    public String stringTags() {
        return mCol.getTags().join(mCol.getTags().canonify(mTags));
    }


    public void setTagsFromStr(String str) {
        mTags = mCol.getTags().split(str);
    }


    public void delTag(String tag) {
        List<String> rem = new LinkedList<>();
        for (String t : mTags) {
            if (t.equalsIgnoreCase(tag)) {
                rem.add(t);
            }
        }
        for (String r : rem) {
            mTags.remove(r);
        }
    }


    /*
     *  duplicates will be stripped on save
     */
    public void addTag(String tag) {
        mTags.add(tag);
    }


    /**
     * Unique/duplicate check
     * ***********************************************************
     */

    /**
     * 
     * @return 1 if first is empty; 2 if first is a duplicate, null otherwise.
     */
    public Integer dupeOrEmpty() {
        String val = mFields[0];
        if (val.trim().length() == 0) {
            return 1;
        }
        long csum = Utils.fieldChecksum(val);
        // find any matching csums and compare
        for (String flds : mCol.getDb().queryColumn(
                String.class,
                "SELECT flds FROM notes WHERE csum = " + csum + " AND id != " + (mId != 0 ? mId : 0) + " AND mid = "
                        + mMid, 0)) {
            if (Utils.stripHTMLMedia(
                    Utils.splitFields(flds)[0]).equals(Utils.stripHTMLMedia(mFields[0]))) {
                return 2;
            }
        }
        return null;
    }


    /**
     * Flushing cloze notes
     * ***********************************************************
     */

    /*
     * have we been added yet?
     */
    private void _preFlush() {
        mNewlyAdded = mCol.getDb().queryScalar("SELECT 1 FROM cards WHERE nid = " + mId) == 0;
    }


    /*
     * generate missing cards
     */
    private void _postFlush() {
        if (!mNewlyAdded) {
            mCol.genCards(new long[] { mId });
        }
    }

    /*
     * ***********************************************************
     * The methods below are not in LibAnki.
     * ***********************************************************
     */

    public long getMid() {
        return mMid;
    }


    /**
     * @return the mId
     */
    public long getId() {
        // TODO: Conflicting method name and return value. Reconsider.
        return mId;
    }


    public Collection getCol() {
        return mCol;
    }


    public String getSFld() {
        return mCol.getDb().queryString("SELECT sfld FROM notes WHERE id = " + mId);
    }


    public String[] getFields() {
        return mFields;
    }


    public void setField(int index, String value) {
        mFields[index] = value;
    }


    public long getMod() {
        return mMod;
    }


    public Note clone() {
        try {
            return (Note)super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }


    public List<String> getTags() {
        return mTags;
    }
}
/****************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 * Copyright (c) 2013 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General private License as published by the Free Software       *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General private License for more details.            *
 *                                                                                      *
 * You should have received a copy of the GNU General private License along with        *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

import android.app.Activity;
import android.content.Context;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteConstraintException;
import android.graphics.Typeface;
import android.text.SpannableStringBuilder;
import android.text.TextUtils;
import android.text.style.StyleSpan;

import com.ichi2.anki.R;
import com.ichi2.libanki.hooks.Hooks;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.lang.ref.WeakReference;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Random;

import timber.log.Timber;

public class Sched {



    // Not in libanki
    private static final int[] FACTOR_ADDITION_VALUES = { -150, 0, 150 };

    private String mName = "std";
    private boolean mHaveCustomStudy = true;
    private boolean mSpreadRev = true;
    private boolean mBurySiblingsOnAnswer = true;

    private Collection mCol;
    private int mQueueLimit;
    private int mReportLimit;
    private int mReps;
    private boolean mHaveQueues;
    private int mToday;
    public long mDayCutoff;

    private int mNewCount;
    private int mLrnCount;
    private int mRevCount;

    private int mNewCardModulus;

    private double[] mEtaCache = new double[] { -1, -1, -1, -1 };

    // Queues
    private final LinkedList<Long> mNewQueue = new LinkedList<>();
    private final LinkedList<long[]> mLrnQueue = new LinkedList<>();
    private final LinkedList<Long> mLrnDayQueue = new LinkedList<>();
    private final LinkedList<Long> mRevQueue = new LinkedList<>();

    private LinkedList<Long> mNewDids;
    private LinkedList<Long> mLrnDids;
    private LinkedList<Long> mRevDids;

    // Not in libanki
    private WeakReference<Activity> mContextReference;

    /**
     * queue types: 0=new/cram, 1=lrn, 2=rev, 3=day lrn, -1=suspended, -2=buried
     * revlog types: 0=lrn, 1=rev, 2=relrn, 3=cram
     * positive revlog intervals are in days (rev), negative in seconds (lrn)
     */

    public Sched(Collection col) {
        mCol = col;
        mQueueLimit = 50;
        mReportLimit = 1000;
        mReps = 0;
        mHaveQueues = false;
        _updateCutoff();
    }


    /**
     * Pop the next card from the queue. None if finished.
     */
    public Card getCard() {
        _checkDay();
        if (!mHaveQueues) {
            reset();
        }
        Card card = _getCard();
        if (card != null) {
            mCol.log(card);
            if (!mBurySiblingsOnAnswer) {
                _burySiblings(card);
            }
            mReps += 1;
            card.startTimer();
            return card;
        }
        return null;
    }


    public void reset() {
        _updateCutoff();
        _resetLrn();
        _resetRev();
        _resetNew();
        mHaveQueues = true;
    }


    public void answerCard(Card card, int ease) {
        mCol.log();
        mCol.markReview(card);
        if (mBurySiblingsOnAnswer) {
            _burySiblings(card);
        }
        card.setReps(card.getReps() + 1);
        // former is for logging new cards, latter also covers filt. decks
        card.setWasNew((card.getType() == 0));
        boolean wasNewQ = (card.getQueue() == 0);
        if (wasNewQ) {
            // came from the new queue, move to learning
            card.setQueue(1);
            // if it was a new card, it's now a learning card
            if (card.getType() == 0) {
                card.setType(1);
            }
            // init reps to graduation
            card.setLeft(_startingLeft(card));
            // dynamic?
            if (card.getODid() != 0 && card.getType() == 2) {
                if (_resched(card)) {
                    // reviews get their ivl boosted on first sight
                    card.setIvl(_dynIvlBoost(card));
                    card.setODue(mToday + card.getIvl());
                }
            }
            _updateStats(card, "new");
        }
        if (card.getQueue() == 1 || card.getQueue() == 3) {
            _answerLrnCard(card, ease);
            if (!wasNewQ) {
                _updateStats(card, "lrn");
            }
        } else if (card.getQueue() == 2) {
            _answerRevCard(card, ease);
            _updateStats(card, "rev");
        } else {
            throw new RuntimeException("Invalid queue");
        }
        _updateStats(card, "time", card.timeTaken());
        card.setMod(Utils.intNow());
        card.setUsn(mCol.usn());
        card.flushSched();
    }


    public int[] counts() {
        return counts(null);
    }
	
	public List<Integer> countsList(){
		int[] is = counts();
		List<Integer> list = new ArrayList();
		for(int i=0; i<is.length; i++){
			list.add(is[i]);
		}
		return list;
	}


    public int[] counts(Card card) {
        int[] counts = {mNewCount, mLrnCount, mRevCount};
        if (card != null) {
            int idx = countIdx(card);
            if (idx == 1) {
                counts[1] += card.getLeft() / 1000;
            } else {
                counts[idx] += 1;
            }
        }
        return counts;
    }


    /**
     * Return counts over next DAYS. Includes today.
     */
    public int dueForecast() {
        return dueForecast(7);
    }


    public int dueForecast(int days) {
        // TODO:...
        return 0;
    }


    public int countIdx(Card card) {
        if (card.getQueue() == 3) {
            return 1;
        }
        return card.getQueue();
    }


    public int answerButtons(Card card) {
        if (card.getODue() != 0) {
            // normal review in dyn deck?
            if (card.getODid() != 0 && card.getQueue() == 2) {
                return 4;
            }
            JSONObject conf = _lrnConf(card);
            try {
                if (card.getType() == 0 || card.getType() == 1 || conf.getJSONArray("delays").length() > 1) {
                    return 3;
                }
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            return 2;
        } else if (card.getQueue() == 2) {
            return 4;
        } else {
            return 3;
        }
    }


    /*
     * Unbury cards.
     */
    public void unburyCards() {
        try {
            mCol.getConf().put("lastUnburied", mToday);
            mCol.log(mCol.getDb().queryColumn(Long.class, "select id from cards where queue = -2", 0));
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }

        mCol.getDb().execute("update cards set queue=type where queue = -2");
    }


    public void unburyCardsForDeck() {
        unburyCardsForDeck(mCol.getDecks().active());
    }

    private void unburyCardsForDeck(List<Long> allDecks) {
        // Refactored to allow unburying an arbitrary deck
        String sids = Utils.ids2str(allDecks);
        mCol.log(mCol.getDb().queryColumn(Long.class, "select id from cards where queue = -2 and did in " + sids, 0));
        mCol.getDb().execute("update cards set mod=?,usn=?,queue=type where queue = -2 and did in " + sids,
                new Object[] { Utils.intNow(), mCol.usn() });
    }

    /**
     * Rev/lrn/time daily stats *************************************************
     * **********************************************
     */

    private void _updateStats(Card card, String type) {
        _updateStats(card, type, 1);
    }


    public void _updateStats(Card card, String type, long cnt) {
        String key = type + "Today";
        long did = card.getDid();
        List<JSONObject> list = mCol.getDecks().parents(did);
        list.add(mCol.getDecks().get(did));
        for (JSONObject g : list) {
            try {
                JSONArray a = g.getJSONArray(key);
                // add
                a.put(1, a.getLong(1) + cnt);
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            mCol.getDecks().save(g);
        }
    }


    public void extendLimits(int newc, int rev) {
        JSONObject cur = mCol.getDecks().current();
        ArrayList<JSONObject> decks = new ArrayList<>();
        decks.add(cur);
        try {
            decks.addAll(mCol.getDecks().parents(cur.getLong("id")));
            for (long did : mCol.getDecks().children(cur.getLong("id")).values()) {
                decks.add(mCol.getDecks().get(did));
            }
            for (JSONObject g : decks) {
                // add
                JSONArray ja = g.getJSONArray("newToday");
                ja.put(1, ja.getInt(1) - newc);
                g.put("newToday", ja);
                ja = g.getJSONArray("revToday");
                ja.put(1, ja.getInt(1) - rev);
                g.put("revToday", ja);
                mCol.getDecks().save(g);
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    private int _walkingCount(Method limFn, Method cntFn) {
        int tot = 0;
        HashMap<Long, Integer> pcounts = new HashMap<>();
        // for each of the active decks
        try {
            for (long did : mCol.getDecks().active()) {
                // get the individual deck's limit
                int lim = (Integer)limFn.invoke(Sched.this, mCol.getDecks().get(did));
                if (lim == 0) {
                    continue;
                }
                // check the parents
                List<JSONObject> parents = mCol.getDecks().parents(did);
                for (JSONObject p : parents) {
                    // add if missing
                    long id = p.getLong("id");
                    if (!pcounts.containsKey(id)) {
                        pcounts.put(id, (Integer)limFn.invoke(Sched.this, p));
                    }
                    // take minimum of child and parent
                    lim = Math.min(pcounts.get(id), lim);
                }
                // see how many cards we actually have
                int cnt = (Integer)cntFn.invoke(Sched.this, did, lim);
                // if non-zero, decrement from parents counts
                for (JSONObject p : parents) {
                    long id = p.getLong("id");
                    pcounts.put(id, pcounts.get(id) - cnt);
                }
                // we may also be a parent
                pcounts.put(did, lim - cnt);
                // and add to running total
                tot += cnt;
            }
        } catch (JSONException | IllegalAccessException | InvocationTargetException e) {
            throw new RuntimeException(e);
        }
        return tot;
    }


    /**
     * Deck list **************************************************************** *******************************
     */


    /**
     * Returns [deckname, did, rev, lrn, new]
     */
    public List<DeckDueTreeNode> deckDueList() {
        _checkDay();
        mCol.getDecks().recoverOrphans();
        ArrayList<JSONObject> decks = mCol.getDecks().allSorted();
        HashMap<String, Integer[]> lims = new HashMap<>();
        ArrayList<DeckDueTreeNode> data = new ArrayList<>();
        try {
            for (JSONObject deck : decks) {
                // if we've already seen the exact same deck name, remove the
                // invalid duplicate and reload
                if (lims.containsKey(deck.getString("name"))) {
                    mCol.getDecks().rem(deck.getLong("id"), false, true);
                    return deckDueList();
                }
                String p;
                List<String> parts = Arrays.asList(deck.getString("name").split("::", -1));
                if (parts.size() < 2) {
                    p = null;
                } else {
                    parts = parts.subList(0, parts.size() - 1);
                    p = TextUtils.join("::", parts);
                }
                // new
                int nlim = _deckNewLimitSingle(deck);
                if (!TextUtils.isEmpty(p)) {
                    if (!lims.containsKey(p)) {
                        // if parent was missing, this deck is invalid, and we need to reload the deck list
                        mCol.getDecks().rem(deck.getLong("id"), false, true);
                        return deckDueList();
                    }
                    nlim = Math.min(nlim, lims.get(p)[0]);
                }
                int _new = _newForDeck(deck.getLong("id"), nlim);
                // learning
                int lrn = _lrnForDeck(deck.getLong("id"));
                // reviews
                int rlim = _deckRevLimitSingle(deck);
                if (!TextUtils.isEmpty(p)) {
                    rlim = Math.min(rlim, lims.get(p)[1]);
                }
                int rev = _revForDeck(deck.getLong("id"), rlim);
                // save to list
                data.add(new DeckDueTreeNode(deck.getString("name"), deck.getLong("id"), rev, lrn, _new));
                // add deck as a parent
                lims.put(deck.getString("name"), new Integer[]{nlim, rlim});
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return data;
    }


    public List<DeckDueTreeNode> deckDueTree() {
        return _groupChildren(deckDueList());
    }


    private List<DeckDueTreeNode> _groupChildren(List<DeckDueTreeNode> grps) {
        // first, split the group names into components
        for (DeckDueTreeNode g : grps) {
            g.names = g.names[0].split("::", -1);
        }
        // and sort based on those components
        Collections.sort(grps);
        // then run main function
        return _groupChildrenMain(grps);
    }


    private List<DeckDueTreeNode> _groupChildrenMain(List<DeckDueTreeNode> grps) {
        List<DeckDueTreeNode> tree = new ArrayList<>();
        // group and recurse
        ListIterator<DeckDueTreeNode> it = grps.listIterator();
        while (it.hasNext()) {
            DeckDueTreeNode node = it.next();
            String head = node.names[0];
            // Compose the "tail" node list. The tail is a list of all the nodes that proceed
            // the current one that contain the same name[0]. I.e., they are subdecks that stem
            // from this node. This is our version of python's itertools.groupby.
            List<DeckDueTreeNode> tail  = new ArrayList<>();
            tail.add(node);
            while (it.hasNext()) {
                DeckDueTreeNode next = it.next();
                if (head.equals(next.names[0])) {
                    // Same head - add to tail of current head.
                    tail.add(next);
                } else {
                    // We've iterated past this head, so step back in order to use this node as the
                    // head in the next iteration of the outer loop.
                    it.previous();
                    break;
                }
            }
            Long did = null;
            int rev = 0;
            int _new = 0;
            int lrn = 0;
            List<DeckDueTreeNode> children = new ArrayList<>();
            for (DeckDueTreeNode c : tail) {
                if (c.names.length == 1) {
                    // current node
                    did = c.did;
                    rev += c.revCount;
                    lrn += c.lrnCount;
                    _new += c.newCount;
                } else {
                    // set new string to tail
                    String[] newTail = new String[c.names.length-1];
                    System.arraycopy(c.names, 1, newTail, 0, c.names.length-1);
                    c.names = newTail;
                    children.add(c);
                }
            }
            children = _groupChildrenMain(children);
            // tally up children counts
            for (DeckDueTreeNode ch : children) {
                rev +=  ch.revCount;
                lrn +=  ch.lrnCount;
                _new += ch.newCount;
            }
            // limit the counts to the deck's limits
            JSONObject conf = mCol.getDecks().confForDid(did);
            JSONObject deck = mCol.getDecks().get(did);
            try {
                if (conf.getInt("dyn") == 0) {
                    rev = Math.max(0, Math.min(rev, conf.getJSONObject("rev").getInt("perDay") - deck.getJSONArray("revToday").getInt(1)));
                    _new = Math.max(0, Math.min(_new, conf.getJSONObject("new").getInt("perDay") - deck.getJSONArray("newToday").getInt(1)));
                }
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            tree.add(new DeckDueTreeNode(head, did, rev, lrn, _new, children));
        }
        return tree;
    }


    /**
     * Getting the next card ****************************************************
     * *******************************************
     */

    /**
     * Return the next due card, or null.
     */
    private Card _getCard() {
        // learning card due?
        Card c = _getLrnCard();
        if (c != null) {
            return c;
        }
        // new first, or time for one?
        if (_timeForNewCard()) {
            c = _getNewCard();
            if (c != null) {
                return c;
            }
        }
        // Card due for review?
        c = _getRevCard();
        if (c != null) {
            return c;
        }
        // day learning card due?
        c = _getLrnDayCard();
        if (c != null) {
            return c;
        }
        // New cards left?
        c = _getNewCard();
        if (c != null) {
            return c;
        }
        // collapse or finish
        return _getLrnCard(true);
    }


    /**
     * New cards **************************************************************** *******************************
     */

    private void _resetNewCount() {
        try {
            mNewCount = _walkingCount(Sched.class.getDeclaredMethod("_deckNewLimitSingle", JSONObject.class),
                    Sched.class.getDeclaredMethod("_cntFnNew", long.class, int.class));
        } catch (NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
    }


    // Used as an argument for _walkingCount() in _resetNewCount() above
    @SuppressWarnings("unused")
    private int _cntFnNew(long did, int lim) {
        return mCol.getDb().queryScalar(
                "SELECT count() FROM (SELECT 1 FROM cards WHERE did = " + did + " AND queue = 0 LIMIT " + lim + ")");
    }


    private void _resetNew() {
        _resetNewCount();
        mNewDids = new LinkedList<>(mCol.getDecks().active());
        mNewQueue.clear();
        _updateNewCardRatio();
    }


    private boolean _fillNew() {
        if (mNewQueue.size() > 0) {
            return true;
        }
        if (mNewCount == 0) {
            return false;
        }
        while (!mNewDids.isEmpty()) {
            long did = mNewDids.getFirst();
            int lim = Math.min(mQueueLimit, _deckNewLimit(did));
            Cursor cur = null;
            if (lim != 0) {
                mNewQueue.clear();
                try {
                    // fill the queue with the current did
                    cur = mCol
                            .getDb()
                            .getDatabase()
                            .rawQuery("SELECT id FROM cards WHERE did = " + did + " AND queue = 0 order by due LIMIT " + lim,
                                    null);
                    while (cur.moveToNext()) {
                        mNewQueue.add(cur.getLong(0));
                    }
                } finally {
                    if (cur != null && !cur.isClosed()) {
                        cur.close();
                    }
                }
                if (!mNewQueue.isEmpty()) {
                    // Note: libanki reverses mNewQueue and returns the last element in _getNewCard().
                    // AnkiDroid differs by leaving the queue intact and returning the *first* element
                    // in _getNewCard().
                    return true;
                }
            }
            // nothing left in the deck; move to next
            mNewDids.remove();
        }
        if (mNewCount != 0) {
            // if we didn't get a card but the count is non-zero,
            // we need to check again for any cards that were
            // removed from the queue but not buried
            _resetNew();
            return _fillNew();
        }
        return false;
    }


    private Card _getNewCard() {
        if (_fillNew()) {
            mNewCount -= 1;
            return mCol.getCard(mNewQueue.remove());
        }
        return null;
    }


    private void _updateNewCardRatio() {
        try {
            if (mCol.getConf().getInt("newSpread") == Consts.NEW_CARDS_DISTRIBUTE) {
                if (mNewCount != 0) {
                    mNewCardModulus = (mNewCount + mRevCount) / mNewCount;
                    // if there are cards to review, ensure modulo >= 2
                    if (mRevCount != 0) {
                        mNewCardModulus = Math.max(2, mNewCardModulus);
                    }
                    return;
                }
            }
            mNewCardModulus = 0;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * @return True if it's time to display a new card when distributing.
     */
    private boolean _timeForNewCard() {
        if (mNewCount == 0) {
            return false;
        }
        int spread;
        try {
            spread = mCol.getConf().getInt("newSpread");
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        if (spread == Consts.NEW_CARDS_LAST) {
            return false;
        } else if (spread == Consts.NEW_CARDS_FIRST) {
            return true;
        } else if (mNewCardModulus != 0) {
            return (mReps != 0 && (mReps % mNewCardModulus == 0));
        } else {
            return false;
        }
    }


    private int _deckNewLimit(long did) {
        return _deckNewLimit(did, null);
    }


    private int _deckNewLimit(long did, Method fn) {
        try {
            if (fn == null) {
                fn = Sched.class.getDeclaredMethod("_deckNewLimitSingle", JSONObject.class);
            }
            List<JSONObject> decks = mCol.getDecks().parents(did);
            decks.add(mCol.getDecks().get(did));
            int lim = -1;
            // for the deck and each of its parents
            int rem = 0;
            for (JSONObject g : decks) {
                rem = (Integer) fn.invoke(Sched.this, g);
                if (lim == -1) {
                    lim = rem;
                } else {
                    lim = Math.min(rem, lim);
                }
            }
            return lim;
        } catch (IllegalArgumentException | NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }


    /* New count for a single deck. */
    public int _newForDeck(long did, int lim) {
    	if (lim == 0) {
    		return 0;
    	}
    	lim = Math.min(lim, mReportLimit);
    	return mCol.getDb().queryScalar("SELECT count() FROM (SELECT 1 FROM cards WHERE did = " + did + " AND queue = 0 LIMIT " + lim + ")");
    }


    /* Limit for deck without parent limits. */
    public int _deckNewLimitSingle(JSONObject g) {
        try {
            if (g.getInt("dyn") != 0) {
                return mReportLimit;
            }
            JSONObject c = mCol.getDecks().confForDid(g.getLong("id"));
            return Math.max(0, c.getJSONObject("new").getInt("perDay") - g.getJSONArray("newToday").getInt(1));
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }

    public int totalNewForCurrentDeck() {
        return mCol.getDb().queryScalar("SELECT count() FROM cards WHERE id IN (SELECT id FROM cards WHERE did IN " + Utils.ids2str(mCol.getDecks().active()) + " AND queue = 0 LIMIT " + mReportLimit + ")");
    }

    /**
     * Learning queues *********************************************************** ************************************
     */

    private void _resetLrnCount() {
        // sub-day
        mLrnCount = mCol.getDb().queryScalar(
                "SELECT sum(left / 1000) FROM (SELECT left FROM cards WHERE did IN " + _deckLimit()
                + " AND queue = 1 AND due < " + mDayCutoff + " LIMIT " + mReportLimit + ")");

        // day
        mLrnCount += mCol.getDb().queryScalar(
                "SELECT count() FROM cards WHERE did IN " + _deckLimit() + " AND queue = 3 AND due <= " + mToday
                        + " LIMIT " + mReportLimit);
    }


    private void _resetLrn() {
        _resetLrnCount();
        mLrnQueue.clear();
        mLrnDayQueue.clear();
        mLrnDids = mCol.getDecks().active();
    }


    // sub-day learning
    private boolean _fillLrn() {
        if (mLrnCount == 0) {
            return false;
        }
        if (!mLrnQueue.isEmpty()) {
            return true;
        }
        Cursor cur = null;
        mLrnQueue.clear();
        try {
            cur = mCol
                    .getDb()
                    .getDatabase()
                    .rawQuery(
                            "SELECT due, id FROM cards WHERE did IN " + _deckLimit() + " AND queue = 1 AND due < "
                                    + mDayCutoff + " LIMIT " + mReportLimit, null);
            while (cur.moveToNext()) {
                mLrnQueue.add(new long[] { cur.getLong(0), cur.getLong(1) });
            }
            // as it arrives sorted by did first, we need to sort it
            Collections.sort(mLrnQueue, new Comparator<long[]>() {
                @Override
                public int compare(long[] lhs, long[] rhs) {
                    return Long.valueOf(lhs[0]).compareTo(rhs[0]);
                }
            });
            return !mLrnQueue.isEmpty();
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
    }


    private Card _getLrnCard() {
        return _getLrnCard(false);
    }


    private Card _getLrnCard(boolean collapse) {
        if (_fillLrn()) {
            double cutoff = Utils.now();
            if (collapse) {
                try {
                    cutoff += mCol.getConf().getInt("collapseTime");
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
            }
            if (mLrnQueue.getFirst()[0] < cutoff) {
                long id = mLrnQueue.remove()[1];
                Card card = mCol.getCard(id);
                mLrnCount -= card.getLeft() / 1000;
                return card;
            }
        }
        return null;
    }


    // daily learning
    private boolean _fillLrnDay() {
        if (mLrnCount == 0) {
            return false;
        }
        if (!mLrnDayQueue.isEmpty()) {
            return true;
        }
        while (mLrnDids.size() > 0) {
            long did = mLrnDids.getFirst();
            // fill the queue with the current did
            mLrnDayQueue.clear();
            Cursor cur = null;
            try {
                cur = mCol
                        .getDb()
                        .getDatabase()
                        .rawQuery(
                                "SELECT id FROM cards WHERE did = " + did + " AND queue = 3 AND due <= " + mToday
                                        + " LIMIT " + mQueueLimit, null);
                while (cur.moveToNext()) {
                    mLrnDayQueue.add(cur.getLong(0));
                }
            } finally {
                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }
            }
            if (mLrnDayQueue.size() > 0) {
                // order
                Random r = new Random();
                r.setSeed(mToday);
                Collections.shuffle(mLrnDayQueue, r);
                // is the current did empty?
                if (mLrnDayQueue.size() < mQueueLimit) {
                    mLrnDids.remove();
                }
                return true;
            }
            // nothing left in the deck; move to next
            mLrnDids.remove();
        }
        return false;
    }


    private Card _getLrnDayCard() {
        if (_fillLrnDay()) {
            mLrnCount -= 1;
            return mCol.getCard(mLrnDayQueue.remove());
        }
        return null;
    }


    /**
     * @param ease 1=no, 2=yes, 3=remove
     */
    private void _answerLrnCard(Card card, int ease) {
        JSONObject conf = _lrnConf(card);
        int type;
        if (card.getODid() != 0 && !card.getWasNew()) {
            type = 3;
        } else if (card.getType() == 2) {
            type = 2;
        } else {
            type = 0;
        }
        boolean leaving = false;
        // lrnCount was decremented once when card was fetched
        int lastLeft = card.getLeft();
        // immediate graduate?
        if (ease == 3) {
            _rescheduleAsRev(card, conf, true);
            leaving = true;
            // graduation time?
        } else if (ease == 2 && (card.getLeft() % 1000) - 1 <= 0) {
            _rescheduleAsRev(card, conf, false);
            leaving = true;
        } else {
            // one step towards graduation
            if (ease == 2) {
                // decrement real left count and recalculate left today
                int left = (card.getLeft() % 1000) - 1;
                try {
                    card.setLeft(_leftToday(conf.getJSONArray("delays"), left) * 1000 + left);
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
                // failed
            } else {
                card.setLeft(_startingLeft(card));
                boolean resched = _resched(card);
                if (conf.has("mult") && resched) {
                    // review that's lapsed
                    try {
                        card.setIvl(Math.max(Math.max(1, (int) (card.getIvl() * conf.getDouble("mult"))), conf.getInt("minInt")));
                    } catch (JSONException e) {
                        throw new RuntimeException(e);
                    }
                } else {
                    // new card; no ivl adjustment
                    // pass
                }
                if (resched && card.getODid() != 0) {
                    card.setODue(mToday + 1);
                }
            }
            int delay = _delayForGrade(conf, card.getLeft());
            if (card.getDue() < Utils.now()) {
                // not collapsed; add some randomness
                delay *= Utils.randomFloatInRange(1f, 1.25f);
            }
            card.setDue((int) (Utils.now() + delay));

            // due today?
            if (card.getDue() < mDayCutoff) {
                mLrnCount += card.getLeft() / 1000;
                // if the queue is not empty and there's nothing else to do, make
                // sure we don't put it at the head of the queue and end up showing
                // it twice in a row
                card.setQueue(1);
                if (!mLrnQueue.isEmpty() && mRevCount == 0 && mNewCount == 0) {
                    long smallestDue = mLrnQueue.getFirst()[0];
                    card.setDue(Math.max(card.getDue(), smallestDue + 1));
                }
                _sortIntoLrn(card.getDue(), card.getId());
            } else {
                // the card is due in one or more days, so we need to use the day learn queue
                long ahead = ((card.getDue() - mDayCutoff) / 86400) + 1;
                card.setDue(mToday + ahead);
                card.setQueue(3);
            }
        }
        _logLrn(card, ease, conf, leaving, type, lastLeft);
    }


    private int _delayForGrade(JSONObject conf, int left) {
        left = left % 1000;
        try {
            double delay;
            JSONArray ja = conf.getJSONArray("delays");
            int len = ja.length();
            try {
                delay = ja.getDouble(len - left);
            } catch (JSONException e) {
            	if (conf.getJSONArray("delays").length() > 0) {
            		delay = conf.getJSONArray("delays").getDouble(0);
            	} else {
            		// user deleted final step; use dummy value
            		delay = 1.0;
            	}
            }
            return (int) (delay * 60.0);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    private JSONObject _lrnConf(Card card) {
        if (card.getType() == 2) {
            return _lapseConf(card);
        } else {
            return _newConf(card);
        }
    }


    private void _rescheduleAsRev(Card card, JSONObject conf, boolean early) {
        boolean lapse = (card.getType() == 2);
        if (lapse) {
            if (_resched(card)) {
                card.setDue(Math.max(mToday + 1, card.getODue()));
            } else {
                card.setDue(card.getODue());
            }
            card.setODue(0);
        } else {
            _rescheduleNew(card, conf, early);
        }
        card.setQueue(2);
        card.setType(2);
        // if we were dynamic, graduating means moving back to the old deck
        boolean resched = _resched(card);
        if (card.getODid() != 0) {
            card.setDid(card.getODid());
            card.setODue(0);
            card.setODid(0);
            // if rescheduling is off, it needs to be set back to a new card
            if (!resched && !lapse) {
                card.setType(0);
                card.setQueue(card.getType());
                card.setDue(mCol.nextID("pos"));
            }
        }
    }


    private int _startingLeft(Card card) {
        try {
            JSONObject conf;
        	if (card.getType() == 2) {
        		conf = _lapseConf(card);
        	} else {
        		conf = _lrnConf(card);
        	}
            int tot = conf.getJSONArray("delays").length();
            int tod = _leftToday(conf.getJSONArray("delays"), tot);
            return tot + tod * 1000;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /* the number of steps that can be completed by the day cutoff */
    private int _leftToday(JSONArray delays, int left) {
        return _leftToday(delays, left, 0);
    }


    private int _leftToday(JSONArray delays, int left, long now) {
        if (now == 0) {
            now = Utils.intNow();
        }
        int ok = 0;
        int offset = Math.min(left, delays.length());
        for (int i = 0; i < offset; i++) {
            try {
                now += (int) (delays.getDouble(delays.length() - offset + i) * 60.0);
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
            if (now > mDayCutoff) {
                break;
            }
            ok = i;
        }
        return ok + 1;
    }


    private int _graduatingIvl(Card card, JSONObject conf, boolean early) {
        return _graduatingIvl(card, conf, early, true);
    }


    private int _graduatingIvl(Card card, JSONObject conf, boolean early, boolean adj) {
        if (card.getType() == 2) {
            // lapsed card being relearnt
            if (card.getODid() != 0) {
                try {
                    if (conf.getBoolean("resched")) {
                        return _dynIvlBoost(card);
                    }
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
            }
            return card.getIvl();
        }
        int ideal;
        JSONArray ja;
        try {
            ja = conf.getJSONArray("ints");
            if (!early) {
                // graduate
                ideal = ja.getInt(0);
            } else {
                ideal = ja.getInt(1);
            }
            if (adj) {
                return _adjRevIvl(card, ideal);
            } else {
                return ideal;
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /* Reschedule a new card that's graduated for the first time. */
    private void _rescheduleNew(Card card, JSONObject conf, boolean early) {
        card.setIvl(_graduatingIvl(card, conf, early));
        card.setDue(mToday + card.getIvl());
        try {
            card.setFactor(conf.getInt("initialFactor"));
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    private void _logLrn(Card card, int ease, JSONObject conf, boolean leaving, int type, int lastLeft) {
        int lastIvl = -(_delayForGrade(conf, lastLeft));
        int ivl = leaving ? card.getIvl() : -(_delayForGrade(conf, card.getLeft()));
        log(card.getId(), mCol.usn(), ease, ivl, lastIvl, card.getFactor(), card.timeTaken(), type);
    }


    private void log(long id, int usn, int ease, int ivl, int lastIvl, int factor, int timeTaken, int type) {
        try {
            mCol.getDb().execute("INSERT INTO revlog VALUES (?,?,?,?,?,?,?,?,?)",
                    new Object[]{Utils.now() * 1000, id, usn, ease, ivl, lastIvl, factor, timeTaken, type});
        } catch (SQLiteConstraintException e) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e1) {
                throw new RuntimeException(e1);
            }
            log(id, usn, ease, ivl, lastIvl, factor, timeTaken, type);
        }
    }


    public void removeLrn() {
    	removeLrn(null);
    }

    /* Remove cards from the learning queues. */
    private void removeLrn(long[] ids) {
        String extra;
        if (ids != null && ids.length > 0) {
            extra = " AND id IN " + Utils.ids2str(ids);
        } else {
            // benchmarks indicate it's about 10x faster to search all decks with the index than scan the table
            extra = " AND did IN " + Utils.ids2str(mCol.getDecks().allIds());
        }
        // review cards in relearning
        mCol.getDb().execute(
                "update cards set due = odue, queue = 2, mod = " + Utils.intNow() +
                ", usn = " + mCol.usn() + ", odue = 0 where queue IN (1,3) and type = 2 " + extra);
        // new cards in learning
        forgetCards(Utils.arrayList2array(mCol.getDb().queryColumn(Long.class, "SELECT id FROM cards WHERE queue IN (1,3) " + extra, 0)));
    }


    private int _lrnForDeck(long did) {
        try {
            int cnt = mCol.getDb().queryScalar(
                    "SELECT sum(left / 1000) FROM (SELECT left FROM cards WHERE did = " + did
                            + " AND queue = 1 AND due < " + (Utils.intNow() + mCol.getConf().getInt("collapseTime"))
                            + " LIMIT " + mReportLimit + ")");
            return cnt + mCol.getDb().queryScalar(
                    "SELECT count() FROM (SELECT 1 FROM cards WHERE did = " + did
                            + " AND queue = 3 AND due <= " + mToday
                            + " LIMIT " + mReportLimit + ")");
        } catch (SQLException | JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Reviews ****************************************************************** *****************************
     */

    private int _deckRevLimit(long did) {
        try {
            return _deckNewLimit(did, Sched.class.getDeclaredMethod("_deckRevLimitSingle", JSONObject.class));
        } catch (NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
    }


    private int _deckRevLimitSingle(JSONObject d) {
        try {
            if (d.getInt("dyn") != 0) {
                return mReportLimit;
            }
            JSONObject c = mCol.getDecks().confForDid(d.getLong("id"));
            return Math.max(0, c.getJSONObject("rev").getInt("perDay") - d.getJSONArray("revToday").getInt(1));
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public int _revForDeck(long did, int lim) {
    	lim = Math.min(lim, mReportLimit);
    	return mCol.getDb().queryScalar("SELECT count() FROM (SELECT 1 FROM cards WHERE did = " + did + " AND queue = 2 AND due <= " + mToday + " LIMIT " + lim + ")");
    }


    private void _resetRevCount() {
        try {
            mRevCount = _walkingCount(Sched.class.getDeclaredMethod("_deckRevLimitSingle", JSONObject.class),
                    Sched.class.getDeclaredMethod("_cntFnRev", long.class, int.class));
        } catch (NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
    }


    // Dynamically invoked in _walkingCount, passed as a parameter in _resetRevCount
    @SuppressWarnings("unused")
    private int _cntFnRev(long did, int lim) {
        return mCol.getDb().queryScalar(
                "SELECT count() FROM (SELECT id FROM cards WHERE did = " + did + " AND queue = 2 and due <= " + mToday
                        + " LIMIT " + lim + ")");
    }


    private void _resetRev() {
        _resetRevCount();
        mRevQueue.clear();
        mRevDids = mCol.getDecks().active();
    }


    private boolean _fillRev() {
        if (!mRevQueue.isEmpty()) {
            return true;
        }
        if (mRevCount == 0) {
            return false;
        }
        while (mRevDids.size() > 0) {
            long did = mRevDids.getFirst();
            int lim = Math.min(mQueueLimit, _deckRevLimit(did));
            Cursor cur = null;
            if (lim != 0) {
                mRevQueue.clear();
                // fill the queue with the current did
                try {
                    cur = mCol
                            .getDb()
                            .getDatabase()
                            .rawQuery(
                                    "SELECT id FROM cards WHERE did = " + did + " AND queue = 2 AND due <= " + mToday
                                            + " LIMIT " + lim, null);
                    while (cur.moveToNext()) {
                        mRevQueue.add(cur.getLong(0));
                    }
                } finally {
                    if (cur != null && !cur.isClosed()) {
                        cur.close();
                    }
                }
                if (!mRevQueue.isEmpty()) {
                    // ordering
                    try {
                        if (mCol.getDecks().get(did).getInt("dyn") != 0) {
                            // dynamic decks need due order preserved
                            // Note: libanki reverses mRevQueue and returns the last element in _getRevCard().
                            // AnkiDroid differs by leaving the queue intact and returning the *first* element
                            // in _getRevCard().
                        } else {
                            Random r = new Random();
                            r.setSeed(mToday);
                            Collections.shuffle(mRevQueue, r);
                        }
                    } catch (JSONException e) {
                        throw new RuntimeException(e);
                    }
                    // is the current did empty?
                    if (mRevQueue.size() < lim) {
                        mRevDids.remove();
                    }
                    return true;
                }
            }
            // nothing left in the deck; move to next
            mRevDids.remove();
        }
        if (mRevCount != 0) {
            // if we didn't get a card but the count is non-zero,
            // we need to check again for any cards that were
            // removed from the queue but not buried
            _resetRev();
            return _fillRev();
        }
        return false;
    }


    private Card _getRevCard() {
        if (_fillRev()) {
            mRevCount -= 1;
            return mCol.getCard(mRevQueue.remove());
        } else {
            return null;
        }
    }


    public int totalRevForCurrentDeck() {
        return mCol.getDb().queryScalar(String.format(Locale.US,
        		"SELECT count() FROM cards WHERE id IN (SELECT id FROM cards WHERE did IN %s AND queue = 2 AND due <= %d LIMIT %s)",
        		Utils.ids2str(mCol.getDecks().active()), mToday, mReportLimit));
    }


    /**
     * Answering a review card **************************************************
     * *********************************************
     */

    private void _answerRevCard(Card card, int ease) {
        int delay = 0;
        if (ease == 1) {
            delay = _rescheduleLapse(card);
        } else {
            _rescheduleRev(card, ease);
        }
        _logRev(card, ease, delay);
    }


    private int _rescheduleLapse(Card card) {
        JSONObject conf;
        try {
            conf = _lapseConf(card);
            card.setLastIvl(card.getIvl());
            if (_resched(card)) {
                card.setLapses(card.getLapses() + 1);
                card.setIvl(_nextLapseIvl(card, conf));
                card.setFactor(Math.max(1300, card.getFactor() - 200));
                card.setDue(mToday + card.getIvl());
                // if it's a filtered deck, update odue as well
                if (card.getODid() != 0) {
                    card.setODue(card.getDue());
                }
            }
            // if suspended as a leech, nothing to do
            int delay = 0;
            if (_checkLeech(card, conf) && card.getQueue() == -1) {
                return delay;
            }
            // if no relearning steps, nothing to do
            if (conf.getJSONArray("delays").length() == 0) {
                return delay;
            }
            // record rev due date for later
            if (card.getODue() == 0) {
                card.setODue(card.getDue());
            }
            delay = _delayForGrade(conf, 0);
            card.setDue((long) (delay + Utils.now()));
            card.setLeft(_startingLeft(card));
            // queue 1
            if (card.getDue() < mDayCutoff) {
                mLrnCount += card.getLeft() / 1000;
                card.setQueue(1);
                _sortIntoLrn(card.getDue(), card.getId());
            } else {
                // day learn queue
                long ahead = ((card.getDue() - mDayCutoff) / 86400) + 1;
                card.setDue(mToday + ahead);
                card.setQueue(3);
            }
            return delay;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    private int _nextLapseIvl(Card card, JSONObject conf) {
        try {
            return Math.max(conf.getInt("minInt"), (int)(card.getIvl() * conf.getDouble("mult")));
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    private void _rescheduleRev(Card card, int ease) {
        // update interval
        card.setLastIvl(card.getIvl());
        if (_resched(card)) {
            _updateRevIvl(card, ease);
            // then the rest
            card.setFactor(Math.max(1300, card.getFactor() + FACTOR_ADDITION_VALUES[ease - 2]));
            card.setDue(mToday + card.getIvl());
        } else {
            card.setDue(card.getODue());
        }
        if (card.getODid() != 0) {
            card.setDid(card.getODid());
            card.setODid(0);
            card.setODue(0);
        }
    }


    private void _logRev(Card card, int ease, int delay) {
        log(card.getId(), mCol.usn(), ease, ((delay != 0) ? (-delay) : card.getIvl()), card.getLastIvl(),
                card.getFactor(), card.timeTaken(), 1);
    }


    /**
     * Interval management ******************************************************
     * *****************************************
     */

    /**
     * Ideal next interval for CARD, given EASE.
     */
    private int _nextRevIvl(Card card, int ease) {
        try {
            long delay = _daysLate(card);
            int interval = 0;
            JSONObject conf = _revConf(card);
            double fct = card.getFactor() / 1000.0;
            int ivl2 = _constrainedIvl((int)((card.getIvl() + delay/4) * 1.2), conf, card.getIvl());
            int ivl3 = _constrainedIvl((int)((card.getIvl() + delay/2) * fct), conf, ivl2);
            int ivl4 = _constrainedIvl((int)((card.getIvl() + delay) * fct * conf.getDouble("ease4")), conf, ivl3);
            if (ease == 2) {
                interval = ivl2;
            } else if (ease == 3) {
                interval = ivl3;
            } else if (ease == 4) {
            	interval = ivl4;
            }
            // interval capped?
            return Math.min(interval, conf.getInt("maxIvl"));
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }

    private int _fuzzedIvl(int ivl) {
        int[] minMax = _fuzzedIvlRange(ivl);
        // Anki's python uses random.randint(a, b) which returns x in [a, b] while the eq Random().nextInt(a, b)
        // returns x in [0, b-a), hence the +1 diff with libanki
        return (new Random().nextInt(minMax[1] - minMax[0] + 1)) + minMax[0];
    }


    public int[] _fuzzedIvlRange(int ivl) {
        int fuzz;
        if (ivl < 2) {
            return new int[]{1, 1};
        } else if (ivl == 2) {
            return new int[]{2, 3};
        } else if (ivl < 7) {
            fuzz = (int)(ivl * 0.25);
        } else if (ivl < 30) {
            fuzz = Math.max(2, (int)(ivl * 0.15));
        } else {
            fuzz = Math.max(4, (int)(ivl * 0.05));
        }
        // fuzz at least a day
        fuzz = Math.max(fuzz, 1);
        return new int[]{ivl - fuzz, ivl + fuzz};
    }


    /** Integer interval after interval factor and prev+1 constraints applied */
    private int _constrainedIvl(int ivl, JSONObject conf, double prev) {
    	double newIvl = ivl;
    	newIvl = ivl * conf.optDouble("ivlFct",1.0);
        return (int) Math.max(newIvl, prev + 1);
    }


    /**
     * Number of days later than scheduled.
     */
    private long _daysLate(Card card) {
        long due = card.getODid() != 0 ? card.getODue() : card.getDue();
        return Math.max(0, mToday - due);
    }


    private void _updateRevIvl(Card card, int ease) {
        int idealIvl = _nextRevIvl(card, ease);
        card.setIvl(_adjRevIvl(card, idealIvl));
    }


    private int _adjRevIvl(Card card, int idealIvl) {
        if (mSpreadRev) {
            idealIvl = _fuzzedIvl(idealIvl);
        }
        return idealIvl;
    }


    /**
     * Dynamic deck handling ******************************************************************
     * *****************************
     */

    /* Rebuild a dynamic deck. */
    public void rebuildDyn() {
        rebuildDyn(0);
    }


    public List<Long> rebuildDyn(long did) {
        if (did == 0) {
            did = mCol.getDecks().selected();
        }
        JSONObject deck = mCol.getDecks().get(did);
        try {
            if (deck.getInt("dyn") == 0) {
                Timber.e("error: deck is not a filtered deck");
                return null;
            }
        } catch (JSONException e1) {
            throw new RuntimeException(e1);
        }
        // move any existing cards back first, then fill
        emptyDyn(did);
        List<Long> ids = _fillDyn(deck);
        if (ids.isEmpty()) {
            return null;
        }
        // and change to our new deck
        mCol.getDecks().select(did);
        return ids;
    }


    private List<Long> _fillDyn(JSONObject deck) {
        JSONArray terms;
        List<Long> ids;
        try {
            terms = deck.getJSONArray("terms").getJSONArray(0);
            String search = terms.getString(0);
            int limit = terms.getInt(1);
            int order = terms.getInt(2);
            String orderlimit = _dynOrder(order, limit);
            if (!TextUtils.isEmpty(search.trim())) {
                search = String.format(Locale.US, "(%s)", search);
            }
            search = String.format(Locale.US, "%s -is:suspended -is:buried -deck:filtered", search);
            ids = mCol.findCards(search, orderlimit);
            if (ids.isEmpty()) {
                return ids;
            }
            // move the cards over
            mCol.log(deck.getLong("id"), ids);
            _moveToDyn(deck.getLong("id"), ids);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return ids;
    }


    public void emptyDyn(long did) {
        emptyDyn(did, null);
    }


    public void emptyDyn(long did, String lim) {
        if (lim == null) {
            lim = "did = " + did;
        }
        mCol.log(mCol.getDb().queryColumn(Long.class, "select id from cards where " + lim, 0));
        // move out of cram queue
        mCol.getDb().execute(
                "update cards set did = odid, queue = (case when type = 1 then 0 " +
                "else type end), type = (case when type = 1 then 0 else type end), " +
                "due = odue, odue = 0, odid = 0, usn = ? where " + lim,
                new Object[] { mCol.usn() });
    }


    public void remFromDyn(long[] cids) {
        emptyDyn(0, "id IN " + Utils.ids2str(cids) + " AND odid");
    }


    /**
     * Generates the required SQL for order by and limit clauses, for dynamic decks.
     *
     * @param o deck["order"]
     * @param l deck["limit"]
     * @return The generated SQL to be suffixed to "select ... from ... order by "
     */
    private String _dynOrder(int o, int l) {
        String t;
        switch (o) {
            case Consts.DYN_OLDEST:
                t = "c.mod";
                break;
            case Consts.DYN_RANDOM:
                t = "random()";
                break;
            case Consts.DYN_SMALLINT:
                t = "ivl";
                break;
            case Consts.DYN_BIGINT:
                t = "ivl desc";
                break;
            case Consts.DYN_LAPSES:
                t = "lapses desc";
                break;
            case Consts.DYN_ADDED:
                t = "n.id";
                break;
            case Consts.DYN_REVADDED:
                t = "n.id desc";
                break;
            case Consts.DYN_DUE:
                t = "c.due";
                break;
            case Consts.DYN_DUEPRIORITY:
                t = String.format(Locale.US,
                        "(case when queue=2 and due <= %d then (ivl / cast(%d-due+0.001 as real)) else 100000+due end)",
                        mToday, mToday);
                break;
            default:
            	// if we don't understand the term, default to due order
            	t = "c.due";
        }
        return t + " limit " + l;
    }


    private void _moveToDyn(long did, List<Long> ids) {
        ArrayList<Object[]> data = new ArrayList<>();
        long t = Utils.intNow();
        int u = mCol.usn();
        for (long c = 0; c < ids.size(); c++) {
            // start at -100000 so that reviews are all due
            data.add(new Object[] { did, -100000 + c, u, ids.get((int) c) });
        }
        // due reviews stay in the review queue. careful: can't use "odid or did", as sqlite converts to boolean
        String queue = "(CASE WHEN type = 2 AND (CASE WHEN odue THEN odue <= " + mToday +
                " ELSE due <= " + mToday + " END) THEN 2 ELSE 0 END)";
        mCol.getDb().executeMany(
                "UPDATE cards SET odid = (CASE WHEN odid THEN odid ELSE did END), " +
                        "odue = (CASE WHEN odue THEN odue ELSE due END), did = ?, queue = " +
                        queue + ", due = ?, usn = ? WHERE id = ?", data);
    }


    private int _dynIvlBoost(Card card) {
        if (card.getODid() == 0 || card.getType() != 2 || card.getFactor() == 0) {
            Timber.e("error: deck is not a filtered deck");
            return 0;
        }
        long elapsed = card.getIvl() - (card.getODue() - mToday);
        double factor = ((card.getFactor() / 1000.0) + 1.2) / 2.0;
        int ivl = Math.max(1, Math.max(card.getIvl(), (int) (elapsed * factor)));
        JSONObject conf = _revConf(card);
        try {
            return Math.min(conf.getInt("maxIvl"), ivl);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Leeches ****************************************************************** *****************************
     */

    /** Leech handler. True if card was a leech. */
    private boolean _checkLeech(Card card, JSONObject conf) {
        int lf;
        try {
            lf = conf.getInt("leechFails");
            if (lf == 0) {
                return false;
            }
            // if over threshold or every half threshold reps after that
            if (card.getLapses() >= lf && (card.getLapses() - lf) % Math.max(lf / 2, 1) == 0) {
                // add a leech tag
                Note n = card.note();
                n.addTag("leech");
                n.flush();
                // handle
                if (conf.getInt("leechAction") == 0) {
                    // if it has an old due, remove it from cram/relearning
                    if (card.getODue() != 0) {
                        card.setDue(card.getODue());
                    }
                    if (card.getODid() != 0) {
                        card.setDid(card.getODid());
                    }
                    card.setODue(0);
                    card.setODid(0);
                    card.setQueue(-1);
                }
                // notify UI
                if (mContextReference != null) {
                    Context context = mContextReference.get();
                    Hooks.getInstance(context).runHook("leech", card, context);
                }
                return true;
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return false;
    }


    /**
     * Tools ******************************************************************** ***************************
     */

    public JSONObject _cardConf(Card card) {
        return mCol.getDecks().confForDid(card.getDid());
    }


    private JSONObject _newConf(Card card) {
        try {
            JSONObject conf = _cardConf(card);
            // normal deck
            if (card.getODid() == 0) {
                return conf.getJSONObject("new");
            }
            // dynamic deck; override some attributes, use original deck for others
            JSONObject oconf = mCol.getDecks().confForDid(card.getODid());
            JSONArray delays = conf.optJSONArray("delays");
            if (delays == null) {
                delays = oconf.getJSONObject("new").getJSONArray("delays");
            }
            JSONObject dict = new JSONObject();
            // original deck
            dict.put("ints", oconf.getJSONObject("new").getJSONArray("ints"));
            dict.put("initialFactor", oconf.getJSONObject("new").getInt("initialFactor"));
            dict.put("bury", oconf.getJSONObject("new").optBoolean("bury", true));
            // overrides
            dict.put("delays", delays);
            dict.put("separate", conf.getBoolean("separate"));
            dict.put("order", Consts.NEW_CARDS_DUE);
            dict.put("perDay", mReportLimit);
            return dict;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    private JSONObject _lapseConf(Card card) {
        try {
            JSONObject conf = _cardConf(card);
            // normal deck
            if (card.getODid() == 0) {
                return conf.getJSONObject("lapse");
            }
            // dynamic deck; override some attributes, use original deck for others
            JSONObject oconf = mCol.getDecks().confForDid(card.getODid());
            JSONArray delays = conf.optJSONArray("delays");
            if (delays == null) {
                delays = oconf.getJSONObject("lapse").getJSONArray("delays");
            }
            JSONObject dict = new JSONObject();
            // original deck
            dict.put("minInt", oconf.getJSONObject("lapse").getInt("minInt"));
            dict.put("leechFails", oconf.getJSONObject("lapse").getInt("leechFails"));
            dict.put("leechAction", oconf.getJSONObject("lapse").getInt("leechAction"));
            dict.put("mult", oconf.getJSONObject("lapse").getDouble("mult"));
            // overrides
            dict.put("delays", delays);
            dict.put("resched", conf.getBoolean("resched"));
            return dict;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    private JSONObject _revConf(Card card) {
        try {
            JSONObject conf = _cardConf(card);
            // normal deck
            if (card.getODid() == 0) {
                return conf.getJSONObject("rev");
            }
            // dynamic deck
            return mCol.getDecks().confForDid(card.getODid()).getJSONObject("rev");
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    public String _deckLimit() {
        return Utils.ids2str(mCol.getDecks().active());
    }


    private boolean _resched(Card card) {
        JSONObject conf = _cardConf(card);
        try {
            if (conf.getInt("dyn") == 0) {
                return true;
            }
            return conf.getBoolean("resched");
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Daily cutoff ************************************************************* **********************************
     * This function uses GregorianCalendar so as to be sensitive to leap years, daylight savings, etc.
     */

    private void _updateCutoff() {
        int oldToday = mToday;
        // days since col created
        mToday = (int) ((Utils.now() - mCol.getCrt()) / 86400);
        // end of day cutoff
        mDayCutoff = mCol.getCrt() + ((mToday + 1) * 86400);
        if (oldToday != mToday) {
            mCol.log(mToday, mDayCutoff);
        }
        // update all daily counts, but don't save decks to prevent needless conflicts. we'll save on card answer
        // instead
        for (JSONObject deck : mCol.getDecks().all()) {
            update(deck);
        }
        // unbury if the day has rolled over
        int unburied = mCol.getConf().optInt("lastUnburied", 0);
        if (unburied < mToday) {
            unburyCards();
        }
    }


    private void update(JSONObject g) {
        for (String t : new String[] { "new", "rev", "lrn", "time" }) {
            String key = t + "Today";
            try {
                if (g.getJSONArray(key).getInt(0) != mToday) {
                    JSONArray ja = new JSONArray();
                    ja.put(mToday);
                    ja.put(0);
                    g.put(key, ja);
                }
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }
    }


    public void _checkDay() {
        // check if the day has rolled over
        if (Utils.now() > mDayCutoff) {
            reset();
        }
    }


    /**
     * Deck finished state ******************************************************
     * *****************************************
     */

    public CharSequence finishedMsg(Context context) {
        SpannableStringBuilder sb = new SpannableStringBuilder();
        sb.append(context.getString(R.string.studyoptions_congrats_finished));
        StyleSpan boldSpan = new StyleSpan(Typeface.BOLD);
        sb.setSpan(boldSpan, 0, sb.length(), 0);
        sb.append(_nextDueMsg(context));
        // sb.append("\n\n");
        // sb.append(_tomorrowDueMsg(context));
        return sb;
    }


    public String _nextDueMsg(Context context) {
        StringBuilder sb = new StringBuilder();
        if (revDue()) {
            sb.append("\n\n");
            sb.append(context.getString(R.string.studyoptions_congrats_more_rev));
        }
        if (newDue()) {
            sb.append("\n\n");
            sb.append(context.getString(R.string.studyoptions_congrats_more_new));
        }
        if (haveBuried()) {
            String now;
            if (mHaveCustomStudy) {
                now = " " + context.getString(R.string.sched_unbury_action);
            } else {
                now = "";
            }
            sb.append("\n\n");
            sb.append("" + context.getString(R.string.sched_has_buried) + now);
        }
        try {
            if (mHaveCustomStudy && mCol.getDecks().current().getInt("dyn") == 0) {
                sb.append("\n\n");
                sb.append(context.getString(R.string.studyoptions_congrats_custom));
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return sb.toString();
    }


    /** true if there are any rev cards due. */
    public boolean revDue() {
        return mCol.getDb()
                .queryScalar(
                        "SELECT 1 FROM cards WHERE did IN " + _deckLimit() + " AND queue = 2 AND due <= " + mToday
                                + " LIMIT 1") != 0;
    }


    /** true if there are any new cards due. */
    public boolean newDue() {
        return mCol.getDb().queryScalar("SELECT 1 FROM cards WHERE did IN " + _deckLimit() + " AND queue = 0 LIMIT 1") != 0;
    }


    public boolean haveBuried() {
        return haveBuried(mCol.getDecks().active());
    }

    private boolean haveBuried(List<Long> allDecks) {
        // Refactored to allow querying an arbitrary deck
        String sdids = Utils.ids2str(allDecks);
        int cnt = mCol.getDb().queryScalar(String.format(Locale.US,
                "select 1 from cards where queue = -2 and did in %s limit 1", sdids));
        return cnt != 0;
    }


    /**
     * Next time reports ********************************************************
     * ***************************************
     */

    /**
     * Return the next interval for a card and ease as a string.
     *
     * For a given card and ease, this returns a string that shows when the card will be shown again when the
     * specific ease button (AGAIN, GOOD etc.) is touched. This uses unit symbols like 鈥渟鈥/****************************************************************************************
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 * Copyright (c) 2014 Timothy rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.Context;
import android.media.AudioManager;
import android.media.MediaPlayer;
import android.media.MediaMetadataRetriever;
import android.media.MediaPlayer.OnCompletionListener;
import android.media.ThumbnailUtils;
import android.net.Uri;
import android.os.Build;
import android.provider.MediaStore;

import android.view.Display;
import android.view.WindowManager;
import android.webkit.MimeTypeMap;
import android.widget.VideoView;

import com.ichi2.anki.AbstractFlashcardViewer;
import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.ReadText;
import com.ichi2.compat.CompatHelper;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import timber.log.Timber;

/**
 * Class used to parse, load and play sound files on AnkiDroid.
 */
public class Sound {

    /**
     * Pattern used to identify the markers for sound files
     */
    public static Pattern sSoundPattern = Pattern.compile("\\[sound\\:([^\\[\\]]*)\\]");

    /**
     * Pattern used to parse URI (according to http://tools.ietf.org/html/rfc3986#page-50)
     */
    private static Pattern sUriPattern = Pattern.compile("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$");

    /**
     * Media player used to play the sounds
     */
    private MediaPlayer mMediaPlayer;

    /**
     * AudioManager to request/release audio focus
     */
    private AudioManager mAudioManager;

    /**
     * OnCompletionListener so that external video player can notify to play next sound
     */
    private static OnCompletionListener mPlayAllListener;

    /**
     * Weak reference to the activity which is attempting to play the sound
     */
    private WeakReference<Activity> mCallingActivity;

    /**
     * Subset Flags: Flags that indicate the subset of sounds to involve
     */
    public static final int  SOUNDS_QUESTION = 0;
    public static final int  SOUNDS_ANSWER = 1;
    public static final int  SOUNDS_QUESTION_AND_ANSWER = 2;

    /**
     * Stores sounds for the current card, key is one of the subset flags. It is intended that it not contain empty lists, and code assumes this will be true.
     */
    private HashMap<Integer, ArrayList<String>> mSoundPaths = new HashMap<>();


    /**
     * Whitelist for video extensions
     */
    private static final String[] VIDEO_WHITELIST = {"3gp", "mp4", "webm", "mkv", "flv"};

    /**
     * Listener to handle audio focus. Currently blank because we're not respecting losing focus from other apps.
     */
    private static AudioManager.OnAudioFocusChangeListener afChangeListener = new AudioManager.OnAudioFocusChangeListener() {
        public void onAudioFocusChange(int focusChange) {
        }
    };


    // Clears current sound paths; call before parseSounds() calls
    public void resetSounds() {
        mSoundPaths.clear();
    }

    /**
     * resetSounds removes lists of sounds
     * @param which -- One of the subset flags, such as Sound.SOUNDS_QUESTION
     */
    public void resetSounds(int which) {
        mSoundPaths.remove(which);
    }


    /**
     * The function addSounds() parses content for sound files, and stores entries to the filepaths for them,
     * categorized as belonging to the front (question) or back (answer) of cards. Note that all sounds embedded in
     * the content will be given the same base categorization of question or answer. Additionally, the result is to be
     * sorted by the order of appearance on the card.
     * @param soundDir -- base path to the media files
     * @param content -- parsed for sound entries, the entries expected in display order
     * @param qa -- the base categorization of the sounds in the content, Sound.SOUNDS_QUESTION or Sound.SOUNDS_ANSWER
     */
    public void addSounds(String soundDir, String content, int qa) {
        Matcher matcher = sSoundPattern.matcher(content);
        // While there is matches of the pattern for sound markers
        while (matcher.find()) {
            // Create appropriate list if needed; list must not be empty so long as code does no check
            if (!mSoundPaths.containsKey(qa)) {
                mSoundPaths.put(qa, new ArrayList<String>());
            }

            // Get the sound file name
            String sound = matcher.group(1).trim();

            // Construct the sound path and store it
            mSoundPaths.get(qa).add(getSoundPath(soundDir, sound));
        }
    }

    /**
     * makeQuestionAnswerSoundList creates a single list of both the question and answer audio only if it does not
     * already exist. It's intended for lazy evaluation, only in the rare cases when both sides are fully played
     * together, which even when configured as supported may not be instigated
     * @return True if a non-null list was created, or false otherwise
     */
    public Boolean makeQuestionAnswerList() {
        // if combined list already exists, don't recreate
        if (mSoundPaths.containsKey(Sound.SOUNDS_QUESTION_AND_ANSWER)) {
            return false; // combined list already exists
        }

        // make combined list only if necessary to avoid an empty combined list
        if (mSoundPaths.containsKey(Sound.SOUNDS_QUESTION) || mSoundPaths.containsKey(Sound.SOUNDS_ANSWER)) {
            // some list exists to place into combined list
            mSoundPaths.put(Sound.SOUNDS_QUESTION_AND_ANSWER, new ArrayList<String>());
        } else { // no need to make list
            return false;
        }

        ArrayList<String> combinedSounds = mSoundPaths.get(Sound.SOUNDS_QUESTION_AND_ANSWER);

        if (mSoundPaths.containsKey(Sound.SOUNDS_QUESTION)) {
            combinedSounds.addAll(mSoundPaths.get(Sound.SOUNDS_QUESTION));
        }
        if (mSoundPaths.containsKey(Sound.SOUNDS_ANSWER)) {
            combinedSounds.addAll(mSoundPaths.get(Sound.SOUNDS_ANSWER));
        }

        return true;
    }

    /**
     * expandSounds takes content with embedded sound file placeholders and expands them to reference the actual media
     * file
     *
     * @param soundDir -- the base path of the media files
     * @param content -- card content to be rendered that may contain embedded audio
     * @return -- the same content but in a format that will render working play buttons when audio was embedded
     */
    public static String expandSounds(String soundDir, String content) {
        StringBuilder stringBuilder = new StringBuilder();
        String contentLeft = content;

        Timber.d("expandSounds");

        Matcher matcher = sSoundPattern.matcher(content);
        // While there is matches of the pattern for sound markers
        while (matcher.find()) {
            // Get the sound file name
            String sound = matcher.group(1).trim();

            // Construct the sound path
            String soundPath = getSoundPath(soundDir, sound);

            // Construct the new content, appending the substring from the beginning of the content left until the
            // beginning of the sound marker
            // and then appending the html code to add the play button
            String button;
            if (CompatHelper.getSdkVersion() >= Build.VERSION_CODES.HONEYCOMB) {
                button = "<svg viewBox=\"0 0 32 32\"><polygon points=\"11,25 25,16 11,7\"/>Replay</svg>";
            } else {
                button = "<img src='file:///android_asset/inline_play_button.png' />";
            }
            String soundMarker = matcher.group();
            int markerStart = contentLeft.indexOf(soundMarker);
            stringBuilder.append(contentLeft.substring(0, markerStart));
            // The <span> around the button (SVG or PNG image) is needed to make the vertical alignment work.
            stringBuilder.append("<a class='replaybutton' href=\"playsound:" + soundPath + "\">"
                    + "<span>"+ button
                    + "</span></a>");
            contentLeft = contentLeft.substring(markerStart + soundMarker.length());
            Timber.d("Content left = %s", contentLeft);
        }

        // unused code related to tts support taken out after v2.2alpha55
        // if/when tts support is considered complete, these comment lines serve no purpose

        stringBuilder.append(contentLeft);

        return stringBuilder.toString();
    }


    /**
     * Plays the sounds for the indicated sides
     * @param qa -- One of Sound.SOUNDS_QUESTION, Sound.SOUNDS_ANSWER, or Sound.SOUNDS_QUESTION_AND_ANSWER
     */
    public void playSounds(int qa) {
        // If there are sounds to play for the current card, start with the first one
        if (mSoundPaths != null && mSoundPaths.containsKey(qa)) {
            playSound(mSoundPaths.get(qa).get(0), new PlayAllCompletionListener(qa));
        } else if (mSoundPaths != null && qa == Sound.SOUNDS_QUESTION_AND_ANSWER) {
            if (makeQuestionAnswerList()) {
                playSound(mSoundPaths.get(qa).get(0), new PlayAllCompletionListener(qa));
            }
        }
    }

    /**
     * Returns length in milliseconds.
     * @param qa -- One of Sound.SOUNDS_QUESTION, Sound.SOUNDS_ANSWER, or Sound.SOUNDS_QUESTION_AND_ANSWER
     */
    public long getSoundsLength(int qa) {
        long length = 0;
        if (mSoundPaths != null && (qa == Sound.SOUNDS_QUESTION_AND_ANSWER && makeQuestionAnswerList() || mSoundPaths.containsKey(qa))) {
            MediaMetadataRetriever metaRetriever = new MediaMetadataRetriever();
            for (String uri_string : mSoundPaths.get(qa)) {
                Uri soundUri = Uri.parse(uri_string);
                try {
                    metaRetriever.setDataSource(AnkiDroidApp.getInstance().getApplicationContext(), soundUri);
                    length += Long.parseLong(metaRetriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION));
                } catch (IllegalArgumentException iae) {
                    Timber.e(iae, "metaRetriever - Error setting Data Source for mediaRetriever (media doesn't exist).");
                }
            }
        }
        return length;
    }

    /**
     * Plays the given sound or video and sets playAllListener if available on media player to start next media
     * @param soundPath
     * @param playAllListener
     */
    public void playSound(String soundPath, OnCompletionListener playAllListener) {
        playSound(soundPath, playAllListener, null);
    }

    /**
     * Plays the given sound or video and sets playAllListener if available on media player to start next media.
     * If videoView is null and the media is a video, then a request is sent to start the VideoPlayer Activity
     * @param soundPath
     * @param playAllListener
     * @param videoView
     */
    @SuppressLint("NewApi")
    public void playSound(String soundPath, OnCompletionListener playAllListener, final VideoView videoView) {
        Timber.d("Playing %s has listener? %b", soundPath, playAllListener != null);
        Uri soundUri = Uri.parse(soundPath);

        if (soundPath.substring(0, 3).equals("tts")) {
            // TODO: give information about did
//            ReadText.textToSpeech(soundPath.substring(4, soundPath.length()),
//                    Integer.parseInt(soundPath.substring(3, 4)));
        } else {
            // Check if the file extension is that of a known video format
            final String extension = soundPath.substring(soundPath.lastIndexOf(".") + 1).toLowerCase();
            boolean isVideo = Arrays.asList(VIDEO_WHITELIST).contains(extension);
            if (!isVideo) {
                final String guessedType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
                isVideo = isVideo || (guessedType != null && guessedType.startsWith("video/"));
            }
            // Also check that there is a video thumbnail, as some formats like mp4 can be audio only
            isVideo = isVideo &&
                ThumbnailUtils.createVideoThumbnail(soundUri.getPath(), MediaStore.Images.Thumbnails.MINI_KIND) != null;
            // No thumbnail: no video after all. (Or maybe not a video we can handle on the specific device.)
            // If video file but no SurfaceHolder provided then ask AbstractFlashcardViewer to provide a VideoView
            // holder
            if (isVideo && videoView == null && mCallingActivity != null && mCallingActivity.get() != null) {
                mPlayAllListener = playAllListener;
                ((AbstractFlashcardViewer) mCallingActivity.get()).playVideo(soundPath);
                return;
            }
            // Play media
            try {
                // Create media player
                if (mMediaPlayer == null) {
                    mMediaPlayer = new MediaPlayer();
                } else {
                    mMediaPlayer.reset();
                }
                if (mAudioManager == null) {
                    mAudioManager = (AudioManager) AnkiDroidApp.getInstance().getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
                }
                // Provide a VideoView to the MediaPlayer if valid video file
                if (isVideo && videoView != null) {
                    mMediaPlayer.setDisplay(videoView.getHolder());
                    mMediaPlayer.setOnVideoSizeChangedListener(new MediaPlayer.OnVideoSizeChangedListener() {
                        @Override
                        public void onVideoSizeChanged(MediaPlayer mp, int width, int height) {
                            configureVideo(videoView, width, height);
                        }
                    });
                }
                // Setup the MediaPlayer
                mMediaPlayer.setDataSource(AnkiDroidApp.getInstance().getApplicationContext(), soundUri);
                mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
                mMediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
                    @Override
                    public void onPrepared(MediaPlayer mp) {
                        mMediaPlayer.start();
                    }
                });
                if (playAllListener != null) {
                    mMediaPlayer.setOnCompletionListener(playAllListener);
                }
                mMediaPlayer.prepareAsync();
                mAudioManager.requestAudioFocus(afChangeListener, AudioManager.STREAM_MUSIC,
                        AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK);
            } catch (Exception e) {
                Timber.e(e, "playSounds - Error reproducing sound %s", soundPath);
                releaseSound();
            }
        }
    }

    private static void configureVideo(VideoView videoView, int videoWidth, int videoHeight) {
        // get the display
        Context context = AnkiDroidApp.getInstance().getApplicationContext();
        WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        Display display = wm.getDefaultDisplay();
        // adjust the size of the video so it fits on the screen
        float videoProportion = (float) videoWidth / (float) videoHeight;
        int screenWidth = display.getWidth();
        int screenHeight = display.getHeight();
        float screenProportion = (float) screenWidth / (float) screenHeight;
        android.view.ViewGroup.LayoutParams lp = videoView.getLayoutParams();

        if (videoProportion > screenProportion) {
            lp.width = screenWidth;
            lp.height = (int) ((float) screenWidth / videoProportion);
        } else {
            lp.width = (int) (videoProportion * (float) screenHeight);
            lp.height = screenHeight;
        }
        videoView.setLayoutParams(lp);
    }

    public void notifyConfigurationChanged(VideoView videoView) {
        if (mMediaPlayer != null) {
            configureVideo(videoView, mMediaPlayer.getVideoWidth(), mMediaPlayer.getVideoHeight());
        }
    }

    /**
     * Class used to play all sounds for a given card side
     */
    private final class PlayAllCompletionListener implements OnCompletionListener {

        /**
         * Question/Answer
         */
        private final int mQa;

        /**
         * next sound to play (onCompletion() is first called after the first (0) has been played)
         */
        private int mNextToPlay = 1;


        private PlayAllCompletionListener(int qa) {
            mQa = qa;
        }


        @Override
        public void onCompletion(MediaPlayer mp) {
            // If there is still more sounds to play for the current card, play the next one
            if (mSoundPaths.containsKey(mQa) && mNextToPlay < mSoundPaths.get(mQa).size()) {
                playSound(mSoundPaths.get(mQa).get(mNextToPlay++), this);
            } else {
                releaseSound();
            }
        }
    }

    /**
     * Releases the sound.
     */
    private void releaseSound() {
        if (mMediaPlayer != null) {
            mMediaPlayer.release();
            mMediaPlayer = null;
        }
        if (mAudioManager != null) {
            mAudioManager.abandonAudioFocus(afChangeListener);
            mAudioManager = null;
        }
    }

    /**
     * Stops the playing sounds.
     */
    public void stopSounds() {
        if (mMediaPlayer != null) {
            mMediaPlayer.stop();
            releaseSound();
        }
        ReadText.stopTts();
    }

    /**
     * @param soundDir -- base path to the media files.
     * @param sound -- path to the sound file from the card content.
     * @return absolute URI to the sound file.
     */
    private static String getSoundPath(String soundDir, String sound) {
        if (hasURIScheme(sound)) {
            return sound;
        }
        return soundDir + Uri.encode(sound);
    }

    /**
     * @param path -- path to the sound file from the card content.
     * @return true if path is well-formed URI and contains URI scheme.
     */
    private static boolean hasURIScheme(String path) {
        Matcher uriMatcher = sUriPattern.matcher(path.trim());
        return uriMatcher.matches() && uriMatcher.group(2) != null;
    }

    /**
     * Set the context for the calling activity (necessary for playing videos)
     * @param activityRef
     */
    public void setContext(WeakReference<Activity> activityRef) {
        mCallingActivity = activityRef;
    }

    public OnCompletionListener getMediaCompletionListener() {
        return mPlayAllListener;
    }

    public boolean hasQuestion() {
        return mSoundPaths.containsKey(Sound.SOUNDS_QUESTION);
    }
    public boolean hasAnswer() {
        return mSoundPaths.containsKey(Sound.SOUNDS_ANSWER);
    }
}
/****************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2014 Michael Goldbach <michael@m-goldbach.net>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

import android.content.Context;
import android.database.Cursor;
import android.text.TextUtils;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.R;
import com.ichi2.anki.stats.OverviewStatsBuilder;
import com.ichi2.anki.stats.StatsMetaInfo;
import com.ichi2.libanki.hooks.Hooks;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.GregorianCalendar;
import java.util.Vector;

import timber.log.Timber;


public class Stats {

    public enum AxisType {
        TYPE_MONTH(30, R.string.stats_period_month),
        TYPE_YEAR(365, R.string.stats_period_year),
        TYPE_LIFE(-1, R.string.stats_period_lifetime);

        public int days;
        public int descriptionId;
        AxisType(int dayss, int descriptionId) {
            this.days = dayss;
            this.descriptionId = descriptionId;
        }
    }

    public enum ChartType {FORECAST, REVIEW_COUNT, REVIEW_TIME,
        INTERVALS, HOURLY_BREAKDOWN, WEEKLY_BREAKDOWN, ANSWER_BUTTONS, CARDS_TYPES, OTHER}

    private static Stats sCurrentInstance;

    private Collection mCol;
    private boolean mWholeCollection;
    private boolean mDynamicAxis = false;
    private double[][] mSeriesList;

    private boolean mHasColoredCumulative = false;
    private AxisType mType;
    private int mTitle;
    private boolean mBackwards;
    private int[] mValueLabels;
    private int[] mColors;
    private int[] mAxisTitles;
    private int mMaxCards = 0;
    private int mMaxElements = 0;
    private double mFirstElement = 0;
    private double mLastElement = 0;
    private int mZeroIndex = 0;
    private boolean mFoundLearnCards = false;
    private boolean mFoundCramCards = false;
    private boolean mFoundRelearnCards;
    private double[][] mCumulative = null;
    private String mAverage;
    private String mLongest;
    private double mPeak;
    private double mMcount;


    public static double SECONDS_PER_DAY = 86400.0;

    public Stats(Collection col, boolean wholeCollection) {
        mCol = col;
        mWholeCollection = wholeCollection;
        sCurrentInstance = this;
    }

    public double[][] getSeriesList() {
        return mSeriesList;
    }
    public double[][] getCumulative() {
        return mCumulative;
    }


    public Object[] getMetaInfo() {
        String title;
        if (mWholeCollection) {
            title = AnkiDroidApp.getInstance().getResources().getString(R.string.card_browser_all_decks);
        } else {
            try {
                title = mCol.getDecks().current().getString("name");
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }
        return new Object[] {/*0*/ mType, /*1*/mTitle, /*2*/mBackwards, /*3*/mValueLabels, /*4*/mColors,
         /*5*/mAxisTitles, /*6*/title, /*7*/mMaxCards, /*8*/mMaxElements, /*9*/mFirstElement, /*10*/mLastElement,
                /*11*/mZeroIndex, /*12*/mFoundLearnCards, /*13*/mFoundCramCards, /*14*/mFoundRelearnCards, /*15*/mAverage,
                /*16*/mLongest, /*17*/mPeak, /*18*/mMcount, /*19*/mHasColoredCumulative, /*20*/mDynamicAxis};
    }


    /**
     * Today's statistics
     */
    public int[] calculateTodayStats(){
        String lim = _getDeckFilter();
        if (lim.length() > 0) {
            lim = " and " + lim;
        }

        Cursor cur = null;
        String query = "select count(), sum(time)/1000, "+
                "sum(case when ease = 1 then 1 else 0 end), "+ /* failed */
                "sum(case when type = 0 then 1 else 0 end), "+ /* learning */
                "sum(case when type = 1 then 1 else 0 end), "+ /* review */
                "sum(case when type = 2 then 1 else 0 end), "+ /* relearn */
                "sum(case when type = 3 then 1 else 0 end) "+ /* filter */
                "from revlog where id > " + ((mCol.getSched().getDayCutoff()-SECONDS_PER_DAY)*1000) + " " +  lim;
        Timber.d("todays statistics query: %s", query);

        int cards, thetime, failed, lrn, rev, relrn, filt;
        try {
            cur = mCol.getDb()
                    .getDatabase()
                    .rawQuery(query, null);

            cur.moveToFirst();
            cards = cur.getInt(0);
            thetime = cur.getInt(1);
            failed = cur.getInt(2);
            lrn = cur.getInt(3);
            rev = cur.getInt(4);
            relrn = cur.getInt(5);
            filt = cur.getInt(6);



        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        query = "select count(), sum(case when ease = 1 then 0 else 1 end) from revlog " +
        "where lastIvl >= 21 and id > " + ((mCol.getSched().getDayCutoff()-SECONDS_PER_DAY)*1000) + " " +  lim;
        Timber.d("todays statistics query 2: %s", query);

        int mcnt, msum;
        try {
            cur = mCol.getDb()
                    .getDatabase()
                    .rawQuery(query, null);

            cur.moveToFirst();
            mcnt = cur.getInt(0);
            msum = cur.getInt(1);
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }

        return new int[]{cards, thetime, failed, lrn, rev, relrn, filt, mcnt, msum};
    }

    private String getRevlogTimeFilter(AxisType timespan, boolean inverse) {
        if (timespan == AxisType.TYPE_LIFE) {
            return "";
        }
        else {
            String operator;
            if (inverse) {
                operator = "<= ";
            } else {
                operator = "> ";
            }
            return "id "+ operator + ((mCol.getSched().getDayCutoff() - (timespan.days * SECONDS_PER_DAY)) * 1000);
        }
    }

    public int getNewCards(AxisType timespan) {
        String filter = getRevlogFilter(timespan,false);
        String queryNeg = "";
        if (timespan != AxisType.TYPE_LIFE){
            String invfilter = getRevlogFilter(timespan,true);
            queryNeg = " EXCEPT SELECT distinct cid FROM revlog " + invfilter;
        }

        String query = "SELECT COUNT(*) FROM(\n" +
                "            SELECT distinct cid\n" +
                "            FROM revlog \n" +
                             filter +
                             queryNeg +
                "        )";
        Timber.d("New cards query: %s", query);
        Cursor cur = null;
        int res = 0;
        try {
            cur = mCol.getDb().getDatabase().rawQuery(query, null);
            while (cur.moveToNext()) {
                res = cur.getInt(0);
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }

        return res;
    }

    String getRevlogFilter(AxisType timespan,boolean inverseTimeSpan){
        ArrayList<String> lims = new ArrayList<>();
        String dayFilter = getRevlogTimeFilter(timespan, inverseTimeSpan);
        if (!TextUtils.isEmpty(dayFilter)) {
            lims.add(dayFilter);
        }
        String lim = _getDeckFilter().replaceAll("[\\[\\]]", "");
        if (lim.length() > 0){
            lims.add(lim);
        }

        if (!lims.isEmpty()) {
            lim = "WHERE ";
            lim += TextUtils.join(" AND ", lims.toArray());
        }

        return lim;
    }

    public void calculateOverviewStatistics(AxisType timespan, OverviewStatsBuilder.OverviewStats oStats) {
        oStats.allDays = timespan.days;
        String lim = getRevlogFilter(timespan,false);
        Cursor cur = null;
        try {
            cur = mCol.getDb().getDatabase().rawQuery(
                    "SELECT COUNT(*) as num_reviews, sum(case when type = 0 then 1 else 0 end) as new_cards FROM revlog " + lim, null);
            while (cur.moveToNext()) {
                oStats.totalReviews = cur.getInt(0);
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }

        String cntquery = "SELECT  COUNT(*) numDays, MIN(day) firstDay, SUM(time_per_day) sum_time  from (" +
                " SELECT (cast((id/1000 - " + mCol.getSched().getDayCutoff() + ") / "+SECONDS_PER_DAY+" AS INT)) AS day,  sum(time/1000.0/60.0) AS time_per_day"
                + " FROM revlog " + lim + " GROUP BY day ORDER BY day)";
        Timber.d("Count cntquery: %s", cntquery);
        try {
            cur = mCol.getDb().getDatabase().rawQuery(cntquery, null);
            while (cur.moveToNext()) {
                oStats.daysStudied = cur.getInt(0);
                oStats.totalTime = cur.getDouble(2);
                if (timespan == AxisType.TYPE_LIFE) {
                    oStats.allDays = Math.abs(cur.getInt(1)) + 1; // +1 for today
                }
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }

        try {
            cur = mCol.getDb().getDatabase().rawQuery(
                    "select avg(ivl), max(ivl) from cards where did in " +_limit() + " and queue = 2", null);
            cur.moveToFirst();
            oStats.averageInterval = cur.getDouble(0);
            oStats.longestInterval = cur.getDouble(1);
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        oStats.reviewsPerDayOnAll = (double) oStats.totalReviews / oStats.allDays;
        oStats.reviewsPerDayOnStudyDays = oStats.daysStudied == 0 ? 0 : (double) oStats.totalReviews / oStats.daysStudied;

        oStats.timePerDayOnAll = oStats.totalTime / oStats.allDays;
        oStats.timePerDayOnStudyDays = oStats.daysStudied == 0 ? 0 : oStats.totalTime / oStats.daysStudied;

        oStats.totalNewCards = getNewCards(timespan);
        oStats.newCardsPerDay = (double) oStats.totalNewCards / (double) oStats.allDays;
    }

    public boolean calculateDue(Context context, AxisType type) {
        // Not in libanki
        StatsMetaInfo metaInfo = new StatsMetaInfo();
        metaInfo = (StatsMetaInfo) Hooks.getInstance(context).runFilter("advancedStatistics", metaInfo, type, context, _limit());
        if (metaInfo.isStatsCalculated()) {
            mDynamicAxis = metaInfo.ismDynamicAxis();
            mHasColoredCumulative = metaInfo.ismHasColoredCumulative();
            mType = metaInfo.getmType();
            mTitle = metaInfo.getmTitle();
            mBackwards = metaInfo.ismBackwards();
            mValueLabels = metaInfo.getmValueLabels();
            mColors = metaInfo.getmColors();
            mAxisTitles = metaInfo.getmAxisTitles();
            mMaxCards = metaInfo.getmMaxCards();
            mMaxElements = metaInfo.getmMaxElements();
            mFirstElement = metaInfo.getmFirstElement();
            mLastElement = metaInfo.getmLastElement();
            mZeroIndex = metaInfo.getmZeroIndex();
            mCumulative = metaInfo.getmCumulative();
            mMcount = metaInfo.getmMcount();
            mSeriesList = metaInfo.getmSeriesList();
            return metaInfo.isDataAvailable();
        } else {
            return calculateDue(type);
        }
    }

    /**
     * Due and cumulative due
     * ***********************************************************************************************
     */
    private boolean calculateDue(AxisType type) {
        mHasColoredCumulative = false;
        mType = type;
        mDynamicAxis = true;
        mBackwards = true;
        mTitle = R.string.stats_forecast;
        mValueLabels = new int[] { R.string.statistics_young, R.string.statistics_mature };
        mColors = new int[] { R.attr.stats_young, R.attr.stats_mature };
        mAxisTitles = new int[] { type.ordinal(), R.string.stats_cards, R.string.stats_cumulative_cards };
        int end = 0;
        int chunk = 0;
        switch (type) {
            case TYPE_MONTH:
                end = 31;
                chunk = 1;
                break;
            case TYPE_YEAR:
                end = 52;
                chunk = 7;
                break;
            case TYPE_LIFE:
                end = -1;
                chunk = 30;
                break;
        }

        String lim = "";// AND due - " + mCol.getSched().getToday() + " >= " + start; // leave this out in order to show
        // card too which were due the days before
        if (end != -1) {
            lim += " AND day <= " + end;
        }

        ArrayList<int[]> dues = new ArrayList<>();
        Cursor cur = null;
        try {
            String query;
            query = "SELECT (due - " + mCol.getSched().getToday() + ")/" + chunk
                    + " AS day, " // day
                    + "count(), " // all cards
                    + "sum(CASE WHEN ivl >= 21 THEN 1 ELSE 0 END) " // mature cards
                    + "FROM cards WHERE did IN " + _limit() + " AND queue IN (2,3)" + lim
                    + " GROUP BY day ORDER BY day";
            Timber.d("Forecast query: %s", query);
            cur = mCol
                    .getDb()
                    .getDatabase()
                    .rawQuery(query, null);
            while (cur.moveToNext()) {
                dues.add(new int[] { cur.getInt(0), cur.getInt(1), cur.getInt(2) });
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        // small adjustment for a proper chartbuilding with achartengine
        if (dues.size() == 0 || dues.get(0)[0] > 0) {
            dues.add(0, new int[] { 0, 0, 0 });
        }
        if (end == -1 && dues.size() < 2) {
            end = 31;
        }
        if (type != AxisType.TYPE_LIFE && dues.get(dues.size() - 1)[0] < end) {
            dues.add(new int[] { end, 0, 0 });
        } else if (type == AxisType.TYPE_LIFE && dues.size() < 2) {
            dues.add(new int[] { Math.max(12, dues.get(dues.size() - 1)[0] + 1), 0, 0 });
        }

        mSeriesList = new double[3][dues.size()];
        for (int i = 0; i < dues.size(); i++) {
            int[] data = dues.get(i);

            if (data[1] > mMaxCards) {
                mMaxCards = data[1];
            }

            mSeriesList[0][i] = data[0];
            mSeriesList[1][i] = data[1];
            mSeriesList[2][i] = data[2];
            if (data[0] > mLastElement) {
                mLastElement = data[0];
            }
            if (data[0] == 0) {
                mZeroIndex = i;
            }
        }
        mMaxElements = dues.size()-1;
        switch (mType) {
            case TYPE_MONTH:
                mLastElement = 31;
                break;
            case TYPE_YEAR:
                mLastElement = 52;
                break;
            default:
        }
        mFirstElement = 0;
        mHasColoredCumulative = false;
        mCumulative = Stats.createCumulative(new double[][]{mSeriesList[0], mSeriesList[1]}, mZeroIndex);
        mMcount = mCumulative[1][mCumulative[1].length-1];
        //some adjustments to not crash the chartbuilding with emtpy data
        if (mMaxElements == 0) {
            mMaxElements = 10;
        }
        if (mMcount == 0) {
            mMcount = 10;
        }
        if (mFirstElement == mLastElement) {
            mFirstElement = 0;
            mLastElement = 6;
        }
        if (mMaxCards == 0) {
            mMaxCards = 10;
        }
        return dues.size() > 0;
    }


    public boolean calculateReviewCount(AxisType type) {
        return calculateDone(type, ChartType.REVIEW_COUNT);
    }

    public boolean calculateReviewTime(AxisType type) {
        return calculateDone(type, ChartType.REVIEW_TIME);
    }


    /**
     * Calculation of Review count or Review time
     * @param type Type
     * @param charType CharType.REVIEW_COUNT or Chartype.REVIEW_TIME
     */
    private boolean calculateDone(AxisType type,  ChartType charType) {
        mHasColoredCumulative = true;
        mDynamicAxis = true;
        mType = type;
        mBackwards = true;
        if (charType == ChartType.REVIEW_COUNT) {
            mTitle = R.string.stats_review_count;
            mAxisTitles = new int[] { type.ordinal(), R.string.stats_answers, R.string.stats_cumulative_answers };
        } else if(charType == ChartType.REVIEW_TIME) {
            mTitle = R.string.stats_review_time;
        }
        mValueLabels = new int[] { R.string.statistics_cram, R.string.statistics_learn, R.string.statistics_relearn, R.string.statistics_young,
                R.string.statistics_mature };
        mColors = new int[] { R.attr.stats_cram, R.attr.stats_learn, R.attr.stats_relearn, R.attr.stats_young,
                R.attr.stats_mature };
        int num = 0;
        int chunk = 0;
        switch (type) {
            case TYPE_MONTH:
                num = 31;
                chunk = 1;
                break;
            case TYPE_YEAR:
                num = 52;
                chunk = 7;
                break;
            case TYPE_LIFE:
                num = -1;
                chunk = 30;
                break;
        }
        ArrayList<String> lims = new ArrayList<>();
        if (num != -1) {
            lims.add("id > " + ((mCol.getSched().getDayCutoff() - ((num + 1) * chunk * SECONDS_PER_DAY)) * 1000));
        }
        String lim = _getDeckFilter().replaceAll("[\\[\\]]", "");
        if (lim.length() > 0) {
            lims.add(lim);
        }
        if (lims.size() > 0) {
            lim = "WHERE ";
            while (lims.size() > 1) {
                lim += lims.remove(0) + " AND ";
            }
            lim += lims.remove(0);
        } else {
            lim = "";
        }
        String ti;
        String tf;
        if (charType == ChartType.REVIEW_TIME) {
            ti = "time/1000.0";
            if (mType == AxisType.TYPE_MONTH) {
                tf = "/60.0"; // minutes
                mAxisTitles = new int[] { type.ordinal(), R.string.stats_minutes, R.string.stats_cumulative_time_minutes };
            } else {
                tf = "/3600.0"; // hours
                mAxisTitles = new int[] { type.ordinal(), R.string.stats_hours, R.string.stats_cumulative_time_hours };
            }
        } else {
            ti = "1";
            tf = "";
        }
        ArrayList<double[]> list = new ArrayList<>();
        Cursor cur = null;
        String query = "SELECT (cast((id/1000 - " + mCol.getSched().getDayCutoff() + ") / "+SECONDS_PER_DAY+" AS INT))/"
                + chunk + " AS day, " + "sum(CASE WHEN type = 0 THEN " + ti + " ELSE 0 END)"
                + tf
                + ", " // lrn
                + "sum(CASE WHEN type = 1 AND lastIvl < 21 THEN " + ti + " ELSE 0 END)" + tf
                + ", " // yng
                + "sum(CASE WHEN type = 1 AND lastIvl >= 21 THEN " + ti + " ELSE 0 END)" + tf
                + ", " // mtr
                + "sum(CASE WHEN type = 2 THEN " + ti + " ELSE 0 END)" + tf + ", " // lapse
                + "sum(CASE WHEN type = 3 THEN " + ti + " ELSE 0 END)" + tf // cram
                + " FROM revlog " + lim + " GROUP BY day ORDER BY day";

        Timber.d("ReviewCount query: %s", query);

        try {
            cur = mCol
                    .getDb()
                    .getDatabase()
                    .rawQuery(
                            query, null);
            while (cur.moveToNext()) {
                list.add(new double[] { cur.getDouble(0), cur.getDouble(5), cur.getDouble(1), cur.getDouble(4),
                        cur.getDouble(2), cur.getDouble(3)});
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }


        // small adjustment for a proper chartbuilding with achartengine
        if (type != AxisType.TYPE_LIFE && (list.size() == 0 || list.get(0)[0] > -num)) {
            list.add(0, new double[] { -num, 0, 0, 0, 0, 0 });
        } else if (type == AxisType.TYPE_LIFE && list.size() == 0) {
            list.add(0, new double[] { -12, 0, 0, 0, 0, 0 });
        }
        if (list.get(list.size() - 1)[0] < 0) {
            list.add(new double[] { 0, 0, 0, 0, 0, 0 });
        }

        mSeriesList = new double[6][list.size()];
        for (int i = 0; i < list.size(); i++) {
            double[] data = list.get(i);
            mSeriesList[0][i] = data[0]; // day
            mSeriesList[1][i] = data[1] + data[2] + data[3] + data[4] + data[5]; // cram
            mSeriesList[2][i] = data[2] + data[3] + data[4] + data[5]; // learn
            mSeriesList[3][i] = data[3] + data[4] + data[5]; // relearn
            mSeriesList[4][i] = data[4] + data[5]; // young
            mSeriesList[5][i] = data[5]; // mature

            if (mSeriesList[1][i] > mMaxCards) {
                mMaxCards = (int) Math.round(data[1] + data[2] + data[3] + data[4] + data[5]);
            }
            if (data[5] >= 0.999) {
                mFoundCramCards = true;
            }
            if (data[1] >= 0.999) {
                mFoundLearnCards = true;
            }
            if (data[2] >= 0.999) {
                mFoundRelearnCards = true;
            }
            if (data[0] > mLastElement) {
                mLastElement = data[0];
            }
            if (data[0] < mFirstElement) {
                mFirstElement = data[0];
            }
            if (data[0] == 0) {
                mZeroIndex = i;
            }
        }
        mMaxElements = list.size()-1;
        mCumulative = new double[6][];
        mCumulative[0] = mSeriesList[0];
        for (int i = 1; i < mSeriesList.length; i++) {
            mCumulative[i] = createCumulative(mSeriesList[i]);
            if (i > 1) {
                for (int j = 0; j < mCumulative[i - 1].length; j++) {
                    mCumulative[i - 1][j] -= mCumulative[i][j];
                }
            }
        }

        switch (mType) {
            case TYPE_MONTH:
                mFirstElement = -31;
                break;
            case TYPE_YEAR:
                mFirstElement = -52;
                break;
            default:
        }

        mMcount = 0;
        // we could assume the last element to be the largest,
        // but on some collections that may not be true due some negative values
        //so we search for the largest element:
        for (int i = 1; i < mCumulative.length; i++) {
            for (int j = 0; j < mCumulative[i].length; j++) {
                if (mMcount < mCumulative[i][j])
                    mMcount = mCumulative[i][j];
            }
        }

        //some adjustments to not crash the chartbuilding with emtpy data
        if (mMaxCards == 0) {
            mMaxCards = 10;
        }
        if (mMaxElements == 0) {
            mMaxElements = 10;
        }
        if (mMcount == 0) {
            mMcount = 10;
        }
        if (mFirstElement == mLastElement) {
            mFirstElement = -10;
            mLastElement = 0;
        }
        return list.size() > 0;
    }


    /**
     * Intervals ***********************************************************************************************
     */

    public boolean calculateIntervals(Context context, AxisType type) {
        mDynamicAxis = true;
        mType = type;
        double all = 0, avg = 0, max_ = 0;
        mBackwards = false;
        mTitle = R.string.stats_review_intervals;
        mAxisTitles = new int[] { type.ordinal(), R.string.stats_cards, R.string.stats_percentage };
        mValueLabels = new int[] { R.string.stats_cards_intervals};
        mColors = new int[] { R.attr.stats_interval};
        int num = 0;
        String lim = "";
        int chunk = 0;
        switch (type) {
            case TYPE_MONTH:
                num = 31;
                chunk = 1;
                lim = " and grp <= 30";
                break;
            case TYPE_YEAR:
                num = 52;
                chunk = 7;
                lim = " and grp <= 52";
                break;
            case TYPE_LIFE:
                num = -1;
                chunk = 30;
                lim = "";
                break;
        }

        ArrayList<double[]> list = new ArrayList<>();
        Cursor cur = null;
        try {
            cur = mCol
                    .getDb()
                    .getDatabase()
                    .rawQuery(
                            "select ivl / " + chunk + " as grp, count() from cards " +
                                    "where did in "+ _limit() +" and queue = 2 " + lim + " " +
                                    "group by grp " +
                                    "order by grp", null);
            while (cur.moveToNext()) {
                list.add(new double[] { cur.getDouble(0), cur.getDouble(1) });
            }
            cur.close();
            cur = mCol
                    .getDb()
                    .getDatabase()
                    .rawQuery(
                            "select count(), avg(ivl), max(ivl) from cards where did in " +_limit() +
                                    " and queue = 2", null);
            cur.moveToFirst();
            all = cur.getDouble(0);
            avg = cur.getDouble(1);
            max_ = cur.getDouble(2);
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }

        // small adjustment for a proper chartbuilding with achartengine
        if (list.size() == 0 || list.get(0)[0] > 0) {
            list.add(0, new double[] { 0, 0, 0 });
        }
        if (num == -1 && list.size() < 2) {
            num = 31;
        }
        if (type != AxisType.TYPE_LIFE && list.get(list.size() - 1)[0] < num) {
            list.add(new double[] { num, 0 });
        } else if (type == AxisType.TYPE_LIFE && list.size() < 2) {
            list.add(new double[] { Math.max(12, list.get(list.size() - 1)[0] + 1), 0 });
        }

        mLastElement = 0;
        mSeriesList = new double[2][list.size()];
        for (int i = 0; i < list.size(); i++) {
            double[] data = list.get(i);
            mSeriesList[0][i] = data[0]; // grp
            mSeriesList[1][i] = data[1]; // cnt
            if (mSeriesList[1][i] > mMaxCards)
                mMaxCards = (int) Math.round(data[1]);
            if (data[0] > mLastElement)
                mLastElement = data[0];

        }
        mCumulative = createCumulative(mSeriesList);
        for (int i = 0; i < list.size(); i++) {
            mCumulative[1][i] /= all / 100;
        }
        mMcount = 100;

        switch (mType) {
            case TYPE_MONTH:
                mLastElement = 31;
                break;
            case TYPE_YEAR:
                mLastElement = 52;
                break;
            default:
        }
        mFirstElement = 0;
        mMaxElements = list.size() - 1;
        mAverage = Utils.timeSpan(context, (int) Math.round(avg * SECONDS_PER_DAY));
        mLongest = Utils.timeSpan(context, (int) Math.round(max_ * SECONDS_PER_DAY));

        //some adjustments to not crash the chartbuilding with emtpy data
        if (mMaxElements == 0) {
            mMaxElements = 10;
        }
        if (mMcount == 0) {
            mMcount = 10;
        }
        if (mFirstElement == mLastElement) {
            mFirstElement = 0;
            mLastElement = 6;
        }
        if (mMaxCards == 0) {
            mMaxCards = 10;
        }
        return list.size() > 0;
    }

    /**
     * Hourly Breakdown
     */
    public boolean calculateBreakdown(AxisType type) {
        mTitle = R.string.stats_breakdown;
        mBackwards = false;
        mAxisTitles = new int[] { R.string.stats_time_of_day, R.string.stats_percentage_correct, R.string.stats_reviews };
        mValueLabels = new int[] { R.string.stats_percentage_correct, R.string.stats_answers};
        mColors = new int[] { R.attr.stats_counts, R.attr.stats_hours};
        mType = type;
        String lim = _getDeckFilter().replaceAll("[\\[\\]]", "");

        if (lim.length() > 0) {
            lim = " and " + lim;
        }

        Calendar sd = GregorianCalendar.getInstance();
        sd.setTimeInMillis(mCol.getCrt() * 1000);

        int pd = _periodDays();
        if (pd > 0) {
            lim += " and id > " + ((mCol.getSched().getDayCutoff() - (SECONDS_PER_DAY * pd)) * 1000);
        }
        long cutoff = mCol.getSched().getDayCutoff();
        long cut = cutoff - sd.get(Calendar.HOUR_OF_DAY) * 3600;

        ArrayList<double[]> list = new ArrayList<>();
        Cursor cur = null;
        String query = "select " +
                "23 - ((cast((" + cut + " - id/1000) / 3600.0 as int)) % 24) as hour, " +
                "sum(case when ease = 1 then 0 else 1 end) / " +
                "cast(count() as float) * 100, " +
                "count() " +
                "from revlog where type in (0,1,2) " + lim +" " +
                "group by hour having count() > 30 order by hour";
        Timber.d(sd.get(Calendar.HOUR_OF_DAY) + " : " +cutoff + " breakdown query: %s", query);
        try {
            cur = mCol.getDb()
                    .getDatabase()
                    .rawQuery(query, null);
            while (cur.moveToNext()) {
                list.add(new double[] { cur.getDouble(0), cur.getDouble(1), cur.getDouble(2) });
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }

        //TODO adjust for breakdown, for now only copied from intervals
        //small adjustment for a proper chartbuilding with achartengine
        if (list.size() == 0) {
            list.add(0, new double[] { 0, 0, 0 });
        }

        for (int i = 0; i < list.size(); i++) {
            double[] data = list.get(i);
            int intHour = (int) data[0];
            int hour = (intHour - 4) % 24;
            if (hour < 0) {
                hour += 24;
            }
            data[0] = hour;
            list.set(i, data);
        }
        Collections.sort(list, new Comparator<double[]>() {
            @Override
            public int compare(double[] s1, double[] s2) {
                if (s1[0] < s2[0]) return -1;
                if (s1[0] > s2[0]) return 1;
                return 0;
            }
        });

        mSeriesList = new double[4][list.size()];
        mPeak = 0.0;
        mMcount = 0.0;
        double minHour = Double.MAX_VALUE;
        double maxHour = 0;
        for (int i = 0; i < list.size(); i++) {
            double[] data = list.get(i);
            int hour = (int)data[0];

            //double hour = data[0];
            if (hour < minHour) {
                minHour = hour;
            }
            if (hour > maxHour) {
                maxHour = hour;
            }
            double pct = data[1];
            if (pct > mPeak) {
                mPeak = pct;
            }
            mSeriesList[0][i] = hour;
            mSeriesList[1][i] = pct;
            mSeriesList[2][i] = data[2];
            if (i == 0) {
                mSeriesList[3][i] = pct;
            } else {
                double prev = mSeriesList[3][i - 1];
                double diff = pct - prev;
                diff /= 3.0;
                diff = Math.round(diff * 10.0) / 10.0;
                mSeriesList[3][i] = prev + diff;
            }
            if (data[2] > mMcount) {
                mMcount = data[2];
            }
            if (mSeriesList[1][i] > mMaxCards) {
                mMaxCards = (int) mSeriesList[1][i];
            }
        }

        mFirstElement = mSeriesList[0][0];
        mLastElement = mSeriesList[0][mSeriesList[0].length - 1];
        mMaxElements = (int) (maxHour - minHour);

        //some adjustments to not crash the chartbuilding with emtpy data
        if (mMaxElements == 0) {
            mMaxElements = 10;
        }
        if (mMcount == 0) {
            mMcount = 10;
        }
        if (mFirstElement == mLastElement) {
            mFirstElement = 0;
            mLastElement = 23;
        }
        if (mMaxCards == 0) {
            mMaxCards = 10;
        }
        return list.size() > 0;
    }

    /**
     * Weekly Breakdown
     */
    public boolean calculateWeeklyBreakdown(AxisType type) {
        mTitle = R.string.stats_weekly_breakdown;
        mBackwards = false;
        mAxisTitles = new int[] { R.string.stats_day_of_week, R.string.stats_percentage_correct, R.string.stats_reviews };
        mValueLabels = new int[] { R.string.stats_percentage_correct, R.string.stats_answers};
        mColors = new int[] { R.attr.stats_counts, R.attr.stats_hours};
        mType = type;
        String lim = _getDeckFilter().replaceAll("[\\[\\]]", "");

        if (lim.length() > 0) {
            lim = " and " + lim;
        }

        Calendar sd = GregorianCalendar.getInstance();
        sd.setTimeInMillis(mCol.getSched().getDayCutoff() * 1000);

        int pd = _periodDays();
        if (pd > 0) {
            pd = Math.round( pd / 7 ) * 7;
            lim += " and id > " + ((mCol.getSched().getDayCutoff() - (SECONDS_PER_DAY * pd)) * 1000);
        }

        long cutoff = mCol.getSched().getDayCutoff();
        ArrayList<double[]> list = new ArrayList<>();
        Cursor cur = null;
        String query = "SELECT strftime('%w',datetime( cast(id/ 1000  -" + sd.get(Calendar.HOUR_OF_DAY) * 3600 +
                " as int), 'unixepoch')) as wd, " +
                "sum(case when ease = 1 then 0 else 1 end) / " +
                "cast(count() as float) * 100, " +
                "count() " +
                "from revlog " +
                "where type in (0,1,2) " + lim +" " +
                "group by wd " +
                "order by wd";
        Timber.d(sd.get(Calendar.HOUR_OF_DAY) + " : " +cutoff + " weekly breakdown query: %s", query);
        try {
            cur = mCol.getDb()
                    .getDatabase()
                    .rawQuery(query, null);
            while (cur.moveToNext()) {
                list.add(new double[] { cur.getDouble(0), cur.getDouble(1), cur.getDouble(2) });
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }

        //TODO adjust for breakdown, for now only copied from intervals
        // small adjustment for a proper chartbuilding with achartengine
        if (list.size() == 0 ) {
            list.add(0, new double[] { 0, 0, 0 });
        }

        mSeriesList = new double[4][list.size()];
        mPeak = 0.0;
        mMcount = 0.0;
        double minHour = Double.MAX_VALUE;
        double maxHour = 0;
        for (int i = 0; i < list.size(); i++) {
            double[] data = list.get(i);
            int hour = (int) data[0];

            //double hour = data[0];
            if (hour < minHour) {
                minHour = hour;
            }
            if (hour > maxHour) {
                maxHour = hour;
            }
            double pct = data[1];
            if (pct > mPeak) {
                mPeak = pct;
            }

            mSeriesList[0][i] = hour;
            mSeriesList[1][i] = pct;
            mSeriesList[2][i] = data[2];
            if (i == 0) {
                mSeriesList[3][i] = pct;
            } else {
                double prev = mSeriesList[3][i - 1];
                double diff = pct - prev;
                diff /= 3.0;
                diff = Math.round(diff * 10.0) / 10.0;
                mSeriesList[3][i] = prev + diff;
            }
            if (data[2] > mMcount) {
                mMcount = data[2];
            }
            if (mSeriesList[1][i] > mMaxCards) {
                mMaxCards = (int) mSeriesList[1][i];
            }
        }
        mFirstElement = mSeriesList[0][0];
        mLastElement = mSeriesList[0][mSeriesList[0].length - 1];
        mMaxElements = (int) (maxHour - minHour);

        //some adjustments to not crash the chartbuilding with emtpy data
        if (mMaxElements == 0) {
            mMaxElements = 10;
        }
        if (mMcount == 0) {
            mMcount = 10;
        }
        if (mFirstElement == mLastElement) {
            mFirstElement = 0;
            mLastElement = 6;
        }
        if (mMaxCards == 0) {
            mMaxCards = 10;
        }
        return list.size() > 0;
    }


    /**
     * Answer Buttons
     */
    public boolean calculateAnswerButtons(AxisType type) {
        mHasColoredCumulative = false;
        mCumulative = null;
        mTitle = R.string.stats_answer_buttons;
        mBackwards = false;
        mAxisTitles = new int[] { R.string.stats_answer_type, R.string.stats_answers };
        mValueLabels = new int[] { R.string.statistics_learn, R.string.statistics_young, R.string.statistics_mature};
        mColors = new int[] { R.attr.stats_learn, R.attr.stats_young, R.attr.stats_mature};
        mType = type;
        String lim = _getDeckFilter().replaceAll("[\\[\\]]", "");

        Vector<String> lims = new Vector<>();
        int days;

        if (lim.length() > 0) {
            lims.add(lim);
        }

        if (type == AxisType.TYPE_MONTH) {
            days = 30;
        } else if (type == AxisType.TYPE_YEAR) {
            days = 365;
        } else {
            days = -1;
        }

        if (days > 0) {
            lims.add("id > " + ((mCol.getSched().getDayCutoff() - (days * SECONDS_PER_DAY)) * 1000));
        }
        if (lims.size() > 0) {
            lim = "where " + lims.get(0);
            for (int i = 1; i < lims.size(); i++) {
                lim += " and " + lims.get(i);
            }
        } else {
            lim = "";
        }

        ArrayList<double[]> list = new ArrayList<>();
        Cursor cur = null;
        String query = "select (case " +
                "                when type in (0,2) then 0 " +
                "        when lastIvl < 21 then 1 " +
                "        else 2 end) as thetype, " +
                "        (case when type in (0,2) and ease = 4 then 3 else ease end), count() from revlog " + lim + " " +
                "        group by thetype, ease " +
                "        order by thetype, ease";
        Timber.d("AnswerButtons query: %s", query);

        try {
            cur = mCol.getDb()
                    .getDatabase()
                    .rawQuery(query, null);
            while (cur.moveToNext()) {
                list.add(new double[]{cur.getDouble(0), cur.getDouble(1), cur.getDouble(2)});
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }

        //TODO adjust for AnswerButton, for now only copied from intervals
        // small adjustment for a proper chartbuilding with achartengine
        if (list.size() == 0) {
            list.add(0, new double[]{0, 1, 0});
        }

        mSeriesList = new double[4][list.size()+1];

        for (int i = 0; i < list.size(); i++) {
            double[] data = list.get(i);
            int currentType = (int)data[0];
            double ease = data[1];
            double cnt = data[2];

            if (currentType == 1) {
                ease += 5;
            } else if (currentType == 2) {
                ease += 10;
            }
            mSeriesList[0][i] = ease;
            mSeriesList[1 + currentType][i] = cnt;
            if (cnt > mMaxCards) {
                mMaxCards = (int) cnt;
            }
        }
        mSeriesList[0][list.size()] = 15;

        mFirstElement = 0.5;
        mLastElement = 14.5;
        mMcount = 100;
        mMaxElements = 15;      //bars are positioned from 1 to 14
        if(mMaxCards == 0) {
            mMaxCards = 10;
        }
        return list.size() > 0;
    }

    /**
     * Card Types
     */
    public boolean calculateCardTypes(AxisType type) {
        mTitle = R.string.stats_cards_types;
        mBackwards = false;
        mAxisTitles = new int[] { R.string.stats_answer_type, R.string.stats_answers, R.string.stats_cumulative_correct_percentage };
        mValueLabels = new int[] {R.string.statistics_mature, R.string.statistics_young_and_learn, R.string.statistics_unlearned, R.string.statistics_suspended_and_buried};
        mColors = new int[] { R.attr.stats_mature, R.attr.stats_young, R.attr.stats_unseen, R.attr.stats_suspended_and_buried };
        mType = type;
        ArrayList<double[]> list = new ArrayList<>();
        double[] pieData;
        Cursor cur = null;
        String query = "select " +
                "sum(case when queue=2 and ivl >= 21 then 1 else 0 end), -- mtr\n" +
                "sum(case when queue in (1,3) or (queue=2 and ivl < 21) then 1 else 0 end), -- yng/lrn\n" +
                "sum(case when queue=0 then 1 else 0 end), -- new\n" +
                "sum(case when queue<0 then 1 else 0 end) -- susp\n" +
                "from cards where did in " + _limit();
        Timber.d("CardsTypes query: %s", query);

        try {
            cur = mCol.getDb()
                    .getDatabase()
                    .rawQuery(query, null);

            cur.moveToFirst();
            pieData = new double[]{ cur.getDouble(0), cur.getDouble(1), cur.getDouble(2), cur.getDouble(3) };
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }

        //TODO adjust for CardsTypes, for now only copied from intervals
        // small adjustment for a proper chartbuilding with achartengine
//        if (list.size() == 0 || list.get(0)[0] > 0) {
//            list.add(0, new double[] { 0, 0, 0 });
//        }
//        if (num == -1 && list.size() < 2) {
//            num = 31;
//        }
//        if (type != Utils.TYPE_LIFE && list.get(list.size() - 1)[0] < num) {
//            list.add(new double[] { num, 0, 0 });
//        } else if (type == Utils.TYPE_LIFE && list.size() < 2) {
//            list.add(new double[] { Math.max(12, list.get(list.size() - 1)[0] + 1), 0, 0 });
//        }

        mSeriesList = new double[1][4];
        mSeriesList[0] = pieData;
        mFirstElement = 0.5;
        mLastElement = 9.5;
        mMcount = 100;
        mMaxElements = 10;      //bars are positioned from 1 to 14
        if (mMaxCards == 0) {
            mMaxCards = 10;
        }
        return list.size() > 0;
    }

    /**
     * Tools ***********************************************************************************************
     */

    private String _limit() {
        if (mWholeCollection) {
            ArrayList<Long> ids = new ArrayList<>();
            for (JSONObject d : mCol.getDecks().all()) {
                try {
                    ids.add(d.getLong("id"));
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
            }
            return Utils.ids2str(Utils.arrayList2array(ids));
        } else {
            return mCol.getSched()._deckLimit();
        }
    }


    private String _getDeckFilter() {
        if (mWholeCollection) {
            return "";
        } else {
            return "cid IN (SELECT id FROM cards WHERE did IN " + Utils.ids2str(mCol.getDecks().active()) + ")";
        }
    }


    public static double[][] createCumulative(double[][] nonCumulative) {
        double[][] cumulativeValues = new double[2][nonCumulative[0].length];
        cumulativeValues[0][0] = nonCumulative[0][0];
        cumulativeValues[1][0] = nonCumulative[1][0];
        for (int i = 1; i < nonCumulative[0].length; i++) {
            cumulativeValues[0][i] = nonCumulative[0][i];
            cumulativeValues[1][i] = cumulativeValues[1][i - 1] + nonCumulative[1][i];
        }
        return cumulativeValues;
    }


    public static double[][] createCumulative(double[][] nonCumulative, int startAtIndex) {
        double[][] cumulativeValues = new double[2][nonCumulative[0].length - startAtIndex];
        cumulativeValues[0][0] = nonCumulative[0][startAtIndex];
        cumulativeValues[1][0] = nonCumulative[1][startAtIndex];
        for (int i = startAtIndex + 1; i < nonCumulative[0].length; i++) {
            cumulativeValues[0][i - startAtIndex] = nonCumulative[0][i];
            cumulativeValues[1][i - startAtIndex] = cumulativeValues[1][i - 1 - startAtIndex] + nonCumulative[1][i];
        }
        return cumulativeValues;
    }


    public static double[] createCumulative(double[] nonCumulative) {
        double[] cumulativeValues = new double[nonCumulative.length];
        cumulativeValues[0] = nonCumulative[0];
        for (int i = 1; i < nonCumulative.length; i++) {
            cumulativeValues[i] = cumulativeValues[i - 1] + nonCumulative[i];
        }
        return cumulativeValues;
    }

    private int _periodDays() {
        switch (mType) {
            case TYPE_MONTH:
                return 30;
            case TYPE_YEAR:
                return 365;
            default:
            case TYPE_LIFE:
                return -1;
        }
    }
}
/***************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

import android.content.ContentValues;
import android.content.Context;

import com.ichi2.anki.exception.ConfirmModSchemaException;
import com.ichi2.libanki.hooks.Hooks;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;

import timber.log.Timber;

public class Storage {
    String mPath;


    /* Open a new or existing collection. Path must be unicode */
    public static Collection Collection(Context context, String path) {
        return Collection(context, path, false, false);
    }


    public static Collection Collection(Context context, String path, boolean server, boolean log) {
        assert path.endsWith(".anki2");
        // Since this is the entry point into libanki, initialize the hooks here.
        Hooks.getInstance(context);
        File dbFile = new File(path);
        boolean create = !dbFile.exists();
        // connect
        DB db = new DB(path);
        try {
            // initialize
            int ver;
            if (create) {
                ver = _createDB(db);
            } else {
                ver = _upgradeSchema(db);
            }
            db.execute("PRAGMA temp_store = memory");
            // add db to col and do any remaining upgrades
        Collection col = new Collection(context, db, path, server, log);
            if (ver < Consts.SCHEMA_VERSION) {
                _upgrade(col, ver);
            } else if (create) {
                try {
                    // add in reverse order so basic is default
                    Models.addClozeModel(col);
                    Models.addForwardOptionalReverse(col);
                    Models.addForwardReverse(col);
                    Models.addBasicModel(col);
                } catch (ConfirmModSchemaException e) {
                    // This should never reached as we've just created a new database
                    throw new RuntimeException(e);
                }
                col.save();
            }
            return col;
        } catch (Exception e) {
            Timber.e(e, "Error opening collection; closing database");
            db.close();
			return null;
            //throw e;
        }
    }


    private static int _upgradeSchema(DB db) {
        int ver = db.queryScalar("SELECT ver FROM col");
        if (ver == Consts.SCHEMA_VERSION) {
            return ver;
        }
        // add odid to cards, edue->odue
        if (db.queryScalar("SELECT ver FROM col") == 1) {
            db.execute("ALTER TABLE cards RENAME TO cards2");
            _addSchema(db, false);
            db.execute("insert into cards select id, nid, did, ord, mod, usn, type, queue, due, ivl, factor, reps, lapses, left, edue, 0, flags, data from cards2");
            db.execute("DROP TABLE cards2");
            db.execute("UPDATE col SET ver = 2");
            _updateIndices(db);
        }
        // remove did from notes
        if (db.queryScalar("SELECT ver FROM col") == 2) {
            db.execute("ALTER TABLE notes RENAME TO notes2");
            _addSchema(db, false);
            db.execute("insert into notes select id, guid, mid, mod, usn, tags, flds, sfld, csum, flags, data from notes2");
            db.execute("DROP TABLE notes2");
            db.execute("UPDATE col SET ver = 3");
            _updateIndices(db);
        }
        return ver;
    }


    private static void _upgrade(Collection col, int ver) {
        try {
            if (ver < 3) {
                // new deck properties
                for (JSONObject d : col.getDecks().all()) {
                    d.put("dyn", 0);
                    d.put("collapsed", false);
                    col.getDecks().save(d);
                }
            }
            if (ver < 4) {
                col.modSchemaNoCheck();
                ArrayList<JSONObject> clozes = new ArrayList<>();
                for (JSONObject m : col.getModels().all()) {
                    if (!m.getJSONArray("tmpls").getJSONObject(0).getString("qfmt").contains("{{cloze:")) {
                        m.put("type", Consts.MODEL_STD);
                    } else {
                        clozes.add(m);
                    }
                }
                for (JSONObject m : clozes) {
                    try {
                        _upgradeClozeModel(col, m);
                    } catch (ConfirmModSchemaException e) {
                        // Will never be reached as we already set modSchemaNoCheck()
                        throw new RuntimeException(e);
                    }
                }
                col.getDb().execute("UPDATE col SET ver = 4");
            }
            if (ver < 5) {
                col.getDb().execute("UPDATE cards SET odue = 0 WHERE queue = 2");
                col.getDb().execute("UPDATE col SET ver = 5");
            }
            if (ver < 6) {
                col.modSchemaNoCheck();
                for (JSONObject m : col.getModels().all()) {
                    m.put("css", new JSONObject(Models.defaultModel).getString("css"));
                    JSONArray ar = m.getJSONArray("tmpls");
                    for (int i = 0; i < ar.length(); i++) {
                        JSONObject t = ar.getJSONObject(i);
                        if (!t.has("css")) {
                            continue;
                        }
                        m.put("css",
                                m.getString("css") + "\n"
                                        + t.getString("css").replace(".card ", ".card" + t.getInt("ord") + 1));
                        t.remove("css");
                    }
                    col.getModels().save(m);
                }
                col.getDb().execute("UPDATE col SET ver = 6");
            }
            if (ver < 7) {
                col.modSchemaNoCheck();
                col.getDb().execute("UPDATE cards SET odue = 0 WHERE (type = 1 OR queue = 2) AND NOT odid");
                col.getDb().execute("UPDATE col SET ver = 7");
            }
            if (ver < 8) {
                col.modSchemaNoCheck();
                col.getDb().execute("UPDATE cards SET due = due / 1000 WHERE due > 4294967296");
                col.getDb().execute("UPDATE col SET ver = 8");
            }
            if (ver < 9) {
                col.getDb().execute("UPDATE col SET ver = 9");
            }
            if (ver < 10) {
                col.getDb().execute("UPDATE cards SET left = left + left * 1000 WHERE queue = 1");
                col.getDb().execute("UPDATE col SET ver = 10");
            }
            if (ver < 11) {
                col.modSchemaNoCheck();
                for (JSONObject d : col.getDecks().all()) {
                    if (d.getInt("dyn") != 0) {
                        int order = d.getInt("order");
                        // failed order was removed
                        if (order >= 5) {
                            order -= 1;
                        }
                        JSONArray ja = new JSONArray(Arrays.asList(new Object[] { d.getString("search"),
                                d.getInt("limit"), order }));
                        d.put("terms", new JSONArray());
                        d.getJSONArray("terms").put(0, ja);
                        d.remove("search");
                        d.remove("limit");
                        d.remove("order");
                        d.put("resched", true);
                        d.put("return", true);
                    } else {
                        if (!d.has("extendNew")) {
                            d.put("extendNew", 10);
                            d.put("extendRev", 50);
                        }
                    }
                    col.getDecks().save(d);
                }
                for (JSONObject c : col.getDecks().allConf()) {
                    JSONObject r = c.getJSONObject("rev");
                    r.put("ivlFct", r.optDouble("ivlFct", 1));
                    if (r.has("ivlfct")) {
                        r.remove("ivlfct");
                    }
                    r.put("maxIvl", 36500);
                    col.getDecks().save(c);
                }
                for (JSONObject m : col.getModels().all()) {
                    JSONArray tmpls = m.getJSONArray("tmpls");
                    for (int ti = 0; ti < tmpls.length(); ++ti) {
                        JSONObject t = tmpls.getJSONObject(ti);
                        t.put("bqfmt", "");
                        t.put("bafmt", "");
                    }
                    col.getModels().save(m);
                }
                col.getDb().execute("update col set ver = 11");
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    private static void _upgradeClozeModel(Collection col, JSONObject m) throws ConfirmModSchemaException {
        try {
            m.put("type", Consts.MODEL_CLOZE);
            // convert first template
            JSONObject t = m.getJSONArray("tmpls").getJSONObject(0);
            for (String type : new String[] { "qfmt", "afmt" }) {
                t.put(type, t.getString(type).replaceAll("\\{\\{cloze:1:(.+?)\\}\\}", "{{cloze:$1}}"));
            }
            t.put("name", "Cloze");
            // delete non-cloze cards for the model
            JSONArray ja = m.getJSONArray("tmpls");
            ArrayList<JSONObject> rem = new ArrayList<>();
            for (int i = 1; i < ja.length(); i++) {
                JSONObject ta = ja.getJSONObject(i);
                if (!ta.getString("afmt").contains("{{cloze:")) {
                    rem.add(ta);
                }
            }
            for (JSONObject r : rem) {
                col.getModels().remTemplate(m, r);
            }
            JSONArray newArray = new JSONArray();
            newArray.put(ja.get(0));
            m.put("tmpls", newArray);
            col.getModels()._updateTemplOrds(m);
            col.getModels().save(m);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }

    }


    private static int _createDB(DB db) {
        db.execute("PRAGMA page_size = 4096");
        db.execute("PRAGMA legacy_file_format = 0");
        db.execute("VACUUM");
        _addSchema(db);
        _updateIndices(db);
        db.execute("ANALYZE");
        return Consts.SCHEMA_VERSION;
    }


    private static void _addSchema(DB db) {
        _addSchema(db, true);
    }


    private static void _addSchema(DB db, boolean setColConf) {
        db.execute("create table if not exists col ( " + "id              integer primary key, "
                + "crt             integer not null," + "mod             integer not null,"
                + "scm             integer not null," + "ver             integer not null,"
                + "dty             integer not null," + "usn             integer not null,"
                + "ls              integer not null," + "conf            text not null,"
                + "models          text not null," + "decks           text not null,"
                + "dconf           text not null," + "tags            text not null" + ");");
        db.execute("create table if not exists notes (" + "   id              integer primary key,   /* 0 */"
                + "  guid            text not null,   /* 1 */" + " mid             integer not null,   /* 2 */"
                + " mod             integer not null,   /* 3 */" + " usn             integer not null,   /* 4 */"
                + " tags            text not null,   /* 5 */" + " flds            text not null,   /* 6 */"
                + " sfld            integer not null,   /* 7 */" + " csum            integer not null,   /* 8 */"
                + " flags           integer not null,   /* 9 */" + " data            text not null   /* 10 */" + ");");
        db.execute("create table if not exists cards (" + "   id              integer primary key,   /* 0 */"
                + "  nid             integer not null,   /* 1 */" + "  did             integer not null,   /* 2 */"
                + "  ord             integer not null,   /* 3 */" + "  mod             integer not null,   /* 4 */"
                + " usn             integer not null,   /* 5 */" + " type            integer not null,   /* 6 */"
                + " queue           integer not null,   /* 7 */" + "    due             integer not null,   /* 8 */"
                + "   ivl             integer not null,   /* 9 */" + "  factor          integer not null,   /* 10 */"
                + " reps            integer not null,   /* 11 */" + "   lapses          integer not null,   /* 12 */"
                + "   left            integer not null,   /* 13 */" + "   odue            integer not null,   /* 14 */"
                + "   odid            integer not null,   /* 15 */" + "   flags           integer not null,   /* 16 */"
                + "   data            text not null   /* 17 */" + ");");
        db.execute("create table if not exists revlog (" + "   id              integer primary key,"
                + "   cid             integer not null," + "   usn             integer not null,"
                + "   ease            integer not null," + "   ivl             integer not null,"
                + "   lastIvl         integer not null," + "   factor          integer not null,"
                + "   time            integer not null," + "   type            integer not null" + ");");
        db.execute("create table if not exists graves (" + "    usn             integer not null,"
                + "    oid             integer not null," + "    type            integer not null" + ")");
        db.execute("INSERT OR IGNORE INTO col VALUES(1,0,0," +
                Utils.intNow(1000) + "," + Consts.SCHEMA_VERSION +
                ",0,0,0,'','{}','','','{}')");
        if (setColConf) {
            _setColVars(db);
        }
    }


    private static void _setColVars(DB db) {
        try {
            JSONObject g = new JSONObject(Decks.defaultDeck);
            g.put("id", 1);
            g.put("name", "Default");
            g.put("conf", 1);
            g.put("mod", Utils.intNow());
            JSONObject gc = new JSONObject(Decks.defaultConf);
            gc.put("id", 1);
            JSONObject ag = new JSONObject();
            ag.put("1", g);
            JSONObject agc = new JSONObject();
            agc.put("1", gc);
            ContentValues values = new ContentValues();
            values.put("conf", Collection.defaultConf);
            values.put("decks", Utils.jsonToString(ag));
            values.put("dconf", Utils.jsonToString(agc));
            db.update("col", values);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    private static void _updateIndices(DB db) {
        db.execute("create index if not exists ix_notes_usn on notes (usn);");
        db.execute("create index if not exists ix_cards_usn on cards (usn);");
        db.execute("create index if not exists ix_revlog_usn on revlog (usn);");
        db.execute("create index if not exists ix_cards_nid on cards (nid);");
        db.execute("create index if not exists ix_cards_sched on cards (did, queue, due);");
        db.execute("create index if not exists ix_revlog_cid on revlog (cid);");
        db.execute("create index if not exists ix_notes_csum on notes (csum);)");
    }


    public static void addIndices(DB db) {
        _updateIndices(db);
    }

}
/****************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 * Copyright (c) 2014 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

import android.content.ContentValues;
import android.database.Cursor;
import android.text.TextUtils;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.regex.Pattern;


/**
Anki maintains a cache of used tags so it can quickly present a list of tags
for autocomplete and in the browser. For efficiency, deletions are not
tracked, so unused tags can only be removed from the list with a DB check.

This module manages the tag cache and tags for notes.

This class differs from the python version by keeping the in-memory tag cache as a TreeMap
instead of a JSONObject. It is much more convenient to work with a TreeMap in Java, but there
may be a performance penalty in doing so (on startup and shutdown).
 */
public class Tags {

    private static final Pattern sCanonify = Pattern.compile("[\"']");

    private Collection mCol;
    private TreeMap<String, Integer> mTags = new TreeMap<>();
    private boolean mChanged;


    /**
     * Registry save/load
     * ***********************************************************
     */

    public Tags(Collection col) {
        mCol = col;
    }


    public void load(String json) {
        try {
            JSONObject tags = new JSONObject(json);
            Iterator<?> i = tags.keys();
            while (i.hasNext()) {
                String t = (String) i.next();
                mTags.put(t, tags.getInt(t));
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        mChanged = false;
    }


    public void flush() {
        if (mChanged) {
            JSONObject tags = new JSONObject();
            for (Map.Entry<String, Integer> t : mTags.entrySet()) {
                try {
                    tags.put(t.getKey(), t.getValue());
                } catch (JSONException e) {
                    throw new RuntimeException(e);
                }
            }
            ContentValues val = new ContentValues();
            val.put("tags", Utils.jsonToString(tags));
            // TODO: the database update call here sets mod = true. Verify if this is intended.
            mCol.getDb().update("col", val);
            mChanged = false;
        }
    }


    /**
     * Registering and fetching tags
     * ***********************************************************
     */

    /** Given a list of tags, add any missing ones to tag registry. */
    public void register(Iterable<String> tags) {
        register(tags, null);
    }


    public void register(Iterable<String> tags, Integer usn) {
        //boolean found = false;
        for (String t : tags) {
            if (!mTags.containsKey(t)) {
                mTags.put(t, usn == null ? mCol.usn() : usn);
                mChanged = true;
            }
        }
        //if (found) {
        //    runHook("newTag"); // TODO
        //}
    }


    public List<String> all() {
        List<String> list = new ArrayList<>();
        list.addAll(mTags.keySet());
        return list;
    }


    public void registerNotes() {
        registerNotes(null);
    }


    /** Add any missing tags from notes to the tags list. */
    public void registerNotes(long[] nids) {
        // when called with a null argument, the old list is cleared first.
        String lim;
        if (nids != null) {
            lim = " WHERE id IN " + Utils.ids2str(nids);
        } else {
            lim = "";
            mTags.clear();
            mChanged = true;
        }
        List<String> tags = new ArrayList<>();
        Cursor cursor = null;
        try {
            cursor = mCol.getDb().getDatabase().rawQuery("SELECT DISTINCT tags FROM notes"+lim, null);
            while (cursor.moveToNext()) {
                tags.add(cursor.getString(0));
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        HashSet<String> tagSet = new HashSet<>();
        for (String s : split(TextUtils.join(" ", tags))) {
            tagSet.add(s);
        }
        register(tagSet);
    }


    public Set<Map.Entry<String, Integer>> allItems() {
        return mTags.entrySet();
    }


    public void save() {
        mChanged = true;
    }


    /**
    * byDeck returns the tags of the cards in the deck
    * @param did the deck id
    * @param children whether to include the deck's children
    * @return a list of the tags
    */
    public ArrayList<String> byDeck(long did, boolean children) {
        String sql;
        if (children) {
            ArrayList<Long> dids = new ArrayList<>();
            dids.add(did);
            for (long id : mCol.getDecks().children(did).values()) {
                dids.add(id);
            }
            sql = "SELECT DISTINCT n.tags FROM cards c, notes n WHERE c.nid = n.id AND c.did IN " + Utils.ids2str(Utils.arrayList2array(dids));
        } else {
            sql = "SELECT DISTINCT n.tags FROM cards c, notes n WHERE c.nid = n.id AND c.did = " + did;
        }
        List<String> tags = mCol.getDb().queryColumn(String.class, sql, 0);
        // Cast to set to remove duplicates
        // Use methods used to get all tags to parse tags here as well.
        return new ArrayList<>(new HashSet<>(split(TextUtils.join(" ", tags))));
    }


    /**
     * Bulk addition/removal from notes
     * ***********************************************************
     */

    /**
     * FIXME: This method must be fixed before it is used. See note below.
     * Add/remove tags in bulk. TAGS is space-separated.
     *
     * @param ids The cards to tag.
     * @param tags List of tags to add/remove. They are space-separated.
     * @param add True/False to add/remove.
     */
    public void bulkAdd(List<Long> ids, String tags) {
        bulkAdd(ids, tags, true);
    }


    /**
     * FIXME: This method must be fixed before it is used. Its behaviour is currently incorrect.
     * This method is currently unused in AnkiDroid so it will not cause any errors in its current state.
     */
    public void bulkAdd(List<Long> ids, String tags, boolean add) {
        List<String> newTags = split(tags);
        if (newTags == null || newTags.isEmpty()) {
            return;
        }
        // cache tag names
        register(newTags);
        // find notes missing the tags
        String l;
        if (add) {
            l = "tags not ";
        } else {
            l = "tags ";
        }
        StringBuilder lim = new StringBuilder();
        for (String t : newTags) {
            if (lim.length() != 0) {
                lim.append(" or ");
            }
            lim.append(l).append("like '% ").append(t).append(" %'");
        }
        Cursor cur = null;
        List<Long> nids = new ArrayList<>();
        ArrayList<Object[]> res = new ArrayList<>();
        try {
            cur = mCol
                    .getDb()
                    .getDatabase()
                    .rawQuery("select id, tags from notes where id in " + Utils.ids2str(ids) +
                            " and (" + lim + ")", null);
            if (add) {
                while (cur.moveToNext()) {
                    nids.add(cur.getLong(0));
                    res.add(new Object[] { addToStr(tags, cur.getString(1)), Utils.intNow(), mCol.usn(), cur.getLong(0) });
                }
            } else {
                while (cur.moveToNext()) {
                    nids.add(cur.getLong(0));
                    res.add(new Object[] { remFromStr(tags, cur.getString(1)), Utils.intNow(), mCol.usn(),
                            cur.getLong(0) });
                }
            }
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        // update tags
        mCol.getDb().executeMany("update notes set tags=:t,mod=:n,usn=:u where id = :id", res);
    }


    public void bulkRem(List<Long> ids, String tags) {
        bulkAdd(ids, tags, false);
    }


    /**
     * String-based utilities
     * ***********************************************************
     */

    /** Parse a string and return a list of tags. */
    public List<String> split(String tags) {
        ArrayList<String> list = new ArrayList<>();
        for (String s : tags.replace('\u3000', ' ').split("\\s")) {
            if (s.length() > 0) {
                list.add(s);
            }
        }
        return list;
    }


    /** Join tags into a single string, with leading and trailing spaces. */
    public String join(java.util.Collection<String> tags) {
        if (tags == null || tags.size() == 0) {
            return "";
        } else {
            String joined = TextUtils.join(" ", tags);
            return String.format(Locale.US, " %s ", joined);
        }
    }


    /** Add tags if they don't exist, and canonify */
    public String addToStr(String addtags, String tags) {
        List<String> currentTags = split(tags);
        for (String tag : split(addtags)) {
            if (!inList(tag, currentTags)) {
                currentTags.add(tag);
            }
        }
        return join(canonify(currentTags));
    }


    /** Delete tags if they don't exist. */
    public String remFromStr(String deltags, String tags) {
        List<String> currentTags = split(tags);
        for (String tag : split(deltags)) {
            List<String> remove = new ArrayList<>();
            for (String tx: currentTags) {
                if (tag.equalsIgnoreCase(tx)) {
                    remove.add(tx);
                }
            }
            // remove them
            for (String r : remove) {
                currentTags.remove(r);
            }
        }
        return join(currentTags);
    }


    /**
     * List-based utilities
     * ***********************************************************
     */

    /** Strip duplicates, adjust case to match existing tags, and sort. */
    public TreeSet<String> canonify(List<String> tagList) {
        // NOTE: The python version creates a list of tags, puts them into a set, then sorts them. The TreeSet
        // used here already guarantees uniqueness and sort order, so we return it as-is without those steps.
        TreeSet<String> strippedTags = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
        for (String t : tagList) {
            String s = sCanonify.matcher(t).replaceAll("");
            for (String existingTag : mTags.keySet()) {
                if (s.equalsIgnoreCase(existingTag)) {
                    s = existingTag;
                }
            }
            strippedTags.add(s);
        }
        return strippedTags;
    }


    /** True if TAG is in TAGS. Ignore case. */
    public boolean inList(String tag, Iterable<String> tags) {
        for (String t : tags) {
            if (t.equalsIgnoreCase(tag)) {
                return true;
            }
        }
        return false;
    }


    /**
     * Sync handling
     * ***********************************************************
     */

    public void beforeUpload() {
        for (String k : mTags.keySet()) {
            mTags.put(k, 0);
        }
        save();
    }

    /*
     * ***********************************************************
     * The methods below are not in LibAnki.
     * ***********************************************************
     */


    /** Add a tag to the collection. We use this method instead of exposing mTags publicly.*/
    public void add(String key, Integer value) {
        mTags.put(key, value);
    }
}
/****************************************************************************************
 * Copyright (c) 2009 Daniel Sv盲rd <daniel.svard@gmail.com>                             *
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.res.Resources;
import android.net.Uri;
import android.text.Html;
import android.view.View;
import android.widget.FrameLayout;
import android.widget.LinearLayout;

import com.ichi2.anki.AnkiFont;
import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.R;
import com.ichi2.utils.LanguageUtil;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.nio.channels.FileChannel;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.Date;
import java.text.Normalizer;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Random;
import java.util.TimeZone;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.Deflater;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import timber.log.Timber;

public class Utils {
    // Used to format doubles with English's decimal separator system
    public static final Locale ENGLISH_LOCALE = new Locale("en_US");

    public static final int CHUNK_SIZE = 32768;

    private static NumberFormat mCurrentPercentageFormat;

    // These are doubles on purpose because we want a rounded, not integer result later.
    private static final double TIME_MINUTE = 60.0;  // seconds
    private static final double TIME_HOUR = 60 * TIME_MINUTE;
    private static final double TIME_DAY = 24 * TIME_HOUR;
    // How long is a year? This is a tropical year, according to NIST.
    // http://www.physics.nist.gov/Pubs/SP811/appenB9.html
    private static final double TIME_YEAR = 31556930.0;  // seconds
    // Pretty much everybody agrees that one year is twelve months
    private static final double TIME_MONTH = TIME_YEAR / 12.0;


    // List of all extensions we accept as font files.
    private static final String[] FONT_FILE_EXTENSIONS = new String[] {".ttf",".ttc",".otf"};

    /* Prevent class from being instantiated */
    private Utils() { }

    // Regex pattern used in removing tags from text before diff
    private static final Pattern stylePattern = Pattern.compile("(?s)<style.*?>.*?</style>");
    private static final Pattern scriptPattern = Pattern.compile("(?s)<script.*?>.*?</script>");
    private static final Pattern tagPattern = Pattern.compile("<.*?>");
    private static final Pattern imgPattern = Pattern.compile("<img src=[\\\"']?([^\\\"'>]+)[\\\"']? ?/?>");
    private static final Pattern htmlEntitiesPattern = Pattern.compile("&#?\\w+;");

    private static final String ALL_CHARACTERS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    private static final String BASE91_EXTRA_CHARS = "!#$%&()*+,-./:;<=>?@[]^_`{|}~";

    public static final int FILE_COPY_BUFFER_SIZE = 2048;

    /**The time in integer seconds. Pass scale=1000 to get milliseconds. */
    public static double now() {
        return (System.currentTimeMillis() / 1000.0);
    }


    /**The time in integer seconds. Pass scale=1000 to get milliseconds. */
    public static long intNow() {
        return intNow(1);
    }
    public static long intNow(int scale) {
        return (long) (now() * scale);
    }

    /**
     * Return a string representing a time quantity
     *
     * @param context The application's environment.
     * @param time_s The time to format, in seconds
     * @return The time quantity string. Something like "3 s" or "1.7 yr".
     */
    public static String timeQuantity(Context context, int time_s) {
        Resources res = context.getResources();
        // N.B.: the integer s, min, h, d and (one decimal, rounded by format) double for month, year is
        // hard-coded. See also 01-core.xml
        if (Math.abs(time_s) < TIME_MINUTE ) {
            return res.getString(R.string.time_quantity_seconds, time_s);
        } else if (Math.abs(time_s) < TIME_HOUR) {
            return res.getString(R.string.time_quantity_minutes, (int) Math.round(time_s/TIME_MINUTE));
        } else if (Math.abs(time_s) < TIME_DAY) {
            return res.getString(R.string.time_quantity_hours, (int) Math.round(time_s/TIME_HOUR));
        } else if (Math.abs(time_s) < TIME_MONTH) {
            return res.getString(R.string.time_quantity_days, (int) Math.round(time_s/TIME_DAY));
        } else if (Math.abs(time_s) < TIME_YEAR) {
            return res.getString(R.string.time_quantity_months, time_s/TIME_MONTH);
        } else {
            return res.getString(R.string.time_quantity_years, time_s/TIME_YEAR);
        }
    }

    /**
     * Return a string representing a time
     * (If you want a certain unit, use the strings directly)
     *
     * @param context The application's environment.
     * @param time_s The time to format, in seconds
     * @return The formatted, localized time string. The time is always an integer.
     */
    public static String timeSpan(Context context, int time_s) {
        int time_x;  // Time in unit x
        Resources res = context.getResources();
        if (Math.abs(time_s) < TIME_MINUTE ) {
            return res.getQuantityString(R.plurals.time_span_seconds, time_s, time_s);
        } else if (Math.abs(time_s) < TIME_HOUR) {
            time_x = (int) Math.round(time_s/TIME_MINUTE);
            return res.getQuantityString(R.plurals.time_span_minutes, time_x, time_x);
        } else if (Math.abs(time_s) < TIME_DAY) {
            time_x = (int) Math.round(time_s/TIME_HOUR);
            return res.getQuantityString(R.plurals.time_span_hours, time_x, time_x);
        } else if (Math.abs(time_s) < TIME_MONTH) {
            time_x = (int) Math.round(time_s/TIME_DAY);
            return res.getQuantityString(R.plurals.time_span_days, time_x, time_x);
        } else if (Math.abs(time_s) < TIME_YEAR) {
            time_x = (int) Math.round(time_s/TIME_MONTH);
            return res.getQuantityString(R.plurals.time_span_months, time_x, time_x);
        } else {
            time_x = (int) Math.round(time_s/TIME_YEAR);
            return res.getQuantityString(R.plurals.time_span_years, time_x, time_x);
        }
    }

    /**
     * Return a proper string for a time value in seconds
     *
     * @param context The application's environment.
     * @param time_s The time to format, in seconds
     * @return The formatted, localized time string. The time is always a float.
     */
    public static String roundedTimeSpan(Context context, int time_s) {
        if (Math.abs(time_s) < TIME_DAY) {
            return context.getResources().getString(R.string.stats_overview_hours, time_s/TIME_HOUR);
        } else if (Math.abs(time_s) < TIME_MONTH) {
            return context.getResources().getString(R.string.stats_overview_days, time_s/TIME_DAY);
        } else if (Math.abs(time_s) < TIME_YEAR) {
            return context.getResources().getString(R.string.stats_overview_months,time_s/TIME_MONTH);
        } else {
            return context.getResources().getString(R.string.stats_overview_years, time_s/TIME_YEAR);
        }
    }

    /**
     * Locale
     * ***********************************************************************************************
     */

    /**
     * @return double with percentage sign
     */
    public static String fmtPercentage(Double value) {
    return fmtPercentage(value, 0);
    }
    public static String fmtPercentage(Double value, int point) {
        // only retrieve the percentage format the first time
        if (mCurrentPercentageFormat == null) {
            mCurrentPercentageFormat = NumberFormat.getPercentInstance(LanguageUtil.getLocale());
        }
        return mCurrentPercentageFormat.format(value);
    }

    // Removed fmtDouble(). Was used only by other functions here. We now use getString() with localized formatting now.

    /**
     * HTML
     * ***********************************************************************************************
     */

    /**
     * Strips a text from <style>...</style>, <script>...</script> and <_any_tag_> HTML tags.
     * @param s The HTML text to be cleaned.
     * @return The text without the aforementioned tags.
     */
    public static String stripHTML(String s) {
        Matcher htmlMatcher = stylePattern.matcher(s);
        s = htmlMatcher.replaceAll("");
        htmlMatcher = scriptPattern.matcher(s);
        s = htmlMatcher.replaceAll("");
        htmlMatcher = tagPattern.matcher(s);
        s = htmlMatcher.replaceAll("");
        return entsToTxt(s);
    }


    /**
     * Strip HTML but keep media filenames
     */
    public static String stripHTMLMedia(String s) {
        Matcher imgMatcher = imgPattern.matcher(s);
        return stripHTML(imgMatcher.replaceAll(" $1 "));
    }


    /**
     * Takes a string and replaces all the HTML symbols in it with their unescaped representation.
     * This should only affect substrings of the form &something; and not tags.
     * Internet rumour says that Html.fromHtml() doesn't cover all cases, but it doesn't get less
     * vague than that.
     * @param html The HTML escaped text
     * @return The text with its HTML entities unescaped.
     */
    private static String entsToTxt(String html) {
        // entitydefs defines nbsp as \xa0 instead of a standard space, so we
        // replace it first
        html = html.replace("&nbsp;", " ");
        Matcher htmlEntities = htmlEntitiesPattern.matcher(html);
        StringBuffer sb = new StringBuffer();
        while (htmlEntities.find()) {
            htmlEntities.appendReplacement(sb, Html.fromHtml(htmlEntities.group()).toString());
        }
        htmlEntities.appendTail(sb);
        return sb.toString();
    }

    /**
     * IDs
     * ***********************************************************************************************
     */

    /** Given a list of integers, return a string '(int1,int2,...)'. */
    public static String ids2str(int[] ids) {
        StringBuilder sb = new StringBuilder();
        sb.append("(");
        if (ids != null) {
            String s = Arrays.toString(ids);
            sb.append(s.substring(1, s.length() - 1));
        }
        sb.append(")");
        return sb.toString();
    }


    /** Given a list of integers, return a string '(int1,int2,...)'. */
    public static String ids2str(long[] ids) {
        StringBuilder sb = new StringBuilder();
        sb.append("(");
        if (ids != null) {
            String s = Arrays.toString(ids);
            sb.append(s.substring(1, s.length() - 1));
        }
        sb.append(")");
        return sb.toString();
    }

    /** Given a list of integers, return a string '(int1,int2,...)'. */
    public static String ids2str(Long[] ids) {
        StringBuilder sb = new StringBuilder();
        sb.append("(");
        if (ids != null) {
            String s = Arrays.toString(ids);
            sb.append(s.substring(1, s.length() - 1));
        }
        sb.append(")");
        return sb.toString();
    }

    /** Given a list of integers, return a string '(int1,int2,...)'. */
    public static <T> String ids2str(List<T> ids) {
        StringBuilder sb = new StringBuilder(512);
        sb.append("(");
        boolean isNotFirst = false;
        for (T id : ids) {
            if (isNotFirst) {
                sb.append(", ");
            } else {
                isNotFirst = true;
            }
            sb.append(id);
        }
        sb.append(")");
        return sb.toString();
    }


    /** Given a list of integers, return a string '(int1,int2,...)'. */
    public static String ids2str(JSONArray ids) {
        StringBuilder str = new StringBuilder(512);
        str.append("(");
        if (ids != null) {
            int len = ids.length();
            for (int i = 0; i < len; i++) {
                try {
                    if (i == (len - 1)) {
                        str.append(ids.get(i));
                    } else {
                        str.append(ids.get(i)).append(",");
                    }
                } catch (JSONException e) {
                    Timber.e(e, "ids2str :: JSONException");
                }
            }
        }
        str.append(")");
        return str.toString();
    }


    /** LIBANKI: not in libanki */
    public static long[] arrayList2array(List<Long> list) {
        long[] ar = new long[list.size()];
        int i = 0;
        for (long l : list) {
            ar[i++] = l;
        }
        return ar;
    }

    public static Long[] list2ObjectArray(List<Long> list) {
        return list.toArray(new Long[list.size()]);
    }

    /** Return a non-conflicting timestamp for table. */
    public static long timestampID(DB db, String table) {
        // be careful not to create multiple objects without flushing them, or they
        // may share an ID.
        long t = intNow(1000);
        while (db.queryScalar("SELECT id FROM " + table + " WHERE id = " + t) != 0) {
            t += 1;
        }
        return t;
    }


    /** Return the first safe ID to use. */
    public static long maxID(DB db) {
        long now = intNow(1000);
        now = Math.max(now, db.queryLongScalar("SELECT MAX(id) FROM cards"));
        now = Math.max(now, db.queryLongScalar("SELECT MAX(id) FROM notes"));
        return now + 1;
    }


    // used in ankiweb
    public static String base62(int num, String extra) {
        String table = ALL_CHARACTERS + extra;
        int len = table.length();
        String buf = "";
        int mod = 0;
        while (num != 0) {
            mod = num % len;
            buf = buf + table.substring(mod, mod + 1);
            num = num / len;
        }
        return buf;
    }

    // all printable characters minus quotes, backslash and separators
    public static String base91(int num) {
        return base62(num, BASE91_EXTRA_CHARS);
    }


    /** return a base91-encoded 64bit random number */
    public static String guid64() {
        return base91((new Random()).nextInt((int) (Math.pow(2, 61) - 1)));
    }

    // increment a guid by one, for note type conflicts
    public static String incGuid(String guid) {
        return new StringBuffer(_incGuid(new StringBuffer(guid).reverse().toString())).reverse().toString();
    }

    private static String _incGuid(String guid) {
        String table = ALL_CHARACTERS + BASE91_EXTRA_CHARS;
        int idx = table.indexOf(guid.substring(0, 1));
        if (idx + 1 == table.length()) {
            // overflow
            guid = table.substring(0, 1) + _incGuid(guid.substring(1, guid.length()));
        } else {
            guid = table.substring(idx + 1) + guid.substring(1, guid.length());
        }
        return guid;
    }


    public static long[] jsonArrayToLongArray(JSONArray jsonArray) throws JSONException {
        long[] ar = new long[jsonArray.length()];
        for (int i = 0; i < jsonArray.length(); i++) {
            ar[i] = jsonArray.getLong(i);
        }
        return ar;
    }


    public static Object[] jsonArray2Objects(JSONArray array) {
        Object[] o = new Object[array.length()];
        for (int i = 0; i < array.length(); i++) {
            try {
                o[i] = array.get(i);
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }
        return o;
    }

    /**
     * Fields
     * ***********************************************************************************************
     */

    public static String joinFields(String[] list) {
        StringBuilder result = new StringBuilder(128);
        for (int i = 0; i < list.length - 1; i++) {
            result.append(list[i]).append("\u001f");
        }
        if (list.length > 0) {
            result.append(list[list.length - 1]);
        }
        return result.toString();
    }


    public static String[] splitFields(String fields) {
        // -1 ensures that we don't drop empty fields at the ends
        return fields.split("\\x1f", -1);
    }

    /**
     * Checksums
     * ***********************************************************************************************
     */

    /**
     * SHA1 checksum.
     * Equivalent to python sha1.hexdigest()
     *
     * @param data the string to generate hash from
     * @return A string of length 40 containing the hexadecimal representation of the MD5 checksum of data.
     */
    public static String checksum(String data) {
        String result = "";
        if (data != null) {
            MessageDigest md = null;
            byte[] digest = null;
            try {
                md = MessageDigest.getInstance("SHA1");
                digest = md.digest(data.getBytes("UTF-8"));
            } catch (NoSuchAlgorithmException e) {
                Timber.e(e, "Utils.checksum: No such algorithm.");
                throw new RuntimeException(e);
            } catch (UnsupportedEncodingException e) {
                Timber.e(e, "Utils.checksum :: UnsupportedEncodingException");
                e.printStackTrace();
            }
            BigInteger biginteger = new BigInteger(1, digest);
            result = biginteger.toString(16);

            // pad with zeros to length of 40 This method used to pad
            // to the length of 32. As it turns out, sha1 has a digest
            // size of 160 bits, leading to a hex digest size of 40,
            // not 32.
            if (result.length() < 40) {
                String zeroes = "0000000000000000000000000000000000000000";
                result = zeroes.substring(0, zeroes.length() - result.length()) + result;
            }
        }
        return result;
    }


    /**
     * @param data the string to generate hash from
     * @return 32 bit unsigned number from first 8 digits of sha1 hash
     */
    public static long fieldChecksum(String data) {
        return Long.valueOf(checksum(stripHTMLMedia(data)).substring(0, 8), 16);
    }

    /**
     * Generate the SHA1 checksum of a file.
     * @param file The file to be checked
     * @return A string of length 32 containing the hexadecimal representation of the SHA1 checksum of the file's contents.
     */
    public static String fileChecksum(String file) {
        byte[] buffer = new byte[1024];
        byte[] digest = null;
        try {
            InputStream fis = new FileInputStream(file);
            MessageDigest md = MessageDigest.getInstance("SHA1");
            int numRead = 0;
            do {
                numRead = fis.read(buffer);
                if (numRead > 0) {
                    md.update(buffer, 0, numRead);
                }
            } while (numRead != -1);
            fis.close();
            digest = md.digest();
        } catch (FileNotFoundException e) {
            Timber.e(e, "Utils.fileChecksum: File not found.");
        } catch (NoSuchAlgorithmException e) {
            Timber.e(e, "Utils.fileChecksum: No such algorithm.");
        } catch (IOException e) {
            Timber.e(e, "Utils.fileChecksum: IO exception.");
        }
        BigInteger biginteger = new BigInteger(1, digest);
        String result = biginteger.toString(16);
        // pad with zeros to length of 40 - SHA1 is 160bit long
        if (result.length() < 40) {
            result = "0000000000000000000000000000000000000000".substring(0, 40 - result.length()) + result;
        }
        return result;
    }


    public static String fileChecksum(File file) {
        return fileChecksum(file.getAbsolutePath());
    }

    /** Replace HTML line break tags with new lines. */
    public static String replaceLineBreak(String text) {
        return text.replaceAll("<br(\\s*\\/*)>", "\n");
    }


    /**
     *  Tempo files
     * ***********************************************************************************************
     */


    /**
     * Converts an InputStream to a String.
     * @param is InputStream to convert
     * @return String version of the InputStream
     */
    public static String convertStreamToString(InputStream is) {
        String contentOfMyInputStream = "";
        try {
            BufferedReader rd = new BufferedReader(new InputStreamReader(is), 4096);
            String line;
            StringBuilder sb = new StringBuilder();
            while ((line = rd.readLine()) != null) {
                sb.append(line);
            }
            rd.close();
            contentOfMyInputStream = sb.toString();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return contentOfMyInputStream;
    }


    public static void unzipFiles(ZipFile zipFile, String targetDirectory, String[] zipEntries,
                                  Map<String, String> zipEntryToFilenameMap) throws IOException {
        byte[] buf = new byte[FILE_COPY_BUFFER_SIZE];
        File dir = new File(targetDirectory);
        if (!dir.exists() && !dir.mkdirs()) {
            throw new IOException("Failed to create target directory: " + targetDirectory);
        }
        if (zipEntryToFilenameMap == null) {
            zipEntryToFilenameMap = new HashMap<>();
        }
        BufferedInputStream zis = null;
        BufferedOutputStream bos = null;
        try {
            for (String requestedEntry : zipEntries) {
                ZipEntry ze = zipFile.getEntry(requestedEntry);
                if (ze != null) {
                    String name = ze.getName();
                    if (zipEntryToFilenameMap.containsKey(name)) {
                        name = zipEntryToFilenameMap.get(name);
                    }
                    File destFile = new File(dir, name);
                    if (!ze.isDirectory()) {
                        Timber.i("uncompress %s", name);
                        zis = new BufferedInputStream(zipFile.getInputStream(ze));
                        bos = new BufferedOutputStream(new FileOutputStream(destFile), FILE_COPY_BUFFER_SIZE);
                        int n;
                        while ((n = zis.read(buf, 0, FILE_COPY_BUFFER_SIZE)) != -1) {
                            bos.write(buf, 0, n);
                        }
                        bos.flush();
                        bos.close();
                        zis.close();
                    }
                }
            }
        } finally {
            if (bos != null) {
                bos.close();
            }
            if (zis != null) {
                zis.close();
            }
        }
    }

    /**
     * Compress data.
     * @param bytesToCompress is the byte array to compress.
     * @return a compressed byte array.
     * @throws java.io.IOException
     */
    public static byte[] compress(byte[] bytesToCompress, int comp) throws IOException {
        // Compressor with highest level of compression.
        Deflater compressor = new Deflater(comp, true);
        // Give the compressor the data to compress.
        compressor.setInput(bytesToCompress);
        compressor.finish();

        // Create an expandable byte array to hold the compressed data.
        // It is not necessary that the compressed data will be smaller than
        // the uncompressed data.
        ByteArrayOutputStream bos = new ByteArrayOutputStream(bytesToCompress.length);

        // Compress the data
        byte[] buf = new byte[65536];
        while (!compressor.finished()) {
            bos.write(buf, 0, compressor.deflate(buf));
        }

        bos.close();

        // Get the compressed data
        return bos.toByteArray();
    }


    /**
     * Utility method to write to a file.
     * Throws the exception, so we can report it in syncing log
     * @throws IOException
     */
    public static void writeToFile(InputStream source, String destination) throws IOException {
        Timber.d("Creating new file... = %s", destination);
        new File(destination).createNewFile();

        long startTimeMillis = System.currentTimeMillis();
        OutputStream output = new BufferedOutputStream(new FileOutputStream(destination));

        // Transfer bytes, from source to destination.
        byte[] buf = new byte[CHUNK_SIZE];
        long sizeBytes = 0;
        int len;
        if (source == null) {
            Timber.e("writeToFile :: source is null!");
        }
        while ((len = source.read(buf)) >= 0) {
            output.write(buf, 0, len);
            sizeBytes += len;
        }
        long endTimeMillis = System.currentTimeMillis();

        Timber.d("Finished writeToFile!");
        long durationSeconds = (endTimeMillis - startTimeMillis) / 1000;
        long sizeKb = sizeBytes / 1024;
        long speedKbSec = 0;
        if (endTimeMillis != startTimeMillis) {
            speedKbSec = sizeKb * 1000 / (endTimeMillis - startTimeMillis);
        }
        Timber.d("Utils.writeToFile: Size: %d Kb, Duration: %d s, Speed: %d Kb/s", sizeKb, durationSeconds, speedKbSec);
        output.close();
    }


    /**
     *  Returns the effective date of the present moment.
     *  If the time is prior the cut-off time (9:00am by default as of 11/02/10) return yesterday,
     *  otherwise today
     *  Note that the Date class is java.sql.Date whose constructor sets hours, minutes etc to zero
     *
     * @param utcOffset The UTC offset in seconds we are going to use to determine today or yesterday.
     * @return The date (with time set to 00:00:00) that corresponds to today in Anki terms
     */
    public static Date genToday(double utcOffset) {
        // The result is not adjusted for timezone anymore, following libanki model
        // Timezone adjustment happens explicitly in Deck.updateCutoff(), but not in Deck.checkDailyStats()
        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
        df.setTimeZone(TimeZone.getTimeZone("GMT"));
        Calendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
        cal.setTimeInMillis(System.currentTimeMillis() - (long) utcOffset * 1000L);
        return Date.valueOf(df.format(cal.getTime()));
    }


    public static void printDate(String name, double date) {
        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH-mm-ss");
        df.setTimeZone(TimeZone.getTimeZone("GMT"));
        Calendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
        cal.setTimeInMillis((long)date * 1000);
        Timber.d("Value of %s: %s", name, cal.getTime().toGMTString());
    }


    // Use DateUtil.formatElapsedTime((long) value) instead of doubleToTime.
    // public static String doubleToTime(double value) { ...}

    /**
     * Indicates whether the specified action can be used as an intent. This method queries the package manager for
     * installed packages that can respond to an intent with the specified action. If no suitable package is found, this
     * method returns false.
     * @param context The application's environment.
     * @param action The Intent action to check for availability.
     * @return True if an Intent with the specified action can be sent and responded to, false otherwise.
     */
    public static boolean isIntentAvailable(Context context, String action) {
        return isIntentAvailable(context, action, null);
    }


    public static boolean isIntentAvailable(Context context, String action, ComponentName componentName) {
        final PackageManager packageManager = context.getPackageManager();
        final Intent intent = new Intent(action);
        intent.setComponent(componentName);
        List<ResolveInfo> list = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);
        return list.size() > 0;
    }

    /**
     * @param mediaDir media directory path on SD card
     * @return path converted to file URL, properly UTF-8 URL encoded
     */
    public static String getBaseUrl(String mediaDir) {
        // Use android.net.Uri class to ensure whole path is properly encoded
        // File.toURL() does not work here, and URLEncoder class is not directly usable
        // with existing slashes
        if (mediaDir.length() != 0 && !mediaDir.equalsIgnoreCase("null")) {
            Uri mediaDirUri = Uri.fromFile(new File(mediaDir));
            return mediaDirUri.toString() +"/";
        }
        return "";
    }


    /**
     * Take an array of Long and return an array of long
     *
     * @param array The input with type Long[]
     * @return The output with type long[]
     */
    public static long[] toPrimitive(Long[] array) {
        if (array == null) {
            return null;
        }
        long[] results = new long[array.length];
        for (int i = 0; i < array.length; i++) {
            results[i] = array[i];
        }
        return results;
    }
    public static long[] toPrimitive(Collection<Long> array) {
        if (array == null) {
            return null;
        }
        long[] results = new long[array.size()];
        int i = 0;
        for (Long item : array) {
            results[i++] = item;
        }
        return results;
    }


    /**
     * Calculate the UTC offset
     */
    public static double utcOffset() {
        Calendar cal = Calendar.getInstance();
        // 4am
        return 4 * 60 * 60 - (cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET)) / 1000;
    }

    /**
     * Returns a String array with two elements:
     * 0 - file name
     * 1 - extension
     */
    public static String[] splitFilename(String filename) {
        String name = filename;
        String ext = "";
        int dotPosition = filename.lastIndexOf('.');
        if (dotPosition != -1) {
            name = filename.substring(0, dotPosition);
            ext = filename.substring(dotPosition);
        }
        return new String[] {name, ext};
    }


    /** Returns a list of files for the installed custom fonts. */
    public static List<AnkiFont> getCustomFonts(Context context) {
        String deckPath = CollectionHelper.getCurrentAnkiDroidDirectory(context);
        String fontsPath = deckPath + "/fonts/";
        File fontsDir = new File(fontsPath);
        int fontsCount = 0;
        File[] fontsList = null;
        if (fontsDir.exists() && fontsDir.isDirectory()) {
            fontsCount = fontsDir.listFiles().length;
            fontsList = fontsDir.listFiles();
        }
        String[] ankiDroidFonts = null;
        try {
            ankiDroidFonts = context.getAssets().list("fonts");
        } catch (IOException e) {
            Timber.e(e, "Error on retrieving ankidroid fonts");
        }
        List<AnkiFont> fonts = new ArrayList<>();
        for (int i = 0; i < fontsCount; i++) {
            String filePath = fontsList[i].getAbsolutePath();
            String filePathExtension = splitFilename(filePath)[1];
            for (String fontExtension : FONT_FILE_EXTENSIONS) {
                // Go through the list of allowed extensios.
                if (filePathExtension.equalsIgnoreCase(fontExtension)) {
                    // This looks like a font file.
                    AnkiFont font = AnkiFont.createAnkiFont(context, filePath, false);
                    if (font != null) {
                        fonts.add(font);
                    }
                    break;  // No need to look for other file extensions.
                }
            }
        }
        if (ankiDroidFonts != null) {
            for (String ankiDroidFont : ankiDroidFonts) {
                // Assume all files in the assets directory are actually fonts.
                AnkiFont font = AnkiFont.createAnkiFont(context, ankiDroidFont, true);
                if (font != null) {
                    fonts.add(font);
                }
            }
        }

        return fonts;
    }


    /** Returns a list of apkg-files. */
    public static List<File> getImportableDecks(Context context) {
        String deckPath = CollectionHelper.getCurrentAnkiDroidDirectory(context);
        File dir = new File(deckPath);
        int deckCount = 0;
        File[] deckList = null;
        if (dir.exists() && dir.isDirectory()) {
            deckList = dir.listFiles(new FileFilter(){
                @Override
                public boolean accept(File pathname) {
                    return pathname.isFile() && pathname.getName().endsWith(".apkg");
                }
            });
            deckCount = deckList.length;
        }
        List<File> decks = new ArrayList<>();
        decks.addAll(Arrays.asList(deckList).subList(0, deckCount));
        return decks;
    }


    /**
     * Simply copy a file to another location
     * @param sourceFile The source file
     * @param destFile The destination file, doesn't need to exist yet.
     * @throws IOException
     */
    public static void copyFile(File sourceFile, File destFile) throws IOException {
        if(!destFile.exists()) {
            destFile.createNewFile();
        }

        FileChannel source = null;
        FileChannel destination = null;

        try {
            source = new FileInputStream(sourceFile).getChannel();
            destination = new FileOutputStream(destFile).getChannel();
            destination.transferFrom(source, 0, source.size());
        } finally {
            if (source != null) {
                source.close();
            }
            if (destination != null) {
                destination.close();
            }
        }
    }

    /**
     * Like org.json.JSONObject except that it doesn't escape forward slashes
     * The necessity for this method is due to python's 2.7 json.dumps() function that doesn't escape chracter '/'.
     * The org.json.JSONObject parser accepts both escaped and unescaped forward slashes, so we only need to worry for
     * our output, when we write to the database or syncing.
     *
     * @param json a json object to serialize
     * @return the json serialization of the object
     * @see org.json.JSONObject#toString()
     */
    public static String jsonToString(JSONObject json) {
        return json.toString().replaceAll("\\\\/", "/");
    }

    /**
     * Like org.json.JSONArray except that it doesn't escape forward slashes
     * The necessity for this method is due to python's 2.7 json.dumps() function that doesn't escape chracter '/'.
     * The org.json.JSONArray parser accepts both escaped and unescaped forward slashes, so we only need to worry for
     * our output, when we write to the database or syncing.
     *
     * @param json a json object to serialize
     * @return the json serialization of the object
     * @see org.json.JSONArray#toString()
     */
    public static String jsonToString(JSONArray json) {
        return json.toString().replaceAll("\\\\/", "/");
    }

    /**
     * @return A description of the device, including the model and android version. No commas are present in the
     * returned string.
     */
    public static String platDesc() {
        // AnkiWeb reads this string and uses , and : as delimiters, so we remove them.
        String model = android.os.Build.MODEL.replace(',', ' ').replace(':', ' ');
        return String.format(Locale.US, "android:%s:%s",
                android.os.Build.VERSION.RELEASE, model);
    }


    /*
     *  Return the input string in the Unicode normalized form. This helps with text comparisons, for example a 眉
     *  stored as u plus the dots but typed as a single character compare as the same.
     *
     * @param txt Text to be normalized
     * @return The input text in its NFC normalized form form.
    */
    public static String nfcNormalized(String txt) {
        if (!Normalizer.isNormalized(txt, Normalizer.Form.NFC)) {
            return Normalizer.normalize(txt, Normalizer.Form.NFC);
        }
        return txt;
    }


    /**
     * Unescapes all sequences within the given string of text, interpreting them as HTML escaped characters.
     * <p/>
     * Not that this code strips any HTML tags untouched, so if the text contains any HTML tags, they will be ignored.
     *
     * @param htmlText the text to convert
     * @return the unescaped text
     */
    public static String unescape(String htmlText) {
        return Html.fromHtml(htmlText).toString();
    }


    /**
     * Return a random float within the range of min and max.
     */
    public static float randomFloatInRange(float min, float max) {
        Random rand = new Random();
        return rand.nextFloat() * (max - min) + min;
    }
}
/****************************************************************************************
/****************************************************************************************
 * Copyright (c) 2016 Jeffrey van Prehn <jvanprehn@gmail.com>                           *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.hooks;

import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.preference.PreferenceManager;

import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.R;
import com.ichi2.anki.stats.StatsMetaInfo;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Decks;
import com.ichi2.libanki.Stats;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Stack;

import io.requery.android.database.sqlite.SQLiteDatabase;
import timber.log.Timber;

/**
 * Display forecast statistics based on a simulation of future reviews.
 *
 * Sequence diagram (https://www.websequencediagrams.com/):
 * Stats->+AdvancedStatistics: runFilter
 * AdvancedStatistics->+ReviewSimulator: simNreviews
 * loop dids
 *   loop nIterations
 *       loop cards
 *           ReviewSimulator->+Review: newCard
 *           Review->+NewCardSimulator: simulateNewCard
 *           NewCardSimulator->-Review: tElapsed:int
 *           Review-->-ReviewSimulator: SimulationResult, Review
 *
 *           loop reviews
 *               ReviewSimulator->+Review: simulateReview
 *               Review->+EaseClassifier: simSingleReview
 *               EaseClassifier->+Card:getType
 *               Card-->-EaseClassifier:cardType:int
 *               EaseClassifier-->-Review: ReviewOutcome
 *               Review-->-ReviewSimulator: SimulationResult, Review[]
 *           end
 *        end
 *   end
 * end
 * ReviewSimulator-->-AdvancedStatistics: SimulationResult
 * AdvancedStatistics-->-Stats: StatsMetaInfo
 *
 * %2F%2F Class diagram (http://yuml.me/diagram/scruffy/class/draw; http://yuml.me/edit/e0ad47bf):
 * [AdvancedStatistics]
 * [ReviewSimulator]
 * [StatsMetaInfo|mTitle:int;mType:int;mAxisTitles:int锛伙冀;mValueLabels:int锛伙冀;mColors:int锛伙冀;]
 * [Settings|computeNDays:int;computeMaxError:double;simulateNIterations:int]
 * [Deck|-did:long;newPerDay:int;revPerDay:int]
 * [Card|-id:long;ivl:int;factor:double;lastReview:int;due:int;correct:int|setAll();getType()]
 * [Review|prob:double;tElapsed:int]
 * [SimulationResult|nReviews锛籆ARD_TYPE锛斤蓟t锛/***************************************************************************************
 * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.hooks;



import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import timber.log.Timber;

public class ChessFilter extends Hook {
    private static final Pattern fFenPattern = Pattern.compile("\\[fen ?([^\\]]*)\\]([^\\[]+)\\[/fen\\]");
    private static final Pattern fFenOrientationPattern = Pattern.compile("orientation *= *\"?(black|white)\"?");
    private static final String fRenderFen =
    		"(function (fentxt, showBlack) {" +
    		"    fentxt=fentxt.replace(/ .*/g,'');" +
    		"    if (showBlack) {" +
    		"        fentxt = fentxt.split(\"\").reverse().join(\"\");" +
    		"    }" +
    		"    fentxt=fentxt.replace(/r/g,'x');" +
    		"    fentxt=fentxt.replace(/\\\\//g,'</tr><tr>');" +
    		"    fentxt=fentxt.replace(/1/g,'<td></td>');" +
    		"    fentxt=fentxt.replace(/2/g,'<td></td><td></td>');" +
    		"    fentxt=fentxt.replace(/3/g,'<td></td><td></td><td></td>');" +
    		"    fentxt=fentxt.replace(/4/g,'<td></td><td></td><td></td><td></td>');" +
    		"    fentxt=fentxt.replace(/5/g,'<td></td><td></td><td></td><td></td><td></td>');" +
    		"    fentxt=fentxt.replace(/6/g,'<td></td><td></td><td></td><td></td><td></td><td></td>');" +
    		"    fentxt=fentxt.replace(/7/g,'<td></td><td></td><td></td><td></td><td></td><td></td><td></td>');" +
    		"    fentxt=fentxt.replace(/8/g,'<td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td>');" +
    		"    fentxt=fentxt.replace(/K/g,'<td>&#9812;</td>');" +
    		"    fentxt=fentxt.replace(/Q/g,'<td>&#9813;</td>');" +
    		"    fentxt=fentxt.replace(/R/g,'<td>&#9814;</td>');" +
    		"    fentxt=fentxt.replace(/B/g,'<td>&#9815;</td>');" +
    		"    fentxt=fentxt.replace(/N/g,'<td>&#9816;</td>');" +
    		"    fentxt=fentxt.replace(/P/g,'<td>&#9817;</td>');" +
    		"    fentxt=fentxt.replace(/k/g,'<td>&#9818;</td>');" +
    		"    fentxt=fentxt.replace(/q/g,'<td>&#9819;</td>');" +
    		"    fentxt=fentxt.replace(/x/g,'<td>&#9820;</td>');" +
    		"    fentxt=fentxt.replace(/b/g,'<td>&#9821;</td>');" +
    		"    fentxt=fentxt.replace(/n/g,'<td>&#9822;</td>');" +
    		"    fentxt=fentxt.replace(/p/g,'<td>&#9823;</td>');" +
    		"    return '<div align=\"center\" width=\"100%%\"><table class=\"chess_board\" cellspacing=\"0\" cellpadding=\"0\"><tr>'+fentxt+'</tr></table></div>';" +
    		"})('%s', %b)";
    @Override
    public Object runFilter(Object arg, Object... args) {
        return fenToChessboard((String) arg);
    }
    public static void install(Hooks h) {
        h.addHook("mungeQA", new ChessFilter());
    }
    public static void uninstall(Hooks h) {
        h.remHook("mungeQA", new ChessFilter());
    }

    private String fenToChessboard(String text) {
        Boolean showBlack = false;
        Matcher mf = fFenPattern.matcher(text);
        StringBuffer sb = new StringBuffer();
        while (mf.find()) {
            if (mf.group(1) != null) {
                Matcher mo = fFenOrientationPattern.matcher(mf.group(1));
                if (mo.find() && mo.group(1) != null && mo.group(1).equalsIgnoreCase("black")) {
                    showBlack = true;
                }
            }

            try {
                mf.appendReplacement(sb, "<script type=\"text/javascript\">document.write(" +
                        String.format(Locale.US, fRenderFen, mf.group(2), showBlack) + ");</script>");
            } catch (Exception e) {
                Timber.e("ChessFilter exception: ", e);
            }
        }
        mf.appendTail(sb);
        return sb.toString();
    }
}
package com.ichi2.libanki.hooks;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.Context;
import android.os.AsyncTask;
import dalvik.system.DexClassLoader;

public class ExternalHookLoader {   
    // Buffer size for file copying.  While 8kb is used in this sample, you
    // may want to tweak it based on actual size of the secondary dex file involved.
    private static final int BUF_SIZE = 8 * 1024;
    private static final String HOOK_SUB_PATH = "plugins/hooks";
    private Activity mMainActivity;
    private final File mHookFolderPath;
    
    /**
     * Adaption of example from Google on loading custom classes. See original example for more help
     * https://code.google.com/p/android-custom-class-loading-sample/source/browse/#svn%2Ftrunk%2Fandroid-custom-class-loading-sample
     * 
     * @param Activity mainActivity : the activity which is going to load the hook
     * @param String colPath : path to AnkiDroid collection. Hook plugins should go in ~/plugins/hooks as compiled apk or jar packages
     */
    public ExternalHookLoader(Activity mainActivity, String colPath) {
        mMainActivity = mainActivity;
        mHookFolderPath = new File(colPath, HOOK_SUB_PATH);
    }


    /**
     * import a hook class from an external apk or jar package stored in COLLECTION_PATH/plugins/hooks
     * 
     * @param String dexFilename : name of the package file in hooks folder -- e.g. "ChessFilter.jar"
     * @param String className: full name of class to load from package -- e.g. "com.testplugin.ChessFilter"
     */
    @SuppressLint("NewApi")
	public HookPlugin importExternalHook(String dexFilename, String className) {
        // filename of the hook which is currently being loaded
        final File dexExternalStoragePath = new File(mHookFolderPath, dexFilename);
        
        // Before the secondary dex file can be processed by the DexClassLoader,
        // it has to be first copied from asset resource to a storage location.
        final File dexInternalStoragePath = new File(mMainActivity.getDir("dex", Context.MODE_PRIVATE), 
                dexFilename);        
        (new PrepareDexTask()).execute(dexExternalStoragePath,dexInternalStoragePath);
        
        // Internal storage where the DexClassLoader writes the optimized dex file to.
        final File optimizedDexOutputPath = mMainActivity.getDir("outdex", Context.MODE_PRIVATE);
        
        // Initialize the class loader with the secondary dex file.
        DexClassLoader cl = new DexClassLoader(dexInternalStoragePath.getAbsolutePath(),
                optimizedDexOutputPath.getAbsolutePath(),
                null,
                mMainActivity.getClassLoader());
        Class hookClass = null;
        
        try {
            hookClass = cl.loadClass(className);
            // Cast the return object to the library interface so that the
            // caller can directly invoke methods in the interface.
            // Alternatively, the caller can invoke methods through reflection,
            // which is more verbose and slow.
            HookPlugin importedHook = (HookPlugin) hookClass.newInstance();
            return importedHook;
        } catch (Exception exception) {
            // Handle exception gracefully here.
            exception.printStackTrace();
            return null;
        }
    }
    
    // File I/O code to copy the secondary dex file from asset resource to internal storage.
    private boolean prepareDex(File dexExternalStoragePath, File dexInternalStoragePath) {
        BufferedInputStream bis = null;
        OutputStream dexWriter = null;

        try {
            bis = new BufferedInputStream(new FileInputStream(dexExternalStoragePath));
            dexWriter = new BufferedOutputStream(new FileOutputStream(dexInternalStoragePath));
            byte[] buf = new byte[BUF_SIZE];
            int len;
            while((len = bis.read(buf, 0, BUF_SIZE)) > 0) {
                dexWriter.write(buf, 0, len);
            }
            dexWriter.close();
            bis.close();
            return true;
        } catch (IOException e) {
            if (dexWriter != null) {
                try {
                    dexWriter.close();
                } catch (IOException ioe) {
                    ioe.printStackTrace();
                }
            }
            if (bis != null) {
                try {
                    bis.close();
                } catch (IOException ioe) {
                    ioe.printStackTrace();
                }
            }
            return false;
        }
    }
    
    private class PrepareDexTask extends AsyncTask<File, Void, Boolean> {

        @Override
        protected void onCancelled() {
            super.onCancelled();
            //if (mProgressDialog != null) mProgressDialog.cancel();
        }

        @Override
        protected void onPostExecute(Boolean result) {
            super.onPostExecute(result);
            //if (mProgressDialog != null) mProgressDialog.cancel();
        }

        @Override
        protected Boolean doInBackground(File... dexStoragePaths) {
            prepareDex(dexStoragePaths[0],dexStoragePaths[1]);
            return null;
        }
    }
}/***************************************************************************************
 * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.hooks;

import com.ichi2.compat.CompatHelper;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class FuriganaFilters {
    private static final Pattern r = Pattern.compile(" ?([^ >]+?)\\[(.+?)\\]");

    // Since there is no ruby tag support in Android before 3.0 (SDK version 11), we must use an alternative
    // approach to align the elements. Anki does the same thing in aqt/qt.py for earlier versions of qt.
    // The fallback approach relies on CSS in the file /assets/ruby.css
    private static final String RUBY = CompatHelper.isHoneycomb() ? "<ruby><rb>$1</rb><rt>$2</rt></ruby>"
            : "<span class='legacy_ruby_rb'><span class='legacy_ruby_rt'>$2</span>$1</span>";


    public void install(Hooks h) {
        h.addHook("fmod_kanji", new Kanji());
        h.addHook("fmod_kana", new Kana());
        h.addHook("fmod_furigana", new Furigana());
    }


    private static String noSound(Matcher match, String repl) {
        if (match.group(2).startsWith("sound:")) {
            // return without modification
            return match.group(0);
        } else {
            return r.matcher(match.group(0)).replaceAll(repl);
        }
    }

    public class Kanji extends Hook {
        @Override
        public Object runFilter(Object arg, Object... args) {
            Matcher m = r.matcher((String) arg);
            StringBuffer sb = new StringBuffer();
            while (m.find()) {
                m.appendReplacement(sb, noSound(m, "$1"));
            }
            m.appendTail(sb);
            return sb.toString();
        }
    }

    public class Kana extends Hook {
        @Override
        public Object runFilter(Object arg, Object... args) {
            Matcher m = r.matcher((String) arg);
            StringBuffer sb = new StringBuffer();
            while (m.find()) {
                m.appendReplacement(sb, noSound(m, "$2"));
            }
            m.appendTail(sb);
            return sb.toString();
        }
    }

    public class Furigana extends Hook {
        @Override
        public Object runFilter(Object arg, Object... args) {
            Matcher m = r.matcher((String) arg);
            StringBuffer sb = new StringBuffer();
            while (m.find()) {
                m.appendReplacement(sb, noSound(m, RUBY));
            }
            m.appendTail(sb);
            return sb.toString();
        }
    }
}

package com.ichi2.libanki.hooks;

import android.util.Pair;

import com.ichi2.libanki.Media;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class HebrewFixFilter extends Hook {
    /** Regex patterns used in identifying and fixing Hebrew words, so we can reverse them */
    private static final Pattern sHebrewPattern = Pattern.compile(
    // Either a series of characters, starting from a hebrew character...
            "([\\u0591-\\u05F4\\uFB1D-\\uFB4F]" +
    // ...followed by hebrew characters, punctuation and spaces...
            "[\\u0591-\\u05F4\\uFB1D-\\uFB4F,.?!;:\"'\\s]*" +
    // ...and ending with hebrew character or punctuation
            "[\\u0591-\\u05F4\\uFB1D-\\uFB4F,.?!;:]|" +
    // or just a single Hebrew character
            "[\\u0591-\\u05F4\\uFB1D-\\uFB4F])");

    @Override
    public Object runFilter(Object arg, Object... args) {
        return applyFixForHebrew((String) arg);
    }


    public static void install(Hooks h) {
        h.addHook("mungeQA", new HebrewFixFilter());
    }


    public static void uninstall(Hooks h) {
        h.remHook("mungeQA", new HebrewFixFilter());
    }


    private String applyFixForHebrew(String text) {
        // Track the regions of text that belong to a media reference so we can skip them.
        // Modifying these regions would break the proper display/playback of the media.
        List<Pair<Integer, Integer>> mediaRegions = new ArrayList<>();
        for (Pattern p : Media.mRegexps) {
            Matcher m = p.matcher(text);
            while (m.find()) {
                mediaRegions.add(new Pair<>(m.start(), m.end()));
            }
        }

        Matcher m = sHebrewPattern.matcher(text);
        StringBuffer sb = new StringBuffer();
        while (m.find()) {
            String hebrewText = m.group();
            if (regionOverlapsMedia(mediaRegions, m.start(), m.end())) {
                continue;
            }
            String reversed = new StringBuffer(hebrewText).reverse().toString();
            String translated = translate(reversed);
            m.appendReplacement(sb, "<span style=\"font-family:Tohu;\">" + translated + "</span>");
        }
        m.appendTail(sb);

        return sb.toString();
    }


    /**
     * Translates sections of Hebrew (RTL) unicode into western locations to bypass the
     * flakey Android BiDi algorithm. This is necessary if the text includes Hebrew vowels.
     * This is supposed to be used in conjuction with a specially modified font Tohu.ttf,
     * see ankidroid forum for more details:
     * https://groups.google.com/forum/?fromgroups#!topic/anki-android/n9JpDiQ_dgU
     *
     * @param text Hebrew text
     * @return text in the Western (LTR) alphabet and punctuation range, starting in the extended range
     */
    String translate(String text) {
        StringBuilder sb = new StringBuilder(text.length());
        int codePoint;

        for (int i = 0; i < text.length(); i++) {
            codePoint = text.codePointAt(i);

            if (codePoint >= 1424 && codePoint < 1536) {
                // Hebrew letters and punctuation
                sb.append(String.valueOf((char) (codePoint - 400)));
            } else if (codePoint >= 64281 && codePoint < 64336) {
                // Hebrew compound forms and ligatures
                sb.append(String.valueOf((char) (codePoint - 63138)));
            } else if (codePoint >= 59393 && codePoint < 59398) {
                // Some characters from the Private Use Area
                sb.append(String.valueOf((char) (codePoint - 58257)));
            } else if (codePoint >= 59408 && codePoint < 59410) {
                // Some more characters from the Private Use Area
                sb.append(String.valueOf((char) (codePoint - 58267)));
            } else if (codePoint >= 1114131 && codePoint < 1114132) {
                // One last "straggler"
                sb.append(String.valueOf((char) (codePoint - 1112933)));
            } else { // anything not in range, leave as it is
                sb.append((text.charAt(i)));
            }
        }
        return sb.toString();
    }

    private boolean regionOverlapsMedia(List<Pair<Integer, Integer>> mediaRegions, int start, int end) {
        for (Pair<Integer, Integer> region : mediaRegions) {
            if (start > region.first && start < region.second
                    || end > region.first && end < region.second) {
                return true;
            }
        }
        return false;
    }
}
/***************************************************************************************
 * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.hooks;

import android.content.res.Resources;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.R;

public class HintFilter {
    public void install(Hooks h) {
        h.addHook("fmod_hint", new Hint());
    }

    public class Hint extends Hook {
        @Override
        public Object runFilter(Object arg, Object... args) {
            String txt = (String) arg;
            if (txt.trim().length() == 0) {
                return "";
            }
            Resources res = AnkiDroidApp.getAppResources();
            // random id
            String domid = "hint" + txt.hashCode();
            return "<a class=hint href=\"#\" onclick=\"this.style.display='none';document.getElementById('" +
                    domid + "').style.display='block';return false;\">" +
                    res.getString(R.string.show_hint, (String) args[2]) + "</a><div id=\"" +
                    domid + "\" class=hint style=\"display: none\">" + txt + "</div>";
        }
    }
}
/***************************************************************************************
 * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.hooks;

/**
 * Basic Hook class. All other hooks should extend this and override either runHook or runFilter.
 * In short if you want result from the hook, override runFilter, otherwise runHook.
 * <p>
 * If the hook you are creating is supposed to have state, meaning that:<ul>
 * <li>It probably uses arguments in its constructor.
 * <li>Can potentially have instances that don't behave identically.
 * <li>Uses private members to store information between runs.
 * </ul>
 * Then you should also override methods equals and hashCode, so that they take into consideration any fields you have added.<p>
 * You can do so using the auto-generate feature from Eclipse: Source->Generate hashCode() and equals()
 */
public class Hook {
    private final String fName = this.getClass().getCanonicalName();

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((fName == null) ? 0 : fName.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        Hook other = (Hook) obj;
        if (fName == null) {
            if (other.fName != null) {
                return false;
            }
        } else if (!fName.equals(other.fName)) {
            return false;
        }
        return true;
    }

    public void runHook(Object... args) {
        return;
    }

    public Object runFilter(Object arg, Object... args) {
        return arg;
    }
}
package com.ichi2.libanki.hooks;

public interface HookPlugin { 
    public void install(Hooks h);
    public void uninstall(Hooks h);   
    public int hashCode();
    public boolean equals(Object obj);
    public Object runFilter(Object arg, Object... args);    
    public void runHook(Object... args);
}/***************************************************************************************
 * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.hooks;

import android.content.Context;
import android.content.SharedPreferences;
import android.preference.PreferenceManager;


import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.libanki.LaTeX;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import timber.log.Timber;

public class Hooks {
    public static Hooks sInstance;
    private static Map<String, List<Hook>> hooks;

    public static synchronized Hooks getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new Hooks(context);
        }
        return sInstance;
    }

    private Hooks(Context context) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context.getApplicationContext());
        hooks = new HashMap<>();
        // Always-ON hooks
        new FuriganaFilters().install(this);
        new HintFilter().install(this);
        new LaTeX().installHook(this);
        new Leech().installHook(this);

        // Preferences activated hooks
        if (prefs.getBoolean("fixHebrewText", false)) {
            HebrewFixFilter.install(this);
        }
        if (prefs.getBoolean("convertFenText", false)) {
            ChessFilter.install(this);
        }
        if (prefs.getBoolean("advanced_statistics_enabled", false)) {
            AdvancedStatistics.install(this);
        }
    }


    /**
     * Add a function to hook. Ignore if already on hook.
     *
     * @param hook The name of the hook.
     * @param func A class implements interface Hook and contains the function to add.
     */
    public void addHook(String hook, Hook func) {
        if (!hooks.containsKey(hook) || hooks.get(hook) == null) {
            hooks.put(hook, new ArrayList<Hook>());
        }
        boolean found = false;
        for (Hook h : hooks.get(hook)) {
            if (func.equals(h)) {
                found = true;
                break;
            }
        }
        if (!found) {
            hooks.get(hook).add(func);
        }
    }


    /**
     * Remove a function if is on hook.
     *
     * @param hook The name of the hook.
     * @param func A class implements interface Hook and contains the function to remove.
     */
    public void remHook(String hook, Hook func) {
        if (hooks.containsKey(hook) && hooks.get(hook) != null) {
            for (Hook h : hooks.get(hook)) {
                if (func.equals(h)) {
                    hooks.get(hook).remove(h);
                    break;
                }
            }
        }
    }


    /**
     * Run all functions on hook.
     *
     * @param hook The name of the hook.
     * @param args Variable arguments to be passed to the method runHook of each function on this hook.
     */
    public void runHook(String hook, Object... args) {
        List<Hook> _hook = hooks.get(hook);
        String funcName = "";
        if (_hook != null) {
            try {
                for (Hook func : _hook) {
                    funcName = func.getClass().getCanonicalName();
                    func.runHook(args);
                }
            } catch (Exception e) {
                Timber.e(e, "Exception while running hook %s : %s", hook, funcName);
                return;
            }
        }
    }


    /**
     * Apply all functions on hook to arg and return the result.
     *
     * @param hook The name of the hook.
     * @param arg The input to the filter on hook.
     * @param args Variable arguments to be passed to the method runHook of each function on this hook.
     */
    public static Object runFilter(String hook, Object arg, Object... args) {
        if (hooks == null) {
            Timber.e("Hooks object has not been initialized");
            AnkiDroidApp.sendExceptionReport(new IllegalStateException("Hooks object uninitialized"), "Hooks.runFilter");
            return arg;
        }
        List<Hook> _hook = hooks.get(hook);
        String funcName = "";
        if (_hook != null) {
            try {
                for (Hook func : _hook) {
                    funcName = func.getClass().getCanonicalName();
                    arg = func.runFilter(arg, args);
                }
            } catch (Exception e) {
                Timber.e(e, "Exception while running hook %s : %s", hook, funcName);
                return "Error in filter " + hook + ":" + funcName;
            }
        }
        return arg;
    }
}

/***************************************************************************************
 * Copyright (c) 2014 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.hooks;

import android.app.Activity;
import android.content.res.Resources;

import android.widget.Toast;

import com.ichi2.anki.R;
import com.ichi2.libanki.Card;

import timber.log.Timber;

/**
 * Class used to display toast when leech is made
 */
public class Leech {
    public class LeechHook extends Hook {
        @Override
        public void runHook(Object... args) {
            Card card = (Card) args[0];
            final Activity activity = (Activity) args[1];
            if (activity != null) {
                Resources res = activity.getResources();
                final String leechMessage;
                if (card.getQueue() < 0) {
                    leechMessage = res.getString(R.string.leech_suspend_notification);
                } else {
                    leechMessage = res.getString(R.string.leech_notification);
                }
                activity.runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        Toast.makeText(activity, leechMessage, Toast.LENGTH_SHORT).show();
                    }
                });

            } else {
                Timber.e("LeechHook :: could not show leech toast as activity was null");
            }
        }
    }


    public void installHook(Hooks h) {
        h.addHook("leech", new LeechHook());
    }
}
/***************************************************************************************
 * Copyright (c) 2012 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2016 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.importer;

import android.database.Cursor;
import android.text.TextUtils;

import com.ichi2.anki.R;
import com.ichi2.async.DeckTask;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Media;
import com.ichi2.libanki.Storage;
import com.ichi2.libanki.Utils;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import timber.log.Timber;

public class Anki2Importer extends Importer {

    private static final int GUID = 1;
    private static final int MID = 2;
    private static final int MOD = 3;

    private static final int MEDIAPICKLIMIT = 1024;

    private String mDeckPrefix;
    private boolean mAllowUpdate;
    private boolean mDupeOnSchemaChange;

    private Map<String, Object[]> mNotes;

    /**
     * Since we can't use a tuple as a key in Java, we resort to indexing twice with nested maps.
     * Python: (guid, ord) -> cid
     * Java: guid -> ord -> cid
     */
    private Map<String, Map<Integer, Long>> mCards;
    private Map<Long, Long> mDecks;
    private Map<Long, Long> mModelMap;
    private Map<String, String> mChangedGuids;
    private Map<String, Boolean> mIgnoredGuids;

    private int mDupes;
    private int mAdded;
    private int mUpdated;

    public Anki2Importer(Collection col, String file) {
        super(col, file);
        mNeedMapper = false;
        mDeckPrefix = null;
        mAllowUpdate = true;
        mDupeOnSchemaChange = false;
    }


    @Override
    public void run() {
        publishProgress(0, 0, 0);
        try {
            _prepareFiles();
            try {
                _import();
            } finally {
                mSrc.close(false);
            }
        } catch (RuntimeException e) {
            Timber.e(e, "RuntimeException while importing");
        }
    }


    private void _prepareFiles() {
        mDst = mCol;
        mSrc = Storage.Collection(mContext, mFile);
    }


    private void _import() {
        mDecks = new HashMap<>();
        try {
            // Use transactions for performance and rollbacks in case of error
            mDst.getDb().getDatabase().beginTransaction();
            mDst.getMedia().getDb().getDatabase().beginTransaction();

            if (!TextUtils.isEmpty(mDeckPrefix)) {
                long id = mDst.getDecks().id(mDeckPrefix);
                mDst.getDecks().select(id);
            }
            _prepareTS();
            _prepareModels();
            _importNotes();
            _importCards();
            _importStaticMedia();
            publishProgress(100, 100, 25);
            _postImport();
            publishProgress(100, 100, 50);
            mDst.getDb().getDatabase().setTransactionSuccessful();
            mDst.getMedia().getDb().getDatabase().setTransactionSuccessful();
        } finally {
            mDst.getDb().getDatabase().endTransaction();
            mDst.getMedia().getDb().getDatabase().endTransaction();
        }
        mDst.getDb().execute("vacuum");
        publishProgress(100, 100, 65);
        mDst.getDb().execute("analyze");
        publishProgress(100, 100, 75);
    }


    /**
     * Notes
     * ***********************************************************
     */

    private void _importNotes() {
        // build guid -> (id,mod,mid) hash & map of existing note ids
        mNotes = new HashMap<>();
        Map<Long, Boolean> existing = new HashMap<>();
        Cursor cur = null;
        try {
            cur = mDst.getDb().getDatabase().rawQuery("select id, guid, mod, mid from notes", null);
            while (cur.moveToNext()) {
                long id = cur.getLong(0);
                String guid = cur.getString(1);
                long mod = cur.getLong(2);
                long mid = cur.getLong(3);
                mNotes.put(guid, new Object[] { id, mod, mid });
                existing.put(id, true);
            }
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        // we may need to rewrite the guid if the model schemas don't match,
        // so we need to keep track of the changes for the card import stage
        mChangedGuids = new HashMap<>();
        // apart from upgrading from anki1 decks, we ignore updates to changed
        // schemas. we need to note the ignored guids, so we avoid importing
        // invalid cards
        mIgnoredGuids = new HashMap<>();
        // iterate over source collection
        ArrayList<Object[]> add = new ArrayList<>();
        ArrayList<Object[]> update = new ArrayList<>();
        ArrayList<Long> dirty = new ArrayList<>();
        int usn = mDst.usn();
        int dupes = 0;
        ArrayList<String> dupesIgnored = new ArrayList<>();
        try {
            cur = mSrc.getDb().getDatabase().rawQuery("select * from notes", null);

            // Counters for progress updates
            int total = cur.getCount();
            boolean largeCollection = total > 200;
            int onePercent = total/100;
            int i = 0;

            while (cur.moveToNext()) {
                // turn the db result into a mutable list
                Object[] note = new Object[]{cur.getLong(0), cur.getString(1), cur.getLong(2),
                        cur.getLong(3), cur.getInt(4), cur.getString(5), cur.getString(6),
                        cur.getString(7), cur.getLong(8), cur.getInt(9), cur.getString(10)};
                boolean shouldAdd = _uniquifyNote(note);
                if (shouldAdd) {
                    // ensure id is unique
                    while (existing.containsKey(note[0])) {
                        note[0] = ((Long) note[0]) + 999;
                    }
                    existing.put((Long) note[0], true);
                    // bump usn
                    note[4] = usn;
                    // update media references in case of dupes
                    note[6] = _mungeMedia((Long) note[MID], (String) note[6]);
                    add.add(note);
                    dirty.add((Long) note[0]);
                    // note we have the added guid
                    mNotes.put((String) note[GUID], new Object[]{note[0], note[3], note[MID]});
                } else {
                    // a duplicate or changed schema - safe to update?
                    dupes += 1;
                    if (mAllowUpdate) {
                        Object[] n = mNotes.get(note[GUID]);
                        long oldNid = (Long) n[0];
                        long oldMod = (Long) n[1];
                        long oldMid = (Long) n[2];
                        // will update if incoming note more recent
                        if (oldMod < (Long) note[MOD]) {
                            // safe if note types identical
                            if (oldMid == (Long) note[MID]) {
                                // incoming note should use existing id
                                note[0] = oldNid;
                                note[4] = usn;
                                note[6] = _mungeMedia((Long) note[MID], (String) note[6]);
                                update.add(note);
                                dirty.add((Long) note[0]);
                            } else {
                                dupesIgnored.add(String.format("%s: %s",
                                        mCol.getModels().get(oldMid).getString("name"),
                                        ((String) note[6]).replace("\u001f", ",")));
                                mIgnoredGuids.put((String) note[GUID], true);
                            }
                        }
                    }
                }
                i++;
                if (total != 0 && (!largeCollection || i % onePercent == 0)) {
                    // Calls to publishProgress are reasonably expensive due to res.getString()
                    publishProgress(i * 100 / total, 0, 0);
                }
            }
            publishProgress(100, 0, 0);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        if (dupes > 0) {
            int up = update.size();
            mLog.add(getRes().getString(R.string.import_update_details, update.size(), dupes));
            if (dupesIgnored.size() > 0) {
                mLog.add(getRes().getString(R.string.import_update_ignored));
                // TODO: uncomment this and fix above string if we implement a detailed
                // log viewer dialog type.
                //mLog.addAll(dupesIgnored);
            }
        }
        // export info for calling code
        mDupes = dupes;
        mAdded = add.size();
        mUpdated = update.size();
        // add to col
        mDst.getDb().executeMany("insert or replace into notes values (?,?,?,?,?,?,?,?,?,?,?)", add);
        mDst.getDb().executeMany("insert or replace into notes values (?,?,?,?,?,?,?,?,?,?,?)", update);
        long[] das = Utils.arrayList2array(dirty);
        mDst.updateFieldCache(das);
        mDst.getTags().registerNotes(das);
    }


    // determine if note is a duplicate, and adjust mid and/or guid as required
    // returns true if note should be added
    private boolean _uniquifyNote(Object[] note) {
        String origGuid = (String) note[GUID];
        long srcMid = (Long) note[MID];
        long dstMid = _mid(srcMid);
        // duplicate Schemas?
        if (srcMid == dstMid) {
            return !mNotes.containsKey(origGuid);
        }
        // differing schemas and note doesn't exist?
        note[MID] = dstMid;
        if (!mNotes.containsKey(origGuid)) {
            return true;
        }
        // as the schemas differ and we already have a note with a different
        // note type, this note needs a new guid
        if (!mDupeOnSchemaChange) {
            return false;
        }
        while (true) {
            note[GUID] = Utils.incGuid((String) note[GUID]);
            mChangedGuids.put(origGuid, (String) note[GUID]);
            // if we don't have an existing guid, we can add
            if (!mNotes.containsKey(note[GUID])) {
                return true;
            }
            // if the existing guid shares the same mid, we can reuse
            if (dstMid == (Long) mNotes.get(note[GUID])[MID]) {
                return false;
            }
        }
    }


    /**
     * Models
     * ***********************************************************
     * Models in the two decks may share an ID but not a schema, so we need to
     * compare the field & template signature rather than just rely on ID. If
     * the schemas don't match, we increment the mid and try again, creating a
     * new model if necessary.
     */

    /** Prepare index of schema hashes. */
    private void _prepareModels() {
        mModelMap = new HashMap<>();
    }


    /** Return local id for remote MID. */
    private long _mid(long srcMid) {
        try {
            // already processed this mid?
            if (mModelMap.containsKey(srcMid)) {
                return mModelMap.get(srcMid);
            }
            long mid = srcMid;
            JSONObject srcModel = mSrc.getModels().get(srcMid);
            String srcScm = mSrc.getModels().scmhash(srcModel);
            while (true) {
                // missing from target col?
                if (!mDst.getModels().have(mid)) {
                    // copy it over
                    JSONObject model = new JSONObject(Utils.jsonToString(srcModel));
                    model.put("id", mid);
                    model.put("mod", Utils.intNow());
                    model.put("usn", mCol.usn());
                    mDst.getModels().update(model);
                    break;
                }
                // there's an existing model; do the schemas match?
                JSONObject dstModel = mDst.getModels().get(mid);
                String dstScm = mDst.getModels().scmhash(dstModel);
                if (srcScm.equals(dstScm)) {
                    // they do; we can reuse this mid
                    JSONObject model = new JSONObject(Utils.jsonToString(srcModel));
                    model.put("id", mid);
                    model.put("mod", Utils.intNow());
                    model.put("usn", mCol.usn());
                    mDst.getModels().update(model);
                    break;
                }
                // as they don't match, try next id
                mid += 1;
            }
            // save map and return new mid
            mModelMap.put(srcMid, mid);
            return mid;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Decks
     * ***********************************************************
     */

    /** Given did in src col, return local id. */
    private long _did(long did) {
        try {
            // already converted?
            if (mDecks.containsKey(did)) {
                return mDecks.get(did);
            }
            // get the name in src
            JSONObject g = mSrc.getDecks().get(did);
            String name = g.getString("name");
            // if there's a prefix, replace the top level deck
            if (!TextUtils.isEmpty(mDeckPrefix)) {
                List<String> parts = Arrays.asList(name.split("::", -1));
                String tmpname = TextUtils.join("::", parts.subList(1, parts.size()));
                name = mDeckPrefix;
                if (!TextUtils.isEmpty(tmpname)) {
                    name += "::" + tmpname;
                }
            }
            // Manually create any parents so we can pull in descriptions
            String head = "";
            List<String> parents = Arrays.asList(name.split("::", -1));
            for (String parent : parents.subList(0, parents.size() -1)) {
                if (!TextUtils.isEmpty(head)) {
                    head += "::";
                }
                head += parent;
                long idInSrc = mSrc.getDecks().id(head);
                _did(idInSrc);
            }
            // create in local
            long newid = mDst.getDecks().id(name);
            // pull conf over
            if (g.has("conf") && g.getLong("conf") != 1) {
                JSONObject conf = mSrc.getDecks().getConf(g.getLong("conf"));
                mDst.getDecks().save(conf);
                mDst.getDecks().updateConf(conf);
                JSONObject g2 = mDst.getDecks().get(newid);
                g2.put("conf", g.getLong("conf"));
                mDst.getDecks().save(g2);
            }
            // save desc
            JSONObject deck = mDst.getDecks().get(newid);
            deck.put("desc", g.getString("desc"));
            mDst.getDecks().save(deck);
            // add to deck map and return
            mDecks.put(did, newid);
            return newid;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Cards
     * ***********************************************************
     */

    private void _importCards() {
        // build map of guid -> (ord -> cid) and used id cache
        mCards = new HashMap<>();
        Map<Long, Boolean> existing = new HashMap<>();
        Cursor cur = null;
        try {
            cur = mDst.getDb().getDatabase().rawQuery(
                    "select f.guid, c.ord, c.id from cards c, notes f " +
                    "where c.nid = f.id", null);
            while (cur.moveToNext()) {
                String guid = cur.getString(0);
                int ord = cur.getInt(1);
                long cid = cur.getLong(2);
                existing.put(cid, true);
                if (mCards.containsKey(guid)) {
                    mCards.get(guid).put(ord, cid);
                } else {
                    Map<Integer, Long> map = new HashMap<>();
                    map.put(ord, cid);
                    mCards.put(guid, map);
                }
            }
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        // loop through src
        List<Object[]> cards = new ArrayList<>();
        List<Object[]> revlog = new ArrayList<>();
        int cnt = 0;
        int usn = mDst.usn();
        long aheadBy = mSrc.getSched().getToday() - mDst.getSched().getToday();
        try {
            cur = mSrc.getDb().getDatabase().rawQuery(
                    "select f.guid, f.mid, c.* from cards c, notes f " +
                    "where c.nid = f.id", null);

            // Counters for progress updates
            int total = cur.getCount();
            boolean largeCollection = total > 200;
            int onePercent = total/100;
            int i = 0;

            while (cur.moveToNext()) {
                Object[] card = new Object[] { cur.getString(0), cur.getLong(1), cur.getLong(2),
                        cur.getLong(3), cur.getLong(4), cur.getInt(5), cur.getLong(6), cur.getInt(7),
                        cur.getInt(8), cur.getInt(9), cur.getLong(10), cur.getLong(11), cur.getLong(12),
                        cur.getInt(13), cur.getInt(14), cur.getInt(15), cur.getLong(16),
                        cur.getLong(17), cur.getInt(18), cur.getString(19) };
                String guid = (String) card[0];
                if (mChangedGuids.containsKey(guid)) {
                    guid = mChangedGuids.get(guid);
                }
                if (mIgnoredGuids.containsKey(guid)) {
                    continue;
                }
                // does the card's note exist in dst col?
                if (!mNotes.containsKey(guid)) {
                    continue;
                }
                Object[] dnid = mNotes.get(guid);
                // does the card already exist in the dst col?
                int ord = (Integer) card[5];
                if (mCards.containsKey(guid) && mCards.get(guid).containsKey(ord)) {
                    // fixme: in future, could update if newer mod time
                    continue;
                }
                // doesn't exist. strip off note info, and save src id for later
                Object[] oc = card;
                card = new Object[oc.length - 2];
                System.arraycopy(oc, 2, card, 0, card.length);
                long scid = (Long) card[0];
                // ensure the card id is unique
                while (existing.containsKey(card[0])) {
                    card[0] = (Long) card[0] + 999;
                }
                existing.put((Long) card[0], true);
                // update cid, nid, etc
                card[1] = mNotes.get(guid)[0];
                card[2] = _did((Long) card[2]);
                card[4] = Utils.intNow();
                card[5] = usn;
                // review cards have a due date relative to collection
                if ((Integer) card[7] == 2 || (Integer) card[7] == 3 || (Integer) card[6] == 2) {
                    card[8] = (Long) card[8] - aheadBy;
                }
                // if odid true, convert card from filtered to normal
                if ((Long) card[15] != 0) {
                    // odid
                    card[15] = 0;
                    // odue
                    card[8] = card[14];
                    card[14] = 0;
                    // queue
                    if ((Integer) card[6] == 1) { // type
                        card[7] = 0;
                    } else {
                        card[7] = card[6];
                    }
                    // type
                    if ((Integer) card[6] == 1) {
                        card[6] = 0;
                    }
                }
                cards.add(card);
                // we need to import revlog, rewriting card ids and bumping usn
                Cursor cur2 = null;
                try {
                    cur2 = mSrc.getDb().getDatabase().rawQuery("select * from revlog where cid = " + scid, null);
                    while (cur2.moveToNext()) {
                        Object[] rev = new Object[] { cur2.getLong(0), cur2.getLong(1), cur2.getInt(2), cur2.getInt(3),
                                cur2.getLong(4), cur2.getLong(5), cur2.getLong(6), cur2.getLong(7), cur2.getInt(8) };
                        rev[1] = card[0];
                        rev[2] = mDst.usn();
                        revlog.add(rev);
                    }
                } finally {
                    if (cur2 != null) {
                        cur2.close();
                    }
                }
                cnt += 1;
                i++;
                if (total != 0 && (!largeCollection || i % onePercent == 0)) {
                    publishProgress(100, i * 100 / total, 0);
                }
            }
            publishProgress(100, 100, 0);
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
        // apply
        mDst.getDb().executeMany("insert or ignore into cards values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)", cards);
        mDst.getDb().executeMany("insert or ignore into revlog values (?,?,?,?,?,?,?,?,?)", revlog);
        mLog.add(getRes().getString(R.string.import_complete_count, cnt));
    }


    /**
     * Media
     * ***********************************************************
     */

    // note: this func only applies to imports of .anki2. For .apkg files, the
    // apkg importer does the copying
    private void _importStaticMedia() {
        // Import any '_foo' prefixed media files regardless of whether
        // they're used on notes or not
        String dir = mSrc.getMedia().dir();
        if (!new File(dir).exists()) {
            return;
        }
        for (File f : new File(dir).listFiles()) {
            String fname = f.getName();
            if (fname.startsWith("_") && ! mDst.getMedia().have(fname)) {
                _writeDstMedia(fname, _srcMediaData(fname));
            }
        }
    }


    private BufferedInputStream _mediaData(String fname) {
        return  _mediaData(fname, null);
    }


    private BufferedInputStream _mediaData(String fname, String dir) {
        if (dir == null) {
            dir = mSrc.getMedia().dir();
        }
        String path = new File(dir, fname).getAbsolutePath();
        try {
            return new BufferedInputStream(new FileInputStream(path), MEDIAPICKLIMIT * 2);
        } catch (IOException e) {
            return null;
        }
    }


    /**
     * Data for FNAME in src collection.
     */
    protected BufferedInputStream _srcMediaData(String fname) {
        return _mediaData(fname, mSrc.getMedia().dir());
    }


    /**
     * Data for FNAME in dst collection.
     */
    private BufferedInputStream _dstMediaData(String fname) {
        return _mediaData(fname, mDst.getMedia().dir());
    }


    private void _writeDstMedia(String fname, BufferedInputStream data) {
        try {
            String path = new File(mDst.getMedia().dir(), Utils.nfcNormalized(fname)).getAbsolutePath();
            Utils.writeToFile(data, path);
            // Mark file addition to media db (see note in Media.java)
            mDst.getMedia().markFileAdd(fname);
        } catch (IOException e) {
            // the user likely used subdirectories
            Timber.e(e, "Error copying file %s.", fname);
        }
    }


    // running splitFields() on every note is fairly expensive and actually not necessary
    private String _mungeMedia(long mid, String fields) {
        for (Pattern p : Media.mRegexps) {
            Matcher m = p.matcher(fields);
            StringBuffer sb = new StringBuffer();
            int fnameIdx = Media.indexOfFname(p);
            while (m.find()) {
                String fname = m.group(fnameIdx);
                BufferedInputStream srcData = _srcMediaData(fname);
                BufferedInputStream dstData = _dstMediaData(fname);
                if (srcData == null) {
                    // file was not in source, ignore
                    m.appendReplacement(sb, Matcher.quoteReplacement(m.group(0)));
                    continue;
                }
                // if model-local file exists from a previous import, use that
                String[] split = Utils.splitFilename(fname);
                String name = split[0];
                String ext = split[1];

                String lname = String.format(Locale.US, "%s_%s%s", name, mid, ext);
                if (mDst.getMedia().have(lname)) {
                    m.appendReplacement(sb, Matcher.quoteReplacement(m.group(0).replace(fname, lname)));
                    continue;
                } else if (dstData == null || compareMedia(srcData, dstData)) { // if missing or the same, pass unmodified
                    // need to copy?
                    if (dstData == null) {
                        _writeDstMedia(fname, srcData);
                    }
                    m.appendReplacement(sb, Matcher.quoteReplacement(m.group(0)));
                    continue;
                }
                // exists but does not match, so we need to dedupe
                _writeDstMedia(lname, srcData);
                m.appendReplacement(sb, Matcher.quoteReplacement(m.group(0).replace(fname, lname)));
            }
            m.appendTail(sb);
            fields = sb.toString();
        }
        return fields;
    }


    /**
     * Post-import cleanup
     * ***********************************************************
     */

    private void _postImport() {
        try {
            for (long did : mDecks.values()) {
                mCol.getSched().maybeRandomizeDeck(did);
            }
            // make sure new position is correct
            mDst.getConf().put("nextPos", mDst.getDb().queryLongScalar(
                    "select max(due)+1 from cards where type = 0"));
            mDst.save();
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * The methods below are not in LibAnki.
     * ***********************************************************
     */


    private boolean compareMedia(BufferedInputStream lhis, BufferedInputStream rhis) {
        byte[] lhbytes = _mediaPick(lhis);
        byte[] rhbytes = _mediaPick(rhis);
        return Arrays.equals(lhbytes, rhbytes);
    }


    /**
     * Return the contents of the given input stream, limited to Anki2Importer.MEDIAPICKLIMIT bytes This is only used
     * for comparison of media files with the limited resources of mobile devices
     */
    byte[] _mediaPick(BufferedInputStream is) {
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream(MEDIAPICKLIMIT * 2);
            byte[] buf = new byte[MEDIAPICKLIMIT];
            int readLen;
            int readSoFar = 0;
            is.mark(MEDIAPICKLIMIT * 2);
            while (true) {
                readLen = is.read(buf);
                baos.write(buf);
                if (readLen == -1) {
                    break;
                }
                readSoFar += readLen;
                if (readSoFar > MEDIAPICKLIMIT) {
                    break;
                }
            }
            is.reset();
            byte[] result = new byte[MEDIAPICKLIMIT];
            System.arraycopy(baos.toByteArray(), 0, result, 0, Math.min(baos.size(), MEDIAPICKLIMIT));
            return result;
        } catch (FileNotFoundException e) {
            return null;
        } catch (IOException e) {
            return null;
        }
    }


    /**
     * @param notesDone Percentage of notes complete.
     * @param cardsDone Percentage of cards complete.
     * @param postProcess Percentage of remaining tasks complete.
     */
    protected void publishProgress(int notesDone, int cardsDone, int postProcess) {
        String checkmark = "\u2714";
        if (mProgress != null) {
            mProgress.publishProgress(new DeckTask.TaskData(getRes().getString(R.string.import_progress,
                    notesDone, cardsDone, postProcess)));
        }
    }


    /* The methods below are only used for testing. */

    public void setDupeOnSchemaChange(boolean b) {
        mDupeOnSchemaChange = b;
    }


    public int getDupes() {
        return mDupes;
    }


    public int getAdded() {
        return mAdded;
    }


    public int getUpdated() {
        return mUpdated;
    }
}/***************************************************************************************
  * Copyright (c) 2016 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.importer;


import com.google.gson.stream.JsonReader;
import com.ichi2.anki.BackupManager;
import com.ichi2.anki.R;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Storage;
import com.ichi2.libanki.Utils;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.zip.ZipFile;

import timber.log.Timber;


public class AnkiPackageImporter extends Anki2Importer {

    private ZipFile mZip;
    private Map<String, String> mNameToNum;

    public AnkiPackageImporter(Collection col, String file) {
        super(col, file);
    }

    @Override
    public void run() {
        publishProgress(0, 0, 0);
        File tempDir = new File(new File(mCol.getPath()).getParent(), "tmpzip");
        Collection tmpCol;
        try {
            // We extract the zip contents into a temporary directory and do a little more
            // validation than the desktop client to ensure the extracted collection is an apkg.
            try {
                // extract the deck from the zip file
                mZip = new ZipFile(new File(mFile), ZipFile.OPEN_READ);
                Utils.unzipFiles(mZip, tempDir.getAbsolutePath(), new String[]{"collection.anki2", "media"}, null);
            } catch (IOException e) {
                Timber.e(e, "Failed to unzip apkg.");
                mLog.add(getRes().getString(R.string.import_log_no_apkg));
                return;
            }
            String colpath = new File(tempDir, "collection.anki2").getAbsolutePath();
            if (!(new File(colpath)).exists()) {
                mLog.add(getRes().getString(R.string.import_log_no_apkg));
                return;
            }
            tmpCol = Storage.Collection(mContext, colpath);
            try {
                if (!tmpCol.validCollection()) {
                    mLog.add(getRes().getString(R.string.import_log_no_apkg));
                    return;
                }
            } finally {
                if (tmpCol != null) {
                    tmpCol.close();
                }
            }
            mFile = colpath;
            // we need the media dict in advance, and we'll need a map of fname ->
            // number to use during the import
            File mediaMapFile = new File(tempDir, "media");
            mNameToNum = new HashMap<>();
            // We need the opposite mapping in AnkiDroid since our extraction method requires it.
            Map<String, String> numToName = new HashMap<>();
            try {
                JsonReader jr = new JsonReader(new FileReader(mediaMapFile));
                jr.beginObject();
                String name;
                String num;
                while (jr.hasNext()) {
                    num = jr.nextName();
                    name = jr.nextString();
                    mNameToNum.put(name, num);
                    numToName.put(num, name);
                }
                jr.endObject();
                jr.close();
            } catch (FileNotFoundException e) {
                Timber.e("Apkg did not contain a media dict. No media will be imported.");
            } catch (IOException e) {
                Timber.e("Malformed media dict. Media import will be incomplete.");
            }
            // run anki2 importer
            super.run();
            // import static media
            for (Map.Entry<String, String> entry : mNameToNum.entrySet()) {
                String file = entry.getKey();
                String c = entry.getValue();
                if (!file.startsWith("_") && !file.startsWith("latex-")) {
                    continue;
                }
                File path = new File(mCol.getMedia().dir(), Utils.nfcNormalized(file));
                if (!path.exists()) {
                    try {
                        Utils.unzipFiles(mZip, mCol.getMedia().dir(), new String[]{c}, numToName);
                    } catch (IOException e) {
                        Timber.e("Failed to extract static media file. Ignoring.");
                    }
                }
            }
        } finally {
            // Clean up our temporary files
            if (tempDir.exists()) {
                BackupManager.removeDir(tempDir);
            }
        }
        publishProgress(100, 100, 100);
    }

    @Override
    protected BufferedInputStream _srcMediaData(String fname) {
        if (mNameToNum.containsKey(fname)) {
            try {
                return new BufferedInputStream(mZip.getInputStream(mZip.getEntry(mNameToNum.get(fname))));
            } catch (IOException e) {
                Timber.e("Could not extract media file " + fname + "from zip file.");
            }
        }
        return null;
    }
}
/***************************************************************************************
 * Copyright (c) 2016 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.importer;


import android.content.Context;
import android.content.res.Resources;

import com.ichi2.async.DeckTask;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Utils;

import java.util.ArrayList;
import java.util.List;

public abstract class Importer {

    protected boolean mNeedMapper = false;
    protected boolean mNeedDelimiter = false;
    protected String mFile;
    protected List<String> mLog;
    protected Collection mCol;
    protected int mTotal;

    private long mTs;
    protected Collection mDst;
    protected Collection mSrc;

    protected Context mContext;
    protected DeckTask.ProgressCallback mProgress;

    public Importer(Collection col, String file) {
        mFile = file;
        mLog = new ArrayList<>();
        mCol = col;
        mTotal = 0;
        mContext = col.getContext();
    }

    abstract public void run();

    /**
     * Timestamps
     * ***********************************************************
     * It's too inefficient to check for existing ids on every object,
     * and a previous import may have created timestamps in the future, so we
     * need to make sure our starting point is safe.
     */

    protected void _prepareTS() {
        mTs = Utils.maxID(mDst.getDb());
    }


    protected long ts() {
        mTs++;
        return mTs;
    }


    /**
     * The methods below are not in LibAnki.
     * ***********************************************************
     */

    public void setProgressCallback(DeckTask.ProgressCallback progressCallback) {
        mProgress = progressCallback;
    }


    protected Resources getRes() {
        return mContext.getResources();
    }

    public List<String> getLog() {
        return mLog;
    }
}
package com.ichi2.libanki.importer;

import com.ichi2.libanki.Collection;

/**
 * This class is a stub. Nothing is implemented yet.
 */
public class NoteImporter extends Importer {
    public NoteImporter(Collection col, String file) {
        super(col, file);
    }

    @Override
    public void run() {

    }

    public int getTotal() {
        return mTotal;
    }
}
package com.ichi2.libanki.importer;

import com.ichi2.libanki.Collection;

/**
 * This class is a stub. Nothing is implemented yet.
 */
public class TextImporter extends NoteImporter {

    public TextImporter(Collection col, String file) {
        super(col, file);
    }

    @Override
    public void run() {

    }

    public void initMapping() {

    }

    public void setImportMode(int mode) {

    }
}
/***************************************************************************************
 * Copyright (c) 2012 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.sync;

import android.content.SharedPreferences;
import android.database.sqlite.SQLiteDatabaseCorruptException;
import android.net.Uri;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.CollectionHelper;
import com.ichi2.anki.R;
import com.ichi2.anki.exception.UnknownHttpResponseException;
import com.ichi2.async.Connection;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Consts;
import com.ichi2.libanki.DB;
import com.ichi2.libanki.Utils;
import com.ichi2.utils.VersionUtils;

import org.apache.http.HttpResponse;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Locale;

import timber.log.Timber;

public class FullSyncer extends HttpSyncer {

    Collection mCol;
    Connection mCon;


    public FullSyncer(Collection col, String hkey, Connection con) {
        super(hkey, con);
        mPostVars = new HashMap<>();
        mPostVars.put("k", hkey);
        mPostVars.put("v",
                String.format(Locale.US, "ankidroid,%s,%s", VersionUtils.getPkgVersionName(), Utils.platDesc()));
        mCol = col;
        mCon = con;
    }


    @Override
    public String syncURL() {
        // Allow user to specify custom sync server
        SharedPreferences userPreferences = AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance());
        if (userPreferences!= null && userPreferences.getBoolean("useCustomSyncServer", false)) {
            Uri syncBase = Uri.parse(userPreferences.getString("syncBaseUrl", Consts.SYNC_BASE));
            return syncBase.buildUpon().appendPath("sync").toString() + "/";
        }
        // Usual case
        return Consts.SYNC_BASE + "sync/";
    }


    @Override
    public Object[] download() throws UnknownHttpResponseException {
        InputStream cont;
        try {
            HttpResponse ret = super.req("download");
            if (ret == null) {
                return null;
            }
            cont = ret.getEntity().getContent();
        } catch (IllegalStateException e1) {
            throw new RuntimeException(e1);
        } catch (IOException e1) {
            return null;
        }
        String path;
        if (mCol != null) {
            // Usual case where collection is non-null
            path = mCol.getPath();
            mCol.close();
            mCol = null;
        } else {
            // Allow for case where collection is completely unreadable
            Timber.w("Collection was unexpectedly null when doing full sync download");
            path = CollectionHelper.getCollectionPath(AnkiDroidApp.getInstance());
        }
        String tpath = path + ".tmp";
        try {
            super.writeToFile(cont, tpath);
            FileInputStream fis = new FileInputStream(tpath);
            if (super.stream2String(fis, 15).equals("upgradeRequired")) {
                return new Object[]{"upgradeRequired"};
            }
        } catch (FileNotFoundException e) {
            Timber.e(e, "Failed to create temp file when downloading collection.");
            throw new RuntimeException(e);
        } catch (IOException e) {
            Timber.e(e, "Full sync failed to download collection.");
            return new Object[] { "sdAccessError" };
        }

        // check the received file is ok
        mCon.publishProgress(R.string.sync_check_download_file);
        DB tempDb = null;
        try {
            tempDb = new DB(tpath);
            if (!tempDb.queryString("PRAGMA integrity_check").equalsIgnoreCase("ok")) {
                Timber.e("Full sync - downloaded file corrupt");
                return new Object[] { "remoteDbError" };
            }
        } catch (SQLiteDatabaseCorruptException e) {
            Timber.e("Full sync - downloaded file corrupt");
            return new Object[] { "remoteDbError" };
        } finally {
            if (tempDb != null) {
                tempDb.close();
            }
        }
        // overwrite existing collection
        File newFile = new File(tpath);
        if (newFile.renameTo(new File(path))) {
            return new Object[] { "success" };
        } else {
            return new Object[] { "overwriteError" };
        }
    }


    @Override
    public Object[] upload() throws UnknownHttpResponseException {
        // make sure it's ok before we try to upload
        mCon.publishProgress(R.string.sync_check_upload_file);
        if (!mCol.getDb().queryString("PRAGMA integrity_check").equalsIgnoreCase("ok")) {
            return new Object[] { "dbError" };
        }
        if (!mCol.basicCheck()) {
            return new Object[] { "dbError" };
        }
        // apply some adjustments, then upload
        mCol.beforeUpload();
        String filePath = mCol.getPath();
        HttpResponse ret;
        mCon.publishProgress(R.string.sync_uploading_message);
        try {
            ret = super.req("upload", new FileInputStream(filePath));
            if (ret == null) {
                return null;
            }
            int status = ret.getStatusLine().getStatusCode();
            if (status != 200) {
                // error occurred
                return new Object[] { "error", status, ret.getStatusLine().getReasonPhrase() };
            } else {
                return new Object[] { super.stream2String(ret.getEntity().getContent()) };
            }
        } catch (IllegalStateException | IOException e) {
            throw new RuntimeException(e);
        }
    }
}
/***************************************************************************************
 * Copyright (c) 2012 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 * Copyright (c) 2014 Timothy Rae <perceptualchaos2@gmail.com>
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.sync;



import android.content.SharedPreferences;
import android.net.Uri;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.exception.UnknownHttpResponseException;
import com.ichi2.async.Connection;
import com.ichi2.libanki.Consts;
import com.ichi2.libanki.Utils;
import com.ichi2.utils.VersionUtils;

import org.apache.commons.httpclient.contrib.ssl.EasySSLSocketFactory;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.HttpVersion;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.conn.params.ConnManagerPNames;
import org.apache.http.conn.params.ConnPerRouteBean;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.entity.AbstractHttpEntity;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.CoreProtocolPNames;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpProtocolParams;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Random;
import java.util.zip.GZIPOutputStream;

import javax.net.ssl.SSLException;

import timber.log.Timber;

/**
 * # HTTP syncing tools
 * Calling code should catch the following codes:
 * - 501: client needs upgrade
 * - 502: ankiweb down
 * - 503/504: server too busy
 */
public class HttpSyncer {

    private static final String BOUNDARY = "Anki-sync-boundary";
    public static final String ANKIWEB_STATUS_OK = "OK";

    public volatile long bytesSent = 0;
    public volatile long bytesReceived = 0;
    public volatile long mNextSendS = 1024;
    public volatile long mNextSendR = 1024;

    /**
     * Synchronization.
     */

    protected String mHKey;
    protected String mSKey;
    protected Connection mCon;
    protected Map<String, Object> mPostVars;


    public HttpSyncer(String hkey, Connection con) {
        mHKey = hkey;
        mSKey = Utils.checksum(Float.toString(new Random().nextFloat())).substring(0, 8);
        mCon = con;
        mPostVars = new HashMap<>();
    }


    public void assertOk(HttpResponse resp) throws UnknownHttpResponseException {
        // Throw RuntimeException if HTTP error
        if (resp == null) {
            throw new UnknownHttpResponseException("Null HttpResponse", -2);
        }
        int resultCode = resp.getStatusLine().getStatusCode();
        if (!(resultCode == 200 || resultCode == 403)) {
            String reason = resp.getStatusLine().getReasonPhrase();
            throw new UnknownHttpResponseException(reason, resultCode);
        }
    }


    public HttpResponse req(String method) throws UnknownHttpResponseException {
        return req(method, null);
    }


    public HttpResponse req(String method, InputStream fobj) throws UnknownHttpResponseException {
        return req(method, fobj, 6);
    }


    public HttpResponse req(String method, int comp, InputStream fobj) throws UnknownHttpResponseException {
        return req(method, fobj, comp);
    }


    public HttpResponse req(String method, InputStream fobj, int comp) throws UnknownHttpResponseException {
        return req(method, fobj, comp, null);
    }


    public HttpResponse req(String method, InputStream fobj, int comp, JSONObject registerData) throws UnknownHttpResponseException {
        return req(method, fobj, comp, registerData, null) ;
    }


    public HttpResponse req(String method, InputStream fobj, int comp, JSONObject registerData,
            Connection.CancelCallback cancelCallback) throws UnknownHttpResponseException {
        File tmpFileBuffer = null;
        try {
            String bdry = "--" + BOUNDARY;
            StringWriter buf = new StringWriter();
            // post vars
            mPostVars.put("c", comp != 0 ? 1 : 0);
            for (String key : mPostVars.keySet()) {
                buf.write(bdry + "\r\n");
                buf.write(String.format(Locale.US, "Content-Disposition: form-data; name=\"%s\"\r\n\r\n%s\r\n", key,
                        mPostVars.get(key)));
            }
            tmpFileBuffer = File.createTempFile("syncer", ".tmp", new File(AnkiDroidApp.getCacheStorageDirectory()));
            FileOutputStream fos = new FileOutputStream(tmpFileBuffer);
            BufferedOutputStream bos = new BufferedOutputStream(fos);
            GZIPOutputStream tgt;
            // payload as raw data or json
            if (fobj != null) {
                // header
                buf.write(bdry + "\r\n");
                buf.write("Content-Disposition: form-data; name=\"data\"; filename=\"data\"\r\nContent-Type: application/octet-stream\r\n\r\n");
                buf.close();
                bos.write(buf.toString().getBytes("UTF-8"));
                // write file into buffer, optionally compressing
                int len;
                BufferedInputStream bfobj = new BufferedInputStream(fobj);
                byte[] chunk = new byte[65536];
                if (comp != 0) {
                    tgt = new GZIPOutputStream(bos);
                    while ((len = bfobj.read(chunk)) >= 0) {
                        tgt.write(chunk, 0, len);
                    }
                    tgt.close();
                    bos = new BufferedOutputStream(new FileOutputStream(tmpFileBuffer, true));
                } else {
                    while ((len = bfobj.read(chunk)) >= 0) {
                        bos.write(chunk, 0, len);
                    }
                }
                bos.write(("\r\n" + bdry + "--\r\n").getBytes("UTF-8"));
            } else {
                buf.close();
                bos.write(buf.toString().getBytes("UTF-8"));
            }
            bos.flush();
            bos.close();
            // connection headers
            String url = Consts.SYNC_BASE;
            if (method.equals("register")) {
                url = url + "account/signup" + "?username=" + registerData.getString("u") + "&password="
                        + registerData.getString("p");
            } else if (method.startsWith("upgrade")) {
                url = url + method;
            } else {
                url = syncURL() + method;
            }
            HttpPost httpPost = new HttpPost(url);
            HttpEntity entity = new ProgressByteEntity(tmpFileBuffer);

            // body
            httpPost.setEntity(entity);
            httpPost.setHeader("Content-type", "multipart/form-data; boundary=" + BOUNDARY);

            // HttpParams
            HttpParams params = new BasicHttpParams();
            params.setParameter(ConnManagerPNames.MAX_TOTAL_CONNECTIONS, 30);
            params.setParameter(ConnManagerPNames.MAX_CONNECTIONS_PER_ROUTE, new ConnPerRouteBean(30));
            params.setParameter(CoreProtocolPNames.USE_EXPECT_CONTINUE, false);
            params.setParameter(CoreProtocolPNames.USER_AGENT, "AnkiDroid-" + VersionUtils.getPkgVersionName());
            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
            HttpConnectionParams.setSoTimeout(params, Connection.CONN_TIMEOUT);

            // Registry
            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
            registry.register(new Scheme("https", new EasySSLSocketFactory(), 443));
            ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(params, registry);
            if (cancelCallback != null) {
                cancelCallback.setConnectionManager(cm);
            }

            try {
                HttpClient httpClient = new DefaultHttpClient(cm, params);
                HttpResponse httpResponse = httpClient.execute(httpPost);
                // we assume badAuthRaises flag from Anki Desktop always False
                // so just throw new RuntimeException if response code not 200 or 403
                assertOk(httpResponse);
                return httpResponse;
            } catch (SSLException e) {
                Timber.e(e, "SSLException while building HttpClient");
                throw new RuntimeException("SSLException while building HttpClient");
            }
        } catch (UnsupportedEncodingException | JSONException e) {
            throw new RuntimeException(e);
        } catch (IOException e) {
            Timber.e(e, "BasicHttpSyncer.sync: IOException");
            throw new RuntimeException(e);
        } finally {
            if (tmpFileBuffer != null && tmpFileBuffer.exists()) {
                tmpFileBuffer.delete();
            }
        }
    }


    public void writeToFile(InputStream source, String destination) throws IOException {
        File file = new File(destination);
        OutputStream output = null;
        try {
            file.createNewFile();
            output = new BufferedOutputStream(new FileOutputStream(file));
            byte[] buf = new byte[Utils.CHUNK_SIZE];
            int len;
            while ((len = source.read(buf)) >= 0) {
                output.write(buf, 0, len);
                bytesReceived += len;
                publishProgress();
            }
        } catch (IOException e) {
            if (file.exists()) {
                // Don't keep the file if something went wrong. It'll be corrupt.
                file.delete();
            }
            // Re-throw so we know what the error was.
            throw e;
        } finally {
            if (output != null) {
                output.close();
            }
        }
    }


    public String stream2String(InputStream stream) {
        return stream2String(stream, -1);
    }


    public String stream2String(InputStream stream, int maxSize) {
        BufferedReader rd;
        try {
            rd = new BufferedReader(new InputStreamReader(stream, "UTF-8"), maxSize == -1 ? 4096 : Math.min(4096,
                    maxSize));
            String line;
            StringBuilder sb = new StringBuilder();
            while ((line = rd.readLine()) != null && (maxSize == -1 || sb.length() < maxSize)) {
                sb.append(line);
                bytesReceived += line.length();
                publishProgress();
            }
            rd.close();
            return sb.toString();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }


    private void publishProgress() {
        if (mCon != null && (mNextSendR <= bytesReceived || mNextSendS <= bytesSent)) {
            long bR = bytesReceived;
            long bS = bytesSent;
            mNextSendR = (bR / 1024 + 1) * 1024;
            mNextSendS = (bS / 1024 + 1) * 1024;
            mCon.publishProgress(0, bS, bR);
        }
    }


    public HttpResponse hostKey(String arg1, String arg2) throws UnknownHttpResponseException {
        return null;
    }


    public JSONObject applyChanges(JSONObject kw) throws UnknownHttpResponseException {
        return null;
    }


    public JSONObject start(JSONObject kw) throws UnknownHttpResponseException {
        return null;
    }


    public JSONObject chunk(JSONObject kw) throws UnknownHttpResponseException {
        return null;
    }


    public JSONObject chunk() throws UnknownHttpResponseException {
        return null;
    }


    public long finish() throws UnknownHttpResponseException {
        return 0;
    }

    public void abort() throws UnknownHttpResponseException {
    }


    public HttpResponse meta() throws UnknownHttpResponseException {
        return null;
    }


    public Object[] download() throws UnknownHttpResponseException {
        return null;
    }


    public Object[] upload() throws UnknownHttpResponseException {
        return null;
    }


    public JSONObject sanityCheck2(JSONObject client) throws UnknownHttpResponseException {
        return null;
    }


    public void applyChunk(JSONObject sech) throws UnknownHttpResponseException {
    }

    public class ProgressByteEntity extends AbstractHttpEntity {

        private InputStream mInputStream;
        private long mLength;


        public ProgressByteEntity(File file) {
            super();
            mLength = file.length();
            try {
                mInputStream = new BufferedInputStream(new FileInputStream(file));
            } catch (FileNotFoundException e) {
                throw new RuntimeException(e);
            }
        }


        @Override
        public void writeTo(OutputStream outstream) throws IOException {
            try {
                byte[] tmp = new byte[4096];
                int len;
                while ((len = mInputStream.read(tmp)) != -1) {
                    outstream.write(tmp, 0, len);
                    bytesSent += len;
                    publishProgress();
                }
                outstream.flush();
            } finally {
                mInputStream.close();
            }
        }


        @Override
        public InputStream getContent() throws IOException, IllegalStateException {
            return mInputStream;
        }


        @Override
        public long getContentLength() {
            return mLength;
        }


        @Override
        public boolean isRepeatable() {
            return false;
        }


        @Override
        public boolean isStreaming() {
            return false;
        }
    }


    public static ByteArrayInputStream getInputStream(String string) {
        try {
            return new ByteArrayInputStream(string.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
            Timber.e(e, "HttpSyncer: error on getting bytes from string");
            return null;
        }
    }


    public HttpResponse register(String user, String pw) throws UnknownHttpResponseException {
        return null;
    }


    public String syncURL() {
        // Allow user to specify custom sync server
        SharedPreferences userPreferences = AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance());
        if (userPreferences!= null && userPreferences.getBoolean("useCustomSyncServer", false)) {
            Uri syncBase = Uri.parse(userPreferences.getString("syncBaseUrl", Consts.SYNC_BASE));
            return syncBase.buildUpon().appendPath("sync").toString() + "/";
        }
        // Usual case
        return Consts.SYNC_BASE + "sync/";
    }
}


/****************************************************************************************
 * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 * Copyright (c) 2014 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.sync;

import android.text.TextUtils;
import android.util.Pair;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.R;
import com.ichi2.anki.exception.MediaSyncException;
import com.ichi2.anki.exception.UnknownHttpResponseException;
import com.ichi2.async.Connection;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Consts;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.zip.ZipFile;

import timber.log.Timber;

/**
 * About conflicts:
 * - to minimize data loss, if both sides are marked for sending and one
 *   side has been deleted, favour the add
 * - if added/changed on both sides, favour the server version on the
 *   assumption other syncers are in sync with the server
 * 
 * A note about differences to the original python version of this class. We found that:
 *  1 - There is no reliable way to detect changes to the media directory on Android due to the
 *      file systems used (mainly FAT32 for sdcards) and the utilities available to probe them.
 *  2 - Scanning for media changes can take a very long time with thousands of files.
 * 
 * Given these two points, we have decided to avoid the call to findChanges() on every sync and
 * only do it on the first sync to build the initial database. Changes to the media collection
 * made through AnkiDroid (e.g., multimedia note editor, media check) are recorded directly in
 * the media database as they are made. This allows us to skip finding media changes entirely
 * as the database already contains the changes.
 * 
 * The downside to this approach is that changes made to the media directory externally (e.g.,
 * through a file manager) will not be recorded and will not be synced. In this case, the user
 * must issue a media check command through the UI to bring the database up-to-date.
 */
public class MediaSyncer {
    private Collection mCol;
    private RemoteMediaServer mServer;
    private int mDownloadCount;
    // Needed to update progress to UI
    private Connection mCon;

    public MediaSyncer(Collection col, RemoteMediaServer server, Connection con) {
        mCol = col;
        mServer = server;
        mCon = con;
    }


    public String sync() throws UnknownHttpResponseException, MediaSyncException {
        try {
            // check if there have been any changes
            // If we haven't built the media db yet, do so on this sync. See note at the top
            // of this class about this difference to the original.
            if (mCol.getMedia().needScan()) {
                mCon.publishProgress(R.string.sync_media_find);
                mCol.log("findChanges");
                mCol.getMedia().findChanges();
            }

            // begin session and check if in sync
            int lastUsn = mCol.getMedia().lastUsn();
            JSONObject ret = mServer.begin();
            int srvUsn = ret.getInt("usn");
            if ((lastUsn == srvUsn) && !(mCol.getMedia().haveDirty())) {
                return "noChanges";
            }
            // loop through and process changes from server
            mCol.log("last local usn is " + lastUsn);
            mDownloadCount = 0;
            while (true) {
                // Allow cancellation (note: media sync has no finish command, so just throw)
                if (Connection.getIsCancelled()) {
                    Timber.i("Sync was cancelled");
                    throw new RuntimeException("UserAbortedSync");
                }
                JSONArray data = mServer.mediaChanges(lastUsn);
                mCol.log("mediaChanges resp count: ", data.length());
                if (data.length() == 0) {
                    break;
                }

                List<String> need = new ArrayList<>();
                lastUsn = data.getJSONArray(data.length()-1).getInt(1);
                for (int i = 0; i < data.length(); i++) {
                    // Allow cancellation (note: media sync has no finish command, so just throw)
                    if (Connection.getIsCancelled()) {
                        Timber.i("Sync was cancelled");
                        throw new RuntimeException("UserAbortedSync");
                    }
                    String fname = data.getJSONArray(i).getString(0);
                    int rusn = data.getJSONArray(i).getInt(1);
                    String rsum = null;
                    if (!data.getJSONArray(i).isNull(2)) {
                        // If `rsum` is a JSON `null` value, `.optString(2)` will
                        // return `"null"` as a string
                        rsum = data.getJSONArray(i).optString(2);
                    }
                    Pair<String, Integer> info = mCol.getMedia().syncInfo(fname);
                    String lsum = info.first;
                    int ldirty = info.second;
                    mCol.log(String.format(Locale.US,
                            "check: lsum=%s rsum=%s ldirty=%d rusn=%d fname=%s",
                            TextUtils.isEmpty(lsum) ? "" : lsum.subSequence(0, 4),
                            TextUtils.isEmpty(rsum) ? "" : rsum.subSequence(0, 4),
                            ldirty,
                            rusn,
                            fname));

                    if (!TextUtils.isEmpty(rsum)) {
                        // added/changed remotely
                        if (TextUtils.isEmpty(lsum) || !lsum.equals(rsum)) {
                            mCol.log("will fetch");
                            need.add(fname);
                        } else {
                            mCol.log("have same already");
                        }
                        mCol.getMedia().markClean(Collections.singletonList(fname));
                        
                    } else if (!TextUtils.isEmpty(lsum)) {
                        // deleted remotely
                        if (ldirty == 0) {
                            mCol.log("delete local");
                            mCol.getMedia().syncDelete(fname);
                        } else {
                            // conflict: local add overrides remote delete
                            mCol.log("conflict; will send");
                        }
                    } else {
                        // deleted both sides
                        mCol.log("both sides deleted");
                        mCol.getMedia().markClean(Collections.singletonList(fname));
                    }
                }
                _downloadFiles(need);

                mCol.log("update last usn to " + lastUsn);
                mCol.getMedia().setLastUsn(lastUsn); // commits
            }

            // at this point, we're all up to date with the server's changes,
            // and we need to send our own

            boolean updateConflict = false;
            int toSend = mCol.getMedia().dirtyCount();
            while (true) {
                Pair<File, List<String>> changesZip = mCol.getMedia().mediaChangesZip();
                File zip = changesZip.first;
                try {
                    List<String> fnames = changesZip.second;
                    if (fnames.size() == 0) {
                        break;
                    }

                    mCon.publishProgress(String.format(
                            AnkiDroidApp.getAppResources().getString(R.string.sync_media_changes_count), toSend));

                    JSONArray changes = mServer.uploadChanges(zip);
                    int processedCnt = changes.getInt(0);
                    int serverLastUsn = changes.getInt(1);
                    mCol.getMedia().markClean(fnames.subList(0, processedCnt));

                    mCol.log(String.format(Locale.US,
                            "processed %d, serverUsn %d, clientUsn %d",
                            processedCnt, serverLastUsn, lastUsn));

                    if (serverLastUsn - processedCnt == lastUsn) {
                        mCol.log("lastUsn in sync, updating local");
                        lastUsn = serverLastUsn;
                        mCol.getMedia().setLastUsn(serverLastUsn); // commits
                    } else {
                        mCol.log("concurrent update, skipping usn update");
                        // commit for markClean
                        mCol.getMedia().getDb().commit();
                        updateConflict = true;
                    }

                    toSend -= processedCnt;
                } finally {
                    zip.delete();
                }
            }
            if (updateConflict) {
                mCol.log("restart sync due to concurrent update");
                return sync();
            }

            int lcnt = mCol.getMedia().mediacount();
            String sRet = mServer.mediaSanity(lcnt);
            if (sRet.equals("OK")) {
                return "OK";
            } else {
                mCol.getMedia().forceResync();
                return sRet;
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    private void _downloadFiles(List<String> fnames) {
        mCol.log(fnames.size() + " files to fetch");
        while (fnames.size() > 0) {
            try {
                List<String> top = fnames.subList(0, Math.min(fnames.size(), Consts.SYNC_ZIP_COUNT));
                mCol.log("fetch " + top);
                ZipFile zipData = mServer.downloadFiles(top);
                int cnt = mCol.getMedia().addFilesFromZip(zipData);
                mDownloadCount += cnt;
                mCol.log("received " + cnt + " files");
                // NOTE: The python version uses slices which return an empty list when indexed beyond what
                // the list contains. Since we can't slice out an empty sublist in Java, we must check
                // if we've reached the end and clear the fnames list manually.
                if (cnt == fnames.size()) {
                    fnames.clear();
                } else {
                    fnames = fnames.subList(cnt, fnames.size());
                }
                mCon.publishProgress(String.format(
                        AnkiDroidApp.getAppResources().getString(R.string.sync_media_downloaded_count), mDownloadCount));
            } catch (IOException | UnknownHttpResponseException e) {
                Timber.e(e, "Error downloading media files");
                throw new RuntimeException(e);
            }
        }
    }
}
/****************************************************************************************
 * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 * Copyright (c) 2014 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.sync;

import android.content.SharedPreferences;
import android.net.Uri;
import android.text.TextUtils;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.exception.MediaSyncException;
import com.ichi2.anki.exception.UnknownHttpResponseException;
import com.ichi2.async.Connection;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Consts;
import com.ichi2.libanki.Utils;
import com.ichi2.utils.VersionUtils;

import org.apache.http.HttpResponse;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.zip.ZipFile;

import timber.log.Timber;

public class RemoteMediaServer extends HttpSyncer {

    private Collection mCol;


    public RemoteMediaServer(Collection col, String hkey, Connection con) {
        super(hkey, con);
        mCol = col;
    }


    @Override
    public String syncURL() {
        // Allow user to specify custom sync server
        SharedPreferences userPreferences = AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance());
        if (userPreferences!= null && userPreferences.getBoolean("useCustomSyncServer", false)) {
            Uri mediaSyncBase = Uri.parse(userPreferences.getString("syncMediaUrl", Consts.SYNC_MEDIA_BASE));
            return mediaSyncBase.toString() + "/";
        }
        // Usual case
        return Consts.SYNC_MEDIA_BASE;
    }


    public JSONObject begin() throws UnknownHttpResponseException, MediaSyncException {
        try {
            mPostVars = new HashMap<>();
            mPostVars.put("k", mHKey);
            mPostVars.put("v",
                    String.format(Locale.US, "ankidroid,%s,%s", VersionUtils.getPkgVersionName(), Utils.platDesc()));

            HttpResponse resp = super.req("begin", super.getInputStream(Utils.jsonToString(new JSONObject())));
            JSONObject jresp = new JSONObject(super.stream2String(resp.getEntity().getContent()));
            JSONObject ret = _dataOnly(jresp, JSONObject.class);
            mSKey = ret.getString("sk");
            return ret;
        } catch (JSONException | IOException e) {
            throw new RuntimeException(e);
        }
    }


    // args: lastUsn
    public JSONArray mediaChanges(int lastUsn) throws UnknownHttpResponseException, MediaSyncException {
        try {
            mPostVars = new HashMap<>();
            mPostVars.put("sk", mSKey);

            HttpResponse resp = super.req("mediaChanges",
                    super.getInputStream(Utils.jsonToString(new JSONObject().put("lastUsn", lastUsn))));
            JSONObject jresp = new JSONObject(super.stream2String(resp.getEntity().getContent()));
            return _dataOnly(jresp, JSONArray.class);
        } catch (JSONException | IOException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * args: files
     * <br>
     * This method returns a ZipFile with the OPEN_DELETE flag, ensuring that the file on disk will
     * be automatically deleted when the stream is closed.
     */
    public ZipFile downloadFiles(List<String> top) throws UnknownHttpResponseException {
        try {
            HttpResponse resp;
            resp = super.req("downloadFiles",
                    super.getInputStream(Utils.jsonToString(new JSONObject().put("files", new JSONArray(top)))));
            String zipPath = mCol.getPath().replaceFirst("collection\\.anki2$", "tmpSyncFromServer.zip");
            // retrieve contents and save to file on disk:
            super.writeToFile(resp.getEntity().getContent(), zipPath);
            return new ZipFile(new File(zipPath), ZipFile.OPEN_READ | ZipFile.OPEN_DELETE);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        } catch (IOException e) {
            Timber.e(e, "Failed to download requested media files");
            throw new RuntimeException(e);
        }
    }


    public JSONArray uploadChanges(File zip) throws UnknownHttpResponseException, MediaSyncException {
        try {
            // no compression, as we compress the zip file instead
            HttpResponse resp = super.req("uploadChanges", new FileInputStream(zip), 0);
            JSONObject jresp = new JSONObject(super.stream2String(resp.getEntity().getContent()));
            return _dataOnly(jresp, JSONArray.class);
        } catch (JSONException | IOException e) {
            throw new RuntimeException(e);
        }
    }


    // args: local
    public String mediaSanity(int lcnt) throws UnknownHttpResponseException, MediaSyncException {
        try {
            HttpResponse resp = super.req("mediaSanity",
                    super.getInputStream(Utils.jsonToString(new JSONObject().put("local", lcnt))));
            JSONObject jresp = new JSONObject(super.stream2String(resp.getEntity().getContent()));
            return _dataOnly(jresp, String.class);
        } catch (JSONException | IOException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Returns the "data" element from the JSON response from the server, or throws an exception if there is a value in
     * the "err" element.
     * <p>
     * The python counterpart to this method is flexible with type coercion; the type of object returned is decided by
     * the content of the "data" element, and there are several such types in the various server responses. Java
     * requires us to specifically choose a type to convert to, so we need an additional parameter (returnType) to
     * specify the type we expect.
     * 
     * @param resp The JSON response from the server
     * @param returnType The type to coerce the 'data' element to.
     * @return The "data" element from the HTTP response from the server. The type of object returned is determined by
     *         returnType.
     */
    @SuppressWarnings("unchecked")
    private <T> T _dataOnly(JSONObject resp, Class<T> returnType) throws MediaSyncException {
        try {
            if (!TextUtils.isEmpty(resp.optString("err"))) {
                String err = resp.getString("err");
                mCol.log("error returned: " + err);
                throw new MediaSyncException("SyncError:" + err);
            }
            if (returnType == String.class) {
                return (T) resp.getString("data");
            } else if (returnType == JSONObject.class) {
                return (T) resp.getJSONObject("data");
            } else if (returnType == JSONArray.class) {
                return (T) resp.getJSONArray("data");
            }
            throw new RuntimeException("Did not specify a valid type for the 'data' element in resopnse");
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }
}
/***************************************************************************************
 * Copyright (c) 2012 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2014 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.sync;

import com.ichi2.anki.exception.UnknownHttpResponseException;
import com.ichi2.async.Connection;
import com.ichi2.libanki.Consts;
import com.ichi2.libanki.Utils;
import com.ichi2.utils.VersionUtils;

import org.apache.http.HttpResponse;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.util.HashMap;
import java.util.Locale;

public class RemoteServer extends HttpSyncer {

    public RemoteServer(Connection con, String hkey) {
        super(hkey, con);
    }


    /** Returns hkey or none if user/pw incorrect. 
     * @throws UnknownHttpResponseException */
    @Override
    public HttpResponse hostKey(String user, String pw) throws UnknownHttpResponseException {
        try {
            mPostVars = new HashMap<>();
            JSONObject jo = new JSONObject();
            jo.put("u", user);
            jo.put("p", pw);
            return super.req("hostKey", super.getInputStream(Utils.jsonToString(jo)));
        } catch (JSONException e) {
            return null;
        }
    }


    @Override
    public HttpResponse meta() throws UnknownHttpResponseException {
        try {
            mPostVars = new HashMap<>();
            mPostVars.put("k", mHKey);
            mPostVars.put("s", mSKey);
            JSONObject jo = new JSONObject();
            jo.put("v", Consts.SYNC_VER);
            jo.put("cv",
                    String.format(Locale.US, "ankidroid,%s,%s", VersionUtils.getPkgVersionName(), Utils.platDesc()));
            return super.req("meta", super.getInputStream(Utils.jsonToString(jo)));
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    @Override
    public JSONObject applyChanges(JSONObject kw) throws UnknownHttpResponseException {
        return parseDict(_run("applyChanges", kw));
    }


    @Override
    public JSONObject start(JSONObject kw) throws UnknownHttpResponseException {
        return parseDict(_run("start", kw));
    }


    @Override
    public JSONObject chunk() throws UnknownHttpResponseException {
        JSONObject co = new JSONObject();
        return parseDict(_run("chunk", co));
    }


    @Override
    public void applyChunk(JSONObject sech) throws UnknownHttpResponseException {
        _run("applyChunk", sech);
    }


    @Override
    public JSONObject sanityCheck2(JSONObject client) throws UnknownHttpResponseException {
        return parseDict(_run("sanityCheck2", client));
    }

    @Override
    public long finish() throws UnknownHttpResponseException {
        return parseLong(_run("finish", new JSONObject()));
    }

    @Override
    public void abort() throws UnknownHttpResponseException {
        _run("abort", new JSONObject());
    }

    /** Python has dynamic type deduction, but we don't, so return String **/
    private String _run(String cmd, JSONObject data) throws UnknownHttpResponseException {
        HttpResponse ret = super.req(cmd, super.getInputStream(Utils.jsonToString(data)));
        try {
            return super.stream2String(ret.getEntity().getContent());
        } catch (IllegalStateException | IOException e) {
            throw new RuntimeException(e);
        }
    }

    /** Note: these conversion helpers aren't needed in libanki as type deduction occurs automatically there **/
    private JSONObject parseDict(String s) {
        try {
            if (!s.equalsIgnoreCase("null") && s.length() != 0) {
                return new JSONObject(s);
            } else {
                return new JSONObject();
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }

    private long parseLong(String s) {
        try {
            return Long.parseLong(s);
        } catch (NumberFormatException e) {
            return 0;
        }
    }
}
/***************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2014 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.sync;

import android.database.Cursor;
import android.database.SQLException;


import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.R;
import com.ichi2.anki.exception.UnknownHttpResponseException;
import com.ichi2.async.Connection;
import com.ichi2.libanki.Collection;
import com.ichi2.libanki.Consts;
import com.ichi2.libanki.Utils;

import org.apache.http.HttpResponse;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import timber.log.Timber;

public class Syncer {
    // Mapping of column type names to Cursor types for API < 11
    public static final int TYPE_NULL = 0;
    public static final int TYPE_INTEGER = 1;
    public static final int TYPE_FLOAT = 2;
    public static final int TYPE_STRING = 3;
    public static final int TYPE_BLOB = 4;

    Collection mCol;
    HttpSyncer mServer;
    long mRMod;
    long mRScm;
    int mMaxUsn;
    long mLMod;
    long mLScm;
    int mMinUsn;
    boolean mLNewer;
    JSONObject mRChg;
    String mSyncMsg;

    private LinkedList<String> mTablesLeft;
    private Cursor mCursor;


    public Syncer(Collection col, HttpSyncer server) {
        mCol = col;
        mServer = server;
    }


    /** Returns 'noChanges', 'fullSync', 'success', etc */
    public Object[] sync() throws UnknownHttpResponseException {
        return sync(null);
    }


    public Object[] sync(Connection con) throws UnknownHttpResponseException {
        mSyncMsg = "";
        // if the deck has any pending changes, flush them first and bump mod time
        mCol.save();
        // step 1: login & metadata
        HttpResponse ret = mServer.meta();
        if (ret == null) {
            return null;
        }
        int returntype = ret.getStatusLine().getStatusCode();
        if (returntype == 403) {
            return new Object[] { "badAuth" };
        }
        try {
            mCol.getDb().getDatabase().beginTransaction();
            try {
                Timber.i("Sync: getting meta data from server");
                JSONObject rMeta = new JSONObject(mServer.stream2String(ret.getEntity().getContent()));
                mCol.log("rmeta", rMeta);
                mSyncMsg = rMeta.getString("msg");
                if (!rMeta.getBoolean("cont")) {
                    // Don't add syncMsg; it can be fetched by UI code using the accessor
                    return new Object[] { "serverAbort" };
                } else {
                    // don't abort, but ui should show messages after sync finishes
                    // and require confirmation if it's non-empty
                }
                throwExceptionIfCancelled(con);
                long rscm = rMeta.getLong("scm");
                int rts = rMeta.getInt("ts");
                mRMod = rMeta.getLong("mod");
                mMaxUsn = rMeta.getInt("usn");
                // skip uname, AnkiDroid already stores and shows it
                Timber.i("Sync: building local meta data");
                JSONObject lMeta = meta();
                mCol.log("lmeta", lMeta);
                mLMod = lMeta.getLong("mod");
                mMinUsn = lMeta.getInt("usn");
                long lscm = lMeta.getLong("scm");
                int lts = lMeta.getInt("ts");

                long diff = Math.abs(rts - lts);
                if (diff > 300) {
                    mCol.log("clock off");
                    return new Object[] { "clockOff", diff };
                }
                if (mLMod == mRMod) {
                    Timber.i("Sync: no changes - returning");
                    mCol.log("no changes");
                    return new Object[] { "noChanges" };
                } else if (lscm != rscm) {
                    Timber.i("Sync: full sync necessary - returning");
                    mCol.log("schema diff");
                    return new Object[] { "fullSync" };
                }
                mLNewer = mLMod > mRMod;
                // step 1.5: check collection is valid
                if (!mCol.basicCheck()) {
                    mCol.log("basic check");
                    return new Object[] { "basicCheckFailed" };
                }
                throwExceptionIfCancelled(con);
                // step 2: deletions
                publishProgress(con, R.string.sync_deletions_message);

                Timber.i("Sync: collection removed data");
                JSONObject lrem = removed();
                JSONObject o = new JSONObject();
                o.put("minUsn", mMinUsn);
                o.put("lnewer", mLNewer);
                o.put("graves", lrem);

                Timber.i("Sync: sending and receiving removed data");
                JSONObject rrem = mServer.start(o);
                Timber.i("Sync: applying removed data");
                throwExceptionIfCancelled(con);
                remove(rrem);
                // ... and small objects
                publishProgress(con, R.string.sync_small_objects_message);

                Timber.i("Sync: collection small changes");
                JSONObject lchg = changes();
                JSONObject sch = new JSONObject();
                sch.put("changes", lchg);

                Timber.i("Sync: sending and receiving small changes");
                JSONObject rchg = mServer.applyChanges(sch);
                throwExceptionIfCancelled(con);
                Timber.i("Sync: merging small changes");
                mergeChanges(lchg, rchg);
                // step 3: stream large tables from server
                publishProgress(con, R.string.sync_download_chunk);
                while (true) {
                    throwExceptionIfCancelled(con);
                    Timber.i("Sync: downloading chunked data");
                    JSONObject chunk = mServer.chunk();
                    mCol.log("server chunk", chunk);
                    Timber.i("Sync: applying chunked data");
                    applyChunk(chunk);
                    if (chunk.getBoolean("done")) {
                        break;
                    }
                }
                // step 4: stream to server
                publishProgress(con, R.string.sync_upload_chunk);
                while (true) {
                    throwExceptionIfCancelled(con);
                    Timber.i("Sync: collecting chunked data");
                    JSONObject chunk = chunk();
                    mCol.log("client chunk", chunk);
                    JSONObject sech = new JSONObject();
                    sech.put("chunk", chunk);
                    Timber.i("Sync: sending chunked data");
                    mServer.applyChunk(sech);
                    if (chunk.getBoolean("done")) {
                        break;
                    }
                }
                // step 5: sanity check
                JSONObject c = sanityCheck();
                JSONObject sanity = mServer.sanityCheck2(c);
                if (sanity == null || !sanity.optString("status", "bad").equals("ok")) {
                    mCol.log("sanity check failed", c, sanity);
                    return new Object[] { "sanityCheckError", null };
                }
                // finalize
                publishProgress(con, R.string.sync_finish_message);
                Timber.i("Sync: sending finish command");
                long mod = mServer.finish();
                if (mod == 0) {
                    return new Object[] { "finishError" };
                }
                Timber.i("Sync: finishing");
                finish(mod);

                publishProgress(con, R.string.sync_writing_db);
                mCol.getDb().getDatabase().setTransactionSuccessful();
            } finally {
                mCol.getDb().getDatabase().endTransaction();
            }
        } catch (JSONException | IllegalStateException e) {
            throw new RuntimeException(e);
        } catch (OutOfMemoryError e) {
            AnkiDroidApp.sendExceptionReport(e, "Syncer-sync");
            return new Object[] { "OutOfMemoryError" };
        } catch (IOException e) {
            AnkiDroidApp.sendExceptionReport(e, "Syncer-sync");
            return new Object[] { "IOException" };
        }
        return new Object[] { "success" };
    }


    private void publishProgress(Connection con, int id) {
        if (con != null) {
            con.publishProgress(id);
        }
    }


    public JSONObject meta() throws JSONException {
        JSONObject j = new JSONObject();
        j.put("mod", mCol.getMod());
        j.put("scm", mCol.getScm());
        j.put("usn", mCol.getUsnForSync());
        j.put("ts", Utils.intNow());
        j.put("musn", 0);
        j.put("msg", "");
        j.put("cont", true);
        return j;
    }


    /** Bundle up small objects. */
    public JSONObject changes() {
        JSONObject o = new JSONObject();
        try {
            o.put("models", getModels());
            o.put("decks", getDecks());
            o.put("tags", getTags());
            if (mLNewer) {
                o.put("conf", getConf());
                o.put("crt", mCol.getCrt());
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return o;
    }


    public JSONObject applyChanges(JSONObject changes) {
        mRChg = changes;
        JSONObject lchg = changes();
        // merge our side before returning
        mergeChanges(lchg, mRChg);
        return lchg;
    }


    public void mergeChanges(JSONObject lchg, JSONObject rchg) {
        try {
            // then the other objects
            mergeModels(rchg.getJSONArray("models"));
            mergeDecks(rchg.getJSONArray("decks"));
            mergeTags(rchg.getJSONArray("tags"));
            if (rchg.has("conf")) {
                mergeConf(rchg.getJSONObject("conf"));
            }
            // this was left out of earlier betas
            if (rchg.has("crt")) {
                mCol.setCrt(rchg.getLong("crt"));
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        prepareToChunk();
    }


    public JSONObject sanityCheck() {
        JSONObject result = new JSONObject();
        try {
            if (mCol.getDb().queryScalar("SELECT count() FROM cards WHERE nid NOT IN (SELECT id FROM notes)") != 0) {
                Timber.e("Sync - SanityCheck: there are cards without mother notes");
                result.put("client", "missing notes");
                return result;
            }
            if (mCol.getDb().queryScalar("SELECT count() FROM notes WHERE id NOT IN (SELECT DISTINCT nid FROM cards)") != 0) {
                Timber.e("Sync - SanityCheck: there are notes without cards");
                result.put("client", "missing cards");
                return result;
            }
            if (mCol.getDb().queryScalar("SELECT count() FROM cards WHERE usn = -1") != 0) {
                Timber.e("Sync - SanityCheck: there are unsynced cards");
                result.put("client", "cards had usn = -1");
                return result;
            }
            if (mCol.getDb().queryScalar("SELECT count() FROM notes WHERE usn = -1") != 0) {
                Timber.e("Sync - SanityCheck: there are unsynced notes");
                result.put("client", "notes had usn = -1");
                return result;
            }
            if (mCol.getDb().queryScalar("SELECT count() FROM revlog WHERE usn = -1") != 0) {
                Timber.e("Sync - SanityCheck: there are unsynced revlogs");
                result.put("client", "revlog had usn = -1");
                return result;
            }
            if (mCol.getDb().queryScalar("SELECT count() FROM graves WHERE usn = -1") != 0) {
                Timber.e("Sync - SanityCheck: there are unsynced graves");
                result.put("client", "graves had usn = -1");
                return result;
            }
            for (JSONObject g : mCol.getDecks().all()) {
                if (g.getInt("usn") == -1) {
                    Timber.e("Sync - SanityCheck: unsynced deck: " + g.getString("name"));
                    result.put("client", "deck had usn = -1");
                    return result;
                }
            }
            for (Map.Entry<String, Integer> tag : mCol.getTags().allItems()) {
                if (tag.getValue() == -1) {
                    Timber.e("Sync - SanityCheck: there are unsynced tags");
                    result.put("client", "tag had usn = -1");
                    return result;
                }
            }
            boolean found = false;
            for (JSONObject m : mCol.getModels().all()) {
                if (mCol.getServer()) {
                    // the web upgrade was mistakenly setting usn
                    if (m.getInt("usn") < 0) {
                        m.put("usn", 0);
                        found = true;
                    }
                } else {
                    if (m.getInt("usn") == -1) {
                        Timber.e("Sync - SanityCheck: unsynced model: " + m.getString("name"));
                        result.put("client", "model had usn = -1");
                        return result;
                    }
                }
            }
            if (found) {
                mCol.getModels().save();
            }
            mCol.getSched().reset();
            // check for missing parent decks
            mCol.getSched().deckDueList();
            // return summary of deck
            JSONArray ja = new JSONArray();
            JSONArray sa = new JSONArray();
            for (int c : mCol.getSched().counts()) {
                sa.put(c);
            }
            ja.put(sa);
            ja.put(mCol.getDb().queryScalar("SELECT count() FROM cards"));
            ja.put(mCol.getDb().queryScalar("SELECT count() FROM notes"));
            ja.put(mCol.getDb().queryScalar("SELECT count() FROM revlog"));
            ja.put(mCol.getDb().queryScalar("SELECT count() FROM graves"));
            ja.put(mCol.getModels().all().size());
            ja.put(mCol.getDecks().all().size());
            ja.put(mCol.getDecks().allConf().size());
            result.put("client", ja);
            return result;
        } catch (JSONException e) {
            Timber.e(e, "Syncer.sanityCheck()");
            throw new RuntimeException(e);
        }
    }


    // private Map<String, Object> sanityCheck2(JSONArray client) {
    // Object server = sanityCheck();
    // Map<String, Object> result = new HashMap<String, Object>();
    // if (client.equals(server)) {
    // result.put("status", "ok");
    // } else {
    // result.put("status", "bad");
    // result.put("c", client);
    // result.put("s", server);
    // }
    // return result;
    // }

    private String usnLim() {
        if (mCol.getServer()) {
            return "usn >= " + mMinUsn;
        } else {
            return "usn = -1";
        }
    }


    public long finish() {
        return finish(0);
    }


    private long finish(long mod) {
        if (mod == 0) {
            // server side; we decide new mod time
            mod = Utils.intNow(1000);
        }
        mCol.setLs(mod);
        mCol.setUsnAfterSync(mMaxUsn + 1);
        // ensure we save the mod time even if no changes made
        mCol.getDb().setMod(true);
        mCol.save(null, mod);
        return mod;
    }


    /**
     * Chunked syncing ********************************************************************
     */

    private void prepareToChunk() {
        mTablesLeft = new LinkedList<>();
        mTablesLeft.add("revlog");
        mTablesLeft.add("cards");
        mTablesLeft.add("notes");
        mCursor = null;
    }


    private Cursor cursorForTable(String table) {
        String lim = usnLim();
        if (table.equals("revlog")) {
            return mCol
                    .getDb()
                    .getDatabase()
                    .rawQuery(
                            String.format(Locale.US,
                                    "SELECT id, cid, %d, ease, ivl, lastIvl, factor, time, type FROM revlog WHERE %s",
                                    mMaxUsn, lim), null);
        } else if (table.equals("cards")) {
            return mCol
                    .getDb()
                    .getDatabase()
                    .rawQuery(
                            String.format(
                                    Locale.US,
                                    "SELECT id, nid, did, ord, mod, %d, type, queue, due, ivl, factor, reps, lapses, left, odue, odid, flags, data FROM cards WHERE %s",
                                    mMaxUsn, lim), null);
        } else {
            return mCol
                    .getDb()
                    .getDatabase()
                    .rawQuery(
                            String.format(
                                    Locale.US,
                                    "SELECT id, guid, mid, mod, %d, tags, flds, '', '', flags, data FROM notes WHERE %s",
                                    mMaxUsn, lim), null);
        }
    }


    private List<Integer> columnTypesForQuery(String table) {
        if (table.equals("revlog")) {
            return Arrays.asList(TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER,
                    TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER);
        } else if (table.equals("cards")) {
            return Arrays.asList(TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER,
                    TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER,
                    TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_STRING);
        } else {
            return Arrays.asList(TYPE_INTEGER, TYPE_STRING, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_STRING,
                    TYPE_STRING, TYPE_STRING, TYPE_STRING, TYPE_INTEGER, TYPE_STRING);
        }
    }


    public JSONObject chunk() {
        JSONObject buf = new JSONObject();
        try {
            buf.put("done", false);
            int lim = 250;
            List<Integer> colTypes = null;
            while (!mTablesLeft.isEmpty() && lim > 0) {
                String curTable = mTablesLeft.getFirst();
                if (mCursor == null) {
                    mCursor = cursorForTable(curTable);
                }
                colTypes = columnTypesForQuery(curTable);
                JSONArray rows = new JSONArray();
                int count = mCursor.getColumnCount();
                int fetched = 0;
                while (mCursor.moveToNext()) {
                    JSONArray r = new JSONArray();
                    for (int i = 0; i < count; i++) {
                        switch (colTypes.get(i)) {
                            case TYPE_STRING:
                                r.put(mCursor.getString(i));
                                break;
                            case TYPE_FLOAT:
                                r.put(mCursor.getDouble(i));
                                break;
                            case TYPE_INTEGER:
                                r.put(mCursor.getLong(i));
                                break;
                        }
                    }
                    rows.put(r);
                    if (++fetched == lim) {
                        break;
                    }
                }
                if (fetched != lim) {
                    // table is empty
                    mTablesLeft.removeFirst();
                    mCursor.close();
                    mCursor = null;
                    // if we're the client, mark the objects as having been sent
                    if (!mCol.getServer()) {
                        mCol.getDb().execute("UPDATE " + curTable + " SET usn=" + mMaxUsn + " WHERE usn=-1");
                    }
                }
                buf.put(curTable, rows);
                lim -= fetched;
            }
            if (mTablesLeft.isEmpty()) {
                buf.put("done", true);
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return buf;
    }


    public void applyChunk(JSONObject chunk) {
        try {
            if (chunk.has("revlog")) {
                mergeRevlog(chunk.getJSONArray("revlog"));
            }
            if (chunk.has("cards")) {
                mergeCards(chunk.getJSONArray("cards"));
            }
            if (chunk.has("notes")) {
                mergeNotes(chunk.getJSONArray("notes"));
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Deletions ********************************************************************
     */

    private JSONObject removed() {
        JSONArray cards = new JSONArray();
        JSONArray notes = new JSONArray();
        JSONArray decks = new JSONArray();
        Cursor cur = null;
        try {
            cur = mCol
                    .getDb()
                    .getDatabase()
                    .rawQuery(
                            "SELECT oid, type FROM graves WHERE usn"
                                    + (mCol.getServer() ? (" >= " + mMinUsn) : (" = -1")), null);
            while (cur.moveToNext()) {
                int type = cur.getInt(1);
                switch (type) {
                    case Consts.REM_CARD:
                        cards.put(cur.getLong(0));
                        break;
                    case Consts.REM_NOTE:
                        notes.put(cur.getLong(0));
                        break;
                    case Consts.REM_DECK:
                        decks.put(cur.getLong(0));
                        break;
                }
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        if (!mCol.getServer()) {
            mCol.getDb().execute("UPDATE graves SET usn=" + mMaxUsn + " WHERE usn=-1");
        }
        JSONObject o = new JSONObject();
        try {
            o.put("cards", cards);
            o.put("notes", notes);
            o.put("decks", decks);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return o;
    }


    public JSONObject start(int minUsn, boolean lnewer, JSONObject graves) {
        mMaxUsn = mCol.getUsnForSync();
        mMinUsn = minUsn;
        mLNewer = !lnewer;
        JSONObject lgraves = removed();
        remove(graves);
        return lgraves;
    }


    private void remove(JSONObject graves) {
        // pretend to be the server so we don't set usn = -1
        boolean wasServer = mCol.getServer();
        mCol.setServer(true);
        try {
            // notes first, so we don't end up with duplicate graves
            mCol._remNotes(Utils.jsonArrayToLongArray(graves.getJSONArray("notes")));
            // then cards
            mCol.remCards(Utils.jsonArrayToLongArray(graves.getJSONArray("cards")), false);
            // and decks
            JSONArray decks = graves.getJSONArray("decks");
            for (int i = 0; i < decks.length(); i++) {
                mCol.getDecks().rem(decks.getLong(i), false, false);
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        mCol.setServer(wasServer);
    }


    /**
     * Models ********************************************************************
     */

    private JSONArray getModels() {
        JSONArray result = new JSONArray();
        try {
            if (mCol.getServer()) {
                for (JSONObject m : mCol.getModels().all()) {
                    if (m.getInt("usn") >= mMinUsn) {
                        result.put(m);
                    }
                }
            } else {
                for (JSONObject m : mCol.getModels().all()) {
                    if (m.getInt("usn") == -1) {
                        m.put("usn", mMaxUsn);
                        result.put(m);
                    }
                }
                mCol.getModels().save();
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return result;
    }


    private void mergeModels(JSONArray rchg) {
        for (int i = 0; i < rchg.length(); i++) {
            try {
                JSONObject r = rchg.getJSONObject(i);
                JSONObject l;
                l = mCol.getModels().get(r.getLong("id"));
                // if missing locally or server is newer, update
                if (l == null || r.getLong("mod") > l.getLong("mod")) {
                    mCol.getModels().update(r);
                }
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }
    }


    /**
     * Decks ********************************************************************
     */

    private JSONArray getDecks() {
        JSONArray result = new JSONArray();
        try {
            if (mCol.getServer()) {
                JSONArray decks = new JSONArray();
                for (JSONObject g : mCol.getDecks().all()) {
                    if (g.getInt("usn") >= mMinUsn) {
                        decks.put(g);
                    }
                }
                JSONArray dconfs = new JSONArray();
                for (JSONObject g : mCol.getDecks().allConf()) {
                    if (g.getInt("usn") >= mMinUsn) {
                        dconfs.put(g);
                    }
                }
                result.put(decks);
                result.put(dconfs);
            } else {
                JSONArray decks = new JSONArray();
                for (JSONObject g : mCol.getDecks().all()) {
                    if (g.getInt("usn") == -1) {
                        g.put("usn", mMaxUsn);
                        decks.put(g);
                    }
                }
                JSONArray dconfs = new JSONArray();
                for (JSONObject g : mCol.getDecks().allConf()) {
                    if (g.getInt("usn") == -1) {
                        g.put("usn", mMaxUsn);
                        dconfs.put(g);
                    }
                }
                mCol.getDecks().save();
                result.put(decks);
                result.put(dconfs);
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return result;
    }


    private void mergeDecks(JSONArray rchg) {
        try {
            JSONArray decks = rchg.getJSONArray(0);
            for (int i = 0; i < decks.length(); i++) {
                JSONObject r = decks.getJSONObject(i);
                JSONObject l = mCol.getDecks().get(r.getLong("id"), false);
                // if missing locally or server is newer, update
                if (l == null || r.getLong("mod") > l.getLong("mod")) {
                    mCol.getDecks().update(r);
                }
            }
            JSONArray confs = rchg.getJSONArray(1);
            for (int i = 0; i < confs.length(); i++) {
                JSONObject r = confs.getJSONObject(i);
                JSONObject l = mCol.getDecks().getConf(r.getLong("id"));
                // if missing locally or server is newer, update
                if (l == null || r.getLong("mod") > l.getLong("mod")) {
                    mCol.getDecks().updateConf(r);
                }
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Tags ********************************************************************
     */

    private JSONArray getTags() {
        JSONArray result = new JSONArray();
        if (mCol.getServer()) {
            for (Map.Entry<String, Integer> t : mCol.getTags().allItems()) {
                if (t.getValue() >= mMinUsn) {
                    result.put(t.getKey());
                }
            }
        } else {
            for (Map.Entry<String, Integer> t : mCol.getTags().allItems()) {
                if (t.getValue() == -1) {
                    String tag = t.getKey();
                    mCol.getTags().add(t.getKey(), mMaxUsn);
                    result.put(tag);
                }
            }
            mCol.getTags().save();
        }
        return result;
    }


    private void mergeTags(JSONArray tags) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < tags.length(); i++) {
            try {
                list.add(tags.getString(i));
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }
        mCol.getTags().register(list, mMaxUsn);
    }


    /**
     * Cards/notes/revlog ********************************************************************
     */

    private void mergeRevlog(JSONArray logs) {
        for (int i = 0; i < logs.length(); i++) {
            try {
                mCol.getDb().execute("INSERT OR IGNORE INTO revlog VALUES (?,?,?,?,?,?,?,?,?)",
                        Utils.jsonArray2Objects(logs.getJSONArray(i)));
            } catch (SQLException | JSONException e) {
                throw new RuntimeException(e);
            }
        }

    }


    private ArrayList<Object[]> newerRows(JSONArray data, String table, int modIdx) {
        long[] ids = new long[data.length()];
        try {
            for (int i = 0; i < data.length(); i++) {
                ids[i] = data.getJSONArray(i).getLong(0);
            }
            HashMap<Long, Long> lmods = new HashMap<>();
            Cursor cur = null;
            try {
                cur = mCol
                        .getDb()
                        .getDatabase()
                        .rawQuery(
                                "SELECT id, mod FROM " + table + " WHERE id IN " + Utils.ids2str(ids) + " AND "
                                        + usnLim(), null);
                while (cur.moveToNext()) {
                    lmods.put(cur.getLong(0), cur.getLong(1));
                }
            } finally {
                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }
            }
            ArrayList<Object[]> update = new ArrayList<>();
            for (int i = 0; i < data.length(); i++) {
                JSONArray r = data.getJSONArray(i);
                if (!lmods.containsKey(r.getLong(0)) || lmods.get(r.getLong(0)) < r.getLong(modIdx)) {
                    update.add(Utils.jsonArray2Objects(r));
                }
            }
            mCol.log(table, data);
            return update;
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
    }


    private void mergeCards(JSONArray cards) {
        for (Object[] r : newerRows(cards, "cards", 4)) {
            mCol.getDb().execute("INSERT OR REPLACE INTO cards VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)", r);
        }
    }


    private void mergeNotes(JSONArray notes) {
        for (Object[] n : newerRows(notes, "notes", 4)) {
            mCol.getDb().execute("INSERT OR REPLACE INTO notes VALUES (?,?,?,?,?,?,?,?,?,?,?)", n);
            mCol.updateFieldCache(new long[]{Long.valueOf(((Number) n[0]).longValue())});
        }
    }


    public String getSyncMsg() {
        return mSyncMsg;
    }


    /**
     * Col config ********************************************************************
     */

    private JSONObject getConf() {
        return mCol.getConf();
    }


    private void mergeConf(JSONObject conf) {
        mCol.setConf(conf);
    }

    /**
     * If the user asked to cancel the sync then we just throw a Runtime exception which should be gracefully handled
     * @param con
     */
    private void throwExceptionIfCancelled(Connection con) {
        if (Connection.getIsCancelled()) {
            Timber.i("Sync was cancelled");
            publishProgress(con, R.string.sync_cancelled);
            try {
                mServer.abort();
            } catch (UnknownHttpResponseException e) {
            }
            throw new RuntimeException("UserAbortedSync");
        }
    }

}
/****************************************************************************************
 * Copyright (c) 2015 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.libanki.template;

import android.text.TextUtils;

import com.ichi2.libanki.Utils;
import com.ichi2.libanki.hooks.Hooks;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This class renders the card content by parsing the card template and replacing all marked sections
 * and tags with their respective data. The data is derived from a context object that is given to
 * the class when constructed which maps tags to the data that they should be replaced with.
 * <p/>
 * The AnkiDroid version of this class makes some assumptions about the valid data types that flow
 * through it and is thus simplified. Namely, the context is assumed to always be a Map<String, String>,
 * and sections are only ever considered to be String objects. Tests have shown that strings are the
 * only data type used, and thus code that handles anything else has been omitted.
 */
public class Template {
    public static final String clozeReg = "(?s)\\{\\{c%s::(.*?)(::(.*?))?\\}\\}";
    private static final Pattern fHookFieldMod = Pattern.compile("^(.*?)(?:\\((.*)\\))?$");
    private static final Pattern fClozeSection = Pattern.compile("c[qa]:(\\d+):(.+)");

    // The regular expression used to find a #section
    private Pattern sSection_re = null;

    // The regular expression used to find a tag.
    private Pattern sTag_re = null;

    // Opening tag delimiter
    private String sOtag = "{{";

    // Closing tag delimiter
    private String sCtag = "}}";

    private String mTemplate;
    private Map<String, String> mContext;

    private static String get_or_attr(Map<String, String> obj, String name) {
        return get_or_attr(obj, name, null);
    }

    private static String get_or_attr(Map<String, String> obj, String name, String _default) {
        if (obj.containsKey(name)) {
            return obj.get(name);
        } else {
            return _default;
        }
    }


    public Template(String template, Map<String, String> context) {
        mTemplate = template;
        mContext = context == null ? new HashMap<String, String>() : context;
        compile_regexps();
    }


    /**
     * Turns a Mustache template into something wonderful.
     */
    public String render() {
        String template = render_sections(mTemplate, mContext);
        return render_tags(template, mContext);
    }

    /**
     * Compiles our section and tag regular expressions.
     */
    private void compile_regexps() {
        String otag = Pattern.quote(sOtag);
        String ctag = Pattern.quote(sCtag);

        String section = String.format(Locale.US,
                "%s[\\#|^]([^\\}]*)%s(.+?)%s/\\1%s", otag, ctag, otag, ctag);
        sSection_re = Pattern.compile(section, Pattern.MULTILINE | Pattern.DOTALL);

        String tag = String.format(Locale.US, "%s(#|=|&|!|>|\\{)?(.+?)\\1?%s+", otag, ctag);
        sTag_re = Pattern.compile(tag);
    }

    /**
     * Expands sections.
     */
    private String render_sections(String template, Map<String, String> context) {
        while (true) {
            Matcher match = sSection_re.matcher(template);
            if (!match.find()) {
                break;
            }

            String section = match.group(0);
            String section_name = match.group(1);
            String inner = match.group(2);
            section_name = section_name.trim();
            String it;

            // check for cloze
            Matcher m = fClozeSection.matcher(section_name);
            if (m.find()) {
                // get full field text
                String txt = get_or_attr(context, m.group(2), null);
                Matcher mm = Pattern.compile(String.format(clozeReg, m.group(1))).matcher(txt);
                if (mm.find()) {
                    it = mm.group(1);
                } else {
                    it = null;
                }
            } else {
                it = get_or_attr(context, section_name, null);
            }
            String replacer = "";
            if (!TextUtils.isEmpty(it)) {
                it = Utils.stripHTMLMedia(it).trim();
            }
            if (!TextUtils.isEmpty(it)) {
                if (section.charAt(2) != '^') {
                    replacer = inner;
                }
            } else if (TextUtils.isEmpty(it) && section.charAt(2) == '^') {
                replacer = inner;
            }
            template = template.replace(section, replacer);
        }
        return template;
    }


    /**
     * Renders all the tags in a template for a context.
     */
    private String render_tags(String template, Map<String, String> context) {
        while (true) {
            Matcher match = sTag_re.matcher(template);
            if (!match.find()) {
                break;
            }

            String tag = match.group(0);
            String tag_type = match.group(1);
            String tag_name = match.group(2).trim();
            String replacement;
            if (tag_type == null) {
                replacement = render_unescaped(tag_name, context);
            } else if (tag_type.equals("{")) {
                replacement = render_tag(tag_name, context);
            } else if (tag_type.equals("!")) {
                replacement = render_comment();
            } else if (tag_type.equals("=")) {
                replacement = render_delimiter(tag_name);
            } else {
                return "{{invalid template}}";
            }
            template = template.replace(tag, replacement);
        }
        return template;
    }

    /**
     * {{{ functions just like {{ in anki
     */
    private String render_tag(String tag_name, Map<String, String> context) {
        return render_unescaped(tag_name, context);
    }


    /**
     * Rendering a comment always returns nothing.
     */
    private String render_comment() {
        return "";
    }

    private String render_unescaped(String tag_name, Map<String, String> context) {
        String txt = get_or_attr(context, tag_name);
        if (txt != null) {
            // some field names could have colons in them
            // avoid interpreting these as field modifiers
            // better would probably be to put some restrictions on field names
            return txt;
        }

        // field modifiers
        List<String> parts = Arrays.asList(tag_name.split(":"));
        String extra = null;
        List<String> mods;
        String tag;
        if (parts.size() == 1 || parts.get(0).equals("")) {
            return String.format("{unknown field %s}", tag_name);
        } else {
            mods = parts.subList(0, parts.size() - 1);
            tag = parts.get(parts.size() - 1);
        }

        txt = get_or_attr(context, tag);

        // Since 'text:' and other mods can affect html on which Anki relies to
        // process clozes, we need to make sure clozes are always
        // treated after all the other mods, regardless of how they're specified
        // in the template, so that {{cloze:text: == {{text:cloze:
        // For type:, we return directly since no other mod than cloze (or other
        // pre-defined mods) can be present and those are treated separately
        Collections.reverse(mods);
        Collections.sort(mods, new Comparator<String>() {
            // This comparator ensures "type:" mods are ordered first in the list. The rest of
            // the list remains in the same order.
            @Override
            public int compare(String lhs, String rhs) {
                if (lhs.equals("type")) {
                    return 0;
                } else {
                    return 1;
                }
            }
        });

        for (String mod : mods) {
            //Timber.d("Models.get():: Processing field: modifier=%s, extra=%s, tag=%s, txt=%s", mod, extra, tag, txt);
            // built-in modifiers
            if (mod.equals("text")) {
                // strip html
                if (!TextUtils.isEmpty(txt)) {
                    txt = Utils.stripHTML(txt);
                } else {
                    txt = "";
                }
            } else if (mod.equals("type")) {
                // type answer field; convert it to [[type:...]] for the gui code
                // to process
                return String.format(Locale.US, "[[%s]]", tag_name);
            } else if (mod.startsWith("cq-") || mod.startsWith("ca-")) {
                // cloze deletion
                String[] split = mod.split("-");
                mod = split[0];
                extra = split[1];
                if (!TextUtils.isEmpty(txt) && !TextUtils.isEmpty(extra)) {
                    txt = clozeText(txt, extra, mod.charAt(1));
                } else {
                    txt = "";
                }
            } else {
                // hook-based field modifier
                Matcher m = fHookFieldMod.matcher(mod);
                if (m.matches()) {
                    mod = m.group(1);
                    extra = m.group(2);
                }

                txt = (String) Hooks.runFilter("fmod_" + mod,
                        txt == null ? "" : txt,
                        extra == null ? "" : extra,
                        context, tag, tag_name);
                if (txt == null) {
                    return String.format("{unknown field %s}", tag_name);
                }
            }
        }
        return txt;
    }

    private static String clozeText(String txt, String ord, char type) {
        Matcher m = Pattern.compile(String.format(Locale.US, clozeReg, ord)).matcher(txt);
        if (!m.find()) {
            return "";
        }
        m.reset();
        StringBuffer repl = new StringBuffer();
        while (m.find()) {
            // replace chosen cloze with type
            if (type == 'q') {
                if (!TextUtils.isEmpty(m.group(3))) {
                    m.appendReplacement(repl, "<span class=cloze>[$3]</span>");
                } else {
                    m.appendReplacement(repl, "<span class=cloze>[...]</span>");
                }
            } else {
                m.appendReplacement(repl, "<span class=cloze>$1</span>");
            }
        }
        txt = m.appendTail(repl).toString();
        // and display other clozes normally
        return txt.replaceAll(String.format(Locale.US, clozeReg, "\\d+"), "$1");
    }

    /**
     * Changes the Mustache delimiter.
     */
    private String render_delimiter(String tag_name) {
        try {
            String[] split = tag_name.split(" ");
            sOtag = split[0];
            sCtag = split[1];
        } catch (IndexOutOfBoundsException e) {
            // invalid
            return null;
        }
        compile_regexps();
        return "";
    }
}
/***************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.preferences;

import android.content.Context;
import android.content.DialogInterface;
import android.content.SharedPreferences.Editor;
import android.preference.DialogPreference;
import android.util.AttributeSet;
import android.widget.Toast;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.MetaDB;
import com.ichi2.anki.R;

public class CustomDialogPreference extends DialogPreference implements DialogInterface.OnClickListener {
    private Context mContext;


    public CustomDialogPreference(Context context, AttributeSet attrs) {
        super(context, attrs);
        mContext = context;
    }


    public void onClick(DialogInterface dialog, int which) {
        if (which == DialogInterface.BUTTON_POSITIVE) {
            if (this.getTitle().equals(mContext.getResources().getString(R.string.deck_conf_reset))) {
                // Deck Options :: Restore Defaults for Options Group
                Editor editor = AnkiDroidApp.getSharedPrefs(mContext).edit();
                editor.putBoolean("confReset", true);
                editor.commit();
            } else if (this.getTitle().equals(mContext.getResources().getString(R.string.deck_conf_remove))) {
                // Deck Options :: Remove Options Group
                Editor editor = AnkiDroidApp.getSharedPrefs(mContext).edit();
                editor.putBoolean("confRemove", true);
                editor.commit();
            } else if (this.getTitle().equals(mContext.getResources().getString(R.string.deck_conf_set_subdecks))) {
                // Deck Options :: Set Options Group for all Sub-decks
                Editor editor = AnkiDroidApp.getSharedPrefs(mContext).edit();
                editor.putBoolean("confSetSubdecks", true);
                editor.commit();
            } else {
                // Main Preferences :: Reset Languages
                if (MetaDB.resetLanguages(mContext)) {
                    Toast successReport = Toast.makeText(this.getContext(),
                            AnkiDroidApp.getAppResources().getString(R.string.reset_confirmation), Toast.LENGTH_SHORT);
                    successReport.show();
                }
            }
        }
    }

}
/****************************************************************************************
 * Copyright (c) 2013 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.preferences;

import android.content.Context;
import android.preference.EditTextPreference;
import android.text.InputFilter;
import android.text.InputType;
import android.text.TextUtils;
import android.util.AttributeSet;

import com.ichi2.anki.AnkiDroidApp;

public class NumberRangePreference extends EditTextPreference {

    private final int mMin;
    private final int mMax;


    public NumberRangePreference(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        mMin = getMinFromAttributes(attrs);
        mMax = getMaxFromAttributes(attrs);
        updateSettings();
    }


    public NumberRangePreference(Context context, AttributeSet attrs) {
        super(context, attrs);
        mMin = getMinFromAttributes(attrs);
        mMax = getMaxFromAttributes(attrs);
        updateSettings();
    }


    public NumberRangePreference(Context context) {
        super(context);
        mMin = getMinFromAttributes(null);
        mMax = getMaxFromAttributes(null);
        updateSettings();
    }


    @Override
    protected void onDialogClosed(boolean positiveResult) {
        if (positiveResult) {
            int validated = getValidatedRangeFromString(getEditText().getText().toString());
            setValue(validated);
        }
    }


    /*
     * Since this preference deals with integers only, it makes sense to only store and retrieve integers. However,
     * since it is extending EditTextPreference, the persistence and retrieval methods that are called are for a String
     * type. The two methods below intercept the persistence and retrieval methods for Strings and replaces them with
     * their Integer equivalents.
     */

    @Override
    protected String getPersistedString(String defaultReturnValue) {
        return String.valueOf(getPersistedInt(mMin));
    }


    @Override
    protected boolean persistString(String value) {
        return persistInt(Integer.valueOf(value));
    }


    /**
     * Return the string as an int with the number rounded to the nearest bound if it is outside of the acceptable
     * range.
     * 
     * @param input User input in text editor.
     * @return The input value within acceptable range.
     */
    private int getValidatedRangeFromString(String input) {
        if (TextUtils.isEmpty(input)) {
            return mMin;
        } else {
            try {
                return getValidatedRangeFromInt(Integer.parseInt(input));
            } catch (NumberFormatException e) {
                return mMin;
            }
        }
    }


    /**
     * Return the integer rounded to the nearest bound if it is outside of the acceptable range.
     * 
     * @param input Integer to validate.
     * @return The input value within acceptable range.
     */
    private int getValidatedRangeFromInt(int input) {
        if (input < mMin) {
            input = mMin;
        } else if (input > mMax) {
            input = mMax;
        }
        return input;
    }


    /**
     * Returns the value of the min attribute, or its default value if not specified
     * <p>
     * This method should only be called once from the constructor.
     */
    private int getMinFromAttributes(AttributeSet attrs) {
        return attrs == null ? 0 : attrs.getAttributeIntValue(AnkiDroidApp.XML_CUSTOM_NAMESPACE, "min", 0);
    }


    /**
     * Returns the value of the max attribute, or its default value if not specified
     * <p>
     * This method should only be called once from the constructor.
     */
    private int getMaxFromAttributes(AttributeSet attrs) {
        return attrs == null ? Integer.MAX_VALUE : attrs.getAttributeIntValue(AnkiDroidApp.XML_CUSTOM_NAMESPACE, "max",
                Integer.MAX_VALUE);
    }


    /**
     * Update settings to only allow integer input and set the maximum number of digits allowed in the text field based
     * on the current value of the {@link #mMax} field.
     * <p>
     * This method should only be called once from the constructor.
     */
    private void updateSettings() {
        // Only allow integer input
        getEditText().setInputType(InputType.TYPE_CLASS_NUMBER);

        // Set max number of digits
        int maxLength = String.valueOf(mMax).length();
        // Clone the existing filters so we don't override them, then append our one at the end.
        InputFilter[] filters = getEditText().getFilters();
        InputFilter[] newFilters = new InputFilter[filters.length + 1];
        System.arraycopy(filters, 0, newFilters, 0, filters.length);
        newFilters[newFilters.length - 1] = new InputFilter.LengthFilter(maxLength);
        getEditText().setFilters(newFilters);
    }


    /**
     * Get the persisted value held by this preference.
     * 
     * @return the persisted value.
     */
    public int getValue() {
        return getPersistedInt(mMin);
    }


    /**
     * Set this preference's value. The value is validated and persisted as an Integer.
     * 
     * @param value to set.
     */
    public void setValue(int value) {
        int validated = getValidatedRangeFromInt(value);
        setText(Integer.toString(validated));
        persistInt(validated);
    }
}
/****************************************************************************************
 * Copyright (c) 2013 Houssam Salem <houssam.salem.au@gmail.com>                        *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.preferences;

import android.content.Context;
import android.preference.EditTextPreference;
import android.text.InputType;
import android.text.TextUtils;
import android.util.AttributeSet;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.R;
import com.ichi2.anki.UIUtils;

import org.json.JSONArray;
import org.json.JSONException;

public class StepsPreference extends EditTextPreference {

    private final boolean mAllowEmpty;


    public StepsPreference(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        mAllowEmpty = getAllowEmptyFromAttributes(attrs);
        updateSettings();
    }


    public StepsPreference(Context context, AttributeSet attrs) {
        super(context, attrs);
        mAllowEmpty = getAllowEmptyFromAttributes(attrs);
        updateSettings();
    }


    public StepsPreference(Context context) {
        super(context);
        mAllowEmpty = getAllowEmptyFromAttributes(null);
        updateSettings();
    }


    /**
     * Update settings to show a numeric keyboard instead of the default keyboard.
     * <p>
     * This method should only be called once from the constructor.
     */
    private void updateSettings() {
        // Use the number pad but still allow normal text for spaces and decimals.
        getEditText().setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_CLASS_TEXT);
    }


    @Override
    protected void onDialogClosed(boolean positiveResult) {
        if (positiveResult) {
            String validated = getValidatedStepsInput(getEditText().getText().toString());
            if (validated == null) {
                UIUtils.showThemedToast(getContext(), getContext().getResources().getString(R.string.steps_error), false);
            } else if (TextUtils.isEmpty(validated) && !mAllowEmpty) {
                UIUtils.showThemedToast(getContext(), getContext().getResources().getString(R.string.steps_min_error),
                        false);
            } else {
                setText(validated);
            }
        }
    }


    /**
     * Check if the string is a valid format for steps and return that string, reformatted for better usability if
     * needed.
     * 
     * @param steps User input in text editor.
     * @return The correctly formatted string or null if the input is not valid.
     */
    private String getValidatedStepsInput(String steps) {
        JSONArray ja = convertToJSON(steps);
        if (ja == null) {
            return null;
        } else {
            StringBuilder sb = new StringBuilder();
            try {
                for (int i = 0; i < ja.length(); i++) {
                    sb.append(ja.getString(i)).append(" ");
                }
                return sb.toString().trim();
            } catch (JSONException e) {
                throw new RuntimeException(e);
            }
        }
    }


    /**
     * Convert steps format.
     * 
     * @param a JSONArray representation of steps.
     * @return The steps as a space-separated string.
     */
    public static String convertFromJSON(JSONArray a) {
        StringBuilder sb = new StringBuilder();
        try {
            for (int i = 0; i < a.length(); i++) {
                sb.append(a.getString(i)).append(" ");
            }
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return sb.toString().trim();
    }


    /**
     * Convert steps format. For better usability, rounded floats are converted to integers (e.g., 1.0 is converted to
     * 1).
     * 
     * @param steps String representation of steps.
     * @return The steps as a JSONArray or null if the steps are not valid.
     */
    public static JSONArray convertToJSON(String steps) {
        JSONArray ja = new JSONArray();
        steps = steps.trim();
        if (TextUtils.isEmpty(steps)) {
            return ja;
        }
        try {
            for (String s : steps.split("\\s+")) {
                float f = Float.parseFloat(s);
                // 0 or less is not a valid step.
                if (f <= 0) {
                    return null;
                }
                // Use whole numbers if we can (but still allow decimals)
                int i = (int) f;
                if (i == f) {
                    ja.put(i);
                } else {
                    ja.put(f);
                }
            }
        } catch (NumberFormatException e) {
            return null;
        } catch (JSONException e) {
            // Can't serialize float. Value likely too big/small.
            return null;
        }
        return ja;
    }


    private boolean getAllowEmptyFromAttributes(AttributeSet attrs) {
        if (attrs == null) {
            return true;
        }
        return attrs.getAttributeBooleanValue(AnkiDroidApp.XML_CUSTOM_NAMESPACE, "allowEmpty", true);
    }
}
package com.ichi2.preferences;

import android.content.Context;
import android.preference.DialogPreference;
import android.util.AttributeSet;
import android.view.View;
import android.widget.TimePicker;


public class TimePreference extends DialogPreference {
    public static final String DEFAULT_VALUE = "00:00";

    private TimePicker timePicker;
    private int hours;
    private int minutes;

    public TimePreference(Context context, AttributeSet attrs) {
        super(context, attrs);

        setPositiveButtonText(android.R.string.ok);
        setNegativeButtonText(android.R.string.cancel);
    }

    @Override
    protected View onCreateDialogView() {
        timePicker = new TimePicker(getContext());

        timePicker.setIs24HourView(true);

        return timePicker;
    }

    @Override
    protected void onSetInitialValue(boolean restorePersistedValue, Object defaultValue) {
        String time;

        if (restorePersistedValue) {
            if (null == defaultValue) {
                time = getPersistedString(DEFAULT_VALUE);
            } else {
                time = getPersistedString(defaultValue.toString());
            }
        } else {
            time = defaultValue.toString();
        }

        hours = parseHours(time);
        minutes = parseMinutes(time);
    }

    @Override
    protected void onBindDialogView(View view) {
        super.onBindDialogView(view);

        timePicker.setCurrentHour(hours);
        timePicker.setCurrentMinute(minutes);
    }

    @Override
    protected void onDialogClosed(boolean positiveResult) {
        super.onDialogClosed(positiveResult);

        if (positiveResult) {
            hours = timePicker.getCurrentHour();
            minutes = timePicker.getCurrentMinute();

            final String time = String.format("%1$02d:%2$02d", hours, minutes);

            if (callChangeListener(time)) {
                persistString(time);
            }
        }
    }

    public static int parseHours(String time) {
        return (Integer.parseInt(time.split(":")[0]));
    }

    public static int parseMinutes(String time) {
        return (Integer.parseInt(time.split(":")[1]));
    }
}
package com.ichi2.themes;

import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class HtmlColors {
    private static final Pattern fHtmlColorPattern = Pattern.compile(
            "((?:color|background)\\s*[=:]\\s*\"?)((?:[a-z]+|#[0-9a-f]+|rgb\\([0-9]+,\\s*[0-9],+\\s*[0-9]+\\)))([\";\\s])", Pattern.CASE_INSENSITIVE);
    private static final Pattern fShortHexColorPattern = Pattern.compile("^#([0-9a-f])([0-9a-f])([0-9a-f])$", Pattern.CASE_INSENSITIVE);
    private static final Pattern fLongHexColorPattern = Pattern.compile("^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$", Pattern.CASE_INSENSITIVE);
    private static final Pattern fRgbColorPattern = Pattern.compile("^rgb\\(([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\)$", Pattern.CASE_INSENSITIVE);
    private static final Pattern fClozeStylePattern = Pattern.compile("(.cloze\\s*\\{[^}]*color:\\s*#)[0-9a-f]{6}(;[^}]*\\})", Pattern.CASE_INSENSITIVE);
    private static final Pattern fDiffStylePattern = Pattern.compile("");

    public static String nameToHex(String name) {
        if (sColorsMap == null) {
            sColorsMap = new HashMap<>();
            for (int i = 0; i < fColorsRawList.length; i+=2) {
                sColorsMap.put(fColorsRawList[i].toLowerCase(Locale.US), fColorsRawList[i+1].toLowerCase(Locale.US));
            }
        }
        name = name.toLowerCase(Locale.US);
        if (sColorsMap.containsKey(name)) {
            return sColorsMap.get(name);
        }
        return name;
    }
    /**
     * Returns a string where all colors have been inverted. It applies to anything that is in a tag and looks like
     * #FFFFFF Example: Here only #000000 will be replaced (#777777 is content) <span style="color: #000000;">Code
     * #777777 is the grey color</span> This is done with a state machine with 2 states: - 0: within content - 1: within
     * a tag
     */
    public static String invertColors(String text) {
        StringBuffer sb = new StringBuffer();
        Matcher m1 = fHtmlColorPattern.matcher(text);
        while (m1.find()) {
            // Convert names to hex
            String color = HtmlColors.nameToHex(m1.group(2));
            Matcher m2 = null;
            try {
                if (color.length() == 4 && color.charAt(0) == '#') {
                    m2 = fShortHexColorPattern.matcher(color);
                    if (m2.find()) {
                        color = String.format(Locale.US, "#%x%x%x",
                                0xf - Integer.parseInt(m2.group(1), 16),
                                0xf - Integer.parseInt(m2.group(2), 16),
                                0xf - Integer.parseInt(m2.group(3), 16));
                    }
                } else if (color.length() == 7 && color.charAt(0) == '#') {
                    m2 = fLongHexColorPattern.matcher(color);
                    if (m2.find()) {
                        color = String.format(Locale.US, "#%02x%02x%02x",
                                0xff - Integer.parseInt(m2.group(1), 16),
                                0xff - Integer.parseInt(m2.group(2), 16),
                                0xff - Integer.parseInt(m2.group(3), 16));
                    }
                } else if (color.length() > 9 && color.toLowerCase(Locale.US).startsWith("rgb")) {
                    m2 = fRgbColorPattern.matcher(color);
                    if (m2.find()) {
                        color = String.format(Locale.US, "rgb(%d, %d, %d)",
                                0xff - Integer.parseInt(m2.group(1)),
                                0xff - Integer.parseInt(m2.group(2)),
                                0xff - Integer.parseInt(m2.group(3)));
                    }
                }
            } catch (NumberFormatException e) {
                // shouldn't happen but ignore anyway
            }
            m1.appendReplacement(sb, m1.group(1) + color + m1.group(3));
        }
        m1.appendTail(sb);
        String invertedText = sb.toString();
        // fix style for cloze to light blue instead of inverted blue which ends up as yellow
        Matcher mc = fClozeStylePattern.matcher(invertedText);
        invertedText = mc.replaceAll("$10088ff$2");

        return invertedText;
    }

    private static Map<String, String> sColorsMap = null;
    private static final String[] fColorsRawList= new String[]{
    "AliceBlue", "#F0F8FF",
    "AntiqueWhite", "#FAEBD7",
    "Aqua", "#00FFFF",
    "Aquamarine", "#7FFFD4",
    "Azure", "#F0FFFF",
    "Beige", "#F5F5DC",
    "Bisque", "#FFE4C4",
    "Black", "#000000",
    "BlanchedAlmond", "#FFEBCD",
    "Blue", "#0000FF",
    "BlueViolet", "#8A2BE2",
    "Brown", "#A52A2A",
    "BurlyWood", "#DEB887",
    "CadetBlue", "#5F9EA0",
    "Chartreuse", "#7FFF00",
    "Chocolate", "#D2691E",
    "Coral", "#FF7F50",
    "CornflowerBlue", "#6495ED",
    "Cornsilk", "#FFF8DC",
    "Crimson", "#DC143C",
    "Cyan", "#00FFFF",
    "DarkBlue", "#00008B",
    "DarkCyan", "#008B8B",
    "DarkGoldenRod", "#B8860B",
    "DarkGray", "#A9A9A9",
    "DarkGrey", "#A9A9A9",
    "DarkGreen", "#006400",
    "DarkKhaki", "#BDB76B",
    "DarkMagenta", "#8B008B",
    "DarkOliveGreen", "#556B2F",
    "Darkorange", "#FF8C00",
    "DarkOrchid", "#9932CC",
    "DarkRed", "#8B0000",
    "DarkSalmon", "#E9967A",
    "DarkSeaGreen", "#8FBC8F",
    "DarkSlateBlue", "#483D8B",
    "DarkSlateGray", "#2F4F4F",
    "DarkSlateGrey", "#2F4F4F",
    "DarkTurquoise", "#00CED1",
    "DarkViolet", "#9400D3",
    "DeepPink", "#FF1493",
    "DeepSkyBlue", "#00BFFF",
    "DimGray", "#696969",
    "DimGrey", "#696969",
    "DodgerBlue", "#1E90FF",
    "FireBrick", "#B22222",
    "FloralWhite", "#FFFAF0",
    "ForestGreen", "#228B22",
    "Fuchsia", "#FF00FF",
    "Gainsboro", "#DCDCDC",
    "GhostWhite", "#F8F8FF",
    "Gold", "#FFD700",
    "GoldenRod", "#DAA520",
    "Gray", "#808080",
    "Grey", "#808080",
    "Green", "#008000",
    "GreenYellow", "#ADFF2F",
    "HoneyDew", "#F0FFF0",
    "HotPink", "#FF69B4",
    "IndianRed", "#CD5C5C",
    "Indigo", "#4B0082",
    "Ivory", "#FFFFF0",
    "Khaki", "#F0E68C",
    "Lavender", "#E6E6FA",
    "LavenderBlush", "#FFF0F5",
    "LawnGreen", "#7CFC00",
    "LemonChiffon", "#FFFACD",
    "LightBlue", "#ADD8E6",
    "LightCoral", "#F08080",
    "LightCyan", "#E0FFFF",
    "LightGoldenRodYellow", "#FAFAD2",
    "LightGray", "#D3D3D3",
    "LightGrey", "#D3D3D3",
    "LightGreen", "#90EE90",
    "LightPink", "#FFB6C1",
    "LightSalmon", "#FFA07A",
    "LightSeaGreen", "#20B2AA",
    "LightSkyBlue", "#87CEFA",
    "LightSlateGray", "#778899",
    "LightSlateGrey", "#778899",
    "LightSteelBlue", "#B0C4DE",
    "LightYellow", "#FFFFE0",
    "Lime", "#00FF00",
    "LimeGreen", "#32CD32",
    "Linen", "#FAF0E6",
    "Magenta", "#FF00FF",
    "Maroon", "#800000",
    "MediumAquaMarine", "#66CDAA",
    "MediumBlue", "#0000CD",
    "MediumOrchid", "#BA55D3",
    "MediumPurple", "#9370D8",
    "MediumSeaGreen", "#3CB371",
    "MediumSlateBlue", "#7B68EE",
    "MediumSpringGreen", "#00FA9A",
    "MediumTurquoise", "#48D1CC",
    "MediumVioletRed", "#C71585",
    "MidnightBlue", "#191970",
    "MintCream", "#F5FFFA",
    "MistyRose", "#FFE4E1",
    "Moccasin", "#FFE4B5",
    "NavajoWhite", "#FFDEAD",
    "Navy", "#000080",
    "OldLace", "#FDF5E6",
    "Olive", "#808000",
    "OliveDrab", "#6B8E23",
    "Orange", "#FFA500",
    "OrangeRed", "#FF4500",
    "Orchid", "#DA70D6",
    "PaleGoldenRod", "#EEE8AA",
    "PaleGreen", "#98FB98",
    "PaleTurquoise", "#AFEEEE",
    "PaleVioletRed", "#D87093",
    "PapayaWhip", "#FFEFD5",
    "PeachPuff", "#FFDAB9",
    "Peru", "#CD853F",
    "Pink", "#FFC0CB",
    "Plum", "#DDA0DD",
    "PowderBlue", "#B0E0E6",
    "Purple", "#800080",
    "Red", "#FF0000",
    "RosyBrown", "#BC8F8F",
    "RoyalBlue", "#4169E1",
    "SaddleBrown", "#8B4513",
    "Salmon", "#FA8072",
    "SandyBrown", "#F4A460",
    "SeaGreen", "#2E8B57",
    "SeaShell", "#FFF5EE",
    "Sienna", "#A0522D",
    "Silver", "#C0C0C0",
    "SkyBlue", "#87CEEB",
    "SlateBlue", "#6A5ACD",
    "SlateGray", "#708090",
    "SlateGrey", "#708090",
    "Snow", "#FFFAFA",
    "SpringGreen", "#00FF7F",
    "SteelBlue", "#4682B4",
    "Tan", "#D2B48C",
    "Teal", "#008080",
    "Thistle", "#D8BFD8",
    "Tomato", "#FF6347",
    "Turquoise", "#40E0D0",
    "Violet", "#EE82EE",
    "Wheat", "#F5DEB3",
    "White", "#FFFFFF",
    "WhiteSmoke", "#F5F5F5",
    "Yellow", "#FFFF00",
    "YellowGreen", "#9ACD32"};
}
/****************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * based on custom Dialog windows by antoine vianey                                     *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.themes;

import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.view.WindowManager.BadTokenException;

import com.afollestad.materialdialogs.MaterialDialog;
import com.ichi2.anki.AnkiActivity;

import timber.log.Timber;

public class StyledProgressDialog extends Dialog {

    private Context mContext;


    public StyledProgressDialog(Context context) {
        super(context);
        mContext = context;
    }


    @Override
    public void show() {
        try {
            setCanceledOnTouchOutside(false);
            super.show();
        } catch (BadTokenException e) {
            Timber.e(e, "Could not show dialog");
        }
    }


    public static MaterialDialog show(Context context, CharSequence title, CharSequence message) {
        return show(context, title, message, false, null);
    }


    public static MaterialDialog show(Context context, CharSequence title, CharSequence message,
            boolean cancelable) {
        return show(context, title, message, cancelable, null);
    }


    public static MaterialDialog show(Context context, CharSequence title, CharSequence message,
            boolean cancelable, DialogInterface.OnCancelListener cancelListener) {
        return new MaterialDialog.Builder(context)
                .title(title)
                .content(message)
                .progress(true, 0)
                .cancelable(cancelable)
                .cancelListener(cancelListener)
                .show();
    }


    private static boolean animationEnabled(Context context) {
        if (context instanceof AnkiActivity) {
            return ((AnkiActivity) context).animationEnabled();
        } else {
            return true;
        }
    }

    public void setMax(int max) {
        // TODO
    }


    public void setProgress(int progress) {
        // TODO
    }


    public void setProgressStyle(int style) {
        // TODO
    }

}
/***************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 * Copyright (c) 2015 Timothy Rae <perceptualchaos2@gmail.com>                          *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.themes;


import android.content.Context;
import android.content.SharedPreferences;
import android.content.res.TypedArray;
import android.support.v4.content.ContextCompat;
import android.widget.Toast;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.R;

public class Themes {
    public final static int ALPHA_ICON_ENABLED_LIGHT = 255; // 100%
    public final static int ALPHA_ICON_DISABLED_LIGHT = 76; // 31%
    public final static int ALPHA_ICON_ENABLED_DARK = 138; // 54%

    // Day themes
    private final static int THEME_DAY_LIGHT = 0;
    private final static int THEME_DAY_PLAIN = 1;
    // Night themes
    private final static int THEME_NIGHT_BLACK = 0;
    private final static int THEME_NIGHT_DARK = 1;


    public static void setTheme(Context context) {
        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(context.getApplicationContext());
        if (prefs.getBoolean("invertedColors", false)) {
            int theme = Integer.parseInt(prefs.getString("nightTheme", "0"));
            switch (theme) {
                case THEME_NIGHT_DARK:
                    context.setTheme(R.style.Theme_Dark_Compat);
                    break;
                case THEME_NIGHT_BLACK:
                    context.setTheme(R.style.Theme_Black_Compat);
                    break;
            }
        } else {
            int theme = Integer.parseInt(prefs.getString("dayTheme", "0"));
            switch (theme) {
                case THEME_DAY_LIGHT:
                    context.setTheme(R.style.Theme_Light_Compat);
                    break;
                case THEME_DAY_PLAIN:
                    context.setTheme(R.style.Theme_Plain_Compat);
                    break;
            }
        }
    }

    public static void setThemeLegacy(Context context) {
        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(context.getApplicationContext());
        if (prefs.getBoolean("invertedColors", false)) {
            int theme = Integer.parseInt(prefs.getString("nightTheme", "0"));
            switch (theme) {
                case THEME_NIGHT_DARK:
                    context.setTheme(R.style.LegacyActionBarDark);
                    break;
                case THEME_NIGHT_BLACK:
                    context.setTheme(R.style.LegacyActionBarBlack);
                    break;
            }
        } else {
            int theme = Integer.parseInt(prefs.getString("dayTheme", "0"));
            switch (theme) {
                case THEME_DAY_LIGHT:
                    context.setTheme(R.style.LegacyActionBarLight);
                    break;
                case THEME_DAY_PLAIN:
                    context.setTheme(R.style.LegacyActionBarPlain);
                    break;
            }
        }
    }


    public static int getResFromAttr(Context context, int resAttr) {
        int[] attrs = new int[] {resAttr};
        return getResFromAttr(context, attrs)[0];
    }

    public static int[] getResFromAttr(Context context, int[] attrs) {
        TypedArray ta = context.obtainStyledAttributes(attrs);
        for (int i = 0; i < attrs.length; i++) {
            attrs[i] = ta.getResourceId(i, 0);
        }
        ta.recycle();
        return attrs;
    }

    public static int getColorFromAttr(Context context, int colorAttr) {
        int[] attrs = new int[] {colorAttr};
        return getColorFromAttr(context, attrs)[0];
    }


    public static int[] getColorFromAttr(Context context, int[] attrs) {
        TypedArray ta = context.obtainStyledAttributes(attrs);
        for (int i = 0; i < attrs.length; i++) {
            attrs[i] = ta.getColor(i, ContextCompat.getColor(context, R.color.white));
        }
        ta.recycle();
        return attrs;
    }

    /**
     * Return the current integer code of the theme being used, taking into account
     * whether we are in day mode or night mode.
     */
    public static int getCurrentTheme(Context context) {
        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(context);
        if (prefs.getBoolean("invertedColors", false)) {
            return Integer.parseInt(prefs.getString("nightTheme", "0"));
        } else {
            return Integer.parseInt(prefs.getString("dayTheme", "0"));
        }
    }
}
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ichi2.ui;

import android.content.res.Configuration;
import android.os.Bundle;
import android.preference.PreferenceActivity;
import android.support.annotation.LayoutRes;
import android.support.annotation.Nullable;
import android.support.v7.app.ActionBar;
import android.support.v7.app.AppCompatDelegate;
import android.support.v7.widget.Toolbar;
import android.view.MenuInflater;
import android.view.View;
import android.view.ViewGroup;

/**
 * A {@link android.preference.PreferenceActivity} which implements and proxies the necessary calls
 * to be used with AppCompat.
 *
 * This technique can be used with an {@link android.app.Activity} class, not just
 * {@link android.preference.PreferenceActivity}.
 */
public abstract class AppCompatPreferenceActivity extends PreferenceActivity {

    private AppCompatDelegate mDelegate;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        getDelegate().installViewFactory();
        getDelegate().onCreate(savedInstanceState);
        super.onCreate(savedInstanceState);
    }

    @Override
    protected void onPostCreate(Bundle savedInstanceState) {
        super.onPostCreate(savedInstanceState);
        getDelegate().onPostCreate(savedInstanceState);
    }

    public ActionBar getSupportActionBar() {
        return getDelegate().getSupportActionBar();
    }

    public void setSupportActionBar(@Nullable Toolbar toolbar) {
        getDelegate().setSupportActionBar(toolbar);
    }

    @Override
    public MenuInflater getMenuInflater() {
        return getDelegate().getMenuInflater();
    }

    @Override
    public void setContentView(@LayoutRes int layoutResID) {
        getDelegate().setContentView(layoutResID);
    }

    @Override
    public void setContentView(View view) {
        getDelegate().setContentView(view);
    }

    @Override
    public void setContentView(View view, ViewGroup.LayoutParams params) {
        getDelegate().setContentView(view, params);
    }

    @Override
    public void addContentView(View view, ViewGroup.LayoutParams params) {
        getDelegate().addContentView(view, params);
    }

    @Override
    protected void onPostResume() {
        super.onPostResume();
        getDelegate().onPostResume();
    }

    @Override
    protected void onTitleChanged(CharSequence title, int color) {
        super.onTitleChanged(title, color);
        getDelegate().setTitle(title);
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        getDelegate().onConfigurationChanged(newConfig);
    }

    @Override
    protected void onStop() {
        super.onStop();
        getDelegate().onStop();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        getDelegate().onDestroy();
    }

    public void invalidateOptionsMenu() {
        getDelegate().invalidateOptionsMenu();
    }

    private AppCompatDelegate getDelegate() {
        if (mDelegate == null) {
            mDelegate = AppCompatDelegate.create(this, null);
        }
        return mDelegate;
    }
}package com.ichi2.ui;

import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.drawable.Drawable;
import android.support.v7.widget.RecyclerView;
import android.view.View;

import com.ichi2.anki.R;

/**
 * Copied and modified from http://stackoverflow.com/questions/24618829/27037230#27037230
 */

public class DividerItemDecoration extends RecyclerView.ItemDecoration {

    private Drawable mDivider;

    public DividerItemDecoration(Context context) {
        int[] attrs = new int[] { R.attr.deckDivider };
        TypedArray ta = context.obtainStyledAttributes(attrs);
        mDivider = ta.getDrawable(0);
        ta.recycle();
    }

    @Override
    public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) {
        int left = parent.getPaddingLeft();
        int right = parent.getWidth() - parent.getPaddingRight();

        int childCount = parent.getChildCount();
        for (int i = 0; i < childCount; i++) {
            View child = parent.getChildAt(i);

            RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();

            int top = child.getBottom() + params.bottomMargin;
            int bottom = top + mDivider.getIntrinsicHeight();

            mDivider.setBounds(left, top, right, bottom);
            mDivider.draw(c);
        }
    }
}/* The following code was written by Matthew Wiggins
 * and is released under the APACHE 2.0 license
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * adjusted by Norbert Nagold 2011 <norbert.nagold@gmail.com>
 */

package com.ichi2.ui;

import android.app.AlertDialog;
import android.content.Context;
import android.preference.DialogPreference;
import android.util.AttributeSet;
import android.view.Gravity;
import android.view.View;
import android.widget.LinearLayout;
import android.widget.SeekBar;
import android.widget.TextView;

import com.ichi2.anki.AnkiDroidApp;

public class SeekBarPreference extends DialogPreference implements SeekBar.OnSeekBarChangeListener {
    private static final String androidns = "http://schemas.android.com/apk/res/android";

    private SeekBar mSeekBar;
    private TextView mValueText;
    private Context mContext;

    private String mSuffix;
    private int mDefault, mMax, mMin, mInterval, mValue = 0;


    public SeekBarPreference(Context context, AttributeSet attrs) {
        super(context, attrs);
        mContext = context;

        mSuffix = attrs.getAttributeValue(androidns, "text");
        mDefault = attrs.getAttributeIntValue(androidns, "defaultValue", 0);
        mMax = attrs.getAttributeIntValue(androidns, "max", 100);
        mMin = attrs.getAttributeIntValue(AnkiDroidApp.XML_CUSTOM_NAMESPACE, "min", 0);
        mInterval = attrs.getAttributeIntValue(AnkiDroidApp.XML_CUSTOM_NAMESPACE, "interval", 1);
    }


    @Override
    protected View onCreateDialogView() {
        LinearLayout.LayoutParams params;
        LinearLayout layout = new LinearLayout(mContext);
        layout.setOrientation(LinearLayout.VERTICAL);
        layout.setPadding(6, 6, 6, 6);

        mValueText = new TextView(mContext);
        mValueText.setGravity(Gravity.CENTER_HORIZONTAL);
        mValueText.setTextSize(32);
        params = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT);
        layout.addView(mValueText, params);

        mSeekBar = new SeekBar(mContext);
        mSeekBar.setOnSeekBarChangeListener(this);

        layout.addView(mSeekBar, new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT));

        if (shouldPersist()) {
            mValue = getPersistedInt(mDefault);
        }

        mSeekBar.setMax((mMax - mMin) / mInterval);
        mSeekBar.setProgress((mValue - mMin) / mInterval);

        String t = String.valueOf(mValue);
        mValueText.setText(mSuffix == null ? t : t.concat(mSuffix));
        return layout;
    }


    @Override
    protected void onBindDialogView(View v) {
        super.onBindDialogView(v);
        mSeekBar.setMax((mMax - mMin) / mInterval);
        mSeekBar.setProgress((mValue - mMin) / mInterval);
    }


    @Override
    protected void onSetInitialValue(boolean restore, Object defaultValue) {
        super.onSetInitialValue(restore, defaultValue);
        mValue = getPersistedInt(mDefault);
        if (restore) {
            mValue = shouldPersist() ? getPersistedInt(mDefault) : 0;
        } else {
            mValue = (Integer) defaultValue;
        }
    }


    public void onProgressChanged(SeekBar seek, int value, boolean fromTouch) {
        if (fromTouch) {
            mValue = (value * mInterval) + mMin;
            String t = String.valueOf(mValue);
            mValueText.setText(mSuffix == null ? t : t.concat(mSuffix));
        }
    }


    public int getValue() {
        if (mValue == 0) {
            return getPersistedInt(mDefault);
        } else {
            return mValue;
        }
    }

    public void setValue(int value) {
        mValue = value;
        persistInt(value);
    }

    public void onStartTrackingTouch(SeekBar seek) {
    }


    public void onStopTrackingTouch(SeekBar seek) {
        if (shouldPersist()) {
            persistInt(mValue);
        }
        callChangeListener(mValue);
        this.getDialog().dismiss();
    }


    @Override
    protected void onPrepareDialogBuilder(AlertDialog.Builder builder) {
        super.onPrepareDialogBuilder(builder);
        builder.setNegativeButton(null, null);
        builder.setPositiveButton(null, null);
        builder.setTitle(null);
    }
}
/*
 * Copyright (C) 2013 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 
package com.ichi2.ui;
 
import android.annotation.SuppressLint;
import android.content.Context;
import android.graphics.Typeface;
import android.os.Build;
import android.support.v4.view.PagerAdapter;
import android.support.v4.view.ViewPager;
import android.util.AttributeSet;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.HorizontalScrollView;
import android.widget.TextView;
 
/**
 * To be used with ViewPager to provide a tab indicator component which give constant feedback as to
 * the user's scroll progress.
 * <p>
 * To use the component, simply add it to your view hierarchy. Then in your
 * {@link android.app.Activity} or {@link android.support.v4.app.Fragment} call
 * {@link #setViewPager(ViewPager)} providing it the ViewPager this layout is being used for.
 * <p>
 * The colors can be customized in two ways. The first and simplest is to provide an array of colors
 * via {@link #setSelectedIndicatorColors(int...)} and {@link #setDividerColors(int...)}. The
 * alternative is via the {@link TabColorizer} interface which provides you complete control over
 * which color is used for any individual position.
 * <p>
 * The views used as tabs can be customized by calling {@link #setCustomTabView(int, int)},
 * providing the layout ID of your custom layout.
 */
public class SlidingTabLayout extends HorizontalScrollView {
 
    /**
     * Allows complete control over the colors drawn in the tab layout. Set with
     * {@link #setCustomTabColorizer(TabColorizer)}.
     */
    public interface TabColorizer {
 
        /**
         * @return return the color of the indicator used when {@code position} is selected.
         */
        int getIndicatorColor(int position);
 
        /**
         * @return return the color of the divider drawn to the right of {@code position}.
         */
        int getDividerColor(int position);
 
    }
 
    private static final int TITLE_OFFSET_DIPS = 24;
    private static final int TAB_VIEW_PADDING_DIPS = 16;
    private static final int TAB_VIEW_TEXT_SIZE_SP = 12;
 
    private int mTitleOffset;
 
    private int mTabViewLayoutId;
    private int mTabViewTextViewId;
 
    private ViewPager mViewPager;
    private ViewPager.OnPageChangeListener mViewPagerPageChangeListener;
 
    private final SlidingTabStrip mTabStrip;
 
    public SlidingTabLayout(Context context) {
        this(context, null);
    }
 
    public SlidingTabLayout(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }
 
    public SlidingTabLayout(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
 
        // Disable the Scroll Bar
        setHorizontalScrollBarEnabled(false);
        // Make sure that the Tab Strips fills this View
        setFillViewport(true);
 
        mTitleOffset = (int) (TITLE_OFFSET_DIPS * getResources().getDisplayMetrics().density);
 
        mTabStrip = new SlidingTabStrip(context);
        addView(mTabStrip, LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
    }
 
    /**
     * Set the custom {@link TabColorizer} to be used.
     *
     * If you only require simple custmisation then you can use
     * {@link #setSelectedIndicatorColors(int...)} and {@link #setDividerColors(int...)} to achieve
     * similar effects.
     */
    public void setCustomTabColorizer(TabColorizer tabColorizer) {
        mTabStrip.setCustomTabColorizer(tabColorizer);
    }
 
    /**
     * Sets the colors to be used for indicating the selected tab. These colors are treated as a
     * circular array. Providing one color will mean that all tabs are indicated with the same color.
     */
    public void setSelectedIndicatorColors(int... colors) {
        mTabStrip.setSelectedIndicatorColors(colors);
    }
 
    /**
     * Sets the colors to be used for tab dividers. These colors are treated as a circular array.
     * Providing one color will mean that all tabs are indicated with the same color.
     */
    public void setDividerColors(int... colors) {
        mTabStrip.setDividerColors(colors);
    }
 
    /**
     * Set the {@link ViewPager.OnPageChangeListener}. When using {@link SlidingTabLayout} you are
     * required to set any {@link ViewPager.OnPageChangeListener} through this method. This is so
     * that the layout can update it's scroll position correctly.
     *
     * @see ViewPager#setOnPageChangeListener(ViewPager.OnPageChangeListener)
     */
    public void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) {
        mViewPagerPageChangeListener = listener;
    }
 
    /**
     * Set the custom layout to be inflated for the tab views.
     *
     * @param layoutResId Layout id to be inflated
     * @param textViewId id of the {@link TextView} in the inflated view
     */
    public void setCustomTabView(int layoutResId, int textViewId) {
        mTabViewLayoutId = layoutResId;
        mTabViewTextViewId = textViewId;
    }
 
    /**
     * Sets the associated view pager. Note that the assumption here is that the pager content
     * (number of tabs and tab titles) does not change after this call has been made.
     */
    public void setViewPager(ViewPager viewPager) {
        mTabStrip.removeAllViews();
 
        mViewPager = viewPager;
        if (viewPager != null) {
            viewPager.setOnPageChangeListener(new InternalViewPagerListener());
            populateTabStrip();
        }
    }
 
    /**
     * Create a default view to be used for tabs. This is called if a custom tab view is not set via
     * {@link #setCustomTabView(int, int)}.
     */
    @SuppressLint("NewApi")
	protected TextView createDefaultTabView(Context context) {
        TextView textView = new TextView(context);
        textView.setGravity(Gravity.CENTER);
        textView.setTextSize(TypedValue.COMPLEX_UNIT_SP, TAB_VIEW_TEXT_SIZE_SP);
        textView.setTypeface(Typeface.DEFAULT_BOLD);
 
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
            // If we're running on Honeycomb or newer, then we can use the Theme's
            // selectableItemBackground to ensure that the View has a pressed state
            TypedValue outValue = new TypedValue();
            getContext().getTheme().resolveAttribute(android.R.attr.selectableItemBackground,
                    outValue, true);
            textView.setBackgroundResource(outValue.resourceId);
        }
 
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
            // If we're running on ICS or newer, enable all-caps to match the Action Bar tab style
            textView.setAllCaps(true);
        }
 
        int padding = (int) (TAB_VIEW_PADDING_DIPS * getResources().getDisplayMetrics().density);
        textView.setPadding(padding, padding, padding, padding);
 
        return textView;
    }
 
    private void populateTabStrip() {
        final PagerAdapter adapter = mViewPager.getAdapter();
        final View.OnClickListener tabClickListener = new TabClickListener();
 
        for (int i = 0; i < adapter.getCount(); i++) {
            View tabView = null;
            TextView tabTitleView = null;
 
            if (mTabViewLayoutId != 0) {
                // If there is a custom tab view layout id set, try and inflate it
                tabView = LayoutInflater.from(getContext()).inflate(mTabViewLayoutId, mTabStrip,
                        false);
                tabTitleView = (TextView) tabView.findViewById(mTabViewTextViewId);
            }
 
            if (tabView == null) {
                tabView = createDefaultTabView(getContext());
            }
 
            if (tabTitleView == null && TextView.class.isInstance(tabView)) {
                tabTitleView = (TextView) tabView;
            }
 
            tabTitleView.setText(adapter.getPageTitle(i));
            tabView.setOnClickListener(tabClickListener);
 
            mTabStrip.addView(tabView);
        }
    }
 
    @Override
    protected void onAttachedToWindow() {
        super.onAttachedToWindow();
 
        if (mViewPager != null) {
            scrollToTab(mViewPager.getCurrentItem(), 0);
        }
    }
 
    private void scrollToTab(int tabIndex, int positionOffset) {
        final int tabStripChildCount = mTabStrip.getChildCount();
        if (tabStripChildCount == 0 || tabIndex < 0 || tabIndex >= tabStripChildCount) {
            return;
        }
 
        View selectedChild = mTabStrip.getChildAt(tabIndex);
        if (selectedChild != null) {
            int targetScrollX = selectedChild.getLeft() + positionOffset;
 
            if (tabIndex > 0 || positionOffset > 0) {
                // If we're not at the first child and are mid-scroll, make sure we obey the offset
                targetScrollX -= mTitleOffset;
            }
 
            scrollTo(targetScrollX, 0);
        }
    }
 
    private class InternalViewPagerListener implements ViewPager.OnPageChangeListener {
        private int mScrollState;
 
        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
            int tabStripChildCount = mTabStrip.getChildCount();
            if ((tabStripChildCount == 0) || (position < 0) || (position >= tabStripChildCount)) {
                return;
            }
 
            mTabStrip.onViewPagerPageChanged(position, positionOffset);
 
            View selectedTitle = mTabStrip.getChildAt(position);
            int extraOffset = (selectedTitle != null)
                    ? (int) (positionOffset * selectedTitle.getWidth())
                    : 0;
            scrollToTab(position, extraOffset);
 
            if (mViewPagerPageChangeListener != null) {
                mViewPagerPageChangeListener.onPageScrolled(position, positionOffset,
                        positionOffsetPixels);
            }
        }
 
        @Override
        public void onPageScrollStateChanged(int state) {
            mScrollState = state;
 
            if (mViewPagerPageChangeListener != null) {
                mViewPagerPageChangeListener.onPageScrollStateChanged(state);
            }
        }
 
        @Override
        public void onPageSelected(int position) {
            if (mScrollState == ViewPager.SCROLL_STATE_IDLE) {
                mTabStrip.onViewPagerPageChanged(position, 0f);
                scrollToTab(position, 0);
            }
 
            if (mViewPagerPageChangeListener != null) {
                mViewPagerPageChangeListener.onPageSelected(position);
            }
        }
 
    }
 
    private class TabClickListener implements View.OnClickListener {
        @Override
        public void onClick(View v) {
            for (int i = 0; i < mTabStrip.getChildCount(); i++) {
                if (v == mTabStrip.getChildAt(i)) {
                    mViewPager.setCurrentItem(i);
                    return;
                }
            }
        }
    }
 
}/*
 * Copyright (C) 2013 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 
package com.ichi2.ui;
 
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.util.AttributeSet;
import android.util.TypedValue;
import android.view.View;
import android.widget.LinearLayout;
 
class SlidingTabStrip extends LinearLayout {
 
    private static final int DEFAULT_BOTTOM_BORDER_THICKNESS_DIPS = 2;
    private static final byte DEFAULT_BOTTOM_BORDER_COLOR_ALPHA = 0x26;
    private static final int SELECTED_INDICATOR_THICKNESS_DIPS = 8;
    private static final int DEFAULT_SELECTED_INDICATOR_COLOR = 0xFF33B5E5;
 
    private static final int DEFAULT_DIVIDER_THICKNESS_DIPS = 1;
    private static final byte DEFAULT_DIVIDER_COLOR_ALPHA = 0x20;
    private static final float DEFAULT_DIVIDER_HEIGHT = 0.5f;
 
    private final int mBottomBorderThickness;
    private final Paint mBottomBorderPaint;
 
    private final int mSelectedIndicatorThickness;
    private final Paint mSelectedIndicatorPaint;
 
    private final int mDefaultBottomBorderColor;
 
    private final Paint mDividerPaint;
    private final float mDividerHeight;
 
    private int mSelectedPosition;
    private float mSelectionOffset;
 
    private SlidingTabLayout.TabColorizer mCustomTabColorizer;
    private final SimpleTabColorizer mDefaultTabColorizer;
 
    SlidingTabStrip(Context context) {
        this(context, null);
    }
 
    SlidingTabStrip(Context context, AttributeSet attrs) {
        super(context, attrs);
        setWillNotDraw(false);
 
        final float density = getResources().getDisplayMetrics().density;
 
        TypedValue outValue = new TypedValue();
        context.getTheme().resolveAttribute(android.R.attr.colorForeground, outValue, true);
        final int themeForegroundColor =  outValue.data;
 
        mDefaultBottomBorderColor = setColorAlpha(themeForegroundColor,
                DEFAULT_BOTTOM_BORDER_COLOR_ALPHA);
 
        mDefaultTabColorizer = new SimpleTabColorizer();
        mDefaultTabColorizer.setIndicatorColors(DEFAULT_SELECTED_INDICATOR_COLOR);
        mDefaultTabColorizer.setDividerColors(setColorAlpha(themeForegroundColor,
                DEFAULT_DIVIDER_COLOR_ALPHA));
 
        mBottomBorderThickness = (int) (DEFAULT_BOTTOM_BORDER_THICKNESS_DIPS * density);
        mBottomBorderPaint = new Paint();
        mBottomBorderPaint.setColor(mDefaultBottomBorderColor);
 
        mSelectedIndicatorThickness = (int) (SELECTED_INDICATOR_THICKNESS_DIPS * density);
        mSelectedIndicatorPaint = new Paint();
 
        mDividerHeight = DEFAULT_DIVIDER_HEIGHT;
        mDividerPaint = new Paint();
        mDividerPaint.setStrokeWidth((int) (DEFAULT_DIVIDER_THICKNESS_DIPS * density));
    }
 
    void setCustomTabColorizer(SlidingTabLayout.TabColorizer customTabColorizer) {
        mCustomTabColorizer = customTabColorizer;
        invalidate();
    }
 
    void setSelectedIndicatorColors(int... colors) {
        // Make sure that the custom colorizer is removed
        mCustomTabColorizer = null;
        mDefaultTabColorizer.setIndicatorColors(colors);
        invalidate();
    }
 
    void setDividerColors(int... colors) {
        // Make sure that the custom colorizer is removed
        mCustomTabColorizer = null;
        mDefaultTabColorizer.setDividerColors(colors);
        invalidate();
    }
 
    void onViewPagerPageChanged(int position, float positionOffset) {
        mSelectedPosition = position;
        mSelectionOffset = positionOffset;
        invalidate();
    }
 
    @Override
    protected void onDraw(Canvas canvas) {
        final int height = getHeight();
        final int childCount = getChildCount();
        final int dividerHeightPx = (int) (Math.min(Math.max(0f, mDividerHeight), 1f) * height);
        final SlidingTabLayout.TabColorizer tabColorizer = mCustomTabColorizer != null
                ? mCustomTabColorizer
                : mDefaultTabColorizer;
 
        // Thick colored underline below the current selection
        if (childCount > 0) {
            View selectedTitle = getChildAt(mSelectedPosition);
            int left = selectedTitle.getLeft();
            int right = selectedTitle.getRight();
            int color = tabColorizer.getIndicatorColor(mSelectedPosition);
 
            if (mSelectionOffset > 0f && mSelectedPosition < (getChildCount() - 1)) {
                int nextColor = tabColorizer.getIndicatorColor(mSelectedPosition + 1);
                if (color != nextColor) {
                    color = blendColors(nextColor, color, mSelectionOffset);
                }
 
                // Draw the selection partway between the tabs
                View nextTitle = getChildAt(mSelectedPosition + 1);
                left = (int) (mSelectionOffset * nextTitle.getLeft() +
                        (1.0f - mSelectionOffset) * left);
                right = (int) (mSelectionOffset * nextTitle.getRight() +
                        (1.0f - mSelectionOffset) * right);
            }
 
            mSelectedIndicatorPaint.setColor(color);
 
            canvas.drawRect(left, height - mSelectedIndicatorThickness, right,
                    height, mSelectedIndicatorPaint);
        }
 
        // Thin underline along the entire bottom edge
        canvas.drawRect(0, height - mBottomBorderThickness, getWidth(), height, mBottomBorderPaint);
 
        // Vertical separators between the titles
        int separatorTop = (height - dividerHeightPx) / 2;
        for (int i = 0; i < childCount - 1; i++) {
            View child = getChildAt(i);
            mDividerPaint.setColor(tabColorizer.getDividerColor(i));
            canvas.drawLine(child.getRight(), separatorTop, child.getRight(),
                    separatorTop + dividerHeightPx, mDividerPaint);
        }
    }
 
    /**
     * Set the alpha value of the {@code color} to be the given {@code alpha} value.
     */
    private static int setColorAlpha(int color, byte alpha) {
        return Color.argb(alpha, Color.red(color), Color.green(color), Color.blue(color));
    }
 
    /**
     * Blend {@code color1} and {@code color2} using the given ratio.
     *
     * @param ratio of which to blend. 1.0 will return {@code color1}, 0.5 will give an even blend,
     *              0.0 will return {@code color2}.
     */
    private static int blendColors(int color1, int color2, float ratio) {
        final float inverseRation = 1f - ratio;
        float r = (Color.red(color1) * ratio) + (Color.red(color2) * inverseRation);
        float g = (Color.green(color1) * ratio) + (Color.green(color2) * inverseRation);
        float b = (Color.blue(color1) * ratio) + (Color.blue(color2) * inverseRation);
        return Color.rgb((int) r, (int) g, (int) b);
    }
 
    private static class SimpleTabColorizer implements SlidingTabLayout.TabColorizer {
        private int[] mIndicatorColors;
        private int[] mDividerColors;
 
        @Override
        public final int getIndicatorColor(int position) {
            return mIndicatorColors[position % mIndicatorColors.length];
        }
 
        @Override
        public final int getDividerColor(int position) {
            return mDividerColors[position % mDividerColors.length];
        }
 
        void setIndicatorColors(int... colors) {
            mIndicatorColors = colors;
        }
 
        void setDividerColors(int... colors) {
            mDividerColors = colors;
        }
    }
}
package com.ichi2.upgrade;

import com.ichi2.libanki.Collection;

import org.json.JSONException;
import org.json.JSONObject;

public class Upgrade {

    public static boolean upgradeJSONIfNecessary(Collection col, JSONObject conf, String name, boolean defaultValue) {
        boolean val = defaultValue;
        try {
            val = conf.getBoolean(name);
        } catch (JSONException e) {
            // workaround to repair wrong values from older libanki versions
            try {
                conf.put(name, val);
            } catch (JSONException e1) {
                // do nothing
            }
            col.save();
        }
        return val;
    }
}
/**
 * <p>Encodes and decodes to and from Base64 notation.</p>
 * <p>Homepage: <a href="http://iharder.net/base64">http://iharder.net/base64</a>.</p>
 *
 * <p>Example:</p>
 *
 * <code>String encoded = Base64.encode( myByteArray );</code>
 * <br />
 * <code>byte[] myByteArray = Base64.decode( encoded );</code>
 *
 * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass
 * several pieces of information to the encoder. In the "higher level" methods such as
 * encodeBytes( bytes, options ) the options parameter can be used to indicate such
 * things as first gzipping the bytes before encoding them, not inserting linefeeds,
 * and encoding using the URL-safe and Ordered dialects.</p>
 *
 * <p>Note, according to <a href="http://www.faqs.org/rfcs/rfc3548.html">RFC3548</a>,
 * Section 2.1, implementations should not add line feeds unless explicitly told
 * to do so. I've got Base64 set to this behavior now, although earlier versions
 * broke lines by default.</p>
 *
 * <p>The constants defined in Base64 can be OR-ed together to combine options, so you
 * might make a call like this:</p>
 *
 * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>
 * <p>to compress the data before encoding it and then making the output have newline characters.</p>
 * <p>Also...</p>
 * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>
 *
 * <p>
 * I am placing this code in the Public Domain. Do with it as you will.
 * This software comes with no guarantees or warranties but with
 * plenty of well-wishing instead!
 * Please visit <a href="http://iharder.net/base64">http://iharder.net/base64</a>
 * periodically to check for updates or to contribute improvements.
 * </p>
 *
 * @author Robert Harder
 * @author rob@iharder.net
 * @version 2.3.3
 */

package com.ichi2.utils;

public class Base64 extends Object {

    /* ******** P U B L I C F I E L D S ******** */

    /** No options specified. Value is zero. */
    public final static int NO_OPTIONS = 0;

    /** Specify encoding in first bit. Value is one. */
    public final static int ENCODE = 1;

    /** Specify decoding in first bit. Value is zero. */
    public final static int DECODE = 0;

    /** Specify that data should be gzip-compressed in second bit. Value is two. */
    public final static int GZIP = 2;

    /**
     * Specify that gzipped data should <em>not</em> be automatically gunzipped.
     */
    public final static int DONT_GUNZIP = 4;

    /** Do break lines when encoding. Value is 8. */
    public final static int DO_BREAK_LINES = 8;

    /**
     * Encode using Base64-like encoding that is URL- and Filename-safe as described in Section 4 of RFC3548: <a
     * href="http://www.faqs.org/rfcs/rfc3548.html" >http://www.faqs.org/rfcs/rfc3548.html</a>. It is important to note
     * that data encoded this way is <em>not</em> officially valid Base64, or at the very least should not be called
     * Base64 without also specifying that is was encoded using the URL- and Filename-safe dialect.
     */
    public final static int URL_SAFE = 16;

    /**
     * Encode using the special "ordered" dialect of Base64 described here: <a
     * href="http://www.faqs.org/qa/rfcc-1940.html">http://www.faqs.org/qa/rfcc- 1940.html</a>.
     */
    public final static int ORDERED = 32;

    /* ******** P R I V A T E F I E L D S ******** */

    /** Maximum line length (76) of Base64 output. */
    private final static int MAX_LINE_LENGTH = 76;

    /** The equals sign (=) as a byte. */
    private final static byte EQUALS_SIGN = (byte) '=';

    /** The new line character (\n) as a byte. */
    private final static byte NEW_LINE = (byte) '\n';

    /** Preferred encoding. */
    private final static String PREFERRED_ENCODING = "US-ASCII";

    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in
                                                    // encoding

    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in
                                                    // encoding

    /* ******** S T A N D A R D B A S E 6 4 A L P H A B E T ******** */

    /** The 64 valid Base64 values. */
    /*
     * Host platform me be something funny like EBCDIC, so we hardcode these values.
     */
    private final static byte[] _STANDARD_ALPHABET = { (byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E',
            (byte) 'F', (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K', (byte) 'L', (byte) 'M', (byte) 'N',
            (byte) 'O', (byte) 'P', (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U', (byte) 'V', (byte) 'W',
            (byte) 'X', (byte) 'Y', (byte) 'Z', (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f',
            (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j', (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
            (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't', (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x',
            (byte) 'y', (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4', (byte) '5', (byte) '6',
            (byte) '7', (byte) '8', (byte) '9', (byte) '+', (byte) '/' };

    /**
     * Translates a Base64 value to either its 6-bit reconstruction value or a negative number indicating some other
     * meaning.
     **/
    private final static byte[] _STANDARD_DECODABET = { -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 0 - 8
            -5, -5, // Whitespace: Tab and Linefeed
            -9, -9, // Decimal 11 - 12
            -5, // Whitespace: Carriage Return
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 -
                                                                // 26
            -9, -9, -9, -9, -9, // Decimal 27 - 31
            -5, // Whitespace: Space
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
            62, // Plus sign at decimal 43
            -9, -9, -9, // Decimal 44 - 46
            63, // Slash at decimal 47
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
            -9, -9, -9, // Decimal 58 - 60
            -1, // Equals sign at decimal 61
            -9, -9, -9, // Decimal 62 - 64
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through
                                                          // 'N'
            14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O'
                                                            // through 'Z'
            -9, -9, -9, -9, -9, -9, // Decimal 91 - 96
            26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a'
                                                                // through 'm'
            39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n'
                                                                // through 'z'
            -9, -9, -9, -9 // Decimal 123 - 126
    /*
     * ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 127 - 139 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal
     * 140 - 152 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 153 - 165 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, //
     * Decimal 166 - 178 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 179 - 191
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 192 - 204 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal
     * 205 - 217 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 218 - 230 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, //
     * Decimal 231 - 243 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9 // Decimal 244 - 255
     */
    };

    /* ******** U R L S A F E B A S E 6 4 A L P H A B E T ******** */

    /**
     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: <a
     * href="http://www.faqs.org/rfcs/rfc3548.html">http://www.faqs.org /rfcs/rfc3548.html</a>. Notice that the last two
     * bytes become "hyphen" and "underscore" instead of "plus" and "slash."
     */
    private final static byte[] _URL_SAFE_ALPHABET = { (byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E',
            (byte) 'F', (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K', (byte) 'L', (byte) 'M', (byte) 'N',
            (byte) 'O', (byte) 'P', (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U', (byte) 'V', (byte) 'W',
            (byte) 'X', (byte) 'Y', (byte) 'Z', (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f',
            (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j', (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
            (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't', (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x',
            (byte) 'y', (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4', (byte) '5', (byte) '6',
            (byte) '7', (byte) '8', (byte) '9', (byte) '-', (byte) '_' };

    /**
     * Used in decoding URL- and Filename-safe dialects of Base64.
     */
    private final static byte[] _URL_SAFE_DECODABET = { -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 0 - 8
            -5, -5, // Whitespace: Tab and Linefeed
            -9, -9, // Decimal 11 - 12
            -5, // Whitespace: Carriage Return
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 -
                                                                // 26
            -9, -9, -9, -9, -9, // Decimal 27 - 31
            -5, // Whitespace: Space
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
            -9, // Plus sign at decimal 43
            -9, // Decimal 44
            62, // Minus sign at decimal 45
            -9, // Decimal 46
            -9, // Slash at decimal 47
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
            -9, -9, -9, // Decimal 58 - 60
            -1, // Equals sign at decimal 61
            -9, -9, -9, // Decimal 62 - 64
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through
                                                          // 'N'
            14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O'
                                                            // through 'Z'
            -9, -9, -9, -9, // Decimal 91 - 94
            63, // Underscore at decimal 95
            -9, // Decimal 96
            26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a'
                                                                // through 'm'
            39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n'
                                                                // through 'z'
            -9, -9, -9, -9 // Decimal 123 - 126
    /*
     * ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 127 - 139 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal
     * 140 - 152 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 153 - 165 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, //
     * Decimal 166 - 178 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 179 - 191
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 192 - 204 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal
     * 205 - 217 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 218 - 230 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, //
     * Decimal 231 - 243 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9 // Decimal 244 - 255
     */
    };

    /* ******** O R D E R E D B A S E 6 4 A L P H A B E T ******** */

    /**
     * I don't get the point of this technique, but someone requested it, and it is described here: <a
     * href="http://www.faqs.org/qa/rfcc-1940.html">http:// www.faqs.org/qa/rfcc-1940.html</a>.
     */
    private final static byte[] _ORDERED_ALPHABET = { (byte) '-', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
            (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8', (byte) '9', (byte) 'A', (byte) 'B', (byte) 'C',
            (byte) 'D', (byte) 'E', (byte) 'F', (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K', (byte) 'L',
            (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P', (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
            (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z', (byte) '_', (byte) 'a', (byte) 'b', (byte) 'c',
            (byte) 'd', (byte) 'e', (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j', (byte) 'k', (byte) 'l',
            (byte) 'm', (byte) 'n', (byte) 'o', (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't', (byte) 'u',
            (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y', (byte) 'z' };

    /**
     * Used in decoding the "ordered" dialect of Base64.
     */
    private final static byte[] _ORDERED_DECODABET = { -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 0 - 8
            -5, -5, // Whitespace: Tab and Linefeed
            -9, -9, // Decimal 11 - 12
            -5, // Whitespace: Carriage Return
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 -
                                                                // 26
            -9, -9, -9, -9, -9, // Decimal 27 - 31
            -5, // Whitespace: Space
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
            -9, // Plus sign at decimal 43
            -9, // Decimal 44
            0, // Minus sign at decimal 45
            -9, // Decimal 46
            -9, // Slash at decimal 47
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, // Numbers zero through nine
            -9, -9, -9, // Decimal 58 - 60
            -1, // Equals sign at decimal 61
            -9, -9, -9, // Decimal 62 - 64
            11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, // Letters 'A'
                                                                // through 'M'
            24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, // Letters 'N'
                                                                // through 'Z'
            -9, -9, -9, -9, // Decimal 91 - 94
            37, // Underscore at decimal 95
            -9, // Decimal 96
            38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, // Letters 'a'
                                                                // through 'm'
            51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, // Letters 'n'
                                                                // through 'z'
            -9, -9, -9, -9 // Decimal 123 - 126
    /*
     * ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 127 - 139 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal
     * 140 - 152 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 153 - 165 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, //
     * Decimal 166 - 178 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 179 - 191
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 192 - 204 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal
     * 205 - 217 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 218 - 230 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, //
     * Decimal 231 - 243 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9 // Decimal 244 - 255
     */
    };


    /* ******** D E T E R M I N E W H I C H A L H A B E T ******** */

    /**
     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on the options specified. It's possible, though
     * silly, to specify ORDERED <b>and</b> URLSAFE in which case one of them will be picked, though there is no
     * guarantee as to which one will be picked.
     */
    private static byte[] getAlphabet(int options) {
        if ((options & URL_SAFE) == URL_SAFE) {
            return _URL_SAFE_ALPHABET;
        } else if ((options & ORDERED) == ORDERED) {
            return _ORDERED_ALPHABET;
        } else {
            return _STANDARD_ALPHABET;
        }
    } // end getAlphabet


    /**
     * Returns one of the _SOMETHING_DECODABET byte arrays depending on the options specified. It's possible, though
     * silly, to specify ORDERED and URL_SAFE in which case one of them will be picked, though there is no guarantee as
     * to which one will be picked.
     */
    private static byte[] getDecodabet(int options) {
        if ((options & URL_SAFE) == URL_SAFE) {
            return _URL_SAFE_DECODABET;
        } else if ((options & ORDERED) == ORDERED) {
            return _ORDERED_DECODABET;
        } else {
            return _STANDARD_DECODABET;
        }
    } // end getAlphabet


    /** Defeats instantiation. */
    private Base64() {
    }


    /* ******** E N C O D I N G M E T H O D S ******** */

    /**
     * Encodes up to the first three bytes of array <var>threeBytes</var> and returns a four-byte array in Base64
     * notation. The actual number of significant bytes in your array is given by <var>numSigBytes</var>. The array
     * <var>threeBytes</var> needs only be as big as <var>numSigBytes</var>. Code can reuse a byte array by passing a
     * four-byte array as <var>b4</var>.
     * 
     * @param b4 A reusable byte array to reduce array instantiation
     * @param threeBytes the array to convert
     * @param numSigBytes the number of significant bytes in your array
     * @return four byte array in Base64 notation.
     * @since 1.5.1
     */
    private static byte[] encode3to4(byte[] b4, byte[] threeBytes, int numSigBytes, int options) {
        encode3to4(threeBytes, 0, numSigBytes, b4, 0, options);
        return b4;
    } // end encode3to4


    /**
     * <p>
     * Encodes up to three bytes of the array <var>source</var> and writes the resulting four Base64 bytes to
     * <var>destination</var>. The source and destination arrays can be manipulated anywhere along their length by
     * specifying <var>srcOffset</var> and <var>destOffset</var>. This method does not check to make sure your arrays
     * are large enough to accomodate <var>srcOffset</var> + 3 for the <var>source</var> array or <var>destOffset</var>
     * + 4 for the <var>destination</var> array. The actual number of significant bytes in your array is given by
     * <var>numSigBytes</var>.
     * </p>
     * <p>
     * This is the lowest level of the encoding methods with all possible parameters.
     * </p>
     * 
     * @param source the array to convert
     * @param srcOffset the index where conversion begins
     * @param numSigBytes the number of significant bytes in your array
     * @param destination the array to hold the conversion
     * @param destOffset the index where output will be put
     * @return the <var>destination</var> array
     * @since 1.3
     */
    private static byte[] encode3to4(byte[] source, int srcOffset, int numSigBytes, byte[] destination, int destOffset,
            int options) {

        byte[] ALPHABET = getAlphabet(options);

        // 1 2 3
        // 01234567890123456789012345678901 Bit position
        // --------000000001111111122222222 Array position from threeBytes
        // --------| || || || | Six bit groups to index ALPHABET
        // >>18 >>12 >> 6 >> 0 Right shift necessary
        // 0x3f 0x3f 0x3f Additional AND

        // Create buffer with zero-padding if there are only one or two
        // significant bytes passed in the array.
        // We have to shift left 24 in order to flush out the 1's that appear
        // when Java treats a value as negative that is cast from a byte to an
        // int.
        int inBuff = (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0)
                | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0)
                | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);

        switch (numSigBytes) {
            case 3:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = ALPHABET[(inBuff) & 0x3f];
                return destination;

            case 2:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = EQUALS_SIGN;
                return destination;

            case 1:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = EQUALS_SIGN;
                destination[destOffset + 3] = EQUALS_SIGN;
                return destination;

            default:
                return destination;
        } // end switch
    } // end encode3to4


    /**
     * Performs Base64 encoding on the <code>raw</code> ByteBuffer, writing it to the <code>encoded</code> ByteBuffer.
     * This is an experimental feature. Currently it does not pass along any options (such as {@link #DO_BREAK_LINES} or
     * {@link #GZIP}.
     * 
     * @param raw input buffer
     * @param encoded output buffer
     * @since 2.3
     */
    public static void encode(java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded) {
        byte[] raw3 = new byte[3];
        byte[] enc4 = new byte[4];

        while (raw.hasRemaining()) {
            int rem = Math.min(3, raw.remaining());
            raw.get(raw3, 0, rem);
            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS);
            encoded.put(enc4);
        } // end input remaining
    }


    /**
     * Performs Base64 encoding on the <code>raw</code> ByteBuffer, writing it to the <code>encoded</code> CharBuffer.
     * This is an experimental feature. Currently it does not pass along any options (such as {@link #DO_BREAK_LINES} or
     * {@link #GZIP}.
     * 
     * @param raw input buffer
     * @param encoded output buffer
     * @since 2.3
     */
    public static void encode(java.nio.ByteBuffer raw, java.nio.CharBuffer encoded) {
        byte[] raw3 = new byte[3];
        byte[] enc4 = new byte[4];

        while (raw.hasRemaining()) {
            int rem = Math.min(3, raw.remaining());
            raw.get(raw3, 0, rem);
            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS);
            for (int i = 0; i < 4; i++) {
                encoded.put((char) (enc4[i] & 0xFF));
            }
        } // end input remaining
    }


    /**
     * Serializes an object and returns the Base64-encoded version of that serialized object.
     * <p>
     * As of v 2.3, if the object cannot be serialized or there is another error, the method will throw an
     * java.io.IOException. <b>This is new to v2.3!</b> In earlier versions, it just returned a null value, but in
     * retrospect that's a pretty poor way to handle it.
     * </p>
     * The object is not GZip-compressed before being encoded.
     * 
     * @param serializableObject The object to encode
     * @return The Base64-encoded object
     * @throws java.io.IOException if there is an error
     * @throws NullPointerException if serializedObject is null
     * @since 1.4
     */
    public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {
        return encodeObject(serializableObject, NO_OPTIONS);
    } // end encodeObject


    /**
     * Serializes an object and returns the Base64-encoded version of that serialized object.
     * <p>
     * As of v 2.3, if the object cannot be serialized or there is another error, the method will throw an
     * java.io.IOException. <b>This is new to v2.3!</b> In earlier versions, it just returned a null value, but in
     * retrospect that's a pretty poor way to handle it.
     * </p>
     * The object is not GZip-compressed before being encoded.
     * <p>
     * Example options:
     * 
     * <pre>
     *   GZIP: gzip-compresses object before encoding it.
     *   DO_BREAK_LINES: break lines at 76 characters
     * </pre>
     * <p>
     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or
     * <p>
     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>
     * 
     * @param serializableObject The object to encode
     * @param options Specified options
     * @return The Base64-encoded object
     * @see Base64#GZIP
     * @see Base64#DO_BREAK_LINES
     * @throws java.io.IOException if there is an error
     * @since 2.0
     */
    public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {

        if (serializableObject == null) {
            throw new NullPointerException("Cannot serialize a null object.");
        } // end if: null

        // Streams
        java.io.ByteArrayOutputStream baos = null;
        java.io.OutputStream b64os = null;
        java.util.zip.GZIPOutputStream gzos = null;
        java.io.ObjectOutputStream oos = null;

        try {
            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream
            baos = new java.io.ByteArrayOutputStream();
            b64os = new Base64.OutputStream(baos, ENCODE | options);
            if ((options & GZIP) != 0) {
                // Gzip
                gzos = new java.util.zip.GZIPOutputStream(b64os);
                oos = new java.io.ObjectOutputStream(gzos);
            } else {
                // Not gzipped
                oos = new java.io.ObjectOutputStream(b64os);
            }
            oos.writeObject(serializableObject);
        } // end try
        catch (java.io.IOException e) {
            // Catch it and then throw it immediately so that
            // the finally{} block is called for cleanup.
            throw e;
        } // end catch
        finally {
            try {
                oos.close();
            } catch (Exception e) {
            }
            try {
                gzos.close();
            } catch (Exception e) {
            }
            try {
                b64os.close();
            } catch (Exception e) {
            }
            try {
                baos.close();
            } catch (Exception e) {
            }
        } // end finally

        // Return value according to relevant encoding.
        try {
            return new String(baos.toByteArray(), PREFERRED_ENCODING);
        } // end try
        catch (java.io.UnsupportedEncodingException uue) {
            // Fall back to some Java default
            return new String(baos.toByteArray());
        } // end catch

    } // end encode


    /**
     * Encodes a byte array into Base64 notation. Does not GZip-compress data.
     * 
     * @param source The data to convert
     * @return The data in Base64-encoded form
     * @throws NullPointerException if source array is null
     * @since 1.4
     */
    public static String encodeBytes(byte[] source) {
        // Since we're not going to have the GZIP encoding turned on,
        // we're not going to have an java.io.IOException thrown, so
        // we should not force the user to have to catch it.
        String encoded = null;
        try {
            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);
        } catch (java.io.IOException ex) {
            assert false : ex.getMessage();
        } // end catch
        assert encoded != null;
        return encoded;
    } // end encodeBytes


    /**
     * Encodes a byte array into Base64 notation.
     * <p>
     * Example options:
     * 
     * <pre>
     *   GZIP: gzip-compresses object before encoding it.
     *   DO_BREAK_LINES: break lines at 76 characters
     *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
     * </pre>
     * <p>
     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or
     * <p>
     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>
     * <p>
     * As of v 2.3, if there is an error with the GZIP stream, the method will throw an java.io.IOException. <b>This is
     * new to v2.3!</b> In earlier versions, it just returned a null value, but in retrospect that's a pretty poor way
     * to handle it.
     * </p>
     * 
     * @param source The data to convert
     * @param options Specified options
     * @return The Base64-encoded data as a String
     * @see Base64#GZIP
     * @see Base64#DO_BREAK_LINES
     * @throws java.io.IOException if there is an error
     * @throws NullPointerException if source array is null
     * @since 2.0
     */
    public static String encodeBytes(byte[] source, int options) throws java.io.IOException {
        return encodeBytes(source, 0, source.length, options);
    } // end encodeBytes


    /**
     * Encodes a byte array into Base64 notation. Does not GZip-compress data.
     * <p>
     * As of v 2.3, if there is an error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In
     * earlier versions, it just returned a null value, but in retrospect that's a pretty poor way to handle it.
     * </p>
     * 
     * @param source The data to convert
     * @param off Offset in array where conversion should begin
     * @param len Length of data to convert
     * @return The Base64-encoded data as a String
     * @throws NullPointerException if source array is null
     * @throws IllegalArgumentException if source array, offset, or length are invalid
     * @since 1.4
     */
    public static String encodeBytes(byte[] source, int off, int len) {
        // Since we're not going to have the GZIP encoding turned on,
        // we're not going to have an java.io.IOException thrown, so
        // we should not force the user to have to catch it.
        String encoded = null;
        try {
            encoded = encodeBytes(source, off, len, NO_OPTIONS);
        } catch (java.io.IOException ex) {
            assert false : ex.getMessage();
        } // end catch
        assert encoded != null;
        return encoded;
    } // end encodeBytes


    /**
     * Encodes a byte array into Base64 notation.
     * <p>
     * Example options:
     * 
     * <pre>
     *   GZIP: gzip-compresses object before encoding it.
     *   DO_BREAK_LINES: break lines at 76 characters
     *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
     * </pre>
     * <p>
     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or
     * <p>
     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>
     * <p>
     * As of v 2.3, if there is an error with the GZIP stream, the method will throw an java.io.IOException. <b>This is
     * new to v2.3!</b> In earlier versions, it just returned a null value, but in retrospect that's a pretty poor way
     * to handle it.
     * </p>
     * 
     * @param source The data to convert
     * @param off Offset in array where conversion should begin
     * @param len Length of data to convert
     * @param options Specified options
     * @return The Base64-encoded data as a String
     * @see Base64#GZIP
     * @see Base64#DO_BREAK_LINES
     * @throws java.io.IOException if there is an error
     * @throws NullPointerException if source array is null
     * @throws IllegalArgumentException if source array, offset, or length are invalid
     * @since 2.0
     */
    public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {
        byte[] encoded = encodeBytesToBytes(source, off, len, options);

        // Return value according to relevant encoding.
        try {
            return new String(encoded, PREFERRED_ENCODING);
        } // end try
        catch (java.io.UnsupportedEncodingException uue) {
            return new String(encoded);
        } // end catch

    } // end encodeBytes


    /**
     * Similar to {@link #encodeBytes(byte[])} but returns a byte array instead of instantiating a String. This is more
     * efficient if you're working with I/O streams and have large data sets to encode.
     * 
     * @param source The data to convert
     * @return The Base64-encoded data as a byte[] (of ASCII characters)
     * @throws NullPointerException if source array is null
     * @since 2.3.1
     */
    public static byte[] encodeBytesToBytes(byte[] source) {
        byte[] encoded = null;
        try {
            encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);
        } catch (java.io.IOException ex) {
            assert false : "IOExceptions only come from GZipping, which is turned off: " + ex.getMessage();
        }
        return encoded;
    }


    /**
     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns a byte array instead of instantiating a
     * String. This is more efficient if you're working with I/O streams and have large data sets to encode.
     * 
     * @param source The data to convert
     * @param off Offset in array where conversion should begin
     * @param len Length of data to convert
     * @param options Specified options
     * @return The Base64-encoded data as a String
     * @see Base64#GZIP
     * @see Base64#DO_BREAK_LINES
     * @throws java.io.IOException if there is an error
     * @throws NullPointerException if source array is null
     * @throws IllegalArgumentException if source array, offset, or length are invalid
     * @since 2.3.1
     */
    public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {

        if (source == null) {
            throw new NullPointerException("Cannot serialize a null array.");
        } // end if: null

        if (off < 0) {
            throw new IllegalArgumentException("Cannot have negative offset: " + off);
        } // end if: off < 0

        if (len < 0) {
            throw new IllegalArgumentException("Cannot have length offset: " + len);
        } // end if: len < 0

        if (off + len > source.length) {
            throw new IllegalArgumentException(String.format(
                    "Cannot have offset of %d and length of %d with array of length %d", off, len, source.length));
        } // end if: off < 0

        // Compress?
        if ((options & GZIP) != 0) {
            java.io.ByteArrayOutputStream baos = null;
            java.util.zip.GZIPOutputStream gzos = null;
            Base64.OutputStream b64os = null;

            try {
                // GZip -> Base64 -> ByteArray
                baos = new java.io.ByteArrayOutputStream();
                b64os = new Base64.OutputStream(baos, ENCODE | options);
                gzos = new java.util.zip.GZIPOutputStream(b64os);

                gzos.write(source, off, len);
                gzos.close();
            } // end try
            catch (java.io.IOException e) {
                // Catch it and then throw it immediately so that
                // the finally{} block is called for cleanup.
                throw e;
            } // end catch
            finally {
                try {
                    gzos.close();
                } catch (Exception e) {
                }
                try {
                    b64os.close();
                } catch (Exception e) {
                }
                try {
                    baos.close();
                } catch (Exception e) {
                }
            } // end finally

            return baos.toByteArray();
        } // end if: compress

        // Else, don't compress. Better not to use streams at all then.
        else {
            boolean breakLines = (options & DO_BREAK_LINES) > 0;

            // int len43 = len * 4 / 3;
            // byte[] outBuff = new byte[ ( len43 ) // Main 4:3
            // + ( (len % 3) > 0 ? 4 : 0 ) // Account for padding
            // + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines
            // Try to determine more precisely how big the array needs to be.
            // If we get it right, we don't have to do an array copy, and
            // we save a bunch of memory.
            int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0); // Bytes needed
                                                                // for actual
                                                                // encoding
            if (breakLines) {
                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline
                                                    // characters
            }
            byte[] outBuff = new byte[encLen];

            int d = 0;
            int e = 0;
            int len2 = len - 2;
            int lineLength = 0;
            for (; d < len2; d += 3, e += 4) {
                encode3to4(source, d + off, 3, outBuff, e, options);

                lineLength += 4;
                if (breakLines && lineLength >= MAX_LINE_LENGTH) {
                    outBuff[e + 4] = NEW_LINE;
                    e++;
                    lineLength = 0;
                } // end if: end of line
            } // en dfor: each piece of array

            if (d < len) {
                encode3to4(source, d + off, len - d, outBuff, e, options);
                e += 4;
            } // end if: some padding needed

            // Only resize array if we didn't guess it right.
            if (e < outBuff.length - 1) {
                byte[] finalOut = new byte[e];
                System.arraycopy(outBuff, 0, finalOut, 0, e);
                // System.err.println("Having to resize array from " +
                // outBuff.length + " to " + e );
                return finalOut;
            } else {
                // System.err.println("No need to resize array.");
                return outBuff;
            }

        } // end else: don't compress

    } // end encodeBytesToBytes


    /* ******** D E C O D I N G M E T H O D S ******** */

    /**
     * Decodes four bytes from array <var>source</var> and writes the resulting bytes (up to three of them) to
     * <var>destination</var>. The source and destination arrays can be manipulated anywhere along their length by
     * specifying <var>srcOffset</var> and <var>destOffset</var>. This method does not check to make sure your arrays
     * are large enough to accomodate <var>srcOffset</var> + 4 for the <var>source</var> array or <var>destOffset</var>
     * + 3 for the <var>destination</var> array. This method returns the actual number of bytes that were converted from
     * the Base64 encoding.
     * <p>
     * This is the lowest level of the decoding methods with all possible parameters.
     * </p>
     * 
     * @param source the array to convert
     * @param srcOffset the index where conversion begins
     * @param destination the array to hold the conversion
     * @param destOffset the index where output will be put
     * @param options alphabet type is pulled from this (standard, url-safe, ordered)
     * @return the number of decoded bytes converted
     * @throws NullPointerException if source or destination arrays are null
     * @throws IllegalArgumentException if srcOffset or destOffset are invalid or there is not enough room in the array.
     * @since 1.3
     */
    private static int decode4to3(byte[] source, int srcOffset, byte[] destination, int destOffset, int options) {

        // Lots of error checking and exception throwing
        if (source == null) {
            throw new NullPointerException("Source array was null.");
        } // end if
        if (destination == null) {
            throw new NullPointerException("Destination array was null.");
        } // end if
        if (srcOffset < 0 || srcOffset + 3 >= source.length) {
            throw new IllegalArgumentException(String.format(
                    "Source array with length %d cannot have offset of %d and still process four bytes.",
                    source.length, srcOffset));
        } // end if
        if (destOffset < 0 || destOffset + 2 >= destination.length) {
            throw new IllegalArgumentException(String.format(
                    "Destination array with length %d cannot have offset of %d and still store three bytes.",
                    destination.length, destOffset));
        } // end if

        byte[] DECODABET = getDecodabet(options);

        // Example: Dk==
        if (source[srcOffset + 2] == EQUALS_SIGN) {
            // Two ways to do the same thing. Don't know which way I like best.
            // int outBuff = ( ( DECODABET[ source[ srcOffset ] ] << 24 ) >>> 6
            // )
            // | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );
            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18)
                    | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12);

            destination[destOffset] = (byte) (outBuff >>> 16);
            return 1;
        }

        // Example: DkL=
        else if (source[srcOffset + 3] == EQUALS_SIGN) {
            // Two ways to do the same thing. Don't know which way I like best.
            // int outBuff = ( ( DECODABET[ source[ srcOffset ] ] << 24 ) >>> 6
            // )
            // | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )
            // | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );
            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18)
                    | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12)
                    | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6);

            destination[destOffset] = (byte) (outBuff >>> 16);
            destination[destOffset + 1] = (byte) (outBuff >>> 8);
            return 2;
        }

        // Example: DkLE
        else {
            // Two ways to do the same thing. Don't know which way I like best.
            // int outBuff = ( ( DECODABET[ source[ srcOffset ] ] << 24 ) >>> 6
            // )
            // | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )
            // | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )
            // | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );
            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18)
                    | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12)
                    | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6) | ((DECODABET[source[srcOffset + 3]] & 0xFF));

            destination[destOffset] = (byte) (outBuff >> 16);
            destination[destOffset + 1] = (byte) (outBuff >> 8);
            destination[destOffset + 2] = (byte) (outBuff);

            return 3;
        }
    } // end decodeToBytes


    /**
     * Low-level access to decoding ASCII characters in the form of a byte array. <strong>Ignores GUNZIP option, if it's
     * set.</strong> This is not generally a recommended method, although it is used internally as part of the decoding
     * process. Special case: if len = 0, an empty array is returned. Still, if you need more speed and reduced memory
     * footprint (and aren't gzipping), consider this method.
     * 
     * @param source The Base64 encoded data
     * @return decoded data
     * @since 2.3.1
     */
    public static byte[] decode(byte[] source) {
        byte[] decoded = null;
        try {
            decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);
        } catch (java.io.IOException ex) {
            assert false : "IOExceptions only come from GZipping, which is turned off: " + ex.getMessage();
        }
        return decoded;
    }


    /**
     * Low-level access to decoding ASCII characters in the form of a byte array. <strong>Ignores GUNZIP option, if it's
     * set.</strong> This is not generally a recommended method, although it is used internally as part of the decoding
     * process. Special case: if len = 0, an empty array is returned. Still, if you need more speed and reduced memory
     * footprint (and aren't gzipping), consider this method.
     * 
     * @param source The Base64 encoded data
     * @param off The offset of where to begin decoding
     * @param len The length of characters to decode
     * @param options Can specify options such as alphabet type to use
     * @return decoded data
     * @throws java.io.IOException If bogus characters exist in source data
     * @since 1.3
     */
    public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {

        // Lots of error checking and exception throwing
        if (source == null) {
            throw new NullPointerException("Cannot decode null source array.");
        } // end if
        if (off < 0 || off + len > source.length) {
            throw new IllegalArgumentException(String.format(
                    "Source array with length %d cannot have offset of %d and process %d bytes.", source.length, off,
                    len));
        } // end if

        if (len == 0) {
            return new byte[0];
        } else if (len < 4) {
            throw new IllegalArgumentException(
                    "Base64-encoded string must have at least four characters, but length specified was " + len);
        } // end if

        byte[] DECODABET = getDecodabet(options);

        int len34 = len * 3 / 4; // Estimate on array size
        byte[] outBuff = new byte[len34]; // Upper limit on size of output
        int outBuffPosn = 0; // Keep track of where we're writing

        byte[] b4 = new byte[4]; // Four byte buffer from source, eliminating
                                 // white space
        int b4Posn = 0; // Keep track of four byte input buffer
        int i = 0; // Source array counter
        byte sbiCrop = 0; // Low seven bits (ASCII) of input
        byte sbiDecode = 0; // Special value from DECODABET

        for (i = off; i < off + len; i++) { // Loop through source

            sbiCrop = (byte) (source[i] & 0x7f); // Only the low seven bits
            sbiDecode = DECODABET[sbiCrop]; // Special value

            // White space, Equals sign, or legit Base64 character
            // Note the values such as -5 and -9 in the
            // DECODABETs at the top of the file.
            if (sbiDecode >= WHITE_SPACE_ENC) {
                if (sbiDecode >= EQUALS_SIGN_ENC) {
                    b4[b4Posn++] = sbiCrop; // Save non-whitespace
                    if (b4Posn > 3) { // Time to decode?
                        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);
                        b4Posn = 0;

                        // If that was the equals sign, break out of 'for' loop
                        if (sbiCrop == EQUALS_SIGN) {
                            break;
                        } // end if: equals sign
                    } // end if: quartet built
                } // end if: equals sign or better
            } // end if: white space, equals sign or better
            else {
                // There's a bad input character in the Base64 stream.
                throw new java.io.IOException(String.format("Bad Base64 input character '%c' in array position %d",
                        source[i], i));
            } // end else:
        } // each input character

        byte[] out = new byte[outBuffPosn];
        System.arraycopy(outBuff, 0, out, 0, outBuffPosn);
        return out;
    } // end decode


    /**
     * Decodes data from Base64 notation, automatically detecting gzip-compressed data and decompressing it.
     * 
     * @param s the string to decode
     * @return the decoded data
     * @throws java.io.IOException If there is a problem
     * @since 1.4
     */
    public static byte[] decode(String s) throws java.io.IOException {
        return decode(s, NO_OPTIONS);
    }


    /**
     * Decodes data from Base64 notation, automatically detecting gzip-compressed data and decompressing it.
     * 
     * @param s the string to decode
     * @param options encode options such as URL_SAFE
     * @return the decoded data
     * @throws java.io.IOException if there is an error
     * @throws NullPointerException if <tt>s</tt> is null
     * @since 1.4
     */
    public static byte[] decode(String s, int options) throws java.io.IOException {

        if (s == null) {
            throw new NullPointerException("Input string was null.");
        } // end if

        byte[] bytes;
        try {
            bytes = s.getBytes(PREFERRED_ENCODING);
        } // end try
        catch (java.io.UnsupportedEncodingException uee) {
            bytes = s.getBytes();
        } // end catch
          // </change>

        // Decode
        bytes = decode(bytes, 0, bytes.length, options);

        // Check to see if it's gzip-compressed
        // GZIP Magic Two-Byte Number: 0x8b1f (35615)
        boolean dontGunzip = (options & DONT_GUNZIP) != 0;
        if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {

            int head = (bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);
            if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {
                java.io.ByteArrayInputStream bais = null;
                java.util.zip.GZIPInputStream gzis = null;
                java.io.ByteArrayOutputStream baos = null;
                byte[] buffer = new byte[2048];
                int length = 0;

                try {
                    baos = new java.io.ByteArrayOutputStream();
                    bais = new java.io.ByteArrayInputStream(bytes);
                    gzis = new java.util.zip.GZIPInputStream(bais);

                    while ((length = gzis.read(buffer)) >= 0) {
                        baos.write(buffer, 0, length);
                    } // end while: reading input

                    // No error? Get new bytes.
                    bytes = baos.toByteArray();

                } // end try
                catch (java.io.IOException e) {
                    e.printStackTrace();
                    // Just return originally-decoded bytes
                } // end catch
                finally {
                    try {
                        baos.close();
                    } catch (Exception e) {
                    }
                    try {
                        gzis.close();
                    } catch (Exception e) {
                    }
                    try {
                        bais.close();
                    } catch (Exception e) {
                    }
                } // end finally

            } // end if: gzipped
        } // end if: bytes.length >= 2

        return bytes;
    } // end decode


    /**
     * Attempts to decode Base64 data and deserialize a Java Object within. Returns <tt>null</tt> if there was an error.
     * 
     * @param encodedObject The Base64 data to decode
     * @return The decoded and deserialized object
     * @throws NullPointerException if encodedObject is null
     * @throws java.io.IOException if there is a general error
     * @throws ClassNotFoundException if the decoded object is of a class that cannot be found by the JVM
     * @since 1.5
     */
    public static Object decodeToObject(String encodedObject) throws java.io.IOException,
            java.lang.ClassNotFoundException {
        return decodeToObject(encodedObject, NO_OPTIONS, null);
    }


    /**
     * Attempts to decode Base64 data and deserialize a Java Object within. Returns <tt>null</tt> if there was an error.
     * If <tt>loader</tt> is not null, it will be the class loader used when deserializing.
     * 
     * @param encodedObject The Base64 data to decode
     * @param options Various parameters related to decoding
     * @param loader Optional class loader to use in deserializing classes.
     * @return The decoded and deserialized object
     * @throws NullPointerException if encodedObject is null
     * @throws java.io.IOException if there is a general error
     * @throws ClassNotFoundException if the decoded object is of a class that cannot be found by the JVM
     * @since 2.3.4
     */
    public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader)
            throws java.io.IOException, java.lang.ClassNotFoundException {

        // Decode and gunzip if necessary
        byte[] objBytes = decode(encodedObject, options);

        java.io.ByteArrayInputStream bais = null;
        java.io.ObjectInputStream ois = null;
        Object obj = null;

        try {
            bais = new java.io.ByteArrayInputStream(objBytes);

            // If no custom class loader is provided, use Java's builtin OIS.
            if (loader == null) {
                ois = new java.io.ObjectInputStream(bais);
            } // end if: no loader provided

            // Else make a customized object input stream that uses
            // the provided class loader.
            else {
                ois = new java.io.ObjectInputStream(bais) {
                    @Override
                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException,
                            ClassNotFoundException {
                        Class<?> c = Class.forName(streamClass.getName(), false, loader);
                        if (c == null) {
                            return super.resolveClass(streamClass);
                        } else {
                            return c; // Class loader knows of this class.
                        } // end else: not null
                    } // end resolveClass
                }; // end ois
            } // end else: no custom class loader

            obj = ois.readObject();
        } // end try
        catch (java.io.IOException | ClassNotFoundException e) {
            //throw e; // Catch and throw in order to execute finally{}
        } // end catch
        // end catch
        finally {
            try {
                bais.close();
            } catch (Exception e) {
            }
            try {
                ois.close();
            } catch (Exception e) {
            }
        } // end finally

        return obj;
    } // end decodeObject


    /**
     * Convenience method for encoding data to a file.
     * <p>
     * As of v 2.3, if there is a error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In
     * earlier versions, it just returned false, but in retrospect that's a pretty poor way to handle it.
     * </p>
     * 
     * @param dataToEncode byte array of data to encode in base64 form
     * @param filename Filename for saving encoded data
     * @throws java.io.IOException if there is an error
     * @throws NullPointerException if dataToEncode is null
     * @since 2.1
     */
    public static void encodeToFile(byte[] dataToEncode, String filename) throws java.io.IOException {

        if (dataToEncode == null) {
            throw new NullPointerException("Data to encode was null.");
        } // end iff

        Base64.OutputStream bos = null;
        try {
            bos = new Base64.OutputStream(new java.io.FileOutputStream(filename), Base64.ENCODE);
            bos.write(dataToEncode);
        } // end try
        catch (java.io.IOException e) {
            throw e; // Catch and throw to execute finally{} block
        } // end catch: java.io.IOException
        finally {
            try {
                bos.close();
            } catch (Exception e) {
            }
        } // end finally

    } // end encodeToFile


    /**
     * Convenience method for decoding data to a file.
     * <p>
     * As of v 2.3, if there is a error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In
     * earlier versions, it just returned false, but in retrospect that's a pretty poor way to handle it.
     * </p>
     * 
     * @param dataToDecode Base64-encoded data as a string
     * @param filename Filename for saving decoded data
     * @throws java.io.IOException if there is an error
     * @since 2.1
     */
    public static void decodeToFile(String dataToDecode, String filename) throws java.io.IOException {

        Base64.OutputStream bos = null;
        try {
            bos = new Base64.OutputStream(new java.io.FileOutputStream(filename), Base64.DECODE);
            bos.write(dataToDecode.getBytes(PREFERRED_ENCODING));
        } // end try
        catch (java.io.IOException e) {
            throw e; // Catch and throw to execute finally{} block
        } // end catch: java.io.IOException
        finally {
            try {
                bos.close();
            } catch (Exception e) {
            }
        } // end finally

    } // end decodeToFile


    /**
     * Convenience method for reading a base64-encoded file and decoding it.
     * <p>
     * As of v 2.3, if there is a error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In
     * earlier versions, it just returned false, but in retrospect that's a pretty poor way to handle it.
     * </p>
     * 
     * @param filename Filename for reading encoded data
     * @return decoded byte array
     * @throws java.io.IOException if there is an error
     * @since 2.1
     */
    public static byte[] decodeFromFile(String filename) throws java.io.IOException {

        byte[] decodedData = null;
        Base64.InputStream bis = null;
        try {
            // Set up some useful variables
            java.io.File file = new java.io.File(filename);
            byte[] buffer = null;
            int length = 0;
            int numBytes = 0;

            // Check for size of file
            if (file.length() > Integer.MAX_VALUE) {
                throw new java.io.IOException("File is too big for this convenience method (" + file.length()
                        + " bytes).");
            } // end if: file too big for int index
            buffer = new byte[(int) file.length()];

            // Open a stream
            bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)),
                    Base64.DECODE);

            // Read until done
            while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {
                length += numBytes;
            } // end while

            // Save in a variable to return
            decodedData = new byte[length];
            System.arraycopy(buffer, 0, decodedData, 0, length);

        } // end try
        catch (java.io.IOException e) {
            throw e; // Catch and release to execute finally{}
        } // end catch: java.io.IOException
        finally {
            try {
                bis.close();
            } catch (Exception e) {
            }
        } // end finally

        return decodedData;
    } // end decodeFromFile


    /**
     * Convenience method for reading a binary file and base64-encoding it.
     * <p>
     * As of v 2.3, if there is a error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In
     * earlier versions, it just returned false, but in retrospect that's a pretty poor way to handle it.
     * </p>
     * 
     * @param filename Filename for reading binary data
     * @return base64-encoded string
     * @throws java.io.IOException if there is an error
     * @since 2.1
     */
    public static String encodeFromFile(String filename) throws java.io.IOException {

        String encodedData = null;
        Base64.InputStream bis = null;
        try {
            // Set up some useful variables
            java.io.File file = new java.io.File(filename);
            byte[] buffer = new byte[Math.max((int) (file.length() * 1.4), 40)]; // Need
                                                                                 // max()
                                                                                 // for
                                                                                 // math
                                                                                 // on
                                                                                 // small
                                                                                 // files
                                                                                 // (v2.2.1)
            int length = 0;
            int numBytes = 0;

            // Open a stream
            bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)),
                    Base64.ENCODE);

            // Read until done
            while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {
                length += numBytes;
            } // end while

            // Save in a variable to return
            encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);

        } // end try
        catch (java.io.IOException e) {
            throw e; // Catch and release to execute finally{}
        } // end catch: java.io.IOException
        finally {
            try {
                bis.close();
            } catch (Exception e) {
            }
        } // end finally

        return encodedData;
    } // end encodeFromFile


    /**
     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.
     * 
     * @param infile Input file
     * @param outfile Output file
     * @throws java.io.IOException if there is an error
     * @since 2.2
     */
    public static void encodeFileToFile(String infile, String outfile) throws java.io.IOException {

        String encoded = Base64.encodeFromFile(infile);
        java.io.OutputStream out = null;
        try {
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            out.write(encoded.getBytes("US-ASCII")); // Strict, 7-bit output.
        } // end try
        catch (java.io.IOException e) {
            throw e; // Catch and release to execute finally{}
        } // end catch
        finally {
            try {
                out.close();
            } catch (Exception ex) {
            }
        } // end finally
    } // end encodeFileToFile


    /**
     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.
     * 
     * @param infile Input file
     * @param outfile Output file
     * @throws java.io.IOException if there is an error
     * @since 2.2
     */
    public static void decodeFileToFile(String infile, String outfile) throws java.io.IOException {

        byte[] decoded = Base64.decodeFromFile(infile);
        java.io.OutputStream out = null;
        try {
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            out.write(decoded);
        } // end try
        catch (java.io.IOException e) {
            throw e; // Catch and release to execute finally{}
        } // end catch
        finally {
            try {
                out.close();
            } catch (Exception ex) {
            }
        } // end finally
    } // end decodeFileToFile

    /* ******** I N N E R C L A S S I N P U T S T R E A M ******** */

    /**
     * A {@link Base64.InputStream} will read data from another <tt>java.io.InputStream</tt>, given in the constructor,
     * and encode/decode to/from Base64 notation on the fly.
     * 
     * @see Base64
     * @since 1.3
     */
    public static class InputStream extends java.io.FilterInputStream {

        private boolean encode; // Encoding or decoding

        private int position; // Current position in the buffer

        private byte[] buffer; // Small buffer holding converted data

        private int bufferLength; // Length of buffer (3 or 4)

        private int numSigBytes; // Number of meaningful bytes in the buffer

        private int lineLength;

        private boolean breakLines; // Break lines at less than 80 characters

        private int options; // Record options used to create the stream.

        private byte[] decodabet; // Local copies to avoid extra method calls


        /**
         * Constructs a {@link Base64.InputStream} in DECODE mode.
         * 
         * @param in the <tt>java.io.InputStream</tt> from which to read data.
         * @since 1.3
         */
        public InputStream(java.io.InputStream in) {
            this(in, DECODE);
        } // end constructor


        /**
         * Constructs a {@link Base64.InputStream} in either ENCODE or DECODE mode.
         * <p>
         * Valid options:
         * 
         * <pre>
         *   ENCODE or DECODE: Encode or Decode as data is read.
         *   DO_BREAK_LINES: break lines at 76 characters
         *     (only meaningful when encoding)&lt;/i&gt;
         * </pre>
         * <p>
         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>
         * 
         * @param in the <tt>java.io.InputStream</tt> from which to read data.
         * @param options Specified options
         * @see Base64#ENCODE
         * @see Base64#DECODE
         * @see Base64#DO_BREAK_LINES
         * @since 2.0
         */
        public InputStream(java.io.InputStream in, int options) {

            super(in);
            this.options = options; // Record for later
            breakLines = (options & DO_BREAK_LINES) > 0;
            encode = (options & ENCODE) > 0;
            bufferLength = encode ? 4 : 3;
            buffer = new byte[bufferLength];
            position = -1;
            lineLength = 0;
            decodabet = getDecodabet(options);
        } // end constructor


        /**
         * Reads enough of the input stream to convert to/from Base64 and returns the next byte.
         * 
         * @return next byte
         * @since 1.3
         */
        @Override
        public int read() throws java.io.IOException {

            // Do we need to get data?
            if (position < 0) {
                if (encode) {
                    byte[] b3 = new byte[3];
                    int numBinaryBytes = 0;
                    for (int i = 0; i < 3; i++) {
                        int b = in.read();

                        // If end of stream, b is -1.
                        if (b >= 0) {
                            b3[i] = (byte) b;
                            numBinaryBytes++;
                        } else {
                            break; // out of for loop
                        } // end else: end of stream

                    } // end for: each needed input byte

                    if (numBinaryBytes > 0) {
                        encode3to4(b3, 0, numBinaryBytes, buffer, 0, options);
                        position = 0;
                        numSigBytes = 4;
                    } // end if: got data
                    else {
                        return -1; // Must be end of stream
                    } // end else
                } // end if: encoding

                // Else decoding
                else {
                    byte[] b4 = new byte[4];
                    int i = 0;
                    for (i = 0; i < 4; i++) {
                        // Read four "meaningful" bytes:
                        int b = 0;
                        do {
                            b = in.read();
                        } while (b >= 0 && decodabet[b & 0x7f] <= WHITE_SPACE_ENC);

                        if (b < 0) {
                            break; // Reads a -1 if end of stream
                        } // end if: end of stream

                        b4[i] = (byte) b;
                    } // end for: each needed input byte

                    if (i == 4) {
                        numSigBytes = decode4to3(b4, 0, buffer, 0, options);
                        position = 0;
                    } // end if: got four characters
                    else if (i == 0) {
                        return -1;
                    } // end else if: also padded correctly
                    else {
                        // Must have broken out from above.
                        throw new java.io.IOException("Improperly padded Base64 input.");
                    } // end

                } // end else: decode
            } // end else: get data

            // Got data?
            if (position >= 0) {
                // End of relevant data?
                if ( /* !encode && */position >= numSigBytes) {
                    return -1;
                } // end if: got data

                if (encode && breakLines && lineLength >= MAX_LINE_LENGTH) {
                    lineLength = 0;
                    return '\n';
                } // end if
                else {
                    lineLength++; // This isn't important when decoding
                    // but throwing an extra "if" seems
                    // just as wasteful.

                    int b = buffer[position++];

                    if (position >= bufferLength) {
                        position = -1;
                    } // end if: end

                    return b & 0xFF; // This is how you "cast" a byte that's
                    // intended to be unsigned.
                } // end else
            } // end if: position >= 0

            // Else error
            else {
                throw new java.io.IOException("Error in Base64 code reading stream.");
            } // end else
        } // end read


        /**
         * Calls {@link #read()} repeatedly until the end of stream is reached or <var>len</var> bytes are read. Returns
         * number of bytes read into array or -1 if end of stream is encountered.
         * 
         * @param dest array to hold values
         * @param off offset for array
         * @param len max number of bytes to read into array
         * @return bytes read into array or -1 if end of stream is encountered.
         * @since 1.3
         */
        @Override
        public int read(byte[] dest, int off, int len) throws java.io.IOException {
            int i;
            int b;
            for (i = 0; i < len; i++) {
                b = read();

                if (b >= 0) {
                    dest[off + i] = (byte) b;
                } else if (i == 0) {
                    return -1;
                } else {
                    break; // Out of 'for' loop
                } // Out of 'for' loop
            } // end for: each byte read
            return i;
        } // end read

    } // end inner class InputStream

    /* ******** I N N E R C L A S S O U T P U T S T R E A M ******** */

    /**
     * A {@link Base64.OutputStream} will write data to another <tt>java.io.OutputStream</tt>, given in the constructor,
     * and encode/decode to/from Base64 notation on the fly.
     * 
     * @see Base64
     * @since 1.3
     */
    public static class OutputStream extends java.io.FilterOutputStream {

        private boolean encode;

        private int position;

        private byte[] buffer;

        private int bufferLength;

        private int lineLength;

        private boolean breakLines;

        private byte[] b4; // Scratch used in a few places

        private boolean suspendEncoding;

        private int options; // Record for later

        private byte[] decodabet; // Local copies to avoid extra method calls


        /**
         * Constructs a {@link Base64.OutputStream} in ENCODE mode.
         * 
         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.
         * @since 1.3
         */
        public OutputStream(java.io.OutputStream out) {
            this(out, ENCODE);
        } // end constructor


        /**
         * Constructs a {@link Base64.OutputStream} in either ENCODE or DECODE mode.
         * <p>
         * Valid options:
         * 
         * <pre>
         *   ENCODE or DECODE: Encode or Decode as data is read.
         *   DO_BREAK_LINES: don't break lines at 76 characters
         *     (only meaningful when encoding)&lt;/i&gt;
         * </pre>
         * <p>
         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>
         * 
         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.
         * @param options Specified options.
         * @see Base64#ENCODE
         * @see Base64#DECODE
         * @see Base64#DO_BREAK_LINES
         * @since 1.3
         */
        public OutputStream(java.io.OutputStream out, int options) {
            super(out);
            breakLines = (options & DO_BREAK_LINES) != 0;
            encode = (options & ENCODE) != 0;
            bufferLength = encode ? 3 : 4;
            buffer = new byte[bufferLength];
            position = 0;
            lineLength = 0;
            suspendEncoding = false;
            b4 = new byte[4];
            this.options = options;
            decodabet = getDecodabet(options);
        } // end constructor


        /**
         * Writes the byte to the output stream after converting to/from Base64 notation. When encoding, bytes are
         * buffered three at a time before the output stream actually gets a write() call. When decoding, bytes are
         * buffered four at a time.
         * 
         * @param theByte the byte to write
         * @since 1.3
         */
        @Override
        public void write(int theByte) throws java.io.IOException {
            // Encoding suspended?
            if (suspendEncoding) {
                out.write(theByte);
                return;
            } // end if: supsended

            // Encode?
            if (encode) {
                buffer[position++] = (byte) theByte;
                if (position >= bufferLength) { // Enough to encode.

                    out.write(encode3to4(b4, buffer, bufferLength, options));

                    lineLength += 4;
                    if (breakLines && lineLength >= MAX_LINE_LENGTH) {
                        out.write(NEW_LINE);
                        lineLength = 0;
                    } // end if: end of line

                    position = 0;
                } // end if: enough to output
            } // end if: encoding

            // Else, Decoding
            else {
                // Meaningful Base64 character?
                if (decodabet[theByte & 0x7f] > WHITE_SPACE_ENC) {
                    buffer[position++] = (byte) theByte;
                    if (position >= bufferLength) { // Enough to output.

                        int len = Base64.decode4to3(buffer, 0, b4, 0, options);
                        out.write(b4, 0, len);
                        position = 0;
                    } // end if: enough to output
                } // end if: meaningful base64 character
                else if (decodabet[theByte & 0x7f] != WHITE_SPACE_ENC) {
                    throw new java.io.IOException("Invalid character in Base64 data.");
                } // end else: not white space either
            } // end else: decoding
        } // end write


        /**
         * Calls {@link #write(int)} repeatedly until <var>len</var> bytes are written.
         * 
         * @param theBytes array from which to read bytes
         * @param off offset for array
         * @param len max number of bytes to read into array
         * @since 1.3
         */
        @Override
        public void write(byte[] theBytes, int off, int len) throws java.io.IOException {
            // Encoding suspended?
            if (suspendEncoding) {
                out.write(theBytes, off, len);
                return;
            } // end if: supsended

            for (int i = 0; i < len; i++) {
                write(theBytes[off + i]);
            } // end for: each byte written

        } // end write


        /**
         * Method added by PHIL. [Thanks, PHIL. -Rob] This pads the buffer without closing the stream.
         * 
         * @throws java.io.IOException if there's an error.
         */
        public void flushBase64() throws java.io.IOException {
            if (position > 0) {
                if (encode) {
                    out.write(encode3to4(b4, buffer, position, options));
                    position = 0;
                } // end if: encoding
                else {
                    throw new java.io.IOException("Base64 input not properly padded.");
                } // end else: decoding
            } // end if: buffer partially full

        } // end flush


        /**
         * Flushes and closes (I think, in the superclass) the stream.
         * 
         * @since 1.3
         */
        @Override
        public void close() throws java.io.IOException {
            // 1. Ensure that pending characters are written
            flushBase64();

            // 2. Actually close the stream
            // Base class both flushes and closes.
            super.close();

            buffer = null;
            out = null;
        } // end close


        /**
         * Suspends encoding of the stream. May be helpful if you need to embed a piece of base64-encoded data in a
         * stream.
         * 
         * @throws java.io.IOException if there's an error flushing
         * @since 1.5.1
         */
        public void suspendEncoding() throws java.io.IOException {
            flushBase64();
            suspendEncoding = true;
        } // end suspendEncoding


        /**
         * Resumes encoding of the stream. May be helpful if you need to embed a piece of base64-encoded data in a
         * stream.
         * 
         * @since 1.5.1
         */
        public void resumeEncoding() {
            suspendEncoding = false;
        } // end resumeEncoding

    } // end inner class OutputStream

} // end class Base64
/****************************************************************************************
 * Copyright (c) 2013 Bibek Shrestha <bibekshrestha@gmail.com>                          *
 * Copyright (c) 2013 Zaur Molotnikov <qutorial@gmail.com>                              *
 * Copyright (c) 2013 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2013 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.utils;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;

import android.widget.ImageView;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

import timber.log.Timber;

public class BitmapUtil {

    public static Bitmap decodeFile(File theFile, int IMAGE_MAX_SIZE) {
        Bitmap bmp = null;
        try {
            // Decode image size
            BitmapFactory.Options o = new BitmapFactory.Options();
            o.inJustDecodeBounds = true;

            FileInputStream fis = new FileInputStream(theFile);
            BitmapFactory.decodeStream(fis, null, o);
            fis.close();

            int scale = 1;
            if (o.outHeight > IMAGE_MAX_SIZE || o.outWidth > IMAGE_MAX_SIZE) {
                scale = (int) Math.pow(
                        2,
                        (int) Math.round(Math.log(IMAGE_MAX_SIZE / (double) Math.max(o.outHeight, o.outWidth))
                                / Math.log(0.5)));
            }

            // Decode with inSampleSize
            BitmapFactory.Options o2 = new BitmapFactory.Options();
            o2.inSampleSize = scale;
            fis = new FileInputStream(theFile);
            bmp = BitmapFactory.decodeStream(fis, null, o2);

            fis.close();
        } catch (IOException e) {
        }
        return bmp;
    }


    public static void freeImageView(ImageView imageView) {
        // This code behaves differently on various OS builds. That is why put into try catch.
        try {
            if (imageView != null) {
                Drawable dr = imageView.getDrawable();

                if (dr == null) {
                    return;
                }

                if (!(dr instanceof BitmapDrawable)) {
                    return;
                }
                BitmapDrawable bd = (BitmapDrawable) imageView.getDrawable();
                if (bd.getBitmap() != null) {
                    bd.getBitmap().recycle();
                    imageView.setImageBitmap(null);
                }
            }
        } catch (Exception e) {
            Timber.e(e.getMessage());
        }
    }

}
/*
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ichi2.utils;

import com.ichi2.compat.CompatHelper;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Pattern;


/**
 * Functions for diff, match and patch. Computes the difference between two texts to create a patch. Applies the patch
 * onto another text, allowing for errors.
 *
 * @author fraser@google.com (Neil Fraser) Class containing the diff, match and patch methods. Also contains the
 *         behaviour settings. TODO if possible, remove the merging code, unneeded.
 */
public class DiffEngine {

    // Defaults.
    // Set these on your diff_match_patch instance to override the defaults.

    /**
     * Number of seconds to map a diff before giving up (0 for infinity).
     */
    public float Diff_Timeout = 1.0f;
    /**
     * Cost of an empty edit operation in terms of edit characters.
     */
    public short Diff_EditCost = 4;
    /**
     * The size beyond which the double-ended diff activates. Double-ending is twice as fast, but less accurate.
     */
    public short Diff_DualThreshold = 32;

    /**
     * Internal class for returning results from diff_linesToChars(). Other less paranoid languages just use a
     * three-element array.
     */
    protected static class LinesToCharsResult {
        protected String chars1;
        protected String chars2;
        protected List<String> lineArray;


        protected LinesToCharsResult(String chars1, String chars2, List<String> lineArray) {
            this.chars1 = chars1;
            this.chars2 = chars2;
            this.lineArray = lineArray;
        }
    }

    // DIFF FUNCTIONS

    /**
     * The data structure representing a diff is a Linked list of Diff objects: {Diff(Operation.DELETE, "Hello"),
     * Diff(Operation.INSERT, "Goodbye"), Diff(Operation.EQUAL, " world.")} which means: delete "Hello", add "Goodbye"
     * and keep " world."
     */
    public enum Operation {
        DELETE, INSERT, EQUAL
    }


    /**
     * Find the differences between two texts. Run a faster slightly less optimal diff This method allows the
     * 'checklines' of diff_main() to be optional. Most of the time checklines is wanted, so default to true.
     *
     * @param text1 Old string to be diffed.
     * @param text2 New string to be diffed.
     * @return Linked List of Diff objects.
     */
    public LinkedList<DiffAction> diff_main(String text1, String text2) {
        return diff_main(text1, text2, true);
    }


    /**
     * Find the differences between two texts. Simplifies the problem by stripping any common prefix or suffix off the
     * texts before diffing.
     *
     * @param text1 Old string to be diffed.
     * @param text2 New string to be diffed.
     * @param checklines Speedup flag. If false, then don't run a line-level diff first to identify the changed areas.
     *            If true, then run a faster slightly less optimal diff
     * @return Linked List of Diff objects.
     */
    public LinkedList<DiffAction> diff_main(String text1, String text2, boolean checklines) {
        // Check for equality (speedup)
        LinkedList<DiffAction> diffs;
        if (text1.equals(text2)) {
            diffs = new LinkedList<>();
            diffs.add(new DiffAction(Operation.EQUAL, text1));
            return diffs;
        }

        // Trim off common prefix (speedup)
        int commonlength = diff_commonPrefix(text1, text2);
        String commonprefix = text1.substring(0, commonlength);
        text1 = text1.substring(commonlength);
        text2 = text2.substring(commonlength);

        // Trim off common suffix (speedup)
        commonlength = diff_commonSuffix(text1, text2);
        String commonsuffix = text1.substring(text1.length() - commonlength);
        text1 = text1.substring(0, text1.length() - commonlength);
        text2 = text2.substring(0, text2.length() - commonlength);

        // Compute the diff on the middle block
        diffs = diff_compute(text1, text2, checklines);

        // Restore the prefix and suffix
        if (commonprefix.length() > 0) {
            diffs.addFirst(new DiffAction(Operation.EQUAL, commonprefix));
        }
        if (commonsuffix.length() > 0) {
            diffs.addLast(new DiffAction(Operation.EQUAL, commonsuffix));
        }

        diff_cleanupMerge(diffs);
        return diffs;
    }


    /**
     * Find the differences between two texts. Assumes that the texts do not have any common prefix or suffix.
     *
     * @param text1 Old string to be diffed.
     * @param text2 New string to be diffed.
     * @param checklines Speedup flag. If false, then don't run a line-level diff first to identify the changed areas.
     *            If true, then run a faster slightly less optimal diff
     * @return Linked List of Diff objects.
     */
    protected LinkedList<DiffAction> diff_compute(String text1, String text2, boolean checklines) {
        LinkedList<DiffAction> diffs = new LinkedList<>();

        if (text1.length() == 0) {
            // Just add some text (speedup)
            diffs.add(new DiffAction(Operation.INSERT, text2));
            return diffs;
        }

        if (text2.length() == 0) {
            // Just delete some text (speedup)
            diffs.add(new DiffAction(Operation.DELETE, text1));
            return diffs;
        }

        String longtext = text1.length() > text2.length() ? text1 : text2;
        String shorttext = text1.length() > text2.length() ? text2 : text1;
        int i = longtext.indexOf(shorttext);
        if (i != -1) {
            // Shorter text is inside the longer text (speedup)
            Operation op = (text1.length() > text2.length()) ? Operation.DELETE : Operation.INSERT;
            diffs.add(new DiffAction(op, longtext.substring(0, i)));
            diffs.add(new DiffAction(Operation.EQUAL, shorttext));
            diffs.add(new DiffAction(op, longtext.substring(i + shorttext.length())));
            return diffs;
        }
        longtext = shorttext = null; // Garbage collect

        // Check to see if the problem can be split in two.
        String[] hm = diff_halfMatch(text1, text2);
        if (hm != null) {
            // A half-match was found, sort out the return data.
            String text1_a = hm[0];
            String text1_b = hm[1];
            String text2_a = hm[2];
            String text2_b = hm[3];
            String mid_common = hm[4];
            // Send both pairs off for separate processing.
            LinkedList<DiffAction> diffs_a = diff_main(text1_a, text2_a, checklines);
            LinkedList<DiffAction> diffs_b = diff_main(text1_b, text2_b, checklines);
            // Merge the results.
            diffs = diffs_a;
            diffs.add(new DiffAction(Operation.EQUAL, mid_common));
            diffs.addAll(diffs_b);
            return diffs;
        }

        // Perform a real diff.
        if (checklines && (text1.length() < 100 || text2.length() < 100)) {
            checklines = false; // Too trivial for the overhead.
        }
        List<String> linearray = null;
        if (checklines) {
            // Scan the text on a line-by-line basis first.
            LinesToCharsResult b = diff_linesToChars(text1, text2);
            text1 = b.chars1;
            text2 = b.chars2;
            linearray = b.lineArray;
        }

        diffs = diff_map(text1, text2);
        if (diffs == null) {
            // No acceptable result.
            diffs = new LinkedList<>();
            diffs.add(new DiffAction(Operation.DELETE, text1));
            diffs.add(new DiffAction(Operation.INSERT, text2));
        }

        if (checklines) {
            // Convert the diff back to original text.
            diff_charsToLines(diffs, linearray);
            // Eliminate freak matches (e.g. blank lines)
            diff_cleanupSemantic(diffs);

            // Rediff any replacement blocks, this time character-by-character.
            // Add a dummy entry at the end.
            diffs.add(new DiffAction(Operation.EQUAL, ""));
            int count_delete = 0;
            int count_insert = 0;
            String text_delete = "";
            String text_insert = "";
            ListIterator<DiffAction> pointer = diffs.listIterator();
            DiffAction thisDiff = pointer.next();
            while (thisDiff != null) {
                switch (thisDiff.operation) {
                    case INSERT:
                        count_insert++;
                        text_insert += thisDiff.text;
                        break;
                    case DELETE:
                        count_delete++;
                        text_delete += thisDiff.text;
                        break;
                    case EQUAL:
                        // Upon reaching an equality, check for prior redundancies.
                        if (count_delete >= 1 && count_insert >= 1) {
                            // Delete the offending records and add the merged ones.
                            pointer.previous();
                            for (int j = 0; j < count_delete + count_insert; j++) {
                                pointer.previous();
                                pointer.remove();
                            }
                            for (DiffAction newDiff : diff_main(text_delete, text_insert, false)) {
                                pointer.add(newDiff);
                            }
                        }
                        count_insert = 0;
                        count_delete = 0;
                        text_delete = "";
                        text_insert = "";
                        break;
                }
                thisDiff = pointer.hasNext() ? pointer.next() : null;
            }
            diffs.removeLast(); // Remove the dummy entry at the end.
        }
        return diffs;
    }


    /**
     * Split two texts into a list of strings. Reduce the texts to a string of hashes where each Unicode character
     * represents one line.
     *
     * @param text1 First string.
     * @param text2 Second string.
     * @return An object containing the encoded text1, the encoded text2 and the List of unique strings. The zeroth
     *         element of the List of unique strings is intentionally blank.
     */
    protected LinesToCharsResult diff_linesToChars(String text1, String text2) {
        List<String> lineArray = new ArrayList<>();
        Map<String, Integer> lineHash = new HashMap<>();
        // e.g. linearray[4] == "Hello\n"
        // e.g. linehash.get("Hello\n") == 4

        // "\x00" is a valid character, but various debuggers don't like it.
        // So we'll insert a junk entry to avoid generating a null character.
        lineArray.add("");

        String chars1 = diff_linesToCharsMunge(text1, lineArray, lineHash);
        String chars2 = diff_linesToCharsMunge(text2, lineArray, lineHash);
        return new LinesToCharsResult(chars1, chars2, lineArray);
    }


    /**
     * Split a text into a list of strings. Reduce the texts to a string of hashes where each Unicode character
     * represents one line.
     *
     * @param text String to encode.
     * @param lineArray List of unique strings.
     * @param lineHash Map of strings to indices.
     * @return Encoded string.
     */
    private String diff_linesToCharsMunge(String text, List<String> lineArray, Map<String, Integer> lineHash) {
        int lineStart = 0;
        int lineEnd = -1;
        String line;
        StringBuilder chars = new StringBuilder();
        // Walk the text, pulling out a substring for each line.
        // text.split('\n') would would temporarily double our memory footprint.
        // Modifying text would create many large strings to garbage collect.
        while (lineEnd < text.length() - 1) {
            lineEnd = text.indexOf('\n', lineStart);
            if (lineEnd == -1) {
                lineEnd = text.length() - 1;
            }
            line = text.substring(lineStart, lineEnd + 1);
            lineStart = lineEnd + 1;

            if (lineHash.containsKey(line)) {
                chars.append(String.valueOf((char) (int) lineHash.get(line)));
            } else {
                lineArray.add(line);
                lineHash.put(line, lineArray.size() - 1);
                chars.append(String.valueOf((char) (lineArray.size() - 1)));
            }
        }
        return chars.toString();
    }


    /**
     * Rehydrate the text in a diff from a string of line hashes to real lines of text.
     *
     * @param diffs LinkedList of Diff objects.
     * @param lineArray List of unique strings.
     */
    protected void diff_charsToLines(LinkedList<DiffAction> diffs, List<String> lineArray) {
        StringBuilder text;
        for (DiffAction diff : diffs) {
            text = new StringBuilder();
            for (int y = 0; y < diff.text.length(); y++) {
                text.append(lineArray.get(diff.text.charAt(y)));
            }
            diff.text = text.toString();
        }
    }


    /**
     * Explore the intersection points between the two texts.
     *
     * @param text1 Old string to be diffed.
     * @param text2 New string to be diffed.
     * @return LinkedList of Diff objects or null if no diff available.
     */
    protected LinkedList<DiffAction> diff_map(String text1, String text2) {
        long ms_end = System.currentTimeMillis() + (long) (Diff_Timeout * 1000);
        // Cache the text lengths to prevent multiple calls.
        int text1_length = text1.length();
        int text2_length = text2.length();
        int max_d = text1_length + text2_length - 1;
        boolean doubleEnd = Diff_DualThreshold * 2 < max_d;
        List<Set<Long>> v_map1 = new ArrayList<>();
        List<Set<Long>> v_map2 = new ArrayList<>();
        Map<Integer, Integer> v1 = new HashMap<>();
        Map<Integer, Integer> v2 = new HashMap<>();
        v1.put(1, 0);
        v2.put(1, 0);
        int x, y;
        Long footstep = 0L; // Used to track overlapping paths.
        Map<Long, Integer> footsteps = new HashMap<>();
        boolean done = false;
        // If the total number of characters is odd, then the front path will
        // collide with the reverse path.
        boolean front = ((text1_length + text2_length) % 2 == 1);
        for (int d = 0; d < max_d; d++) {
            // Bail out if timeout reached.
            if (Diff_Timeout > 0 && System.currentTimeMillis() > ms_end) {
                return null;
            }

            // Walk the front path one step.
            v_map1.add(new HashSet<Long>()); // Adds at index 'd'.
            for (int k = -d; k <= d; k += 2) {
                if (k == -d || k != d && v1.get(k - 1) < v1.get(k + 1)) {
                    x = v1.get(k + 1);
                } else {
                    x = v1.get(k - 1) + 1;
                }
                y = x - k;
                if (doubleEnd) {
                    footstep = diff_footprint(x, y);
                    if (front && (footsteps.containsKey(footstep))) {
                        done = true;
                    }
                    if (!front) {
                        footsteps.put(footstep, d);
                    }
                }
                while (!done && x < text1_length && y < text2_length && text1.charAt(x) == text2.charAt(y)) {
                    x++;
                    y++;
                    if (doubleEnd) {
                        footstep = diff_footprint(x, y);
                        if (front && (footsteps.containsKey(footstep))) {
                            done = true;
                        }
                        if (!front) {
                            footsteps.put(footstep, d);
                        }
                    }
                }
                v1.put(k, x);
                v_map1.get(d).add(diff_footprint(x, y));
                if (x == text1_length && y == text2_length) {
                    // Reached the end in single-path mode.
                    return diff_path1(v_map1, text1, text2);
                } else if (done) {
                    // Front path ran over reverse path.
                    v_map2 = v_map2.subList(0, footsteps.get(footstep) + 1);
                    LinkedList<DiffAction> a = diff_path1(v_map1, text1.substring(0, x), text2.substring(0, y));
                    a.addAll(diff_path2(v_map2, text1.substring(x), text2.substring(y)));
                    return a;
                }
            }

            if (doubleEnd) {
                // Walk the reverse path one step.
                v_map2.add(new HashSet<Long>()); // Adds at index 'd'.
                for (int k = -d; k <= d; k += 2) {
                    if (k == -d || k != d && v2.get(k - 1) < v2.get(k + 1)) {
                        x = v2.get(k + 1);
                    } else {
                        x = v2.get(k - 1) + 1;
                    }
                    y = x - k;
                    footstep = diff_footprint(text1_length - x, text2_length - y);
                    if (!front && (footsteps.containsKey(footstep))) {
                        done = true;
                    }
                    if (front) {
                        footsteps.put(footstep, d);
                    }
                    while (!done && x < text1_length && y < text2_length
                            && text1.charAt(text1_length - x - 1) == text2.charAt(text2_length - y - 1)) {
                        x++;
                        y++;
                        footstep = diff_footprint(text1_length - x, text2_length - y);
                        if (!front && (footsteps.containsKey(footstep))) {
                            done = true;
                        }
                        if (front) {
                            footsteps.put(footstep, d);
                        }
                    }
                    v2.put(k, x);
                    v_map2.get(d).add(diff_footprint(x, y));
                    if (done) {
                        // Reverse path ran over front path.
                        v_map1 = v_map1.subList(0, footsteps.get(footstep) + 1);
                        LinkedList<DiffAction> a = diff_path1(v_map1, text1.substring(0, text1_length - x),
                                text2.substring(0, text2_length - y));
                        a.addAll(diff_path2(v_map2, text1.substring(text1_length - x),
                                text2.substring(text2_length - y)));
                        return a;
                    }
                }
            }
        }
        // Number of diffs equals number of characters, no commonality at all.
        return null;
    }


    /**
     * Work from the middle back to the start to determine the path.
     *
     * @param v_map List of path sets.
     * @param text1 Old string fragment to be diffed.
     * @param text2 New string fragment to be diffed.
     * @return LinkedList of Diff objects.
     */
    protected LinkedList<DiffAction> diff_path1(List<Set<Long>> v_map, String text1, String text2) {
        LinkedList<DiffAction> path = new LinkedList<>();
        int x = text1.length();
        int y = text2.length();
        Operation last_op = null;
        for (int d = v_map.size() - 2; d >= 0; d--) {
            while (true) {
                if (v_map.get(d).contains(diff_footprint(x - 1, y))) {
                    x--;
                    if (last_op == Operation.DELETE) {
                        path.getFirst().text = text1.charAt(x) + path.getFirst().text;
                    } else {
                        path.addFirst(new DiffAction(Operation.DELETE, text1.substring(x, x + 1)));
                    }
                    last_op = Operation.DELETE;
                    break;
                } else if (v_map.get(d).contains(diff_footprint(x, y - 1))) {
                    y--;
                    if (last_op == Operation.INSERT) {
                        path.getFirst().text = text2.charAt(y) + path.getFirst().text;
                    } else {
                        path.addFirst(new DiffAction(Operation.INSERT, text2.substring(y, y + 1)));
                    }
                    last_op = Operation.INSERT;
                    break;
                } else {
                    x--;
                    y--;
                    assert (text1.charAt(x) == text2.charAt(y)) : "No diagonal.  Can't happen. (diff_path1)";
                    if (last_op == Operation.EQUAL) {
                        path.getFirst().text = text1.charAt(x) + path.getFirst().text;
                    } else {
                        path.addFirst(new DiffAction(Operation.EQUAL, text1.substring(x, x + 1)));
                    }
                    last_op = Operation.EQUAL;
                }
            }
        }
        return path;
    }


    /**
     * Work from the middle back to the end to determine the path.
     *
     * @param v_map List of path sets.
     * @param text1 Old string fragment to be diffed.
     * @param text2 New string fragment to be diffed.
     * @return LinkedList of Diff objects.
     */
    protected LinkedList<DiffAction> diff_path2(List<Set<Long>> v_map, String text1, String text2) {
        LinkedList<DiffAction> path = new LinkedList<>();
        int x = text1.length();
        int y = text2.length();
        Operation last_op = null;
        for (int d = v_map.size() - 2; d >= 0; d--) {
            while (true) {
                if (v_map.get(d).contains(diff_footprint(x - 1, y))) {
                    x--;
                    if (last_op == Operation.DELETE) {
                        path.getLast().text += text1.charAt(text1.length() - x - 1);
                    } else {
                        path.addLast(new DiffAction(Operation.DELETE, text1.substring(text1.length() - x - 1,
                                text1.length() - x)));
                    }
                    last_op = Operation.DELETE;
                    break;
                } else if (v_map.get(d).contains(diff_footprint(x, y - 1))) {
                    y--;
                    if (last_op == Operation.INSERT) {
                        path.getLast().text += text2.charAt(text2.length() - y - 1);
                    } else {
                        path.addLast(new DiffAction(Operation.INSERT, text2.substring(text2.length() - y - 1,
                                text2.length() - y)));
                    }
                    last_op = Operation.INSERT;
                    break;
                } else {
                    x--;
                    y--;
                    assert (text1.charAt(text1.length() - x - 1) == text2.charAt(text2.length() - y - 1)) : "No diagonal.  Can't happen. (diff_path2)";
                    if (last_op == Operation.EQUAL) {
                        path.getLast().text += text1.charAt(text1.length() - x - 1);
                    } else {
                        path.addLast(new DiffAction(Operation.EQUAL, text1.substring(text1.length() - x - 1,
                                text1.length() - x)));
                    }
                    last_op = Operation.EQUAL;
                }
            }
        }
        return path;
    }


    /**
     * Compute a good hash of two integers.
     *
     * @param x First int.
     * @param y Second int.
     * @return A long made up of both ints.
     */
    protected long diff_footprint(int x, int y) {
        // The maximum size for a long is 9,223,372,036,854,775,807
        // The maximum size for an int is 2,147,483,647
        // Two ints fit nicely in one long.
        long result = x;
        result = result << 32;
        result += y;
        return result;
    }


    /**
     * Determine the common prefix of two strings
     *
     * @param text1 First string.
     * @param text2 Second string.
     * @return The number of characters common to the start of each string.
     */
    public int diff_commonPrefix(String text1, String text2) {
        // Performance analysis: http://neil.fraser.name/news/2007/10/09/
        int n = Math.min(text1.length(), text2.length());
        for (int i = 0; i < n; i++) {
            if (text1.charAt(i) != text2.charAt(i)) {
                return i;
            }
        }
        return n;
    }


    /**
     * Determine the common suffix of two strings
     *
     * @param text1 First string.
     * @param text2 Second string.
     * @return The number of characters common to the end of each string.
     */
    public int diff_commonSuffix(String text1, String text2) {
        // Performance analysis: http://neil.fraser.name/news/2007/10/09/
        int text1_length = text1.length();
        int text2_length = text2.length();
        int n = Math.min(text1_length, text2_length);
        for (int i = 1; i <= n; i++) {
            if (text1.charAt(text1_length - i) != text2.charAt(text2_length - i)) {
                return i - 1;
            }
        }
        return n;
    }


    /**
     * Do the two texts share a substring which is at least half the length of the longer text?
     *
     * @param text1 First string.
     * @param text2 Second string.
     * @return Five element String array, containing the prefix of text1, the suffix of text1, the prefix of text2, the
     *         suffix of text2 and the common middle. Or null if there was no match.
     */
    protected String[] diff_halfMatch(String text1, String text2) {
        String longtext = text1.length() > text2.length() ? text1 : text2;
        String shorttext = text1.length() > text2.length() ? text2 : text1;
        if (longtext.length() < 10 || shorttext.length() < 1) {
            return null; // Pointless.
        }

        // First check if the second quarter is the seed for a half-match.
        String[] hm1 = diff_halfMatchI(longtext, shorttext, (longtext.length() + 3) / 4);
        // Check again based on the third quarter.
        String[] hm2 = diff_halfMatchI(longtext, shorttext, (longtext.length() + 1) / 2);
        String[] hm;
        if (hm1 == null && hm2 == null) {
            return null;
        } else if (hm2 == null) {
            hm = hm1;
        } else if (hm1 == null) {
            hm = hm2;
        } else {
            // Both matched. Select the longest.
            hm = hm1[4].length() > hm2[4].length() ? hm1 : hm2;
        }

        // A half-match was found, sort out the return data.
        if (text1.length() > text2.length()) {
            return hm;
            // return new String[]{hm[0], hm[1], hm[2], hm[3], hm[4]};
        } else {
            return new String[] { hm[2], hm[3], hm[0], hm[1], hm[4] };
        }
    }


    /**
     * Does a substring of shorttext exist within longtext such that the substring is at least half the length of
     * longtext?
     *
     * @param longtext Longer string.
     * @param shorttext Shorter string.
     * @param i Start index of quarter length substring within longtext.
     * @return Five element String array, containing the prefix of longtext, the suffix of longtext, the prefix of
     *         shorttext, the suffix of shorttext and the common middle. Or null if there was no match.
     */
    private String[] diff_halfMatchI(String longtext, String shorttext, int i) {
        // Start with a 1/4 length substring at position i as a seed.
        String seed = longtext.substring(i, i + longtext.length() / 4);
        int j = -1;
        String best_common = "";
        String best_longtext_a = "", best_longtext_b = "";
        String best_shorttext_a = "", best_shorttext_b = "";
        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
            int prefixLength = diff_commonPrefix(longtext.substring(i), shorttext.substring(j));
            int suffixLength = diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));
            if (best_common.length() < suffixLength + prefixLength) {
                best_common = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
                best_longtext_a = longtext.substring(0, i - suffixLength);
                best_longtext_b = longtext.substring(i + prefixLength);
                best_shorttext_a = shorttext.substring(0, j - suffixLength);
                best_shorttext_b = shorttext.substring(j + prefixLength);
            }
        }
        if (best_common.length() >= longtext.length() / 2) {
            return new String[] { best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common };
        } else {
            return null;
        }
    }


    /**
     * Reduce the number of edits by eliminating semantically trivial equalities.
     *
     * @param diffs LinkedList of Diff objects.
     */
    public void diff_cleanupSemantic(LinkedList<DiffAction> diffs) {
        if (diffs.isEmpty()) {
            return;
        }
        boolean changes = false;
        Stack<DiffAction> equalities = new Stack<>(); // Stack of qualities.
        String lastequality = null; // Always equal to equalities.lastElement().text
        ListIterator<DiffAction> pointer = diffs.listIterator();
        // Number of characters that changed prior to the equality.
        int length_changes1 = 0;
        // Number of characters that changed after the equality.
        int length_changes2 = 0;
        DiffAction thisDiff = pointer.next();
        while (thisDiff != null) {
            if (thisDiff.operation == Operation.EQUAL) {
                // equality found
                equalities.push(thisDiff);
                length_changes1 = length_changes2;
                length_changes2 = 0;
                lastequality = thisDiff.text;
            } else {
                // an insertion or deletion
                length_changes2 += thisDiff.text.length();
                if (lastequality != null && (lastequality.length() <= length_changes1)
                        && (lastequality.length() <= length_changes2)) {
                    // System.out.println("Splitting: '" + lastequality + "'");
                    // Walk back to offending equality.
                    while (thisDiff != equalities.lastElement()) {
                        thisDiff = pointer.previous();
                    }
                    pointer.next();

                    // Replace equality with a delete.
                    pointer.set(new DiffAction(Operation.DELETE, lastequality));
                    // Insert a corresponding an insert.
                    pointer.add(new DiffAction(Operation.INSERT, lastequality));

                    equalities.pop(); // Throw away the equality we just deleted.
                    if (!equalities.empty()) {
                        // Throw away the previous equality (it needs to be reevaluated).
                        equalities.pop();
                    }
                    if (equalities.empty()) {
                        // There are no previous equalities, walk back to the start.
                        while (pointer.hasPrevious()) {
                            pointer.previous();
                        }
                    } else {
                        // There is a safe equality we can fall back to.
                        thisDiff = equalities.lastElement();
                        while (thisDiff != pointer.previous()) {
                            // Intentionally empty loop.
                        }
                    }

                    length_changes1 = 0; // Reset the counters.
                    length_changes2 = 0;
                    lastequality = null;
                    changes = true;
                }
            }
            thisDiff = pointer.hasNext() ? pointer.next() : null;
        }

        if (changes) {
            diff_cleanupMerge(diffs);
        }
        diff_cleanupSemanticLossless(diffs);
    }


    /**
     * Look for single edits surrounded on both sides by equalities which can be shifted sideways to align the edit to a
     * word boundary. e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
     *
     * @param diffs LinkedList of Diff objects.
     */
    public void diff_cleanupSemanticLossless(LinkedList<DiffAction> diffs) {
        String equality1, edit, equality2;
        String commonString;
        int commonOffset;
        int score, bestScore;
        String bestEquality1, bestEdit, bestEquality2;
        // Create a new iterator at the start.
        ListIterator<DiffAction> pointer = diffs.listIterator();
        DiffAction prevDiff = pointer.hasNext() ? pointer.next() : null;
        DiffAction thisDiff = pointer.hasNext() ? pointer.next() : null;
        DiffAction nextDiff = pointer.hasNext() ? pointer.next() : null;
        // Intentionally ignore the first and last element (don't need checking).
        while (nextDiff != null) {
            if (prevDiff.operation == Operation.EQUAL && nextDiff.operation == Operation.EQUAL) {
                // This is a single edit surrounded by equalities.
                equality1 = prevDiff.text;
                edit = thisDiff.text;
                equality2 = nextDiff.text;

                // First, shift the edit as far left as possible.
                commonOffset = diff_commonSuffix(equality1, edit);
                if (commonOffset != 0) {
                    commonString = edit.substring(edit.length() - commonOffset);
                    equality1 = equality1.substring(0, equality1.length() - commonOffset);
                    edit = commonString + edit.substring(0, edit.length() - commonOffset);
                    equality2 = commonString + equality2;
                }

                // Second, step character by character right, looking for the best fit.
                bestEquality1 = equality1;
                bestEdit = edit;
                bestEquality2 = equality2;
                bestScore = diff_cleanupSemanticScore(equality1, edit) + diff_cleanupSemanticScore(edit, equality2);
                while (edit.length() > 0 && equality2.length() > 0 && edit.charAt(0) == equality2.charAt(0)) {
                    equality1 += edit.charAt(0);
                    edit = edit.substring(1) + equality2.charAt(0);
                    equality2 = equality2.substring(1);
                    score = diff_cleanupSemanticScore(equality1, edit) + diff_cleanupSemanticScore(edit, equality2);
                    // The >= encourages trailing rather than leading whitespace on edits.
                    if (score >= bestScore) {
                        bestScore = score;
                        bestEquality1 = equality1;
                        bestEdit = edit;
                        bestEquality2 = equality2;
                    }
                }

                if (!prevDiff.text.equals(bestEquality1)) {
                    // We have an improvement, save it back to the diff.
                    if (bestEquality1.length() > 0) {
                        prevDiff.text = bestEquality1;
                    } else {
                        pointer.previous(); // Walk past nextDiff.
                        pointer.previous(); // Walk past thisDiff.
                        pointer.previous(); // Walk past prevDiff.
                        pointer.remove(); // Delete prevDiff.
                        pointer.next(); // Walk past thisDiff.
                        pointer.next(); // Walk past nextDiff.
                    }
                    thisDiff.text = bestEdit;
                    if (bestEquality2.length() > 0) {
                        nextDiff.text = bestEquality2;
                    } else {
                        pointer.remove(); // Delete nextDiff.
                        nextDiff = thisDiff;
                        thisDiff = prevDiff;
                    }
                }
            }
            prevDiff = thisDiff;
            thisDiff = nextDiff;
            nextDiff = pointer.hasNext() ? pointer.next() : null;
        }
    }


    /**
     * Given two strings, compute a score representing whether the internal boundary falls on logical boundaries. Scores
     * range from 5 (best) to 0 (worst).
     *
     * @param one First string.
     * @param two Second string.
     * @return The score.
     */
    private int diff_cleanupSemanticScore(String one, String two) {
        if (one.length() == 0 || two.length() == 0) {
            // Edges are the best.
            return 5;
        }

        // Each port of this function behaves slightly differently due to
        // subtle differences in each language's definition of things like
        // 'whitespace'. Since this function's purpose is largely cosmetic,
        // the choice has been made to use each language's native features
        // rather than force total conformity.
        int score = 0;
        // One point for non-alphanumeric.
        if (!Character.isLetterOrDigit(one.charAt(one.length() - 1)) || !Character.isLetterOrDigit(two.charAt(0))) {
            score++;
            // Two points for whitespace.
            if (Character.isWhitespace(one.charAt(one.length() - 1)) || Character.isWhitespace(two.charAt(0))) {
                score++;
                // Three points for line breaks.
                if (Character.getType(one.charAt(one.length() - 1)) == Character.CONTROL
                        || Character.getType(two.charAt(0)) == Character.CONTROL) {
                    score++;
                    // Four points for blank lines.
                    if (BLANKLINEEND.matcher(one).find() || BLANKLINESTART.matcher(two).find()) {
                        score++;
                    }
                }
            }
        }
        return score;
    }

    private Pattern BLANKLINEEND = Pattern.compile("\\n\\r?\\n\\Z", Pattern.DOTALL);
    private Pattern BLANKLINESTART = Pattern.compile("\\A\\r?\\n\\r?\\n", Pattern.DOTALL);


    /**
     * Reorder and merge like edit sections. Merge equalities. Any edit section can move as long as it doesn't cross an
     * equality.
     *
     * @param diffs LinkedList of Diff objects.
     */
    public void diff_cleanupMerge(LinkedList<DiffAction> diffs) {
        diffs.add(new DiffAction(Operation.EQUAL, "")); // Add a dummy entry at the end.
        ListIterator<DiffAction> pointer = diffs.listIterator();
        int count_delete = 0;
        int count_insert = 0;
        String text_delete = "";
        String text_insert = "";
        DiffAction thisDiff = pointer.next();
        DiffAction prevEqual = null;
        int commonlength;
        while (thisDiff != null) {
            switch (thisDiff.operation) {
                case INSERT:
                    count_insert++;
                    text_insert += thisDiff.text;
                    prevEqual = null;
                    break;
                case DELETE:
                    count_delete++;
                    text_delete += thisDiff.text;
                    prevEqual = null;
                    break;
                case EQUAL:
                    if (count_delete != 0 || count_insert != 0) {
                        // Delete the offending records.
                        pointer.previous(); // Reverse direction.
                        while (count_delete-- > 0) {
                            pointer.previous();
                            pointer.remove();
                        }
                        while (count_insert-- > 0) {
                            pointer.previous();
                            pointer.remove();
                        }
                        if (count_delete != 0 && count_insert != 0) {
                            // Factor out any common prefixies.
                            commonlength = diff_commonPrefix(text_insert, text_delete);
                            if (commonlength != 0) {
                                if (pointer.hasPrevious()) {
                                    thisDiff = pointer.previous();
                                    assert thisDiff.operation == Operation.EQUAL : "Previous diff should have been an equality.";
                                    thisDiff.text += text_insert.substring(0, commonlength);
                                    pointer.next();
                                } else {
                                    pointer.add(new DiffAction(Operation.EQUAL, text_insert.substring(0, commonlength)));
                                }
                                text_insert = text_insert.substring(commonlength);
                                text_delete = text_delete.substring(commonlength);
                            }
                            // Factor out any common suffixies.
                            commonlength = diff_commonSuffix(text_insert, text_delete);
                            if (commonlength != 0) {
                                thisDiff = pointer.next();
                                thisDiff.text = text_insert.substring(text_insert.length() - commonlength)
                                        + thisDiff.text;
                                text_insert = text_insert.substring(0, text_insert.length() - commonlength);
                                text_delete = text_delete.substring(0, text_delete.length() - commonlength);
                                pointer.previous();
                            }
                        }
                        // Insert the merged records.
                        if (text_delete.length() > 0) {
                            pointer.add(new DiffAction(Operation.DELETE, text_delete));
                        }
                        if (text_insert.length() > 0) {
                            pointer.add(new DiffAction(Operation.INSERT, text_insert));
                        }
                        // Step forward to the equality.
                        thisDiff = pointer.hasNext() ? pointer.next() : null;
                    } else if (prevEqual != null) {
                        // Merge this equality with the previous one.
                        prevEqual.text += thisDiff.text;
                        pointer.remove();
                        thisDiff = pointer.previous();
                        pointer.next(); // Forward direction
                    }
                    count_insert = 0;
                    count_delete = 0;
                    text_delete = "";
                    text_insert = "";
                    prevEqual = thisDiff;
                    break;
            }
            thisDiff = pointer.hasNext() ? pointer.next() : null;
        }
        // System.out.println(diff);
        if (diffs.getLast().text.length() == 0) {
            diffs.removeLast(); // Remove the dummy entry at the end.
        }

        /*
         * Second pass: look for single edits surrounded on both sides by equalities which can be shifted sideways to
         * eliminate an equality. e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
         */
        boolean changes = false;
        // Create a new iterator at the start.
        // (As opposed to walking the current one back.)
        pointer = diffs.listIterator();
        DiffAction prevDiff = pointer.hasNext() ? pointer.next() : null;
        thisDiff = pointer.hasNext() ? pointer.next() : null;
        DiffAction nextDiff = pointer.hasNext() ? pointer.next() : null;
        // Intentionally ignore the first and last element (don't need checking).
        while (nextDiff != null) {
            if (prevDiff.operation == Operation.EQUAL && nextDiff.operation == Operation.EQUAL) {
                // This is a single edit surrounded by equalities.
                if (thisDiff.text.endsWith(prevDiff.text)) {
                    // Shift the edit over the previous equality.
                    thisDiff.text = prevDiff.text
                            + thisDiff.text.substring(0, thisDiff.text.length() - prevDiff.text.length());
                    nextDiff.text = prevDiff.text + nextDiff.text;
                    pointer.previous(); // Walk past nextDiff.
                    pointer.previous(); // Walk past thisDiff.
                    pointer.previous(); // Walk past prevDiff.
                    pointer.remove(); // Delete prevDiff.
                    pointer.next(); // Walk past thisDiff.
                    thisDiff = pointer.next(); // Walk past nextDiff.
                    nextDiff = pointer.hasNext() ? pointer.next() : null;
                    changes = true;
                } else if (thisDiff.text.startsWith(nextDiff.text)) {
                    // Shift the edit over the next equality.
                    prevDiff.text += nextDiff.text;
                    thisDiff.text = thisDiff.text.substring(nextDiff.text.length()) + nextDiff.text;
                    pointer.remove(); // Delete nextDiff.
                    nextDiff = pointer.hasNext() ? pointer.next() : null;
                    changes = true;
                }
            }
            prevDiff = thisDiff;
            thisDiff = nextDiff;
            nextDiff = pointer.hasNext() ? pointer.next() : null;
        }
        // If shifts were made, the diff needs reordering and another shift sweep.
        if (changes) {
            diff_cleanupMerge(diffs);
        }
    }


    /**
     * Return two strings to display as typed and correct text.
     *
     * @param typed (cleaned-up) text the user typed in,
     * @param typed (cleaned-up) correct text
     * @return Two-element String array with HTML representation of the diffs between the inputs.
     */
    public String[] diffedHtmlStrings(String typed, String correct) {
        StringBuilder prettyTyped = new StringBuilder();
        StringBuilder prettyCorrect = new StringBuilder();
        for (DiffAction aDiff : diff_main(typed, correct)) {
            switch (aDiff.operation) {
                case INSERT:
                    prettyTyped.append(wrapBad(aDiff.text));
                    break;
                case DELETE:
                    prettyCorrect.append(wrapMissing(aDiff.text));
                    break;
                case EQUAL:
                    prettyTyped.append(wrapGood(aDiff.text));
                    prettyCorrect.append(wrapGood(aDiff.text));
                    break;
            }
        }
        return new String[] {prettyTyped.toString(), prettyCorrect.toString()};
    }

    public static String wrapBad(String in) {
        // We do the comparison with 鈥